//
// File: FlightMissionMode.cpp
//
// Code generated for Simulink model 'FlightMissionMode'.
//
// Model version                  : 3.33
// Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021
// C/C++ source code generated on : Wed Aug 10 14:05:40 2022
//
// Target selection: ert.tlc
// Embedded hardware selection: ARM Compatible->ARM 64-bit (LLP64)
// Code generation objectives:
//    1. Safety precaution
//    2. Execution efficiency
//    3. RAM efficiency
//    4. ROM efficiency
// Validation result: Not run
//
#include "FlightMissionMode.h"
#include "rtwtypes.h"
#include "FlightMissionMode_types.h"
#include "MissionModes.h"
#include "DatalinkInterface.h"
#include <stdio.h>
#include <cmath>
#include <cstring>
#include <math.h>
#include "rt_atan2d_snf.h"
#include <stddef.h>
#include "sum_kSJnGZ04.h"
#include "mod_d42kHWKw.h"
#include "wrapToPi_kQV0kjUY.h"
#include <cstdlib>
#include "rtw_linux.h"
#include "rt_modd_snf.h"
#include "rt_mrdivide_U1d1x3_U2d3x3_Yd1x3_snf.h"
#include "rt_remd_snf.h"
#include "FlightMissionMode_private.h"
#include "div_s32_sat.h"

extern "C" {

#include "rt_nonfinite.h"

}
// Named constants for Chart: '<S95>/Chart'
    const uint8_T FlightMissionMode_IN_Bottom
{
    1U
};
const uint8_T FlightMissionMode_IN_Init{ 1U };

const uint8_T FlightMissionMode_IN_Left{ 2U };

const uint8_T FlightMissionMode_IN_NO_ACTIVE_CHILD{ 0U };

const uint8_T FlightMissionMode_IN_Right{ 3U };

const uint8_T FlightMissionMode_IN_Running{ 2U };

const uint8_T FlightMissionMode_IN_Top{ 4U };

// Named constants for Chart: '<Root>/PreemptableMissionModeSelector'
const uint8_T FlightMissionMode_IN_FlightMission{ 1U };

const uint8_T FlightMissionMode_IN_WaitToStart{ 2U };

const FixedWingGuidanceBus FlightMissionMode_rtZFixedWingGuidanceBus{
    0.0,                               // Height
    0.0,                               // AirSpeed
    0.0                                // HeadingAngle
};                                     // FixedWingGuidanceBus ground

// System initialize for atomic system:
void FlightMissionMode::FlightMissionMode_RotateATMissionHdg_Init
    (self_RotateATMissionHdg_FlightMissionMode_T *FlightMissionMode_self_arg,
     const real_T rtu_0[3])
{
    (void) (rtu_0);

    // Start for MATLABSystem: '<S38>/RotateATMissionHdg'
    FlightMissionMode_self_arg->dwork.objisempty = true;
    FlightMissionMode_self_arg->dwork.obj.isInitialized = 1;
}

// Output and update for atomic system:
void FlightMissionMode::FlightMissionMode_RotateATMissionHdg
    (self_RotateATMissionHdg_FlightMissionMode_T *FlightMissionMode_self_arg,
     const real_T rtu_0[3])
{
    real_T out[9];
    real_T ct_idx_0;
    real_T ct_idx_1;
    real_T ct_idx_2;
    real_T out_tmp;
    real_T out_tmp_0;
    real_T st_idx_0;
    real_T st_idx_1;
    real_T st_idx_2;

    // MATLABSystem: '<S38>/RotateATMissionHdg'
    ct_idx_0 = std::cos(rtu_0[0]);
    ct_idx_1 = std::cos(rtu_0[1]);
    ct_idx_2 = std::cos(rtu_0[2]);
    st_idx_0 = std::sin(rtu_0[0]);
    st_idx_1 = std::sin(rtu_0[1]);
    st_idx_2 = std::sin(rtu_0[2]);
    out[0] = ct_idx_0 * ct_idx_1;
    out_tmp = st_idx_1 * st_idx_2;
    out[3] = out_tmp * ct_idx_0 - st_idx_0 * ct_idx_2;
    out_tmp_0 = st_idx_1 * ct_idx_2;
    out[6] = out_tmp_0 * ct_idx_0 + st_idx_0 * st_idx_2;
    out[1] = st_idx_0 * ct_idx_1;
    out[4] = out_tmp * st_idx_0 + ct_idx_0 * ct_idx_2;
    out[7] = out_tmp_0 * st_idx_0 - ct_idx_0 * st_idx_2;
    out[2] = -st_idx_1;
    out[5] = ct_idx_1 * st_idx_2;
    out[8] = ct_idx_1 * ct_idx_2;

    // MATLABSystem: '<S38>/RotateATMissionHdg'
    std::memcpy(&FlightMissionMode_self_arg->dwork.RotateATMissionHdg[0], &out[0],
                static_cast<uint32_T>(9U * sizeof(real_T)));
}

real_T FlightMissionMode::FlightMissionMode_norm(const real_T x[3])
{
    real_T absxk;
    real_T scale;
    real_T t;
    real_T y;
    scale = 3.3121686421112381E-170;
    absxk = std::abs(x[0]);
    if (absxk > 3.3121686421112381E-170) {
        y = 1.0;
        scale = absxk;
    } else {
        t = absxk / 3.3121686421112381E-170;
        y = t * t;
    }

    absxk = std::abs(x[1]);
    if (absxk > scale) {
        t = scale / absxk;
        y = y * t * t + 1.0;
        scale = absxk;
    } else {
        t = absxk / scale;
        y += t * t;
    }

    absxk = std::abs(x[2]);
    if (absxk > scale) {
        t = scale / absxk;
        y = y * t * t + 1.0;
        scale = absxk;
    } else {
        t = absxk / scale;
        y += t * t;
    }

    return scale * std::sqrt(y);
}

// System initialize for atomic system:
void FlightMissionMode::FlightMissionMode_WaypointFollower_Init
    (DW_WaypointFollower_FlightMissionMode_T *localDW)
{
    // Start for MATLABSystem: '<S122>/Waypoint Follower'
    localDW->obj.LastWaypointFlag = false;
    localDW->obj.StartFlag = true;
    localDW->obj.LookaheadFactor = 1.01;
    localDW->objisempty = true;
    localDW->obj.isInitialized = 1;

    // InitializeConditions for MATLABSystem: '<S122>/Waypoint Follower'
    localDW->obj.WaypointIndex = 1.0;
    for (int32_T i{0}; i < 384; i++) {
        // InitializeConditions for MATLABSystem: '<S122>/Waypoint Follower'
        localDW->obj.WaypointsInternal[i] = (rtNaN);
    }
}

// System reset for atomic system:
void FlightMissionMode::FlightMissionMode_WaypointFollower_Reset
    (DW_WaypointFollower_FlightMissionMode_T *localDW)
{
    // InitializeConditions for MATLABSystem: '<S122>/Waypoint Follower'
    localDW->obj.WaypointIndex = 1.0;
    for (int32_T i{0}; i < 384; i++) {
        localDW->obj.WaypointsInternal[i] = (rtNaN);
    }

    // End of InitializeConditions for MATLABSystem: '<S122>/Waypoint Follower'
}

// Output and update for atomic system:
void FlightMissionMode::FlightMissionMode_WaypointFollower(const real_T rtu_0[4],
    const real_T rtu_1[384], real_T rtu_2,
    DW_WaypointFollower_FlightMissionMode_T *localDW)
{
    real_T b_waypointsIn_data[384];
    real_T waypoints_data[384];
    real_T b_waypointsIn[3];
    real_T rtu_0_0[3];
    real_T lambda;
    real_T r_idx_0;
    real_T r_idx_1;
    real_T r_idx_2;
    int32_T b_exponent;
    int32_T b_exponent_0;
    int32_T b_k;
    int32_T i1;
    int32_T i2;
    int32_T rtu_1_tmp;
    uint8_T c_data[128];
    boolean_T x[384];
    boolean_T b[128];
    boolean_T exitg1;
    boolean_T p;
    boolean_T p_0;

    // MATLABSystem: '<S122>/Waypoint Follower'
    lambda = rtu_2;
    localDW->obj.LookaheadDistFlag = 0U;
    if (rtu_2 < 0.1) {
        lambda = 0.1;
        localDW->obj.LookaheadDistFlag = 1U;
    }

    localDW->obj.InitialPose[0] = 0.0;
    localDW->obj.InitialPose[1] = 0.0;
    localDW->obj.InitialPose[2] = 0.0;
    localDW->obj.InitialPose[3] = 0.0;
    p = false;
    p_0 = true;
    b_k = 0;
    exitg1 = false;
    while ((!exitg1) && (b_k < 384)) {
        if ((localDW->obj.WaypointsInternal[b_k] == rtu_1[b_k]) || (std::isnan
                (localDW->obj.WaypointsInternal[b_k]) && std::isnan(rtu_1[b_k])))
        {
            b_k = static_cast<int32_T>(b_k + 1);
        } else {
            p_0 = false;
            exitg1 = true;
        }
    }

    if (p_0) {
        p = true;
    }

    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(p) ^ 1)))
    {
        std::memcpy(&localDW->obj.WaypointsInternal[0], &rtu_1[0],
                    static_cast<uint32_T>(384U * sizeof(real_T)));
        localDW->obj.WaypointIndex = 1.0;
    }

    b_k = 0;
    for (i1 = 0; i1 < 3; i1++) {
        std::memcpy(&b_waypointsIn_data[b_k], &rtu_1[static_cast<int32_T>(b_k +
                     1)], static_cast<uint32_T>(127U * sizeof(real_T)));
        b_k = static_cast<int32_T>(b_k + 128);
    }

    b_waypointsIn_data[127] = (rtNaN);
    b_waypointsIn_data[255] = (rtNaN);
    b_waypointsIn_data[383] = (rtNaN);
    for (b_k = 0; b_k < 384; b_k++) {
        x[b_k] = (rtu_1[b_k] != b_waypointsIn_data[b_k]);
    }

    i1 = 0;
    i2 = 256;
    for (b_k = 0; b_k < 128; b_k++) {
        b[b_k] = false;
        i1 = static_cast<int32_T>(i1 + 1);
        i2 = static_cast<int32_T>(i2 + 1);
        rtu_1_tmp = i1;
        exitg1 = false;
        while ((!exitg1) && (rtu_1_tmp <= i2)) {
            if (x[static_cast<int32_T>(rtu_1_tmp - 1)]) {
                b[b_k] = true;
                exitg1 = true;
            } else {
                rtu_1_tmp = static_cast<int32_T>(rtu_1_tmp + 128);
            }
        }
    }

    i1 = 0;
    for (b_k = 0; b_k < 128; b_k++) {
        if (b[b_k]) {
            i1 = static_cast<int32_T>(i1 + 1);
        }
    }

    i2 = i1;
    i1 = 0;
    for (b_k = 0; b_k < 128; b_k++) {
        if (b[b_k]) {
            c_data[i1] = static_cast<uint8_T>(static_cast<int32_T>(b_k + 1));
            i1 = static_cast<int32_T>(i1 + 1);
        }
    }

    for (b_k = 0; b_k < 3; b_k++) {
        for (i1 = 0; i1 <= static_cast<int32_T>(i2 - 1); i1++) {
            b_waypointsIn_data[static_cast<int32_T>(i1 + static_cast<int32_T>(i2
                * b_k))] = rtu_1[static_cast<int32_T>(static_cast<int32_T>(
                static_cast<int32_T>(b_k << 7) + static_cast<int32_T>(c_data[i1]))
                - 1)];
        }
    }

    localDW->obj.NumWaypoints = static_cast<real_T>(i2);
    localDW->obj.LookaheadDistance = lambda;
    if (i2 == 0) {
        // MATLABSystem: '<S122>/Waypoint Follower'
        localDW->WaypointFollower_o1[0] = lambda * std::cos(rtu_0[3]) + rtu_0[0];
        localDW->WaypointFollower_o1[1] = lambda * std::sin(rtu_0[3]) + rtu_0[1];
        localDW->WaypointFollower_o1[2] = lambda * 0.0 + rtu_0[2];
        lambda = rtu_0[3];

        // MATLABSystem: '<S122>/Waypoint Follower'
        localDW->WaypointFollower_o3 = rtu_0[3];

        // MATLABSystem: '<S122>/Waypoint Follower'
        localDW->WaypointFollower_o5 = 1U;
    } else {
        boolean_T guard1{ false };

        guard1 = false;
        if (i2 == 1) {
            if (localDW->obj.StartFlag) {
                localDW->obj.InitialPose[0] = rtu_0[0];
                localDW->obj.InitialPose[1] = rtu_0[1];
                localDW->obj.InitialPose[2] = rtu_0[2];
                localDW->obj.InitialPose[3] = rtu_0[3];
            }

            b_waypointsIn[0] = b_waypointsIn_data[0] - rtu_0[0];
            b_waypointsIn[1] = b_waypointsIn_data[1] - rtu_0[1];
            b_waypointsIn[2] = b_waypointsIn_data[2] - rtu_0[2];
            if (FlightMissionMode_norm(b_waypointsIn) < 1.4901161193847656E-8) {
                // MATLABSystem: '<S122>/Waypoint Follower'
                localDW->WaypointFollower_o1[0] = lambda * std::cos(rtu_0[3]) +
                    rtu_0[0];
                localDW->WaypointFollower_o1[1] = lambda * std::sin(rtu_0[3]) +
                    rtu_0[1];
                localDW->WaypointFollower_o1[2] = lambda * 0.0 + rtu_0[2];
                lambda = rtu_0[3];

                // MATLABSystem: '<S122>/Waypoint Follower'
                localDW->WaypointFollower_o3 = rtu_0[3];

                // MATLABSystem: '<S122>/Waypoint Follower'
                localDW->WaypointFollower_o5 = 1U;
                localDW->obj.StartFlag = false;
            } else {
                localDW->obj.StartFlag = false;
                localDW->obj.NumWaypoints = 2.0;
                rtu_1_tmp = static_cast<int32_T>(i2 + 1);
                for (b_k = 0; b_k < 3; b_k++) {
                    int32_T waypoints_data_tmp;
                    waypoints_data_tmp = static_cast<int32_T>
                        (static_cast<int32_T>(i2 + 1) * b_k);
                    waypoints_data[waypoints_data_tmp] =
                        localDW->obj.InitialPose[b_k];
                    for (i1 = 0; i1 <= static_cast<int32_T>(i2 - 1); i1++) {
                        waypoints_data[static_cast<int32_T>(static_cast<int32_T>
                            (i1 + waypoints_data_tmp) + 1)] =
                            b_waypointsIn_data[static_cast<int32_T>
                            (static_cast<int32_T>(i2 * b_k) + i1)];
                    }
                }

                guard1 = true;
            }
        } else {
            rtu_1_tmp = i2;
            i2 = static_cast<int32_T>(i2 * 3);
            for (b_k = 0; b_k <= static_cast<int32_T>(i2 - 1); b_k++) {
                waypoints_data[b_k] = b_waypointsIn_data[b_k];
            }

            guard1 = true;
        }

        if (guard1) {
            real_T b_0;
            real_T b_tmp_idx_2_tmp;
            real_T lambda_tmp;
            real_T rtu_0_tmp;
            real_T waypoints_tmp;
            real_T waypoints_tmp_0;
            real_T waypoints_tmp_1;
            boolean_T guard2{ false };

            p = false;
            if (localDW->obj.WaypointIndex == localDW->obj.NumWaypoints) {
                p = true;
            }

            if (p) {
                localDW->obj.LastWaypointFlag = true;
                localDW->obj.WaypointIndex--;
            }

            rtu_0_0[0] = rtu_0[0] - waypoints_data[static_cast<int32_T>(
                static_cast<int32_T>(localDW->obj.WaypointIndex + 1.0) - 1)];
            rtu_0_0[1] = rtu_0[1] - waypoints_data[static_cast<int32_T>(
                static_cast<int32_T>(static_cast<int32_T>
                (localDW->obj.WaypointIndex + 1.0) + rtu_1_tmp) - 1)];
            rtu_0_0[2] = rtu_0[2] - waypoints_data[static_cast<int32_T>(
                static_cast<int32_T>(static_cast<int32_T>
                (localDW->obj.WaypointIndex + 1.0) + static_cast<int32_T>
                (rtu_1_tmp << 1)) - 1)];
            guard2 = false;
            if (FlightMissionMode_norm(rtu_0_0) <= 100.0) {
                guard2 = true;
            } else {
                r_idx_0 = waypoints_data[static_cast<int32_T>
                    (static_cast<int32_T>(localDW->obj.WaypointIndex + 1.0) - 1)];
                b_waypointsIn[0] = rtu_0[0] - r_idx_0;
                rtu_0_0[0] = r_idx_0 - waypoints_data[static_cast<int32_T>(
                    static_cast<int32_T>(localDW->obj.WaypointIndex) - 1)];
                r_idx_0 = waypoints_data[static_cast<int32_T>
                    (static_cast<int32_T>(static_cast<int32_T>
                      (localDW->obj.WaypointIndex + 1.0) + rtu_1_tmp) - 1)];
                b_waypointsIn[1] = rtu_0[1] - r_idx_0;
                rtu_0_0[1] = r_idx_0 - waypoints_data[static_cast<int32_T>(
                    static_cast<int32_T>(static_cast<int32_T>
                    (localDW->obj.WaypointIndex) + rtu_1_tmp) - 1)];
                r_idx_2 = waypoints_data[static_cast<int32_T>
                    (static_cast<int32_T>(static_cast<int32_T>
                      (localDW->obj.WaypointIndex + 1.0) + static_cast<int32_T>
                      (rtu_1_tmp << 1)) - 1)];
                b_waypointsIn[2] = rtu_0[2] - r_idx_2;
                rtu_0_tmp = waypoints_data[static_cast<int32_T>
                    (static_cast<int32_T>(static_cast<int32_T>(rtu_1_tmp << 1) +
                      static_cast<int32_T>(localDW->obj.WaypointIndex)) - 1)];
                rtu_0_0[2] = r_idx_2 - rtu_0_tmp;
                lambda = FlightMissionMode_norm(rtu_0_0);
                b_0 = FlightMissionMode_norm(b_waypointsIn);
                waypoints_tmp = waypoints_data[static_cast<int32_T>
                    (static_cast<int32_T>(localDW->obj.WaypointIndex) - 1)];
                r_idx_0 = waypoints_data[static_cast<int32_T>
                    (static_cast<int32_T>(localDW->obj.WaypointIndex + 1.0) - 1)];
                waypoints_tmp_0 = waypoints_data[static_cast<int32_T>(
                    static_cast<int32_T>(static_cast<int32_T>
                    (localDW->obj.WaypointIndex) + rtu_1_tmp) - 1)];
                r_idx_1 = waypoints_data[static_cast<int32_T>
                    (static_cast<int32_T>(static_cast<int32_T>
                      (localDW->obj.WaypointIndex + 1.0) + rtu_1_tmp) - 1)];
                lambda = ((r_idx_0 - waypoints_tmp) / lambda * (b_waypointsIn[0]
                           / b_0) + (r_idx_1 - waypoints_tmp_0) / lambda *
                          (b_waypointsIn[1] / b_0)) + (r_idx_2 - rtu_0_tmp) /
                    lambda * (b_waypointsIn[2] / b_0);
                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>(std::isnan
                        (lambda)) ^ 1))) {
                    if (lambda < 0.0) {
                        lambda = -1.0;
                    } else {
                        lambda = static_cast<real_T>(lambda > 0.0);
                    }
                }

                if (lambda >= 0.0) {
                    guard2 = true;
                } else {
                    b_waypointsIn[0] = waypoints_tmp;
                    b_waypointsIn[1] = waypoints_tmp_0;
                    b_waypointsIn[2] = rtu_0_tmp;
                }
            }

            if (guard2) {
                localDW->obj.WaypointIndex++;
                p = false;
                if (localDW->obj.WaypointIndex == localDW->obj.NumWaypoints) {
                    p = true;
                }

                if (p) {
                    localDW->obj.LastWaypointFlag = true;
                    localDW->obj.WaypointIndex--;
                }

                b_waypointsIn[0] = waypoints_data[static_cast<int32_T>(
                    static_cast<int32_T>(localDW->obj.WaypointIndex) - 1)];
                r_idx_0 = waypoints_data[static_cast<int32_T>
                    (static_cast<int32_T>(localDW->obj.WaypointIndex + 1.0) - 1)];
                b_waypointsIn[1] = waypoints_data[static_cast<int32_T>(
                    static_cast<int32_T>(static_cast<int32_T>
                    (localDW->obj.WaypointIndex) + rtu_1_tmp) - 1)];
                r_idx_1 = waypoints_data[static_cast<int32_T>
                    (static_cast<int32_T>(static_cast<int32_T>
                      (localDW->obj.WaypointIndex + 1.0) + rtu_1_tmp) - 1)];
                b_waypointsIn[2] = waypoints_data[static_cast<int32_T>(
                    static_cast<int32_T>(static_cast<int32_T>(rtu_1_tmp << 1) +
                    static_cast<int32_T>(localDW->obj.WaypointIndex)) - 1)];
                r_idx_2 = waypoints_data[static_cast<int32_T>
                    (static_cast<int32_T>(static_cast<int32_T>
                      (localDW->obj.WaypointIndex + 1.0) + static_cast<int32_T>
                      (rtu_1_tmp << 1)) - 1)];
            }

            waypoints_tmp = r_idx_0 - b_waypointsIn[0];
            b_0 = rtu_0[0] - b_waypointsIn[0];
            waypoints_tmp_0 = r_idx_1 - b_waypointsIn[1];
            rtu_0_tmp = rtu_0[1] - b_waypointsIn[1];
            waypoints_tmp_1 = r_idx_2 - b_waypointsIn[2];
            lambda_tmp = rtu_0[2] - b_waypointsIn[2];
            lambda = ((rtu_0_tmp * waypoints_tmp_0 + b_0 * waypoints_tmp) +
                      lambda_tmp * waypoints_tmp_1) / ((waypoints_tmp_0 *
                waypoints_tmp_0 + waypoints_tmp * waypoints_tmp) +
                waypoints_tmp_1 * waypoints_tmp_1);
            if (lambda < 0.0) {
                rtu_0_0[0] = b_0;
                rtu_0_0[1] = rtu_0_tmp;
                rtu_0_0[2] = lambda_tmp;
                lambda = FlightMissionMode_norm(rtu_0_0);
            } else if (lambda > 1.0) {
                rtu_0_0[0] = rtu_0[0] - r_idx_0;
                rtu_0_0[1] = rtu_0[1] - r_idx_1;
                rtu_0_0[2] = rtu_0[2] - r_idx_2;
                lambda = FlightMissionMode_norm(rtu_0_0);
            } else {
                rtu_0_0[0] = rtu_0[0] - (lambda * waypoints_tmp + b_waypointsIn
                    [0]);
                rtu_0_0[1] = rtu_0[1] - (lambda * waypoints_tmp_0 +
                    b_waypointsIn[1]);
                rtu_0_0[2] = rtu_0[2] - (lambda * waypoints_tmp_1 +
                    b_waypointsIn[2]);
                lambda = FlightMissionMode_norm(rtu_0_0);
            }

            if (localDW->obj.LastWaypointFlag) {
                lambda = (((rtu_0[0] - b_waypointsIn[0]) * (r_idx_0 -
                            b_waypointsIn[0]) + (rtu_0[1] - b_waypointsIn[1]) *
                           (r_idx_1 - b_waypointsIn[1])) + (rtu_0[2] -
                           b_waypointsIn[2]) * (r_idx_2 - b_waypointsIn[2])) /
                    (((r_idx_0 - b_waypointsIn[0]) * (r_idx_0 - b_waypointsIn[0])
                      + (r_idx_1 - b_waypointsIn[1]) * (r_idx_1 - b_waypointsIn
                       [1])) + (r_idx_2 - b_waypointsIn[2]) * (r_idx_2 -
                      b_waypointsIn[2]));
                rtu_0_0[0] = rtu_0[0] - (lambda * waypoints_tmp + b_waypointsIn
                    [0]);
                rtu_0_0[1] = rtu_0[1] - (lambda * waypoints_tmp_0 +
                    b_waypointsIn[1]);
                rtu_0_0[2] = rtu_0[2] - (lambda * waypoints_tmp_1 +
                    b_waypointsIn[2]);
                lambda = FlightMissionMode_norm(rtu_0_0);
            }

            lambda_tmp = std::abs(lambda);
            if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                    (static_cast<boolean_T>(static_cast<int32_T>
                    (static_cast<int32_T>(std::isinf(lambda_tmp)) ^ 1))) &
                    static_cast<int32_T>(static_cast<boolean_T>
                    (static_cast<int32_T>(static_cast<int32_T>(std::isnan
                      (lambda_tmp)) ^ 1)))))) {
                if (lambda_tmp <= 2.2250738585072014E-308) {
                    b_0 = 4.94065645841247E-324;
                    lambda_tmp = 4.94065645841247E-324;
                } else {
                    frexp(lambda_tmp, &b_exponent);
                    b_0 = std::ldexp(1.0, static_cast<int32_T>(b_exponent - 53));
                    frexp(lambda_tmp, &b_exponent_0);
                    lambda_tmp = std::ldexp(1.0, static_cast<int32_T>
                                            (b_exponent_0 - 53));
                }
            } else {
                b_0 = (rtNaN);
                lambda_tmp = (rtNaN);
            }

            if (localDW->obj.LookaheadDistance <= std::fmax(std::sqrt(b_0), 5.0 *
                 lambda_tmp) + lambda) {
                localDW->obj.LookaheadDistance = localDW->obj.LookaheadFactor *
                    lambda;
            }

            lambda = b_waypointsIn[0] - rtu_0[0];
            lambda_tmp = b_waypointsIn[1] - rtu_0[1];
            rtu_0_tmp = ((r_idx_0 - b_waypointsIn[0]) * (r_idx_0 -
                          b_waypointsIn[0]) + (r_idx_1 - b_waypointsIn[1]) *
                         (r_idx_1 - b_waypointsIn[1])) + (r_idx_2 -
                b_waypointsIn[2]) * (r_idx_2 - b_waypointsIn[2]);
            b_tmp_idx_2_tmp = b_waypointsIn[2] - rtu_0[2];
            b_0 = ((waypoints_tmp * lambda + waypoints_tmp_0 * lambda_tmp) +
                   waypoints_tmp_1 * b_tmp_idx_2_tmp) * 2.0;
            lambda_tmp = std::sqrt(b_0 * b_0 - (((lambda * lambda + lambda_tmp *
                lambda_tmp) + b_tmp_idx_2_tmp * b_tmp_idx_2_tmp) -
                                    localDW->obj.LookaheadDistance *
                                    localDW->obj.LookaheadDistance) * (4.0 *
                                    rtu_0_tmp));
            lambda = std::fmax((-b_0 + lambda_tmp) / 2.0 / rtu_0_tmp, (-b_0 -
                                lambda_tmp) / 2.0 / rtu_0_tmp);
            rtu_0_tmp = (1.0 - lambda) * b_waypointsIn[0] + lambda * r_idx_0;

            // MATLABSystem: '<S122>/Waypoint Follower'
            localDW->WaypointFollower_o1[0] = rtu_0_tmp;
            r_idx_0 = rtu_0_tmp;
            rtu_0_tmp = (1.0 - lambda) * b_waypointsIn[1] + lambda * r_idx_1;

            // MATLABSystem: '<S122>/Waypoint Follower'
            localDW->WaypointFollower_o1[1] = rtu_0_tmp;
            localDW->WaypointFollower_o1[2] = (1.0 - lambda) * b_waypointsIn[2]
                + lambda * r_idx_2;
            lambda = rt_atan2d_snf(rtu_0_tmp - rtu_0[1], r_idx_0 - rtu_0[0]);

            // MATLABSystem: '<S122>/Waypoint Follower'
            localDW->WaypointFollower_o3 = lambda;

            // MATLABSystem: '<S122>/Waypoint Follower'
            localDW->WaypointFollower_o5 = 0U;
            p = false;
            if (localDW->obj.LastWaypointFlag) {
                p = true;
            }

            if (p) {
                // MATLABSystem: '<S122>/Waypoint Follower'
                localDW->WaypointFollower_o5 = 1U;
            }

            localDW->obj.LastWaypointFlag = false;
        }
    }

    // MATLABSystem: '<S122>/Waypoint Follower'
    localDW->WaypointFollower_o2 = lambda;

    // MATLABSystem: '<S122>/Waypoint Follower'
    localDW->WaypointFollower_o4 = localDW->obj.LookaheadDistFlag;
}

//
// System initialize for atomic system:
//    '<S91>/SegmentSwitch'
//    '<S133>/SegmentSwitch'
//
void FlightMissionMode::FlightMissionMode_SegmentSwitch_Init(real_T
    rty_LookAheadPoint[3], real_T *rty_DesiredCourse, RunWayLineSegment
    *rty_Status, DW_SegmentSwitch_FlightMissionMode_T *localDW)
{
    // Start for SwitchCase: '<S95>/Switch Case'
    localDW->SwitchCase_ActiveSubsystem = -1;

    // SystemInitialize for Chart: '<S95>/Chart'
    *rty_Status = RunWayLineSegment::None;

    // SystemInitialize for IfAction SubSystem: '<S95>/Left'

    // Constant: '<S122>/LookAheadDis'
    FlightMissionMode_WaypointFollower_Init(&localDW->WaypointFollower);

    // End of SystemInitialize for SubSystem: '<S95>/Left'

    // SystemInitialize for IfAction SubSystem: '<S95>/Top'

    // Constant: '<S124>/LookAheadDis'
    FlightMissionMode_WaypointFollower_Init(&localDW->WaypointFollower_k);

    // End of SystemInitialize for SubSystem: '<S95>/Top'

    // SystemInitialize for IfAction SubSystem: '<S95>/Right'

    // Constant: '<S123>/LookAheadDis'
    FlightMissionMode_WaypointFollower_Init(&localDW->WaypointFollower_n);

    // End of SystemInitialize for SubSystem: '<S95>/Right'

    // SystemInitialize for IfAction SubSystem: '<S95>/Bottom'

    // Constant: '<S119>/LookAheadDis'
    FlightMissionMode_WaypointFollower_Init(&localDW->WaypointFollower_i);

    // End of SystemInitialize for SubSystem: '<S95>/Bottom'

    // SystemInitialize for IfAction SubSystem: '<S95>/Initial'

    // Constant: '<S121>/LookAheadDis'
    FlightMissionMode_WaypointFollower_Init(&localDW->WaypointFollower_e);

    // End of SystemInitialize for SubSystem: '<S95>/Initial'

    // SystemInitialize for Merge: '<S95>/MergeDesiredCourse'
    *rty_DesiredCourse = 0.0;

    // SystemInitialize for Merge: '<S95>/MergeLookAheadP'
    rty_LookAheadPoint[0] = 0.0;
    rty_LookAheadPoint[1] = 0.0;
    rty_LookAheadPoint[2] = 0.0;
}

//
// System reset for atomic system:
//    '<S91>/SegmentSwitch'
//    '<S133>/SegmentSwitch'
//
void FlightMissionMode::FlightMissionMode_SegmentSwitch_Reset(RunWayLineSegment *
    rty_Status, DW_SegmentSwitch_FlightMissionMode_T *localDW)
{
    // InitializeConditions for Memory: '<S95>/Memory'
    localDW->Memory_PreviousInput = 0.0;

    // SystemReset for Chart: '<S95>/Chart'
    localDW->temporalCounter_i1 = 0U;
    localDW->is_Running = FlightMissionMode_IN_NO_ACTIVE_CHILD;
    localDW->is_active_c3_PathPlanning = 0U;
    localDW->is_c3_PathPlanning = FlightMissionMode_IN_NO_ACTIVE_CHILD;
    *rty_Status = RunWayLineSegment::None;
}

//
// Disable for atomic system:
//    '<S91>/SegmentSwitch'
//    '<S133>/SegmentSwitch'
//
void FlightMissionMode::FlightMissionMode_SegmentSwitch_Disable
    (DW_SegmentSwitch_FlightMissionMode_T *localDW)
{
    // Disable for SwitchCase: '<S95>/Switch Case'
    localDW->SwitchCase_ActiveSubsystem = -1;
}

//
// Output and update for atomic system:
//    '<S91>/SegmentSwitch'
//    '<S133>/SegmentSwitch'
//
void FlightMissionMode::FlightMissionMode_SegmentSwitch(const int32_T *rtu_Reset,
    const real_T rtu_Pose[4], const real_T rtu_RawWaypoint[1920], real_T
    rty_LookAheadPoint[3], real_T *rty_DesiredCourse, RunWayLineSegment
    *rty_Status, real_T rtp_LookAheadDis, DW_SegmentSwitch_FlightMissionMode_T
    *localDW)
{
    // local block i/o variables
    real_T rtb_Selector[384];
    real_T rtb_Selector_a[384];
    real_T rtb_Selector_h[384];
    real_T rtb_Selector_o[384];
    real_T rtb_Selector_a0[384];
    int8_T rtAction;
    int8_T rtPrevAction;

    // Chart: '<S95>/Chart' incorporates:
    //   Memory: '<S95>/Memory'

    if (static_cast<uint32_T>(localDW->temporalCounter_i1) < 7U) {
        localDW->temporalCounter_i1 = static_cast<uint8_T>(static_cast<uint32_T>
            (static_cast<uint32_T>(localDW->temporalCounter_i1) + 1U));
    }

    // Gateway: SegmentSwitch/Chart
    // During: SegmentSwitch/Chart
    if (static_cast<uint32_T>(localDW->is_active_c3_PathPlanning) == 0U) {
        // Entry: SegmentSwitch/Chart
        localDW->is_active_c3_PathPlanning = 1U;

        // Entry Internal: SegmentSwitch/Chart
        // Transition: '<S120>:2'
        localDW->is_c3_PathPlanning = FlightMissionMode_IN_Init;
        localDW->temporalCounter_i1 = 0U;
        *rty_Status = RunWayLineSegment::Init;
    } else if (localDW->is_c3_PathPlanning == FlightMissionMode_IN_Init) {
        // During 'Init': '<S120>:1'
        if (static_cast<boolean_T>(static_cast<int32_T>((static_cast<uint32_T>
                (localDW->temporalCounter_i1) >= 5U) &
                (localDW->Memory_PreviousInput == 1.0)))) {
            // Transition: '<S120>:4'
            localDW->is_c3_PathPlanning = FlightMissionMode_IN_Running;
            localDW->is_Running = FlightMissionMode_IN_Left;
            *rty_Status = RunWayLineSegment::Left;
        }

        // During 'Running': '<S120>:5'
    } else if (*rtu_Reset != 0) {
        // Transition: '<S120>:15'
        // Exit Internal 'Running': '<S120>:5'
        localDW->is_Running = FlightMissionMode_IN_NO_ACTIVE_CHILD;
        localDW->is_c3_PathPlanning = FlightMissionMode_IN_Init;
        localDW->temporalCounter_i1 = 0U;
        *rty_Status = RunWayLineSegment::Init;
    } else {
        switch (localDW->is_Running) {
          case FlightMissionMode_IN_Bottom:
            // During 'Bottom': '<S120>:13'
            if (localDW->Memory_PreviousInput == 1.0) {
                // Transition: '<S120>:8'
                localDW->is_Running = FlightMissionMode_IN_Left;
                *rty_Status = RunWayLineSegment::Left;
            }
            break;

          case FlightMissionMode_IN_Left:
            // During 'Left': '<S120>:11'
            if (localDW->Memory_PreviousInput == 1.0) {
                // Transition: '<S120>:7'
                localDW->is_Running = FlightMissionMode_IN_Top;
                *rty_Status = RunWayLineSegment::Top;
            }
            break;

          case FlightMissionMode_IN_Right:
            // During 'Right': '<S120>:14'
            if (localDW->Memory_PreviousInput == 1.0) {
                // Transition: '<S120>:10'
                localDW->is_Running = FlightMissionMode_IN_Bottom;
                *rty_Status = RunWayLineSegment::Bottom;
            }
            break;

          default:
            // During 'Top': '<S120>:12'
            if (localDW->Memory_PreviousInput == 1.0) {
                // Transition: '<S120>:9'
                localDW->is_Running = FlightMissionMode_IN_Right;
                *rty_Status = RunWayLineSegment::Right;
            }
            break;
        }
    }

    // End of Chart: '<S95>/Chart'

    // SwitchCase: '<S95>/Switch Case' incorporates:
    //   Constant: '<S119>/LookAheadDis'
    //   Constant: '<S121>/LookAheadDis'
    //   Constant: '<S122>/LookAheadDis'
    //   Constant: '<S123>/LookAheadDis'
    //   Constant: '<S124>/LookAheadDis'

    rtPrevAction = localDW->SwitchCase_ActiveSubsystem;
    switch (*rty_Status) {
      case RunWayLineSegment::Left:
        rtAction = 0;
        break;

      case RunWayLineSegment::Top:
        rtAction = 1;
        break;

      case RunWayLineSegment::Right:
        rtAction = 2;
        break;

      case RunWayLineSegment::Bottom:
        rtAction = 3;
        break;

      case RunWayLineSegment::Init:
        rtAction = 4;
        break;

      default:
        rtAction = 5;
        break;
    }

    localDW->SwitchCase_ActiveSubsystem = rtAction;
    switch (rtAction) {
      case 0:
        {
            int32_T tmp;
            if (static_cast<int32_T>(rtAction) != static_cast<int32_T>
                    (rtPrevAction)) {
                // SystemReset for IfAction SubSystem: '<S95>/Left' incorporates:
                //   ActionPort: '<S122>/Action Port'

                // SystemReset for SwitchCase: '<S95>/Switch Case'
                FlightMissionMode_WaypointFollower_Reset
                    (&localDW->WaypointFollower);

                // End of SystemReset for SubSystem: '<S95>/Left'
            }

            // Outputs for IfAction SubSystem: '<S95>/Left' incorporates:
            //   ActionPort: '<S122>/Action Port'

            // Selector: '<S122>/Selector'
            tmp = 0;
            for (int32_T i{0}; i < 3; i++) {
                std::memcpy(&rtb_Selector_a0[tmp], &rtu_RawWaypoint[tmp],
                            static_cast<uint32_T>(sizeof(real_T) << 7U));
                tmp = static_cast<int32_T>(tmp + 128);
            }

            // End of Selector: '<S122>/Selector'
            FlightMissionMode_WaypointFollower(rtu_Pose, rtb_Selector_a0,
                rtp_LookAheadDis, &localDW->WaypointFollower);

            // Merge: '<S95>/MergeStatus' incorporates:
            //   Constant: '<S122>/LookAheadDis'
            //   DataTypeConversion: '<S122>/Cast To Double'
            //   SignalConversion generated from: '<S122>/Waypoint Follower'

            localDW->MergeStatus = static_cast<real_T>
                (localDW->WaypointFollower.WaypointFollower_o5);

            // SignalConversion generated from: '<S122>/Waypoint Follower' incorporates:
            //   MATLABSystem: '<S122>/Waypoint Follower'

            rty_LookAheadPoint[0] =
                localDW->WaypointFollower.WaypointFollower_o1[0];
            rty_LookAheadPoint[1] =
                localDW->WaypointFollower.WaypointFollower_o1[1];
            rty_LookAheadPoint[2] =
                localDW->WaypointFollower.WaypointFollower_o1[2];

            // SignalConversion generated from: '<S122>/Waypoint Follower'
            *rty_DesiredCourse = localDW->WaypointFollower.WaypointFollower_o2;

            // End of Outputs for SubSystem: '<S95>/Left'
        }
        break;

      case 1:
        {
            int32_T tmp;
            if (static_cast<int32_T>(rtAction) != static_cast<int32_T>
                    (rtPrevAction)) {
                // SystemReset for IfAction SubSystem: '<S95>/Top' incorporates:
                //   ActionPort: '<S124>/Action Port'

                // SystemReset for SwitchCase: '<S95>/Switch Case'
                FlightMissionMode_WaypointFollower_Reset
                    (&localDW->WaypointFollower_k);

                // End of SystemReset for SubSystem: '<S95>/Top'
            }

            // Outputs for IfAction SubSystem: '<S95>/Top' incorporates:
            //   ActionPort: '<S124>/Action Port'

            // Selector: '<S124>/Selector'
            tmp = 0;
            for (int32_T i{0}; i < 3; i++) {
                std::memcpy(&rtb_Selector_o[tmp], &rtu_RawWaypoint
                            [static_cast<int32_T>(tmp + 384)],
                            static_cast<uint32_T>(sizeof(real_T) << 7U));
                tmp = static_cast<int32_T>(tmp + 128);
            }

            // End of Selector: '<S124>/Selector'
            FlightMissionMode_WaypointFollower(rtu_Pose, rtb_Selector_o,
                rtp_LookAheadDis, &localDW->WaypointFollower_k);

            // Merge: '<S95>/MergeStatus' incorporates:
            //   Constant: '<S124>/LookAheadDis'
            //   DataTypeConversion: '<S124>/Cast To Double'
            //   SignalConversion generated from: '<S124>/Waypoint Follower'

            localDW->MergeStatus = static_cast<real_T>
                (localDW->WaypointFollower_k.WaypointFollower_o5);

            // SignalConversion generated from: '<S124>/Waypoint Follower' incorporates:
            //   MATLABSystem: '<S124>/Waypoint Follower'

            rty_LookAheadPoint[0] =
                localDW->WaypointFollower_k.WaypointFollower_o1[0];
            rty_LookAheadPoint[1] =
                localDW->WaypointFollower_k.WaypointFollower_o1[1];
            rty_LookAheadPoint[2] =
                localDW->WaypointFollower_k.WaypointFollower_o1[2];

            // SignalConversion generated from: '<S124>/Waypoint Follower'
            *rty_DesiredCourse = localDW->WaypointFollower_k.WaypointFollower_o2;

            // End of Outputs for SubSystem: '<S95>/Top'
        }
        break;

      case 2:
        {
            int32_T tmp;
            if (static_cast<int32_T>(rtAction) != static_cast<int32_T>
                    (rtPrevAction)) {
                // SystemReset for IfAction SubSystem: '<S95>/Right' incorporates:
                //   ActionPort: '<S123>/Action Port'

                // SystemReset for SwitchCase: '<S95>/Switch Case'
                FlightMissionMode_WaypointFollower_Reset
                    (&localDW->WaypointFollower_n);

                // End of SystemReset for SubSystem: '<S95>/Right'
            }

            // Outputs for IfAction SubSystem: '<S95>/Right' incorporates:
            //   ActionPort: '<S123>/Action Port'

            // Selector: '<S123>/Selector'
            tmp = 0;
            for (int32_T i{0}; i < 3; i++) {
                std::memcpy(&rtb_Selector_h[tmp], &rtu_RawWaypoint
                            [static_cast<int32_T>(tmp + 768)],
                            static_cast<uint32_T>(sizeof(real_T) << 7U));
                tmp = static_cast<int32_T>(tmp + 128);
            }

            // End of Selector: '<S123>/Selector'
            FlightMissionMode_WaypointFollower(rtu_Pose, rtb_Selector_h,
                rtp_LookAheadDis, &localDW->WaypointFollower_n);

            // Merge: '<S95>/MergeStatus' incorporates:
            //   Constant: '<S123>/LookAheadDis'
            //   DataTypeConversion: '<S123>/Cast To Double'
            //   SignalConversion generated from: '<S123>/Waypoint Follower'

            localDW->MergeStatus = static_cast<real_T>
                (localDW->WaypointFollower_n.WaypointFollower_o5);

            // SignalConversion generated from: '<S123>/Waypoint Follower' incorporates:
            //   MATLABSystem: '<S123>/Waypoint Follower'

            rty_LookAheadPoint[0] =
                localDW->WaypointFollower_n.WaypointFollower_o1[0];
            rty_LookAheadPoint[1] =
                localDW->WaypointFollower_n.WaypointFollower_o1[1];
            rty_LookAheadPoint[2] =
                localDW->WaypointFollower_n.WaypointFollower_o1[2];

            // SignalConversion generated from: '<S123>/Waypoint Follower'
            *rty_DesiredCourse = localDW->WaypointFollower_n.WaypointFollower_o2;

            // End of Outputs for SubSystem: '<S95>/Right'
        }
        break;

      case 3:
        {
            int32_T tmp;
            if (static_cast<int32_T>(rtAction) != static_cast<int32_T>
                    (rtPrevAction)) {
                // SystemReset for IfAction SubSystem: '<S95>/Bottom' incorporates:
                //   ActionPort: '<S119>/Action Port'

                // SystemReset for SwitchCase: '<S95>/Switch Case'
                FlightMissionMode_WaypointFollower_Reset
                    (&localDW->WaypointFollower_i);

                // End of SystemReset for SubSystem: '<S95>/Bottom'
            }

            // Outputs for IfAction SubSystem: '<S95>/Bottom' incorporates:
            //   ActionPort: '<S119>/Action Port'

            // Selector: '<S119>/Selector'
            tmp = 0;
            for (int32_T i{0}; i < 3; i++) {
                std::memcpy(&rtb_Selector_a[tmp], &rtu_RawWaypoint
                            [static_cast<int32_T>(tmp + 1152)],
                            static_cast<uint32_T>(sizeof(real_T) << 7U));
                tmp = static_cast<int32_T>(tmp + 128);
            }

            // End of Selector: '<S119>/Selector'
            FlightMissionMode_WaypointFollower(rtu_Pose, rtb_Selector_a,
                rtp_LookAheadDis, &localDW->WaypointFollower_i);

            // Merge: '<S95>/MergeStatus' incorporates:
            //   Constant: '<S119>/LookAheadDis'
            //   DataTypeConversion: '<S119>/Cast To Double'
            //   SignalConversion generated from: '<S119>/Waypoint Follower'

            localDW->MergeStatus = static_cast<real_T>
                (localDW->WaypointFollower_i.WaypointFollower_o5);

            // SignalConversion generated from: '<S119>/Waypoint Follower' incorporates:
            //   MATLABSystem: '<S119>/Waypoint Follower'

            rty_LookAheadPoint[0] =
                localDW->WaypointFollower_i.WaypointFollower_o1[0];
            rty_LookAheadPoint[1] =
                localDW->WaypointFollower_i.WaypointFollower_o1[1];
            rty_LookAheadPoint[2] =
                localDW->WaypointFollower_i.WaypointFollower_o1[2];

            // SignalConversion generated from: '<S119>/Waypoint Follower'
            *rty_DesiredCourse = localDW->WaypointFollower_i.WaypointFollower_o2;

            // End of Outputs for SubSystem: '<S95>/Bottom'
        }
        break;

      case 4:
        {
            int32_T tmp;
            if (static_cast<int32_T>(rtAction) != static_cast<int32_T>
                    (rtPrevAction)) {
                // SystemReset for IfAction SubSystem: '<S95>/Initial' incorporates:
                //   ActionPort: '<S121>/Action Port'

                // SystemReset for SwitchCase: '<S95>/Switch Case'
                FlightMissionMode_WaypointFollower_Reset
                    (&localDW->WaypointFollower_e);

                // End of SystemReset for SubSystem: '<S95>/Initial'
            }

            // Outputs for IfAction SubSystem: '<S95>/Initial' incorporates:
            //   ActionPort: '<S121>/Action Port'

            // Selector: '<S121>/Selector'
            tmp = 0;
            for (int32_T i{0}; i < 3; i++) {
                std::memcpy(&rtb_Selector[tmp], &rtu_RawWaypoint[static_cast<
                            int32_T>(tmp + 1536)], static_cast<uint32_T>(sizeof
                             (real_T) << 7U));
                tmp = static_cast<int32_T>(tmp + 128);
            }

            // End of Selector: '<S121>/Selector'
            FlightMissionMode_WaypointFollower(rtu_Pose, rtb_Selector,
                rtp_LookAheadDis, &localDW->WaypointFollower_e);

            // Merge: '<S95>/MergeStatus' incorporates:
            //   Constant: '<S121>/LookAheadDis'
            //   DataTypeConversion: '<S121>/Cast To Double'
            //   SignalConversion generated from: '<S121>/Waypoint Follower'

            localDW->MergeStatus = static_cast<real_T>
                (localDW->WaypointFollower_e.WaypointFollower_o5);

            // SignalConversion generated from: '<S121>/Waypoint Follower' incorporates:
            //   MATLABSystem: '<S121>/Waypoint Follower'

            rty_LookAheadPoint[0] =
                localDW->WaypointFollower_e.WaypointFollower_o1[0];
            rty_LookAheadPoint[1] =
                localDW->WaypointFollower_e.WaypointFollower_o1[1];
            rty_LookAheadPoint[2] =
                localDW->WaypointFollower_e.WaypointFollower_o1[2];

            // SignalConversion generated from: '<S121>/Waypoint Follower'
            *rty_DesiredCourse = localDW->WaypointFollower_e.WaypointFollower_o2;

            // End of Outputs for SubSystem: '<S95>/Initial'
        }
        break;
    }

    // End of SwitchCase: '<S95>/Switch Case'

    // Update for Memory: '<S95>/Memory'
    localDW->Memory_PreviousInput = localDW->MergeStatus;
}

void FlightMissionMode::FlightMissionMode_emxInit_char_T
    (emxArray_char_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions)
{
    emxArray_char_T_FlightMissionMode_T *emxArray;
    *pEmxArray = static_cast<emxArray_char_T_FlightMissionMode_T *>(std::malloc
        (sizeof(emxArray_char_T_FlightMissionMode_T)));
    emxArray = *pEmxArray;
    emxArray->data = static_cast<char_T *>(nullptr);
    emxArray->numDimensions = numDimensions;
    emxArray->size = static_cast<int32_T *>(std::malloc(static_cast<uint32_T>
        (sizeof(int32_T) * static_cast<uint32_T>(numDimensions))));
    emxArray->allocatedSize = 0;
    emxArray->canFreeData = true;
    for (int32_T i{0}; i <= static_cast<int32_T>(numDimensions - 1); i++) {
        emxArray->size[i] = 0;
    }
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
int8_T FlightMissionMode::FlightMissionMode_filedata
    (DW_StartPointGenerator_FlightMissionMode_T *localDW)
{
    int32_T k;
    int8_T f;
    boolean_T exitg1;
    f = 0;
    k = 1;
    exitg1 = false;
    while ((!exitg1) && (static_cast<int32_T>(k - 1) < 20)) {
        if (localDW->eml_openfiles[static_cast<int32_T>(static_cast<int32_T>(
                static_cast<int8_T>(k)) - 1)] == NULL) {
            f = static_cast<int8_T>(k);
            exitg1 = true;
        } else {
            k = static_cast<int32_T>(k + 1);
        }
    }

    return f;
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
int8_T FlightMissionMode::FlightMissionMode_cfopen(const char_T *cfilename,
    const char_T *cpermission, DW_StartPointGenerator_FlightMissionMode_T
    *localDW)
{
    int8_T fileid;
    int8_T j;
    fileid = -1;
    j = FlightMissionMode_filedata(localDW);
    if (static_cast<int32_T>(j) >= 1) {
        FILE* filestar;
        filestar = fopen(cfilename, cpermission);
        if (filestar != NULL) {
            int32_T tmp;
            localDW->eml_openfiles[static_cast<int32_T>(static_cast<int32_T>(j)
                - 1)] = filestar;
            tmp = static_cast<int32_T>(static_cast<int32_T>(j) + 2);
            if (static_cast<int32_T>(static_cast<int32_T>(j) + 2) > 127) {
                tmp = 127;
            }

            fileid = static_cast<int8_T>(tmp);
        }
    }

    return fileid;
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
real_T FlightMissionMode::FlightMissionMode_fileManager
    (DW_StartPointGenerator_FlightMissionMode_T *localDW)
{
    real_T f;
    int8_T fileid;
    fileid = FlightMissionMode_cfopen("config.ini", "rb", localDW);
    f = static_cast<real_T>(fileid);
    return f;
}

void FlightMissionMode::FlightMissionMode_emxEnsureCapacity_char_T
    (emxArray_char_T_FlightMissionMode_T *emxArray, int32_T oldNumel)
{
    int32_T i;
    int32_T newNumel;
    void *newData;
    if (oldNumel < 0) {
        oldNumel = 0;
    }

    newNumel = 1;
    for (i = 0; i <= static_cast<int32_T>(emxArray->numDimensions - 1); i++) {
        newNumel = static_cast<int32_T>(newNumel * emxArray->size[i]);
    }

    if (newNumel > emxArray->allocatedSize) {
        i = emxArray->allocatedSize;
        if (i < 16) {
            i = 16;
        }

        while (i < newNumel) {
            if (i > 1073741823) {
                i = MAX_int32_T;
            } else {
                i = static_cast<int32_T>(i << 1);
            }
        }

        newData = std::calloc(static_cast<uint32_T>(i), sizeof(char_T));
        if (emxArray->data != nullptr) {
            std::memcpy(newData, emxArray->data, static_cast<uint32_T>(sizeof
                         (char_T) * static_cast<uint32_T>(oldNumel)));
            if (emxArray->canFreeData) {
                std::free(emxArray->data);
            }
        }

        emxArray->data = static_cast<char_T *>(newData);
        emxArray->allocatedSize = i;
        emxArray->canFreeData = true;
    }
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_fread(real_T fileID,
    emxArray_char_T_FlightMissionMode_T *A,
    DW_StartPointGenerator_FlightMissionMode_T *localDW)
{
    FILE* filestar;
    size_t nBytes;
    char_T tbuf[1024];
    int8_T fileid;
    nBytes = sizeof(char_T);
    fileid = static_cast<int8_T>(std::round(fileID));
    if (fileID != static_cast<real_T>(fileid)) {
        fileid = -1;
    }

    if (static_cast<int32_T>(fileid) >= 3) {
        filestar = localDW->eml_openfiles[static_cast<int32_T>
            (static_cast<int32_T>(fileid) - 3)];
    } else {
        switch (static_cast<int32_T>(fileid)) {
          case 0:
            filestar = stdin;
            break;

          case 1:
            filestar = stdout;
            break;

          case 2:
            filestar = stderr;
            break;

          default:
            filestar = NULL;
            break;
        }
    }

    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
            static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
              static_cast<boolean_T>(static_cast<int32_T>((fileID != 0.0) ^ 1)))
             | static_cast<int32_T>(static_cast<boolean_T>(static_cast<int32_T>
               ((fileID != 1.0) ^ 1)))))) | static_cast<int32_T>
            (static_cast<boolean_T>(static_cast<int32_T>((fileID != 2.0) ^ 1))))))
    {
        filestar = NULL;
    }

    A->size[0] = 0;
    if (static_cast<boolean_T>(static_cast<int32_T>((filestar == NULL) ^ 1))) {
        int32_T c;
        c = 1;
        while (c > 0) {
            int32_T c_0;
            int32_T i;
            int32_T numRead;
            c = 0;
            numRead = 1;
            while (static_cast<boolean_T>(static_cast<int32_T>((c < 1024) &
                     (numRead > 0)))) {
                size_t numReadSizeT;
                numReadSizeT = fread(&tbuf[c], nBytes, (size_t)(1024 - c),
                                     filestar);
                numRead = (int32_T)numReadSizeT;
                c = static_cast<int32_T>(c + (int32_T)numReadSizeT);
            }

            numRead = A->size[0];
            if (c < 1) {
                c_0 = -1;
            } else {
                c_0 = static_cast<int32_T>(c - 1);
            }

            i = A->size[0];
            A->size[0] = static_cast<int32_T>(static_cast<int32_T>(c_0 + A->
                size[0]) + 1);
            FlightMissionMode_emxEnsureCapacity_char_T(A, i);
            if (c < 1) {
                c_0 = -1;
            } else {
                c_0 = static_cast<int32_T>(c - 1);
            }

            for (i = 0; i <= c_0; i++) {
                A->data[static_cast<int32_T>(numRead + i)] = tbuf[i];
            }
        }
    }
}

void FlightMissionMode::FlightMissionMode_emxFree_char_T
    (emxArray_char_T_FlightMissionMode_T **pEmxArray)
{
    if (*pEmxArray != static_cast<emxArray_char_T_FlightMissionMode_T *>(nullptr))
    {
        if (((*pEmxArray)->data != static_cast<char_T *>(nullptr)) &&
                (*pEmxArray)->canFreeData) {
            std::free((*pEmxArray)->data);
        }

        std::free((*pEmxArray)->size);
        std::free(*pEmxArray);
        *pEmxArray = static_cast<emxArray_char_T_FlightMissionMode_T *>(nullptr);
    }
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_copydigits
    (emxArray_char_T_FlightMissionMode_T *s1, int32_T *idx, const
     emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n, boolean_T
     allowpoint)
{
    boolean_T exitg1;
    boolean_T haspoint;
    boolean_T success;
    success = (*k <= n);
    haspoint = false;
    exitg1 = false;
    while ((!exitg1) && (static_cast<boolean_T>(static_cast<int32_T>((*k <= n) &
              static_cast<int32_T>(success))))) {
        char_T tmp;
        tmp = s->data[static_cast<int32_T>(*k - 1)];
        if ((tmp >= '0') && (tmp <= '9')) {
            s1->data[static_cast<int32_T>(*idx - 1)] = tmp;
            *idx = static_cast<int32_T>(*idx + 1);
            *k = static_cast<int32_T>(*k + 1);
        } else if (tmp == '.') {
            success = static_cast<boolean_T>(static_cast<int32_T>
                (static_cast<int32_T>(static_cast<boolean_T>(static_cast<int32_T>
                (static_cast<int32_T>(haspoint) ^ 1))) & static_cast<int32_T>
                 (allowpoint)));
            if (success) {
                s1->data[static_cast<int32_T>(*idx - 1)] = '.';
                *idx = static_cast<int32_T>(*idx + 1);
                haspoint = true;
            }

            *k = static_cast<int32_T>(*k + 1);
        } else if (tmp == ',') {
            *k = static_cast<int32_T>(*k + 1);
        } else {
            exitg1 = true;
        }
    }

    return success;
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_readfloat
    (emxArray_char_T_FlightMissionMode_T *s1, int32_T *idx, const
     emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n, boolean_T
     allowimag, boolean_T *isimag, boolean_T *b_finite, real_T *nfv, boolean_T
     *foundsign, boolean_T *success)
{
    static const boolean_T b[128]{ false, false, false, false, false, false,
        false, false, false, true, true, true, true, true, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, true, true, true, true, true, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false };

    emxArray_char_T_FlightMissionMode_T *d;
    int32_T b_idx;
    int32_T b_k;
    int32_T g_k;
    char_T c_idx_0;
    boolean_T a__3;
    boolean_T exitg1;
    boolean_T isneg;
    FlightMissionMode_emxInit_char_T(&d, 2);
    *isimag = false;
    *b_finite = true;
    *nfv = 0.0;
    b_idx = *idx;
    b_k = *k;
    isneg = false;
    *foundsign = false;
    exitg1 = false;
    while ((!exitg1) && (b_k <= n)) {
        c_idx_0 = s->data[static_cast<int32_T>(b_k - 1)];
        if (c_idx_0 == '-') {
            isneg = static_cast<boolean_T>(static_cast<int32_T>
                (static_cast<int32_T>(isneg) ^ 1));
            *foundsign = true;
            b_k = static_cast<int32_T>(b_k + 1);
        } else if (c_idx_0 == ',') {
            b_k = static_cast<int32_T>(b_k + 1);
        } else if (c_idx_0 == '+') {
            *foundsign = true;
            b_k = static_cast<int32_T>(b_k + 1);
        } else if (static_cast<boolean_T>(static_cast<int32_T>
                    (static_cast<int32_T>(b[static_cast<int32_T>
                      (static_cast<int32_T>(static_cast<uint8_T>(c_idx_0)) & 127)])
                     ^ 1))) {
            exitg1 = true;
        } else {
            b_k = static_cast<int32_T>(b_k + 1);
        }
    }

    *success = (b_k <= n);
    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
            (*success) & static_cast<int32_T>(isneg)))) {
        if ((*idx >= 2) && (s1->data[static_cast<int32_T>(*idx - 2)] == '-')) {
            s1->data[static_cast<int32_T>(*idx - 2)] = ' ';
        } else {
            s1->data[static_cast<int32_T>(*idx - 1)] = '-';
            b_idx = static_cast<int32_T>(*idx + 1);
        }
    }

    *idx = b_idx;
    *k = b_k;
    if (*success) {
        char_T c_idx_1;
        char_T c_idx_2;
        isneg = false;
        if (b_k <= n) {
            c_idx_0 = s->data[static_cast<int32_T>(b_k - 1)];
            if (c_idx_0 == 'j') {
                isneg = true;
            } else if (c_idx_0 == 'i') {
                if (b_k >= static_cast<int32_T>(n - 1)) {
                    isneg = true;
                } else {
                    g_k = b_k;
                    c_idx_0 = '\x00';
                    while ((g_k <= n) && (s->data[static_cast<int32_T>(g_k - 1)]
                                          == ',')) {
                        g_k = static_cast<int32_T>(g_k + 1);
                    }

                    if (g_k <= n) {
                        c_idx_0 = s->data[static_cast<int32_T>(g_k - 1)];
                    }

                    g_k = static_cast<int32_T>(g_k + 1);
                    c_idx_1 = '\x00';
                    while ((g_k <= n) && (s->data[static_cast<int32_T>(g_k - 1)]
                                          == ',')) {
                        g_k = static_cast<int32_T>(g_k + 1);
                    }

                    if (g_k <= n) {
                        c_idx_1 = s->data[static_cast<int32_T>(g_k - 1)];
                    }

                    g_k = static_cast<int32_T>(g_k + 1);
                    c_idx_2 = '\x00';
                    while ((g_k <= n) && (s->data[static_cast<int32_T>(g_k - 1)]
                                          == ',')) {
                        g_k = static_cast<int32_T>(g_k + 1);
                    }

                    if (g_k <= n) {
                        c_idx_2 = s->data[static_cast<int32_T>(g_k - 1)];
                    }

                    if (((c_idx_0 == 'I') || (c_idx_0 == 'i')) && ((c_idx_1 ==
                            'N') || (c_idx_1 == 'n')) && ((c_idx_2 == 'F') ||
                            (c_idx_2 == 'f'))) {
                    } else if ((c_idx_0 == 'N') || (c_idx_0 == 'n')) {
                        if ((c_idx_1 == 'A') || (c_idx_1 == 'a')) {
                            if ((c_idx_2 != 'N') && (c_idx_2 != 'n')) {
                                isneg = true;
                            }
                        } else {
                            isneg = true;
                        }
                    } else {
                        isneg = true;
                    }
                }
            }
        }

        if (isneg) {
            if (allowimag) {
                *isimag = true;
                *k = static_cast<int32_T>(b_k + 1);
                exitg1 = false;
                while ((!exitg1) && (*k <= n)) {
                    if (b[static_cast<int32_T>(static_cast<int32_T>
                                               (static_cast<uint8_T>(s->data[
                            static_cast<int32_T>(*k - 1)])) & 127)]) {
                        *k = static_cast<int32_T>(*k + 1);
                    } else {
                        c_idx_0 = s->data[static_cast<int32_T>(*k - 1)];
                        if ((c_idx_0 == '\x00') || (c_idx_0 == ',')) {
                            *k = static_cast<int32_T>(*k + 1);
                        } else {
                            exitg1 = true;
                        }
                    }
                }

                if ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == '*'))
                {
                    *k = static_cast<int32_T>(*k + 1);
                    FlightMissionMode_readfloat(s1, idx, s, k, n, false, &isneg,
                        b_finite, nfv, &a__3, success);
                } else {
                    s1->data[static_cast<int32_T>(b_idx - 1)] = '1';
                    *idx = static_cast<int32_T>(b_idx + 1);
                }
            } else {
                *success = false;
            }
        } else {
            g_k = b_k;
            c_idx_0 = '\x00';
            while ((g_k <= n) && (s->data[static_cast<int32_T>(g_k - 1)] == ','))
            {
                g_k = static_cast<int32_T>(g_k + 1);
            }

            if (g_k <= n) {
                c_idx_0 = s->data[static_cast<int32_T>(g_k - 1)];
            }

            g_k = static_cast<int32_T>(g_k + 1);
            c_idx_1 = '\x00';
            while ((g_k <= n) && (s->data[static_cast<int32_T>(g_k - 1)] == ','))
            {
                g_k = static_cast<int32_T>(g_k + 1);
            }

            if (g_k <= n) {
                c_idx_1 = s->data[static_cast<int32_T>(g_k - 1)];
            }

            g_k = static_cast<int32_T>(g_k + 1);
            c_idx_2 = '\x00';
            while ((g_k <= n) && (s->data[static_cast<int32_T>(g_k - 1)] == ','))
            {
                g_k = static_cast<int32_T>(g_k + 1);
            }

            if (g_k <= n) {
                c_idx_2 = s->data[static_cast<int32_T>(g_k - 1)];
            }

            g_k = static_cast<int32_T>(g_k + 1);
            if (((c_idx_0 == 'I') || (c_idx_0 == 'i')) && ((c_idx_1 == 'N') ||
                    (c_idx_1 == 'n')) && ((c_idx_2 == 'F') || (c_idx_2 == 'f')))
            {
                *b_finite = false;
                *nfv = (rtInf);
            } else if (((c_idx_0 == 'N') || (c_idx_0 == 'n')) && ((c_idx_1 ==
                         'A') || (c_idx_1 == 'a')) && ((c_idx_2 == 'N') ||
                        (c_idx_2 == 'n'))) {
                *b_finite = false;
                *nfv = (rtNaN);
            } else {
                g_k = b_k;
            }

            *k = g_k;
            if (*b_finite) {
                int32_T loop_ub;
                b_k = static_cast<int32_T>(d->size[0] * d->size[1]);
                d->size[0] = 1;
                d->size[1] = s1->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T(d, b_k);
                loop_ub = static_cast<int32_T>(s1->size[1] - 1);
                for (b_k = 0; b_k <= loop_ub; b_k++) {
                    d->data[b_k] = s1->data[b_k];
                }

                *success = FlightMissionMode_copydigits(d, &b_idx, s, &g_k, n,
                    true);
                b_k = static_cast<int32_T>(s1->size[0] * s1->size[1]);
                s1->size[0] = 1;
                s1->size[1] = d->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T(s1, b_k);
                loop_ub = d->size[1];
                for (b_k = 0; b_k <= static_cast<int32_T>(loop_ub - 1); b_k++) {
                    s1->data[b_k] = d->data[b_k];
                }

                *idx = b_idx;
                *k = g_k;
                if ((*success) && (g_k <= n)) {
                    c_idx_0 = s->data[static_cast<int32_T>(g_k - 1)];
                    if ((c_idx_0 == 'E') || (c_idx_0 == 'e')) {
                        s1->data[static_cast<int32_T>(b_idx - 1)] = 'e';
                        *idx = static_cast<int32_T>(b_idx + 1);
                        while ((static_cast<int32_T>(g_k + 1) <= n) && (s->
                                data[g_k] == ',')) {
                            g_k = static_cast<int32_T>(g_k + 1);
                        }

                        if (static_cast<int32_T>(g_k + 1) <= n) {
                            if (s->data[g_k] == '-') {
                                s1->data[b_idx] = '-';
                                *idx = static_cast<int32_T>(b_idx + 2);
                                g_k = static_cast<int32_T>(g_k + 1);
                            } else if (s->data[g_k] == '+') {
                                g_k = static_cast<int32_T>(g_k + 1);
                            }
                        }

                        b_k = static_cast<int32_T>(d->size[0] * d->size[1]);
                        d->size[0] = 1;
                        d->size[1] = s1->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T(d, b_k);
                        loop_ub = static_cast<int32_T>(s1->size[1] - 1);
                        for (b_k = 0; b_k <= loop_ub; b_k++) {
                            d->data[b_k] = s1->data[b_k];
                        }

                        b_idx = static_cast<int32_T>(g_k + 1);
                        isneg = FlightMissionMode_copydigits(d, idx, s, &b_idx,
                            n, false);
                        b_k = static_cast<int32_T>(s1->size[0] * s1->size[1]);
                        s1->size[0] = 1;
                        s1->size[1] = d->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T(s1, b_k);
                        loop_ub = d->size[1];
                        for (b_k = 0; b_k <= static_cast<int32_T>(loop_ub - 1);
                                b_k++) {
                            s1->data[b_k] = d->data[b_k];
                        }

                        *k = b_idx;
                        if (static_cast<boolean_T>(static_cast<int32_T>((b_idx <=
                               static_cast<int32_T>(g_k + 1)) |
                                static_cast<int32_T>(static_cast<boolean_T>(
                                static_cast<int32_T>(static_cast<int32_T>(isneg)
                                 ^ 1)))))) {
                            *success = false;
                        }
                    }
                }
            } else if ((b_idx >= 2) && (s1->data[static_cast<int32_T>(b_idx - 2)]
                        == '-')) {
                *idx = static_cast<int32_T>(b_idx - 1);
                s1->data[static_cast<int32_T>(b_idx - 2)] = ' ';
                *nfv = -*nfv;
            }

            exitg1 = false;
            while ((!exitg1) && (*k <= n)) {
                if (b[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(s->data[
                        static_cast<int32_T>(*k - 1)])) & 127)]) {
                    *k = static_cast<int32_T>(*k + 1);
                } else {
                    c_idx_0 = s->data[static_cast<int32_T>(*k - 1)];
                    if ((c_idx_0 == '\x00') || (c_idx_0 == ',')) {
                        *k = static_cast<int32_T>(*k + 1);
                    } else {
                        exitg1 = true;
                    }
                }
            }

            if ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == '*')) {
                *k = static_cast<int32_T>(*k + 1);
                while ((*k <= n) && (b[static_cast<int32_T>(static_cast<int32_T>
                         (static_cast<uint8_T>(s->data[static_cast<int32_T>(*k -
                            1)])) & 127)] || (s->data[static_cast<int32_T>(*k -
                          1)] == '\x00') || (s->data[static_cast<int32_T>(*k - 1)]
                         == ','))) {
                    *k = static_cast<int32_T>(*k + 1);
                }
            }

            if (*k <= n) {
                c_idx_0 = s->data[static_cast<int32_T>(*k - 1)];
                if ((c_idx_0 == 'i') || (c_idx_0 == 'j')) {
                    *k = static_cast<int32_T>(*k + 1);
                    *isimag = true;
                }
            }
        }

        exitg1 = false;
        while ((!exitg1) && (*k <= n)) {
            c_idx_0 = s->data[static_cast<int32_T>(*k - 1)];
            if (b[static_cast<int32_T>(static_cast<int32_T>(static_cast<uint8_T>
                    (c_idx_0)) & 127)] || (c_idx_0 == '\x00') || (c_idx_0 == ','))
            {
                *k = static_cast<int32_T>(*k + 1);
            } else {
                exitg1 = true;
            }
        }
    }

    FlightMissionMode_emxFree_char_T(&d);
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
creal_T FlightMissionMode::FlightMissionMode_str2double(const
    emxArray_char_T_FlightMissionMode_T *s)
{
    static const boolean_T c[128]{ false, false, false, false, false, false,
        false, false, false, true, true, true, true, true, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, true, true, true, true, true, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false };

    emxArray_char_T_FlightMissionMode_T *d;
    emxArray_char_T_FlightMissionMode_T *s1;
    creal_T x;
    real_T b_scanned1;
    real_T scanned1;
    real_T scanned2;
    int32_T idx;
    int32_T k;
    boolean_T a__1;
    boolean_T c_success;
    boolean_T foundsign;
    boolean_T isfinite1;
    boolean_T isimag1;
    boolean_T success;
    FlightMissionMode_emxInit_char_T(&d, 2);
    x.re = (rtNaN);
    x.im = 0.0;
    if (s->size[1] >= 1) {
        int32_T i;
        int32_T loop_ub;
        int32_T ntoread;
        boolean_T exitg1;
        FlightMissionMode_emxInit_char_T(&s1, 2);
        ntoread = 0;
        k = 1;
        exitg1 = false;
        while ((!exitg1) && (k <= s->size[1])) {
            char_T tmp;
            tmp = s->data[static_cast<int32_T>(k - 1)];
            if (c[static_cast<int32_T>(static_cast<int32_T>(static_cast<uint8_T>
                    (tmp)) & 127)] || (tmp == '\x00')) {
                k = static_cast<int32_T>(k + 1);
            } else {
                exitg1 = true;
            }
        }

        i = static_cast<int32_T>(d->size[0] * d->size[1]);
        d->size[0] = 1;
        d->size[1] = static_cast<int32_T>(s->size[1] + 2);
        FlightMissionMode_emxEnsureCapacity_char_T(d, i);
        loop_ub = s->size[1];
        for (i = 0; i <= static_cast<int32_T>(loop_ub + 1); i++) {
            d->data[i] = '\x00';
        }

        idx = 1;
        FlightMissionMode_readfloat(d, &idx, s, &k, s->size[1], true, &isimag1,
            &isfinite1, &scanned1, &a__1, &success);
        i = static_cast<int32_T>(s1->size[0] * s1->size[1]);
        s1->size[0] = 1;
        s1->size[1] = d->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T(s1, i);
        loop_ub = static_cast<int32_T>(d->size[1] - 1);
        for (i = 0; i <= loop_ub; i++) {
            s1->data[i] = d->data[i];
        }

        if (isfinite1) {
            ntoread = 1;
        }

        if (success) {
            if (k <= s->size[1]) {
                s1->data[static_cast<int32_T>(idx - 1)] = ' ';
                i = static_cast<int32_T>(d->size[0] * d->size[1]);
                d->size[0] = 1;
                d->size[1] = s1->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T(d, i);
                loop_ub = static_cast<int32_T>(s1->size[1] - 1);
                for (i = 0; i <= loop_ub; i++) {
                    d->data[i] = s1->data[i];
                }

                idx = static_cast<int32_T>(idx + 1);
                FlightMissionMode_readfloat(d, &idx, s, &k, s->size[1], true,
                    &a__1, &success, &scanned2, &foundsign, &c_success);
                i = static_cast<int32_T>(s1->size[0] * s1->size[1]);
                s1->size[0] = 1;
                s1->size[1] = d->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T(s1, i);
                loop_ub = static_cast<int32_T>(d->size[1] - 1);
                for (i = 0; i <= loop_ub; i++) {
                    s1->data[i] = d->data[i];
                }

                if (success) {
                    ntoread = static_cast<int32_T>(ntoread + 1);
                }

                success = static_cast<boolean_T>(static_cast<int32_T>(
                    static_cast<int32_T>(static_cast<boolean_T>
                    (static_cast<int32_T>(static_cast<int32_T>
                    (static_cast<boolean_T>(static_cast<int32_T>
                    (static_cast<int32_T>(static_cast<boolean_T>
                    (static_cast<int32_T>(static_cast<int32_T>(isimag1) ^
                    static_cast<int32_T>(a__1)))) & static_cast<int32_T>
                     (foundsign)))) & (k > s->size[1])))) & static_cast<int32_T>
                    (c_success)));
            } else {
                scanned2 = 0.0;
            }
        } else {
            scanned2 = 0.0;
        }

        if (success) {
            s1->data[static_cast<int32_T>(idx - 1)] = '\x00';
            switch (ntoread) {
              case 2:
                ntoread = sscanf(&s1->data[0], "%lf %lf", &scanned1, &scanned2);
                if (ntoread != 2) {
                    scanned1 = (rtNaN);
                    scanned2 = (rtNaN);
                }
                break;

              case 1:
                ntoread = sscanf(&s1->data[0], "%lf", &b_scanned1);
                if (isfinite1) {
                    if (ntoread == 1) {
                        scanned1 = b_scanned1;
                    } else {
                        scanned1 = (rtNaN);
                    }
                } else if (ntoread == 1) {
                    scanned2 = b_scanned1;
                } else {
                    scanned2 = (rtNaN);
                }
                break;
            }

            if (isimag1) {
                x.re = scanned2;
                x.im = scanned1;
            } else {
                x.re = scanned1;
                x.im = scanned2;
            }
        }

        FlightMissionMode_emxFree_char_T(&s1);
    }

    FlightMissionMode_emxFree_char_T(&d);
    return x;
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
int32_T FlightMissionMode::FlightMissionMode_cfclose(real_T fid,
    DW_StartPointGenerator_FlightMissionMode_T *localDW)
{
    FILE* filestar;
    int32_T st;
    int8_T b_fileid;
    int8_T fileid;
    st = -1;
    fileid = static_cast<int8_T>(std::round(fid));
    if (fid != static_cast<real_T>(fileid)) {
        fileid = -1;
    }

    b_fileid = fileid;
    if (static_cast<int32_T>(fileid) < 0) {
        b_fileid = -1;
    }

    if (static_cast<int32_T>(b_fileid) >= 3) {
        filestar = localDW->eml_openfiles[static_cast<int32_T>
            (static_cast<int32_T>(b_fileid) - 3)];
    } else {
        switch (static_cast<int32_T>(b_fileid)) {
          case 0:
            filestar = stdin;
            break;

          case 1:
            filestar = stdout;
            break;

          case 2:
            filestar = stderr;
            break;

          default:
            filestar = NULL;
            break;
        }
    }

    if (static_cast<boolean_T>(static_cast<int32_T>((filestar != NULL) & (
            static_cast<int32_T>(fileid) >= 3)))) {
        int32_T cst;
        cst = fclose(filestar);
        if (cst == 0) {
            st = 0;
            localDW->eml_openfiles[static_cast<int32_T>(static_cast<int32_T>
                (fileid) - 3)] = NULL;
        }
    }

    return st;
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_strtok(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token, emxArray_char_T_FlightMissionMode_T *remain)
{
    int32_T b;
    int32_T i;
    int32_T itoken;
    int32_T k;
    int32_T n;
    n = x->size[1];
    k = 0;
    while ((static_cast<int32_T>(k + 1) <= n) && (x->data[k] == '\x0a')) {
        k = static_cast<int32_T>(k + 1);
    }

    itoken = static_cast<int32_T>(k + 1);
    while ((static_cast<int32_T>(k + 1) <= n) && (x->data[k] != '\x0a')) {
        k = static_cast<int32_T>(k + 1);
    }

    if (static_cast<int32_T>(k + 1) > x->size[1]) {
        n = 0;
        b = 0;
    } else {
        n = k;
        b = x->size[1];
    }

    i = static_cast<int32_T>(remain->size[0] * remain->size[1]);
    remain->size[0] = 1;
    b = static_cast<int32_T>(b - n);
    remain->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T(remain, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        remain->data[i] = x->data[static_cast<int32_T>(n + i)];
    }

    if (itoken > k) {
        itoken = 0;
        k = 0;
    } else {
        itoken = static_cast<int32_T>(itoken - 1);
    }

    i = static_cast<int32_T>(token->size[0] * token->size[1]);
    token->size[0] = 1;
    b = static_cast<int32_T>(k - itoken);
    token->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T(token, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        token->data[i] = x->data[static_cast<int32_T>(itoken + i)];
    }
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_strtok_o(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token)
{
    int32_T itoken;
    int32_T k;
    int32_T n;
    n = x->size[1];
    k = 1;
    while ((k <= n) && (x->data[static_cast<int32_T>(k - 1)] == ';')) {
        k = static_cast<int32_T>(k + 1);
    }

    itoken = k;
    while ((k <= n) && (x->data[static_cast<int32_T>(k - 1)] != ';')) {
        k = static_cast<int32_T>(k + 1);
    }

    if (itoken > static_cast<int32_T>(k - 1)) {
        n = 0;
        k = 0;
    } else {
        n = static_cast<int32_T>(itoken - 1);
        k = static_cast<int32_T>(k - 1);
    }

    itoken = static_cast<int32_T>(token->size[0] * token->size[1]);
    token->size[0] = 1;
    k = static_cast<int32_T>(k - n);
    token->size[1] = k;
    FlightMissionMode_emxEnsureCapacity_char_T(token, itoken);
    for (itoken = 0; itoken <= static_cast<int32_T>(k - 1); itoken++) {
        token->data[itoken] = x->data[static_cast<int32_T>(n + itoken)];
    }
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_strtrim(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    y)
{
    static const boolean_T d[128]{ false, false, false, false, false, false,
        false, false, false, true, true, true, true, true, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, true, true, true, true, true, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false };

    int32_T b_j1;
    int32_T i;
    int32_T j2;
    b_j1 = 0;
    while ((static_cast<int32_T>(b_j1 + 1) <= x->size[1]) &&
            (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(d[
               static_cast<int32_T>(static_cast<int32_T>(static_cast<uint8_T>
                 (x->data[b_j1])) & 127)]) & (x->data[b_j1] != '\x00'))))) {
        b_j1 = static_cast<int32_T>(b_j1 + 1);
    }

    j2 = static_cast<int32_T>(x->size[1] - 1);
    while ((static_cast<int32_T>(j2 + 1) > 0) && (static_cast<boolean_T>(
             static_cast<int32_T>(static_cast<int32_T>(d[static_cast<int32_T>(
                static_cast<int32_T>(static_cast<uint8_T>(x->data[j2])) & 127)])
              & (x->data[j2] != '\x00'))))) {
        j2 = static_cast<int32_T>(j2 - 1);
    }

    if (static_cast<int32_T>(b_j1 + 1) > static_cast<int32_T>(j2 + 1)) {
        b_j1 = 0;
        j2 = -1;
    }

    i = static_cast<int32_T>(y->size[0] * y->size[1]);
    y->size[0] = 1;
    j2 = static_cast<int32_T>(j2 - b_j1);
    y->size[1] = static_cast<int32_T>(j2 + 1);
    FlightMissionMode_emxEnsureCapacity_char_T(y, i);
    for (i = 0; i <= j2; i++) {
        y->data[i] = x->data[static_cast<int32_T>(b_j1 + i)];
    }
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[3]{ 'U', 'A', 'V' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T(aTmp, i);
        loop_ub = static_cast<int32_T>(a->size[1] - 1);
        for (i = 0; i <= loop_ub; i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 3) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 3) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_b(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[10]{ 'N', 'o', 'r', 'm', 'A', 'i', 'r', 'S', 'p', 'd'
    };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T(aTmp, i);
        loop_ub = static_cast<int32_T>(a->size[1] - 1);
        for (i = 0; i <= loop_ub; i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 10) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 10) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_contains(const
    emxArray_char_T_FlightMissionMode_T *str)
{
    int32_T matchPos;
    matchPos = 0;
    int32_T exitg1;
    do {
        exitg1 = 0;
        if (matchPos <= static_cast<int32_T>(str->size[1] - 1)) {
            if (str->data[matchPos] == '=') {
                exitg1 = 1;
            } else {
                matchPos = static_cast<int32_T>(matchPos + 1);
            }
        } else {
            matchPos = -1;
            exitg1 = 1;
        }
    } while (exitg1 == 0);

    return static_cast<int32_T>(matchPos + 1) > 0;
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_find_token(const
    emxArray_char_T_FlightMissionMode_T *x, int32_T *itoken, int32_T *iremain)
{
    int32_T n;
    n = x->size[1];
    *iremain = 1;
    while ((*iremain <= n) && (x->data[static_cast<int32_T>(*iremain - 1)] ==
                               '=')) {
        *iremain = static_cast<int32_T>(*iremain + 1);
    }

    *itoken = *iremain;
    while ((*iremain <= n) && (x->data[static_cast<int32_T>(*iremain - 1)] !=
                               '=')) {
        *iremain = static_cast<int32_T>(*iremain + 1);
    }
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_strtok_of(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token, emxArray_char_T_FlightMissionMode_T *remain)
{
    int32_T b;
    int32_T c;
    int32_T i;
    int32_T iremain;
    int32_T itoken;
    FlightMissionMode_find_token(x, &itoken, &iremain);
    if (iremain > x->size[1]) {
        c = 0;
        b = 0;
    } else {
        c = static_cast<int32_T>(iremain - 1);
        b = x->size[1];
    }

    i = static_cast<int32_T>(remain->size[0] * remain->size[1]);
    remain->size[0] = 1;
    b = static_cast<int32_T>(b - c);
    remain->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T(remain, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        remain->data[i] = x->data[static_cast<int32_T>(c + i)];
    }

    if (itoken > static_cast<int32_T>(iremain - 1)) {
        itoken = 0;
        iremain = 0;
    } else {
        itoken = static_cast<int32_T>(itoken - 1);
        iremain = static_cast<int32_T>(iremain - 1);
    }

    i = static_cast<int32_T>(token->size[0] * token->size[1]);
    token->size[0] = 1;
    b = static_cast<int32_T>(iremain - itoken);
    token->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T(token, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        token->data[i] = x->data[static_cast<int32_T>(itoken + i)];
    }
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_strtok_ofg(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token)
{
    int32_T i;
    int32_T iremain;
    int32_T itoken;
    FlightMissionMode_find_token(x, &itoken, &iremain);
    if (itoken > static_cast<int32_T>(iremain - 1)) {
        itoken = 0;
        iremain = 0;
    } else {
        itoken = static_cast<int32_T>(itoken - 1);
        iremain = static_cast<int32_T>(iremain - 1);
    }

    i = static_cast<int32_T>(token->size[0] * token->size[1]);
    token->size[0] = 1;
    iremain = static_cast<int32_T>(iremain - itoken);
    token->size[1] = iremain;
    FlightMissionMode_emxEnsureCapacity_char_T(token, i);
    for (i = 0; i <= static_cast<int32_T>(iremain - 1); i++) {
        token->data[i] = x->data[static_cast<int32_T>(itoken + i)];
    }
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_bt(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[9]{ 'M', 'a', 'x', 'A', 'i', 'r', 'S', 'p', 'd' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T(aTmp, i);
        loop_ub = static_cast<int32_T>(a->size[1] - 1);
        for (i = 0; i <= loop_ub; i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 9) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 9) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_readINI
    (emxArray_char_T_FlightMissionMode_T *ret,
     DW_StartPointGenerator_FlightMissionMode_T *localDW)
{
    static const char_T h[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T i[15]{ 'C', 'l', 'i', 'm', 'b', 'A', 'n', 'g', 'l', 'e',
        'L', 'i', 'm', 'i', 't' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    emxArray_char_T_FlightMissionMode_T *curKey;
    emxArray_char_T_FlightMissionMode_T *curLine;
    emxArray_char_T_FlightMissionMode_T *curSection;
    emxArray_char_T_FlightMissionMode_T *curVal;
    emxArray_char_T_FlightMissionMode_T *data;
    emxArray_char_T_FlightMissionMode_T *data_0;
    emxArray_char_T_FlightMissionMode_T *j;
    emxArray_char_T_FlightMissionMode_T *tmp;
    int32_T iremain;
    int32_T itoken;
    int8_T fileid;
    ret->size[0] = 1;
    ret->size[1] = 0;
    fileid = FlightMissionMode_cfopen("config.ini", "rb", localDW);
    if (static_cast<int32_T>(fileid) < 0) {
        printf("INI-file \"%s\" was not found or could not be read.\n",
               "config.ini");
        fflush(stdout);
    } else {
        int32_T itoken_0;
        int32_T loop_ub;
        FlightMissionMode_emxInit_char_T(&data, 2);
        FlightMissionMode_emxInit_char_T(&j, 1);
        FlightMissionMode_fread(static_cast<real_T>(fileid), j, localDW);
        itoken_0 = static_cast<int32_T>(data->size[0] * data->size[1]);
        data->size[0] = 1;
        data->size[1] = j->size[0];
        FlightMissionMode_emxEnsureCapacity_char_T(data, itoken_0);
        loop_ub = j->size[0];
        for (itoken_0 = 0; itoken_0 <= static_cast<int32_T>(loop_ub - 1);
                itoken_0++) {
            data->data[itoken_0] = j->data[itoken_0];
        }

        FlightMissionMode_emxFree_char_T(&j);
        FlightMissionMode_emxInit_char_T(&curSection, 2);
        FlightMissionMode_emxInit_char_T(&curKey, 2);
        FlightMissionMode_emxInit_char_T(&curVal, 2);
        FlightMissionMode_cfclose(static_cast<real_T>(fileid), localDW);
        curSection->size[0] = 1;
        curSection->size[1] = 0;
        curKey->size[0] = 1;
        curKey->size[1] = 0;
        curVal->size[0] = 1;
        curVal->size[1] = 0;
        FlightMissionMode_emxInit_char_T(&curLine, 2);
        FlightMissionMode_emxInit_char_T(&aTmp, 2);
        FlightMissionMode_emxInit_char_T(&tmp, 2);
        FlightMissionMode_emxInit_char_T(&data_0, 2);
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (data->size[1] != 0) {
                boolean_T b_bool;
                itoken_0 = static_cast<int32_T>(data_0->size[0] * data_0->size[1]);
                data_0->size[0] = 1;
                data_0->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T(data_0, itoken_0);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (itoken_0 = 0; itoken_0 <= loop_ub; itoken_0++) {
                    itoken = itoken_0;
                    data_0->data[itoken_0] = data->data[itoken_0];
                }

                FlightMissionMode_strtok(data_0, curLine, data);
                FlightMissionMode_strtok_o(curLine, tmp);
                FlightMissionMode_strtrim(tmp, curLine);
                if (curLine->size[1] >= 2) {
                    boolean_T guard1{ false };

                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                iremain = 0;
                                itoken = 0;
                            } else {
                                iremain = 1;
                                itoken = static_cast<int32_T>(curLine->size[1] -
                                    1);
                            }

                            itoken_0 = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(itoken - iremain);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T
                                (curSection, itoken_0);
                            for (itoken_0 = 0; itoken_0 <= static_cast<int32_T>
                                    (loop_ub - 1); itoken_0++) {
                                curSection->data[itoken_0] = curLine->data[
                                    static_cast<int32_T>(iremain + itoken_0)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains(curLine)) {
                            FlightMissionMode_strtok_of(curLine, aTmp, curVal);
                            FlightMissionMode_find_token(curVal, &itoken,
                                &iremain);
                            if (itoken > static_cast<int32_T>(iremain - 1)) {
                                itoken = 0;
                                iremain = 0;
                            } else {
                                itoken = static_cast<int32_T>(itoken - 1);
                                iremain = static_cast<int32_T>(iremain - 1);
                            }

                            FlightMissionMode_strtrim(aTmp, curKey);
                            itoken_0 = static_cast<int32_T>(curLine->size[0] *
                                curLine->size[1]);
                            curLine->size[0] = 1;
                            loop_ub = static_cast<int32_T>(iremain - itoken);
                            curLine->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T(curLine,
                                itoken_0);
                            for (itoken_0 = 0; itoken_0 <= static_cast<int32_T>
                                    (loop_ub - 1); itoken_0++) {
                                curLine->data[itoken_0] = curVal->data[
                                    static_cast<int32_T>(itoken + itoken_0)];
                            }

                            FlightMissionMode_strtrim(curLine, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp(curSection)) {
                    if (curKey->size[1] == 0) {
                        aTmp->size[0] = 1;
                        aTmp->size[1] = 0;
                    } else {
                        itoken_0 = static_cast<int32_T>(aTmp->size[0] *
                            aTmp->size[1]);
                        aTmp->size[0] = 1;
                        aTmp->size[1] = curKey->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T(aTmp,
                            itoken_0);
                        loop_ub = static_cast<int32_T>(curKey->size[1] - 1);
                        for (itoken_0 = 0; itoken_0 <= loop_ub; itoken_0++) {
                            itoken = itoken_0;
                            aTmp->data[itoken_0] = curKey->data[itoken_0];
                        }
                    }

                    b_bool = false;
                    if (aTmp->size[1] == 15) {
                        iremain = 0;
                        int32_T exitg2;
                        do {
                            exitg2 = 0;
                            if (iremain < 15) {
                                if (h[static_cast<int32_T>(static_cast<int32_T>(
                                        static_cast<uint8_T>(aTmp->data[iremain]))
                                     & 127)] != h[static_cast<int32_T>(i[iremain])])
                                {
                                    exitg2 = 1;
                                } else {
                                    iremain = static_cast<int32_T>(iremain + 1);
                                }
                            } else {
                                b_bool = true;
                                exitg2 = 1;
                            }
                        } while (exitg2 == 0);
                    }

                    if (b_bool) {
                        itoken_0 = static_cast<int32_T>(ret->size[0] * ret->
                            size[1]);
                        ret->size[0] = 1;
                        ret->size[1] = curVal->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T(ret, itoken_0);
                        loop_ub = static_cast<int32_T>(curVal->size[1] - 1);
                        for (itoken_0 = 0; itoken_0 <= loop_ub; itoken_0++) {
                            ret->data[itoken_0] = curVal->data[itoken_0];
                        }

                        exitg1 = 1;
                    }
                }
            } else {
                exitg1 = 1;
            }
        } while (exitg1 == 0);

        FlightMissionMode_emxFree_char_T(&data_0);
        FlightMissionMode_emxFree_char_T(&tmp);
        FlightMissionMode_emxFree_char_T(&aTmp);
        FlightMissionMode_emxFree_char_T(&curLine);
        FlightMissionMode_emxFree_char_T(&curVal);
        FlightMissionMode_emxFree_char_T(&curKey);
        FlightMissionMode_emxFree_char_T(&curSection);
        FlightMissionMode_emxFree_char_T(&data);
    }
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_readINI_b
    (emxArray_char_T_FlightMissionMode_T *ret,
     DW_StartPointGenerator_FlightMissionMode_T *localDW)
{
    static const char_T h[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T i[14]{ 'D', 'i', 'v', 'e', 'A', 'n', 'g', 'l', 'e', 'L',
        'i', 'm', 'i', 't' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    emxArray_char_T_FlightMissionMode_T *curKey;
    emxArray_char_T_FlightMissionMode_T *curLine;
    emxArray_char_T_FlightMissionMode_T *curSection;
    emxArray_char_T_FlightMissionMode_T *curVal;
    emxArray_char_T_FlightMissionMode_T *data;
    emxArray_char_T_FlightMissionMode_T *data_0;
    emxArray_char_T_FlightMissionMode_T *j;
    emxArray_char_T_FlightMissionMode_T *tmp;
    int32_T iremain;
    int32_T itoken;
    int8_T fileid;
    ret->size[0] = 1;
    ret->size[1] = 0;
    fileid = FlightMissionMode_cfopen("config.ini", "rb", localDW);
    if (static_cast<int32_T>(fileid) < 0) {
        printf("INI-file \"%s\" was not found or could not be read.\n",
               "config.ini");
        fflush(stdout);
    } else {
        int32_T itoken_0;
        int32_T loop_ub;
        FlightMissionMode_emxInit_char_T(&data, 2);
        FlightMissionMode_emxInit_char_T(&j, 1);
        FlightMissionMode_fread(static_cast<real_T>(fileid), j, localDW);
        itoken_0 = static_cast<int32_T>(data->size[0] * data->size[1]);
        data->size[0] = 1;
        data->size[1] = j->size[0];
        FlightMissionMode_emxEnsureCapacity_char_T(data, itoken_0);
        loop_ub = j->size[0];
        for (itoken_0 = 0; itoken_0 <= static_cast<int32_T>(loop_ub - 1);
                itoken_0++) {
            data->data[itoken_0] = j->data[itoken_0];
        }

        FlightMissionMode_emxFree_char_T(&j);
        FlightMissionMode_emxInit_char_T(&curSection, 2);
        FlightMissionMode_emxInit_char_T(&curKey, 2);
        FlightMissionMode_emxInit_char_T(&curVal, 2);
        FlightMissionMode_cfclose(static_cast<real_T>(fileid), localDW);
        curSection->size[0] = 1;
        curSection->size[1] = 0;
        curKey->size[0] = 1;
        curKey->size[1] = 0;
        curVal->size[0] = 1;
        curVal->size[1] = 0;
        FlightMissionMode_emxInit_char_T(&curLine, 2);
        FlightMissionMode_emxInit_char_T(&aTmp, 2);
        FlightMissionMode_emxInit_char_T(&tmp, 2);
        FlightMissionMode_emxInit_char_T(&data_0, 2);
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (data->size[1] != 0) {
                boolean_T b_bool;
                itoken_0 = static_cast<int32_T>(data_0->size[0] * data_0->size[1]);
                data_0->size[0] = 1;
                data_0->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T(data_0, itoken_0);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (itoken_0 = 0; itoken_0 <= loop_ub; itoken_0++) {
                    itoken = itoken_0;
                    data_0->data[itoken_0] = data->data[itoken_0];
                }

                FlightMissionMode_strtok(data_0, curLine, data);
                FlightMissionMode_strtok_o(curLine, tmp);
                FlightMissionMode_strtrim(tmp, curLine);
                if (curLine->size[1] >= 2) {
                    boolean_T guard1{ false };

                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                iremain = 0;
                                itoken = 0;
                            } else {
                                iremain = 1;
                                itoken = static_cast<int32_T>(curLine->size[1] -
                                    1);
                            }

                            itoken_0 = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(itoken - iremain);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T
                                (curSection, itoken_0);
                            for (itoken_0 = 0; itoken_0 <= static_cast<int32_T>
                                    (loop_ub - 1); itoken_0++) {
                                curSection->data[itoken_0] = curLine->data[
                                    static_cast<int32_T>(iremain + itoken_0)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains(curLine)) {
                            FlightMissionMode_strtok_of(curLine, aTmp, curVal);
                            FlightMissionMode_find_token(curVal, &itoken,
                                &iremain);
                            if (itoken > static_cast<int32_T>(iremain - 1)) {
                                itoken = 0;
                                iremain = 0;
                            } else {
                                itoken = static_cast<int32_T>(itoken - 1);
                                iremain = static_cast<int32_T>(iremain - 1);
                            }

                            FlightMissionMode_strtrim(aTmp, curKey);
                            itoken_0 = static_cast<int32_T>(curLine->size[0] *
                                curLine->size[1]);
                            curLine->size[0] = 1;
                            loop_ub = static_cast<int32_T>(iremain - itoken);
                            curLine->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T(curLine,
                                itoken_0);
                            for (itoken_0 = 0; itoken_0 <= static_cast<int32_T>
                                    (loop_ub - 1); itoken_0++) {
                                curLine->data[itoken_0] = curVal->data[
                                    static_cast<int32_T>(itoken + itoken_0)];
                            }

                            FlightMissionMode_strtrim(curLine, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp(curSection)) {
                    if (curKey->size[1] == 0) {
                        aTmp->size[0] = 1;
                        aTmp->size[1] = 0;
                    } else {
                        itoken_0 = static_cast<int32_T>(aTmp->size[0] *
                            aTmp->size[1]);
                        aTmp->size[0] = 1;
                        aTmp->size[1] = curKey->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T(aTmp,
                            itoken_0);
                        loop_ub = static_cast<int32_T>(curKey->size[1] - 1);
                        for (itoken_0 = 0; itoken_0 <= loop_ub; itoken_0++) {
                            itoken = itoken_0;
                            aTmp->data[itoken_0] = curKey->data[itoken_0];
                        }
                    }

                    b_bool = false;
                    if (aTmp->size[1] == 14) {
                        iremain = 0;
                        int32_T exitg2;
                        do {
                            exitg2 = 0;
                            if (iremain < 14) {
                                if (h[static_cast<int32_T>(static_cast<int32_T>(
                                        static_cast<uint8_T>(aTmp->data[iremain]))
                                     & 127)] != h[static_cast<int32_T>(i[iremain])])
                                {
                                    exitg2 = 1;
                                } else {
                                    iremain = static_cast<int32_T>(iremain + 1);
                                }
                            } else {
                                b_bool = true;
                                exitg2 = 1;
                            }
                        } while (exitg2 == 0);
                    }

                    if (b_bool) {
                        itoken_0 = static_cast<int32_T>(ret->size[0] * ret->
                            size[1]);
                        ret->size[0] = 1;
                        ret->size[1] = curVal->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T(ret, itoken_0);
                        loop_ub = static_cast<int32_T>(curVal->size[1] - 1);
                        for (itoken_0 = 0; itoken_0 <= loop_ub; itoken_0++) {
                            ret->data[itoken_0] = curVal->data[itoken_0];
                        }

                        exitg1 = 1;
                    }
                }
            } else {
                exitg1 = 1;
            }
        } while (exitg1 == 0);

        FlightMissionMode_emxFree_char_T(&data_0);
        FlightMissionMode_emxFree_char_T(&tmp);
        FlightMissionMode_emxFree_char_T(&aTmp);
        FlightMissionMode_emxFree_char_T(&curLine);
        FlightMissionMode_emxFree_char_T(&curVal);
        FlightMissionMode_emxFree_char_T(&curKey);
        FlightMissionMode_emxFree_char_T(&curSection);
        FlightMissionMode_emxFree_char_T(&data);
    }
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_bt4(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[9]{ 'M', 'i', 'n', 'A', 'i', 'r', 'S', 'p', 'd' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T(aTmp, i);
        loop_ub = static_cast<int32_T>(a->size[1] - 1);
        for (i = 0; i <= loop_ub; i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 9) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 9) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_bt4y(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[12]{ 'M', 'a', 'x', 'R', 'o', 'l', 'l', 'A', 'n', 'g',
        'l', 'e' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T(aTmp, i);
        loop_ub = static_cast<int32_T>(a->size[1] - 1);
        for (i = 0; i <= loop_ub; i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 12) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 12) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
uavDubinsConnection_FlightMissionMode_T *FlightMissionMode::
    FlightMissionMode_uavDubinsConnection_uavDubinsConnection
    (uavDubinsConnection_FlightMissionMode_T *b_this, real_T varargin_2, real_T
     varargin_4, const real_T varargin_6[2])
{
    uavDubinsConnection_FlightMissionMode_T *c_this;
    real_T b_x;
    c_this = b_this;
    b_this->AirSpeed = 10.0;
    b_this->FlightPathAngleLimit[0] = varargin_6[0];
    b_this->FlightPathAngleLimit[1] = varargin_6[1];
    b_this->MaxRollAngle = varargin_4;
    b_x = b_this->MaxRollAngle;
    b_this->MinTurningRadius = b_this->AirSpeed * b_this->AirSpeed / (9.8 * std::
        tan(b_x));
    b_this->AirSpeed = varargin_2;
    b_x = b_this->MaxRollAngle;
    b_this->MinTurningRadius = b_this->AirSpeed * b_this->AirSpeed / (9.8 * std::
        tan(b_x));
    b_x = b_this->MaxRollAngle;
    b_this->MinTurningRadius = b_this->AirSpeed * b_this->AirSpeed / (9.8 * std::
        tan(b_x));
    return c_this;
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
uavDubinsConnection_FlightMissionMode_T *FlightMissionMode::
    FlightMissionMode_DubinsObjSingleton_getConnector
    (DW_StartPointGenerator_FlightMissionMode_T *localDW)
{
    emxArray_char_T_FlightMissionMode_T *b_remainder;
    emxArray_char_T_FlightMissionMode_T *curKey;
    emxArray_char_T_FlightMissionMode_T *curLine;
    emxArray_char_T_FlightMissionMode_T *curSection;
    emxArray_char_T_FlightMissionMode_T *curVal;
    emxArray_char_T_FlightMissionMode_T *data;
    emxArray_char_T_FlightMissionMode_T *data_0;
    emxArray_char_T_FlightMissionMode_T *data_1;
    emxArray_char_T_FlightMissionMode_T *data_2;
    emxArray_char_T_FlightMissionMode_T *data_3;
    emxArray_char_T_FlightMissionMode_T *k;
    emxArray_char_T_FlightMissionMode_T *ret;
    emxArray_char_T_FlightMissionMode_T *tmp_1;
    emxArray_char_T_FlightMissionMode_T *tmp_2;
    emxArray_char_T_FlightMissionMode_T *tmp_3;
    emxArray_char_T_FlightMissionMode_T *tmp_4;
    emxArray_char_T_FlightMissionMode_T *tmp_5;
    emxArray_char_T_FlightMissionMode_T *tmp_6;
    emxArray_char_T_FlightMissionMode_T *tmp_7;
    emxArray_char_T_FlightMissionMode_T *tmp_8;
    uavDubinsConnection_FlightMissionMode_T *outputArg;
    real_T tmp_9[2];
    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
            (localDW->SingletonInstance_not_empty) ^ 1))) {
        creal_T tmp;
        creal_T tmp_0;
        real_T ClimbAngleLimit;
        real_T DiveAngleLimit;
        real_T fid;
        int32_T b;
        int32_T b_0;
        int32_T c;
        int32_T loop_ub;
        boolean_T b_bool;
        boolean_T exitg1;
        boolean_T guard1{ false };

        FlightMissionMode_emxInit_char_T(&ret, 2);
        localDW->SingletonInstance.AirSpeed = 35.0;
        localDW->SingletonInstance.MaxRollAngle = 0.3490658503988659;
        localDW->SingletonInstance.FlightPathAngleLimit[0] = -0.175;
        localDW->SingletonInstance.FlightPathAngleLimit[1] = 0.175;
        ret->size[0] = 1;
        ret->size[1] = 0;
        fid = FlightMissionMode_fileManager(localDW);
        FlightMissionMode_emxInit_char_T(&data, 2);
        FlightMissionMode_emxInit_char_T(&curSection, 2);
        FlightMissionMode_emxInit_char_T(&curKey, 2);
        FlightMissionMode_emxInit_char_T(&curVal, 2);
        FlightMissionMode_emxInit_char_T(&curLine, 2);
        FlightMissionMode_emxInit_char_T(&b_remainder, 2);
        FlightMissionMode_emxInit_char_T(&k, 1);
        if (fid < 0.0) {
            printf("INI-file \"%s\" was not found or could not be read.\n",
                   "config.ini");
            fflush(stdout);
        } else {
            FlightMissionMode_fread(fid, k, localDW);
            b_0 = static_cast<int32_T>(data->size[0] * data->size[1]);
            data->size[0] = 1;
            data->size[1] = k->size[0];
            FlightMissionMode_emxEnsureCapacity_char_T(data, b_0);
            loop_ub = k->size[0];
            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                data->data[b] = k->data[b];
            }

            FlightMissionMode_cfclose(fid, localDW);
            curSection->size[0] = 1;
            curSection->size[1] = 0;
            curKey->size[0] = 1;
            curKey->size[1] = 0;
            curVal->size[0] = 1;
            curVal->size[1] = 0;
            FlightMissionMode_emxInit_char_T(&tmp_7, 2);
            FlightMissionMode_emxInit_char_T(&tmp_8, 2);
            FlightMissionMode_emxInit_char_T(&data_3, 2);
            exitg1 = false;
            while ((!exitg1) && (data->size[1] != 0)) {
                b_0 = static_cast<int32_T>(data_3->size[0] * data_3->size[1]);
                data_3->size[0] = 1;
                data_3->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T(data_3, b_0);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (b_0 = 0; b_0 <= loop_ub; b_0++) {
                    data_3->data[b_0] = data->data[b_0];
                }

                FlightMissionMode_strtok(data_3, curLine, data);
                FlightMissionMode_strtok_o(curLine, tmp_8);
                FlightMissionMode_strtrim(tmp_8, curLine);
                if (curLine->size[1] >= 2) {
                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                c = 0;
                                b = 0;
                            } else {
                                c = 1;
                                b = static_cast<int32_T>(curLine->size[1] - 1);
                            }

                            b_0 = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(b - c);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T
                                (curSection, b_0);
                            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1);
                                    b++) {
                                curSection->data[b] = curLine->data[static_cast<
                                    int32_T>(c + b)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains(curLine)) {
                            FlightMissionMode_strtok_of(curLine, curVal,
                                b_remainder);
                            FlightMissionMode_strtrim(curVal, curKey);
                            FlightMissionMode_strtok_ofg(b_remainder, tmp_7);
                            FlightMissionMode_strtrim(tmp_7, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp(curSection) &&
                        FlightMissionMode_strcmp_b(curKey)) {
                    b_0 = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                    ret->size[0] = 1;
                    ret->size[1] = curVal->size[1];
                    FlightMissionMode_emxEnsureCapacity_char_T(ret, b_0);
                    loop_ub = static_cast<int32_T>(curVal->size[1] - 1);
                    for (b = 0; b <= loop_ub; b++) {
                        ret->data[b] = curVal->data[b];
                    }

                    exitg1 = true;
                }
            }

            FlightMissionMode_emxFree_char_T(&data_3);
            FlightMissionMode_emxFree_char_T(&tmp_8);
            FlightMissionMode_emxFree_char_T(&tmp_7);
        }

        tmp = FlightMissionMode_str2double(ret);
        printf("Set UAV NormAirSpeed:\t\t%f\n", tmp.re);
        fflush(stdout);
        ret->size[0] = 1;
        ret->size[1] = 0;
        fid = FlightMissionMode_fileManager(localDW);
        if (fid < 0.0) {
            printf("INI-file \"%s\" was not found or could not be read.\n",
                   "config.ini");
            fflush(stdout);
        } else {
            FlightMissionMode_fread(fid, k, localDW);
            b_0 = static_cast<int32_T>(data->size[0] * data->size[1]);
            data->size[0] = 1;
            data->size[1] = k->size[0];
            FlightMissionMode_emxEnsureCapacity_char_T(data, b_0);
            loop_ub = k->size[0];
            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                data->data[b] = k->data[b];
            }

            FlightMissionMode_cfclose(fid, localDW);
            curSection->size[0] = 1;
            curSection->size[1] = 0;
            curKey->size[0] = 1;
            curKey->size[1] = 0;
            curVal->size[0] = 1;
            curVal->size[1] = 0;
            FlightMissionMode_emxInit_char_T(&tmp_5, 2);
            FlightMissionMode_emxInit_char_T(&tmp_6, 2);
            FlightMissionMode_emxInit_char_T(&data_2, 2);
            exitg1 = false;
            while ((!exitg1) && (data->size[1] != 0)) {
                b_0 = static_cast<int32_T>(data_2->size[0] * data_2->size[1]);
                data_2->size[0] = 1;
                data_2->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T(data_2, b_0);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (b_0 = 0; b_0 <= loop_ub; b_0++) {
                    data_2->data[b_0] = data->data[b_0];
                }

                FlightMissionMode_strtok(data_2, curLine, data);
                FlightMissionMode_strtok_o(curLine, tmp_6);
                FlightMissionMode_strtrim(tmp_6, curLine);
                if (curLine->size[1] >= 2) {
                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                c = 0;
                                b = 0;
                            } else {
                                c = 1;
                                b = static_cast<int32_T>(curLine->size[1] - 1);
                            }

                            b_0 = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(b - c);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T
                                (curSection, b_0);
                            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1);
                                    b++) {
                                curSection->data[b] = curLine->data[static_cast<
                                    int32_T>(c + b)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains(curLine)) {
                            FlightMissionMode_strtok_of(curLine, curVal,
                                b_remainder);
                            FlightMissionMode_strtrim(curVal, curKey);
                            FlightMissionMode_strtok_ofg(b_remainder, tmp_5);
                            FlightMissionMode_strtrim(tmp_5, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp(curSection) &&
                        FlightMissionMode_strcmp_bt(curKey)) {
                    b_0 = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                    ret->size[0] = 1;
                    ret->size[1] = curVal->size[1];
                    FlightMissionMode_emxEnsureCapacity_char_T(ret, b_0);
                    loop_ub = static_cast<int32_T>(curVal->size[1] - 1);
                    for (b = 0; b <= loop_ub; b++) {
                        ret->data[b] = curVal->data[b];
                    }

                    exitg1 = true;
                }
            }

            FlightMissionMode_emxFree_char_T(&data_2);
            FlightMissionMode_emxFree_char_T(&tmp_6);
            FlightMissionMode_emxFree_char_T(&tmp_5);
        }

        tmp_0 = FlightMissionMode_str2double(ret);
        printf("Set UAV MaxAirSpeed:\t\t%f\n", tmp_0.re);
        fflush(stdout);
        ret->size[0] = 1;
        ret->size[1] = 0;
        fid = FlightMissionMode_fileManager(localDW);
        if (fid < 0.0) {
            printf("INI-file \"%s\" was not found or could not be read.\n",
                   "config.ini");
            fflush(stdout);
        } else {
            FlightMissionMode_fread(fid, k, localDW);
            b_0 = static_cast<int32_T>(data->size[0] * data->size[1]);
            data->size[0] = 1;
            data->size[1] = k->size[0];
            FlightMissionMode_emxEnsureCapacity_char_T(data, b_0);
            loop_ub = k->size[0];
            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                data->data[b] = k->data[b];
            }

            FlightMissionMode_cfclose(fid, localDW);
            curSection->size[0] = 1;
            curSection->size[1] = 0;
            curKey->size[0] = 1;
            curKey->size[1] = 0;
            curVal->size[0] = 1;
            curVal->size[1] = 0;
            FlightMissionMode_emxInit_char_T(&tmp_3, 2);
            FlightMissionMode_emxInit_char_T(&tmp_4, 2);
            FlightMissionMode_emxInit_char_T(&data_1, 2);
            exitg1 = false;
            while ((!exitg1) && (data->size[1] != 0)) {
                b_0 = static_cast<int32_T>(data_1->size[0] * data_1->size[1]);
                data_1->size[0] = 1;
                data_1->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T(data_1, b_0);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (b_0 = 0; b_0 <= loop_ub; b_0++) {
                    data_1->data[b_0] = data->data[b_0];
                }

                FlightMissionMode_strtok(data_1, curLine, data);
                FlightMissionMode_strtok_o(curLine, tmp_4);
                FlightMissionMode_strtrim(tmp_4, curLine);
                if (curLine->size[1] >= 2) {
                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                c = 0;
                                b = 0;
                            } else {
                                c = 1;
                                b = static_cast<int32_T>(curLine->size[1] - 1);
                            }

                            b_0 = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(b - c);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T
                                (curSection, b_0);
                            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1);
                                    b++) {
                                curSection->data[b] = curLine->data[static_cast<
                                    int32_T>(c + b)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains(curLine)) {
                            FlightMissionMode_strtok_of(curLine, curVal,
                                b_remainder);
                            FlightMissionMode_strtrim(curVal, curKey);
                            FlightMissionMode_strtok_ofg(b_remainder, tmp_3);
                            FlightMissionMode_strtrim(tmp_3, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp(curSection) &&
                        FlightMissionMode_strcmp_bt4(curKey)) {
                    b_0 = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                    ret->size[0] = 1;
                    ret->size[1] = curVal->size[1];
                    FlightMissionMode_emxEnsureCapacity_char_T(ret, b_0);
                    loop_ub = static_cast<int32_T>(curVal->size[1] - 1);
                    for (b = 0; b <= loop_ub; b++) {
                        ret->data[b] = curVal->data[b];
                    }

                    exitg1 = true;
                }
            }

            FlightMissionMode_emxFree_char_T(&data_1);
            FlightMissionMode_emxFree_char_T(&tmp_4);
            FlightMissionMode_emxFree_char_T(&tmp_3);
        }

        tmp_0 = FlightMissionMode_str2double(ret);
        printf("Set UAV MinAirSpeed:\t\t%f\n", tmp_0.re);
        fflush(stdout);
        ret->size[0] = 1;
        ret->size[1] = 0;
        fid = FlightMissionMode_fileManager(localDW);
        if (fid < 0.0) {
            printf("INI-file \"%s\" was not found or could not be read.\n",
                   "config.ini");
            fflush(stdout);
        } else {
            FlightMissionMode_fread(fid, k, localDW);
            b_0 = static_cast<int32_T>(data->size[0] * data->size[1]);
            data->size[0] = 1;
            data->size[1] = k->size[0];
            FlightMissionMode_emxEnsureCapacity_char_T(data, b_0);
            loop_ub = k->size[0];
            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                data->data[b] = k->data[b];
            }

            FlightMissionMode_cfclose(fid, localDW);
            curSection->size[0] = 1;
            curSection->size[1] = 0;
            curKey->size[0] = 1;
            curKey->size[1] = 0;
            curVal->size[0] = 1;
            curVal->size[1] = 0;
            FlightMissionMode_emxInit_char_T(&tmp_1, 2);
            FlightMissionMode_emxInit_char_T(&tmp_2, 2);
            FlightMissionMode_emxInit_char_T(&data_0, 2);
            exitg1 = false;
            while ((!exitg1) && (data->size[1] != 0)) {
                b_0 = static_cast<int32_T>(data_0->size[0] * data_0->size[1]);
                data_0->size[0] = 1;
                data_0->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T(data_0, b_0);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (b_0 = 0; b_0 <= loop_ub; b_0++) {
                    data_0->data[b_0] = data->data[b_0];
                }

                FlightMissionMode_strtok(data_0, curLine, data);
                FlightMissionMode_strtok_o(curLine, tmp_2);
                FlightMissionMode_strtrim(tmp_2, curLine);
                if (curLine->size[1] >= 2) {
                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                c = 0;
                                b = 0;
                            } else {
                                c = 1;
                                b = static_cast<int32_T>(curLine->size[1] - 1);
                            }

                            b_0 = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(b - c);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T
                                (curSection, b_0);
                            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1);
                                    b++) {
                                curSection->data[b] = curLine->data[static_cast<
                                    int32_T>(c + b)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains(curLine)) {
                            FlightMissionMode_strtok_of(curLine, curVal,
                                b_remainder);
                            FlightMissionMode_strtrim(curVal, curKey);
                            FlightMissionMode_strtok_ofg(b_remainder, tmp_1);
                            FlightMissionMode_strtrim(tmp_1, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp(curSection) &&
                        FlightMissionMode_strcmp_bt4y(curKey)) {
                    b_0 = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                    ret->size[0] = 1;
                    ret->size[1] = curVal->size[1];
                    FlightMissionMode_emxEnsureCapacity_char_T(ret, b_0);
                    loop_ub = static_cast<int32_T>(curVal->size[1] - 1);
                    for (b = 0; b <= loop_ub; b++) {
                        ret->data[b] = curVal->data[b];
                    }

                    exitg1 = true;
                }
            }

            FlightMissionMode_emxFree_char_T(&data_0);
            FlightMissionMode_emxFree_char_T(&tmp_2);
            FlightMissionMode_emxFree_char_T(&tmp_1);
        }

        FlightMissionMode_emxFree_char_T(&k);
        FlightMissionMode_emxFree_char_T(&b_remainder);
        FlightMissionMode_emxFree_char_T(&curLine);
        FlightMissionMode_emxFree_char_T(&curVal);
        FlightMissionMode_emxFree_char_T(&curKey);
        FlightMissionMode_emxFree_char_T(&curSection);
        FlightMissionMode_emxFree_char_T(&data);
        tmp_0 = FlightMissionMode_str2double(ret);
        fid = 0.017453292519943295 * tmp_0.re;
        printf("Set UAV MaxRollAngle:\t\t%f\n", fid);
        fflush(stdout);
        FlightMissionMode_readINI(ret, localDW);
        tmp_0 = FlightMissionMode_str2double(ret);
        ClimbAngleLimit = 0.017453292519943295 * tmp_0.re;
        printf("Set UAV ClimbAngleLimit:\t%f\n", ClimbAngleLimit);
        fflush(stdout);
        FlightMissionMode_readINI_b(ret, localDW);
        tmp_0 = FlightMissionMode_str2double(ret);
        DiveAngleLimit = 0.017453292519943295 * tmp_0.re;
        printf("Set UAV DiveAngleLimit:\t\t%f\n", DiveAngleLimit);
        fflush(stdout);
        FlightMissionMode_emxFree_char_T(&ret);
        if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(std::
                isnan(tmp.re)) ^ 1))) {
            localDW->SingletonInstance.AirSpeed = tmp.re;
        }

        if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(std::
                isnan(fid)) ^ 1))) {
            localDW->SingletonInstance.MaxRollAngle = fid;
        }

        if ((static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                (std::isnan(ClimbAngleLimit)) ^ 1))) && (static_cast<boolean_T>(
                static_cast<int32_T>(static_cast<int32_T>(std::isnan
                (DiveAngleLimit)) ^ 1)))) {
            localDW->SingletonInstance.FlightPathAngleLimit[0] = DiveAngleLimit;
            localDW->SingletonInstance.FlightPathAngleLimit[1] = ClimbAngleLimit;
        }

        for (b_0 = 0; b_0 < 2; b_0++) {
            tmp_9[b_0] = localDW->SingletonInstance.FlightPathAngleLimit[b_0];
        }

        FlightMissionMode_uavDubinsConnection_uavDubinsConnection
            (&localDW->SingletonInstance.Connector,
             localDW->SingletonInstance.AirSpeed,
             localDW->SingletonInstance.MaxRollAngle, tmp_9);
        localDW->SingletonInstance_not_empty = true;
    }

    outputArg = &localDW->SingletonInstance.Connector;
    return outputArg;
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_merge(int32_T idx_data[], int32_T
    x_data[], int32_T offset, int32_T np, int32_T nq, int32_T iwork_data[],
    int32_T xwork_data[])
{
    if (nq != 0) {
        int32_T iout;
        int32_T n;
        int32_T n_tmp;
        int32_T q;
        n_tmp = static_cast<int32_T>(np + nq);
        for (q = 0; q <= static_cast<int32_T>(n_tmp - 1); q =
                static_cast<int32_T>(q + 1)) {
            iout = static_cast<int32_T>(offset + q);
            iwork_data[q] = idx_data[iout];
            xwork_data[q] = x_data[iout];
        }

        n = 0;
        q = np;
        iout = static_cast<int32_T>(offset - 1);
        int32_T exitg1;
        do {
            exitg1 = 0;
            iout = static_cast<int32_T>(iout + 1);
            if (xwork_data[n] <= xwork_data[q]) {
                idx_data[iout] = iwork_data[n];
                x_data[iout] = xwork_data[n];
                if (static_cast<int32_T>(n + 1) < np) {
                    n = static_cast<int32_T>(n + 1);
                } else {
                    exitg1 = 1;
                }
            } else {
                idx_data[iout] = iwork_data[q];
                x_data[iout] = xwork_data[q];
                if (static_cast<int32_T>(q + 1) < n_tmp) {
                    q = static_cast<int32_T>(q + 1);
                } else {
                    q = static_cast<int32_T>(iout - n);
                    while (static_cast<int32_T>(n + 1) <= np) {
                        iout = static_cast<int32_T>(static_cast<int32_T>(q + n)
                            + 1);
                        idx_data[iout] = iwork_data[n];
                        x_data[iout] = xwork_data[n];
                        n = static_cast<int32_T>(n + 1);
                    }

                    exitg1 = 1;
                }
            }
        } while (exitg1 == 0);
    }
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_sort(int32_T x_data[], const int32_T
    *x_size, int32_T idx_data[], int32_T *idx_size)
{
    int32_T d_data[28];
    int32_T e_data[28];
    int32_T f_data[28];
    int32_T g_data[28];
    int32_T vwork_data[28];
    int32_T x4[4];
    int32_T b;
    int32_T c_k;
    int32_T d_size;
    int32_T dim;
    int32_T e_size;
    int32_T f_size;
    int32_T g_size;
    int32_T vstride;
    int32_T vwork_size_idx_0;
    int8_T idx4[4];
    int8_T perm[4];
    dim = 2;
    if (*x_size != 1) {
        dim = 1;
        b = static_cast<int32_T>(*x_size - 1);
    } else {
        b = 0;
    }

    vwork_size_idx_0 = static_cast<int32_T>(b + 1);
    *idx_size = *x_size;
    vstride = 1;
    c_k = 0;
    while (c_k <= static_cast<int32_T>(dim - 2)) {
        vstride = static_cast<int32_T>(vstride * *x_size);
        c_k = 1;
    }

    for (dim = 0; dim <= static_cast<int32_T>(vstride - 1); dim =
            static_cast<int32_T>(dim + 1)) {
        int32_T nQuartets;
        for (nQuartets = 0; nQuartets <= b; nQuartets = static_cast<int32_T>
                (nQuartets + 1)) {
            vwork_data[nQuartets] = x_data[static_cast<int32_T>
                (static_cast<int32_T>(nQuartets * vstride) + dim)];
        }

        e_size = vwork_size_idx_0;
        for (c_k = 0; c_k <= static_cast<int32_T>(vwork_size_idx_0 - 1); c_k++)
        {
            e_data[c_k] = vwork_data[c_k];
        }

        d_size = static_cast<int32_T>(static_cast<int8_T>(vwork_size_idx_0));
        nQuartets = static_cast<int32_T>(static_cast<int8_T>(vwork_size_idx_0));
        for (c_k = 0; c_k <= static_cast<int32_T>(nQuartets - 1); c_k++) {
            d_data[c_k] = 0;
        }

        if (vwork_size_idx_0 != 0) {
            int32_T nLeft;
            int32_T nQuartets_tmp;
            int32_T nTail;
            int32_T tailOffset;
            d_size = static_cast<int32_T>(static_cast<int8_T>(vwork_size_idx_0));
            nQuartets = static_cast<int32_T>(static_cast<int8_T>
                (vwork_size_idx_0));
            for (c_k = 0; c_k <= static_cast<int32_T>(nQuartets - 1); c_k++) {
                d_data[c_k] = 0;
            }

            x4[0] = 0;
            idx4[0] = 0;
            x4[1] = 0;
            idx4[1] = 0;
            x4[2] = 0;
            idx4[2] = 0;
            x4[3] = 0;
            idx4[3] = 0;
            f_size = static_cast<int32_T>(static_cast<int8_T>(vwork_size_idx_0));
            g_size = vwork_size_idx_0;
            nQuartets_tmp = static_cast<int32_T>(vwork_size_idx_0 >> 2);
            for (nLeft = 0; nLeft <= static_cast<int32_T>(nQuartets_tmp - 1);
                    nLeft = static_cast<int32_T>(nLeft + 1)) {
                int32_T i3;
                int32_T i4;
                int32_T tmp;
                tailOffset = static_cast<int32_T>(nLeft << 2);
                idx4[0] = static_cast<int8_T>(static_cast<int32_T>(tailOffset +
                    1));
                idx4[1] = static_cast<int8_T>(static_cast<int32_T>(tailOffset +
                    2));
                idx4[2] = static_cast<int8_T>(static_cast<int32_T>(tailOffset +
                    3));
                idx4[3] = static_cast<int8_T>(static_cast<int32_T>(tailOffset +
                    4));
                x4[0] = e_data[tailOffset];
                x4[1] = e_data[static_cast<int32_T>(tailOffset + 1)];
                x4[2] = e_data[static_cast<int32_T>(tailOffset + 2)];
                x4[3] = e_data[static_cast<int32_T>(tailOffset + 3)];
                if (e_data[tailOffset] <= e_data[static_cast<int32_T>(tailOffset
                     + 1)]) {
                    nTail = 1;
                    nQuartets = 2;
                } else {
                    nTail = 2;
                    nQuartets = 1;
                }

                if (e_data[static_cast<int32_T>(tailOffset + 2)] <= e_data[
                        static_cast<int32_T>(tailOffset + 3)]) {
                    i3 = 3;
                    i4 = 4;
                } else {
                    i3 = 4;
                    i4 = 3;
                }

                c_k = x4[static_cast<int32_T>(nTail - 1)];
                tmp = x4[static_cast<int32_T>(i3 - 1)];
                if (c_k <= tmp) {
                    c_k = x4[static_cast<int32_T>(nQuartets - 1)];
                    if (c_k <= tmp) {
                        perm[0] = static_cast<int8_T>(nTail);
                        perm[1] = static_cast<int8_T>(nQuartets);
                        perm[2] = static_cast<int8_T>(i3);
                        perm[3] = static_cast<int8_T>(i4);
                    } else if (c_k <= x4[static_cast<int32_T>(i4 - 1)]) {
                        perm[0] = static_cast<int8_T>(nTail);
                        perm[1] = static_cast<int8_T>(i3);
                        perm[2] = static_cast<int8_T>(nQuartets);
                        perm[3] = static_cast<int8_T>(i4);
                    } else {
                        perm[0] = static_cast<int8_T>(nTail);
                        perm[1] = static_cast<int8_T>(i3);
                        perm[2] = static_cast<int8_T>(i4);
                        perm[3] = static_cast<int8_T>(nQuartets);
                    }
                } else {
                    tmp = x4[static_cast<int32_T>(i4 - 1)];
                    if (c_k <= tmp) {
                        if (x4[static_cast<int32_T>(nQuartets - 1)] <= tmp) {
                            perm[0] = static_cast<int8_T>(i3);
                            perm[1] = static_cast<int8_T>(nTail);
                            perm[2] = static_cast<int8_T>(nQuartets);
                            perm[3] = static_cast<int8_T>(i4);
                        } else {
                            perm[0] = static_cast<int8_T>(i3);
                            perm[1] = static_cast<int8_T>(nTail);
                            perm[2] = static_cast<int8_T>(i4);
                            perm[3] = static_cast<int8_T>(nQuartets);
                        }
                    } else {
                        perm[0] = static_cast<int8_T>(i3);
                        perm[1] = static_cast<int8_T>(i4);
                        perm[2] = static_cast<int8_T>(nTail);
                        perm[3] = static_cast<int8_T>(nQuartets);
                    }
                }

                d_data[tailOffset] = static_cast<int32_T>(idx4
                    [static_cast<int32_T>(static_cast<int32_T>(perm[0]) - 1)]);
                d_data[static_cast<int32_T>(tailOffset + 1)] =
                    static_cast<int32_T>(idx4[static_cast<int32_T>
                    (static_cast<int32_T>(perm[1]) - 1)]);
                d_data[static_cast<int32_T>(tailOffset + 2)] =
                    static_cast<int32_T>(idx4[static_cast<int32_T>
                    (static_cast<int32_T>(perm[2]) - 1)]);
                d_data[static_cast<int32_T>(tailOffset + 3)] =
                    static_cast<int32_T>(idx4[static_cast<int32_T>
                    (static_cast<int32_T>(perm[3]) - 1)]);
                e_data[tailOffset] = x4[static_cast<int32_T>(static_cast<int32_T>
                    (perm[0]) - 1)];
                e_data[static_cast<int32_T>(tailOffset + 1)] = x4
                    [static_cast<int32_T>(static_cast<int32_T>(perm[1]) - 1)];
                e_data[static_cast<int32_T>(tailOffset + 2)] = x4
                    [static_cast<int32_T>(static_cast<int32_T>(perm[2]) - 1)];
                e_data[static_cast<int32_T>(tailOffset + 3)] = x4
                    [static_cast<int32_T>(static_cast<int32_T>(perm[3]) - 1)];
            }

            nQuartets = static_cast<int32_T>(nQuartets_tmp << 2);
            nLeft = static_cast<int32_T>(vwork_size_idx_0 - nQuartets);
            if (nLeft > 0) {
                for (tailOffset = 0; tailOffset <= static_cast<int32_T>(nLeft -
                        1); tailOffset = static_cast<int32_T>(tailOffset + 1)) {
                    c_k = static_cast<int32_T>(nQuartets + tailOffset);
                    idx4[tailOffset] = static_cast<int8_T>(static_cast<int32_T>
                        (c_k + 1));
                    x4[tailOffset] = e_data[c_k];
                }

                perm[1] = 0;
                perm[2] = 0;
                perm[3] = 0;
                switch (nLeft) {
                  case 1:
                    perm[0] = 1;
                    break;

                  case 2:
                    if (x4[0] <= x4[1]) {
                        perm[0] = 1;
                        perm[1] = 2;
                    } else {
                        perm[0] = 2;
                        perm[1] = 1;
                    }
                    break;

                  default:
                    if (x4[0] <= x4[1]) {
                        if (x4[1] <= x4[2]) {
                            perm[0] = 1;
                            perm[1] = 2;
                            perm[2] = 3;
                        } else if (x4[0] <= x4[2]) {
                            perm[0] = 1;
                            perm[1] = 3;
                            perm[2] = 2;
                        } else {
                            perm[0] = 3;
                            perm[1] = 1;
                            perm[2] = 2;
                        }
                    } else if (x4[0] <= x4[2]) {
                        perm[0] = 2;
                        perm[1] = 1;
                        perm[2] = 3;
                    } else if (x4[1] <= x4[2]) {
                        perm[0] = 2;
                        perm[1] = 3;
                        perm[2] = 1;
                    } else {
                        perm[0] = 3;
                        perm[1] = 2;
                        perm[2] = 1;
                    }
                    break;
                }

                for (tailOffset = 0; tailOffset <= static_cast<int32_T>(nLeft -
                        1); tailOffset = static_cast<int32_T>(tailOffset + 1)) {
                    c_k = static_cast<int32_T>(static_cast<int32_T>
                        (perm[tailOffset]) - 1);
                    nTail = static_cast<int32_T>(nQuartets + tailOffset);
                    d_data[nTail] = static_cast<int32_T>(idx4[c_k]);
                    e_data[nTail] = x4[c_k];
                }
            }

            if (vwork_size_idx_0 > 1) {
                nQuartets = f_size;
                f_size = nQuartets;
                for (c_k = 0; c_k <= static_cast<int32_T>(nQuartets - 1); c_k++)
                {
                    f_data[c_k] = 0;
                }

                nQuartets = g_size;
                g_size = nQuartets;
                for (c_k = 0; c_k <= static_cast<int32_T>(nQuartets - 1); c_k++)
                {
                    g_data[c_k] = 0;
                }

                nLeft = nQuartets_tmp;
                nQuartets = 4;
                while (nLeft > 1) {
                    if (static_cast<uint32_T>(static_cast<uint32_T>(nLeft) & 1U)
                        != 0U) {
                        nLeft = static_cast<int32_T>(nLeft - 1);
                        tailOffset = static_cast<int32_T>(nQuartets * nLeft);
                        nTail = static_cast<int32_T>(vwork_size_idx_0 -
                            tailOffset);
                        if (nTail > nQuartets) {
                            FlightMissionMode_merge(d_data, e_data, tailOffset,
                                                    nQuartets,
                                                    static_cast<int32_T>(nTail -
                                nQuartets), f_data, g_data);
                        }
                    }

                    tailOffset = static_cast<int32_T>(nQuartets << 1);
                    nLeft = static_cast<int32_T>(nLeft >> 1);
                    for (nTail = 0; nTail <= static_cast<int32_T>(nLeft - 1);
                            nTail = static_cast<int32_T>(nTail + 1)) {
                        FlightMissionMode_merge(d_data, e_data,
                                                static_cast<int32_T>(nTail *
                            tailOffset), nQuartets, nQuartets, f_data, g_data);
                    }

                    nQuartets = tailOffset;
                }

                if (vwork_size_idx_0 > nQuartets) {
                    FlightMissionMode_merge(d_data, e_data, 0, nQuartets,
                                            static_cast<int32_T>
                                            (vwork_size_idx_0 - nQuartets),
                                            f_data, g_data);
                }
            }
        }

        vwork_size_idx_0 = e_size;
        nQuartets = e_size;
        for (c_k = 0; c_k <= static_cast<int32_T>(nQuartets - 1); c_k++) {
            vwork_data[c_k] = e_data[c_k];
        }

        for (nQuartets = 0; nQuartets <= b; nQuartets = static_cast<int32_T>
                (nQuartets + 1)) {
            c_k = static_cast<int32_T>(static_cast<int32_T>(nQuartets * vstride)
                + dim);
            x_data[c_k] = e_data[nQuartets];
            idx_data[c_k] = d_data[nQuartets];
        }
    }
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_do_vectors(real_T c_data[], int32_T
    c_size[2], int32_T ia_data[], int32_T *ia_size, int32_T *ib_size)
{
    static const real_T f[28]{ 6.384265086E+9, 6.384265284E+9, 6.384480708E+9,
        6.384480906E+9, 6.384473283E+9, 6.384263997E+9, 2.1067690282E+11,
        2.10676902826E+11, 2.10677124976E+11, 2.10677124982E+11,
        2.10677124751E+11, 2.10676902787E+11, 2.10680747748E+11,
        2.10680754288E+11, 2.10687863274E+11, 2.10687869814E+11,
        2.10687618255E+11, 2.10680711811E+11, 6.384264226E+9, 6.384264232E+9,
        6.384264001E+9, 6.38447332E+9, 6.384473281E+9, 6.384473314E+9,
        6.384265282E+9, 6.384480904E+9, 6.38426509E+9, 6.384480712E+9 };

    static const int8_T e[28]{ 6, 21, 19, 20, 1, 27, 25, 2, 23, 5, 24, 22, 3, 28,
        26, 4, 12, 7, 8, 11, 9, 10, 18, 13, 14, 17, 15, 16 };

    emxArray_int32_T_28_FlightMissionMode_T ia_data_0;
    int32_T iafirst;
    int32_T ialast;
    int32_T nc;
    int32_T nia;
    c_size[0] = 1;
    *ib_size = 0;
    nc = 0;
    nia = -1;
    iafirst = 0;
    ialast = 1;
    while (ialast <= 28) {
        int32_T b_ialast;
        b_ialast = ialast;
        while ((b_ialast < 28) && (f[static_cast<int32_T>(static_cast<int32_T>
                 (e[static_cast<int32_T>(ialast - 1)]) - 1)] == f
                                   [static_cast<int32_T>(static_cast<int32_T>
                 (e[b_ialast]) - 1)])) {
            b_ialast = static_cast<int32_T>(b_ialast + 1);
        }

        nc = static_cast<int32_T>(nc + 1);
        nia = static_cast<int32_T>(nia + 1);
        ia_data[nia] = static_cast<int32_T>(e[iafirst]);
        ialast = static_cast<int32_T>(b_ialast + 1);
        iafirst = b_ialast;
    }

    if (static_cast<int32_T>(nia + 1) < 1) {
        iafirst = -1;
    } else {
        iafirst = nia;
    }

    *ia_size = static_cast<int32_T>(iafirst + 1);
    FlightMissionMode_sort(ia_data, ia_size, ia_data_0.data, &ia_data_0.size);
    for (iafirst = 0; iafirst <= nia; iafirst = static_cast<int32_T>(iafirst + 1))
    {
        c_data[iafirst] = f[static_cast<int32_T>(ia_data[iafirst] - 1)];
    }

    if (nc < 1) {
        c_size[1] = 0;
    } else {
        c_size[1] = nc;
    }
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_do_vectors_b(const real_T b_data[],
    const int32_T *b_size, real_T c_data[], int32_T c_size[2], int32_T ia_data[],
    int32_T *ia_size, int32_T *ib_size)
{
    emxArray_int32_T_28_FlightMissionMode_T ia_data_0;
    real_T bk;
    int32_T bperm_data[28];
    int32_T iwork_data[28];
    int32_T b_p;
    int32_T i;
    int32_T i2;
    int32_T j;
    int32_T kEnd;
    int32_T n;
    int32_T pEnd;
    int32_T qEnd;
    c_size[0] = 1;
    *ib_size = 0;
    i = static_cast<int32_T>(static_cast<int8_T>(*b_size));
    for (n = 0; n <= static_cast<int32_T>(i - 1); n++) {
        bperm_data[n] = 0;
    }

    if (*b_size != 0) {
        for (i = 1; i <= static_cast<int32_T>(static_cast<int32_T>(*b_size + 1)
                - 2); i = static_cast<int32_T>(i + 2)) {
            if (static_cast<boolean_T>(static_cast<int32_T>((b_data[static_cast<
                    int32_T>(i - 1)] <= b_data[i]) | static_cast<int32_T>(std::
                    isnan(b_data[i]))))) {
                bperm_data[static_cast<int32_T>(i - 1)] = i;
                bperm_data[i] = static_cast<int32_T>(i + 1);
            } else {
                bperm_data[static_cast<int32_T>(i - 1)] = static_cast<int32_T>(i
                    + 1);
                bperm_data[i] = i;
            }
        }

        if (static_cast<uint32_T>(static_cast<uint32_T>(*b_size) & 1U) != 0U) {
            bperm_data[static_cast<int32_T>(*b_size - 1)] = *b_size;
        }

        i = 2;
        while (i < static_cast<int32_T>(static_cast<int32_T>(*b_size + 1) - 1))
        {
            i2 = static_cast<int32_T>(i << 1);
            j = 1;
            pEnd = static_cast<int32_T>(i + 1);
            while (pEnd < static_cast<int32_T>(*b_size + 1)) {
                int32_T c_k;
                int32_T q;
                b_p = j;
                q = static_cast<int32_T>(pEnd - 1);
                qEnd = static_cast<int32_T>(j + i2);
                if (qEnd > static_cast<int32_T>(*b_size + 1)) {
                    qEnd = static_cast<int32_T>(*b_size + 1);
                }

                c_k = 0;
                kEnd = static_cast<int32_T>(qEnd - j);
                while (static_cast<int32_T>(c_k + 1) <= kEnd) {
                    bk = b_data[static_cast<int32_T>(bperm_data[q] - 1)];
                    n = bperm_data[static_cast<int32_T>(b_p - 1)];
                    if (static_cast<boolean_T>(static_cast<int32_T>((b_data[
                            static_cast<int32_T>(n - 1)] <= bk) |
                            static_cast<int32_T>(std::isnan(bk))))) {
                        iwork_data[c_k] = n;
                        b_p = static_cast<int32_T>(b_p + 1);
                        if (b_p == pEnd) {
                            while (static_cast<int32_T>(q + 1) < qEnd) {
                                c_k = static_cast<int32_T>(c_k + 1);
                                iwork_data[c_k] = bperm_data[q];
                                q = static_cast<int32_T>(q + 1);
                            }
                        }
                    } else {
                        iwork_data[c_k] = bperm_data[q];
                        q = static_cast<int32_T>(q + 1);
                        if (static_cast<int32_T>(q + 1) == qEnd) {
                            while (b_p < pEnd) {
                                c_k = static_cast<int32_T>(c_k + 1);
                                iwork_data[c_k] = bperm_data[static_cast<int32_T>
                                    (b_p - 1)];
                                b_p = static_cast<int32_T>(b_p + 1);
                            }
                        }
                    }

                    c_k = static_cast<int32_T>(c_k + 1);
                }

                for (pEnd = 0; pEnd <= static_cast<int32_T>(kEnd - 1); pEnd =
                        static_cast<int32_T>(pEnd + 1)) {
                    bperm_data[static_cast<int32_T>(static_cast<int32_T>(j +
                        pEnd) - 1)] = iwork_data[pEnd];
                }

                j = qEnd;
                pEnd = static_cast<int32_T>(qEnd + i);
            }

            i = i2;
        }
    }

    n = 0;
    i = -1;
    i2 = 0;
    j = 1;
    qEnd = 1;
    while ((j <= 28) && (qEnd <= *b_size)) {
        kEnd = j;
        pEnd = j;
        while (static_cast<boolean_T>(static_cast<int32_T>((static_cast<int32_T>
                  (kEnd + 1) == j) & (kEnd < 28)))) {
            kEnd = static_cast<int32_T>(kEnd + 1);
        }

        j = kEnd;
        b_p = qEnd;
        bk = b_data[static_cast<int32_T>(bperm_data[static_cast<int32_T>(qEnd -
            1)] - 1)];
        while ((b_p < *b_size) && (b_data[static_cast<int32_T>(bperm_data[b_p] -
                 1)] == bk)) {
            b_p = static_cast<int32_T>(b_p + 1);
        }

        qEnd = b_p;
        if (static_cast<real_T>(pEnd) == bk) {
            j = static_cast<int32_T>(kEnd + 1);
            i2 = kEnd;
            qEnd = static_cast<int32_T>(b_p + 1);
        } else if (static_cast<boolean_T>(static_cast<int32_T>
                    ((static_cast<real_T>(pEnd) < bk) | static_cast<int32_T>(std::
                      isnan(bk))))) {
            n = static_cast<int32_T>(n + 1);
            i = static_cast<int32_T>(i + 1);
            ia_data[i] = static_cast<int32_T>(i2 + 1);
            j = static_cast<int32_T>(kEnd + 1);
            i2 = kEnd;
        } else {
            qEnd = static_cast<int32_T>(b_p + 1);
        }
    }

    while (j <= 28) {
        qEnd = j;
        while (static_cast<boolean_T>(static_cast<int32_T>((static_cast<int32_T>
                  (qEnd + 1) == j) & (qEnd < 28)))) {
            qEnd = static_cast<int32_T>(qEnd + 1);
        }

        n = static_cast<int32_T>(n + 1);
        i = static_cast<int32_T>(i + 1);
        ia_data[i] = static_cast<int32_T>(i2 + 1);
        j = static_cast<int32_T>(qEnd + 1);
        i2 = qEnd;
    }

    if (static_cast<int32_T>(i + 1) < 1) {
        i2 = -1;
    } else {
        i2 = i;
    }

    *ia_size = static_cast<int32_T>(i2 + 1);
    FlightMissionMode_sort(ia_data, ia_size, ia_data_0.data, &ia_data_0.size);
    for (i2 = 0; i2 <= i; i2 = static_cast<int32_T>(i2 + 1)) {
        c_data[i2] = static_cast<real_T>(static_cast<int32_T>(ia_data[i2] - 1))
            + 1.0;
    }

    if (n < 1) {
        c_size[1] = 0;
    } else {
        c_size[1] = n;
    }
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_merge_m(int32_T idx_data[], real_T
    x_data[], int32_T offset, int32_T np, int32_T nq, int32_T iwork_data[],
    real_T xwork_data[])
{
    if (nq != 0) {
        int32_T iout;
        int32_T n;
        int32_T n_tmp;
        int32_T q;
        n_tmp = static_cast<int32_T>(np + nq);
        for (q = 0; q <= static_cast<int32_T>(n_tmp - 1); q =
                static_cast<int32_T>(q + 1)) {
            iout = static_cast<int32_T>(offset + q);
            iwork_data[q] = idx_data[iout];
            xwork_data[q] = x_data[iout];
        }

        n = 0;
        q = np;
        iout = static_cast<int32_T>(offset - 1);
        int32_T exitg1;
        do {
            exitg1 = 0;
            iout = static_cast<int32_T>(iout + 1);
            if (xwork_data[n] <= xwork_data[q]) {
                idx_data[iout] = iwork_data[n];
                x_data[iout] = xwork_data[n];
                if (static_cast<int32_T>(n + 1) < np) {
                    n = static_cast<int32_T>(n + 1);
                } else {
                    exitg1 = 1;
                }
            } else {
                idx_data[iout] = iwork_data[q];
                x_data[iout] = xwork_data[q];
                if (static_cast<int32_T>(q + 1) < n_tmp) {
                    q = static_cast<int32_T>(q + 1);
                } else {
                    q = static_cast<int32_T>(iout - n);
                    while (static_cast<int32_T>(n + 1) <= np) {
                        iout = static_cast<int32_T>(static_cast<int32_T>(q + n)
                            + 1);
                        idx_data[iout] = iwork_data[n];
                        x_data[iout] = xwork_data[n];
                        n = static_cast<int32_T>(n + 1);
                    }

                    exitg1 = 1;
                }
            }
        } while (exitg1 == 0);
    }
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_sort_l(real_T x_data[], const int32_T *
    x_size)
{
    real_T e_data[28];
    real_T g_data[28];
    real_T vwork_data[28];
    real_T x4[4];
    int32_T d_data[28];
    int32_T f_data[28];
    int32_T b;
    int32_T d_size;
    int32_T dim;
    int32_T e_size;
    int32_T f_size;
    int32_T g_size;
    int32_T n;
    int32_T vstride;
    int32_T vwork_size_idx_0;
    int8_T idx4[4];
    int8_T perm[4];
    dim = 2;
    if (*x_size != 1) {
        dim = 1;
        b = static_cast<int32_T>(*x_size - 1);
    } else {
        b = 0;
    }

    vwork_size_idx_0 = static_cast<int32_T>(b + 1);
    vstride = 1;
    n = 0;
    while (n <= static_cast<int32_T>(dim - 2)) {
        vstride = static_cast<int32_T>(vstride * *x_size);
        n = 1;
    }

    for (dim = 0; dim <= static_cast<int32_T>(vstride - 1); dim =
            static_cast<int32_T>(dim + 1)) {
        int32_T bLen;
        for (n = 0; n <= b; n = static_cast<int32_T>(n + 1)) {
            vwork_data[n] = x_data[static_cast<int32_T>(static_cast<int32_T>(n *
                vstride) + dim)];
        }

        e_size = vwork_size_idx_0;
        for (bLen = 0; bLen <= static_cast<int32_T>(vwork_size_idx_0 - 1); bLen
                ++) {
            e_data[bLen] = vwork_data[bLen];
        }

        if (vwork_size_idx_0 != 0) {
            int32_T i3;
            int32_T i4;
            int32_T itmp;
            int32_T nTail;
            int32_T wOffset;
            int32_T wOffset_tmp;
            d_size = static_cast<int32_T>(static_cast<int8_T>(vwork_size_idx_0));
            n = static_cast<int32_T>(static_cast<int8_T>(vwork_size_idx_0));
            for (bLen = 0; bLen <= static_cast<int32_T>(n - 1); bLen++) {
                d_data[bLen] = 0;
            }

            x4[0] = 0.0;
            idx4[0] = 0;
            x4[1] = 0.0;
            idx4[1] = 0;
            x4[2] = 0.0;
            idx4[2] = 0;
            x4[3] = 0.0;
            idx4[3] = 0;
            f_size = static_cast<int32_T>(static_cast<int8_T>(vwork_size_idx_0));
            g_size = vwork_size_idx_0;
            n = g_size;
            g_size = n;
            for (bLen = 0; bLen <= static_cast<int32_T>(n - 1); bLen++) {
                g_data[bLen] = 0.0;
            }

            bLen = 1;
            n = 0;
            for (wOffset = 0; wOffset <= static_cast<int32_T>(vwork_size_idx_0 -
                  1); wOffset = static_cast<int32_T>(wOffset + 1)) {
                if (std::isnan(e_data[wOffset])) {
                    i3 = static_cast<int32_T>(vwork_size_idx_0 - bLen);
                    d_data[i3] = static_cast<int32_T>(wOffset + 1);
                    g_data[i3] = e_data[wOffset];
                    bLen = static_cast<int32_T>(bLen + 1);
                } else {
                    n = static_cast<int32_T>(n + 1);
                    idx4[static_cast<int32_T>(n - 1)] = static_cast<int8_T>(
                        static_cast<int32_T>(wOffset + 1));
                    x4[static_cast<int32_T>(n - 1)] = e_data[wOffset];
                    if (n == 4) {
                        real_T tmp;
                        real_T tmp_0;
                        n = static_cast<int32_T>(wOffset - bLen);
                        if (x4[0] <= x4[1]) {
                            nTail = 1;
                            itmp = 2;
                        } else {
                            nTail = 2;
                            itmp = 1;
                        }

                        if (x4[2] <= x4[3]) {
                            i3 = 3;
                            i4 = 4;
                        } else {
                            i3 = 4;
                            i4 = 3;
                        }

                        tmp = x4[static_cast<int32_T>(nTail - 1)];
                        tmp_0 = x4[static_cast<int32_T>(i3 - 1)];
                        if (tmp <= tmp_0) {
                            tmp = x4[static_cast<int32_T>(itmp - 1)];
                            if (tmp <= tmp_0) {
                                perm[0] = static_cast<int8_T>(nTail);
                                perm[1] = static_cast<int8_T>(itmp);
                                perm[2] = static_cast<int8_T>(i3);
                                perm[3] = static_cast<int8_T>(i4);
                            } else if (tmp <= x4[static_cast<int32_T>(i4 - 1)])
                            {
                                perm[0] = static_cast<int8_T>(nTail);
                                perm[1] = static_cast<int8_T>(i3);
                                perm[2] = static_cast<int8_T>(itmp);
                                perm[3] = static_cast<int8_T>(i4);
                            } else {
                                perm[0] = static_cast<int8_T>(nTail);
                                perm[1] = static_cast<int8_T>(i3);
                                perm[2] = static_cast<int8_T>(i4);
                                perm[3] = static_cast<int8_T>(itmp);
                            }
                        } else {
                            tmp_0 = x4[static_cast<int32_T>(i4 - 1)];
                            if (tmp <= tmp_0) {
                                if (x4[static_cast<int32_T>(itmp - 1)] <= tmp_0)
                                {
                                    perm[0] = static_cast<int8_T>(i3);
                                    perm[1] = static_cast<int8_T>(nTail);
                                    perm[2] = static_cast<int8_T>(itmp);
                                    perm[3] = static_cast<int8_T>(i4);
                                } else {
                                    perm[0] = static_cast<int8_T>(i3);
                                    perm[1] = static_cast<int8_T>(nTail);
                                    perm[2] = static_cast<int8_T>(i4);
                                    perm[3] = static_cast<int8_T>(itmp);
                                }
                            } else {
                                perm[0] = static_cast<int8_T>(i3);
                                perm[1] = static_cast<int8_T>(i4);
                                perm[2] = static_cast<int8_T>(nTail);
                                perm[3] = static_cast<int8_T>(itmp);
                            }
                        }

                        d_data[static_cast<int32_T>(n - 2)] = static_cast<
                            int32_T>(idx4[static_cast<int32_T>
                                     (static_cast<int32_T>(perm[0]) - 1)]);
                        d_data[static_cast<int32_T>(n - 1)] =
                            static_cast<int32_T>(idx4[static_cast<int32_T>(
                            static_cast<int32_T>(perm[1]) - 1)]);
                        d_data[n] = static_cast<int32_T>(idx4
                            [static_cast<int32_T>(static_cast<int32_T>(perm[2])
                            - 1)]);
                        d_data[static_cast<int32_T>(n + 1)] =
                            static_cast<int32_T>(idx4[static_cast<int32_T>(
                            static_cast<int32_T>(perm[3]) - 1)]);
                        e_data[static_cast<int32_T>(n - 2)] = x4
                            [static_cast<int32_T>(static_cast<int32_T>(perm[0])
                            - 1)];
                        e_data[static_cast<int32_T>(n - 1)] = x4
                            [static_cast<int32_T>(static_cast<int32_T>(perm[1])
                            - 1)];
                        e_data[n] = x4[static_cast<int32_T>(static_cast<int32_T>
                            (perm[2]) - 1)];
                        e_data[static_cast<int32_T>(n + 1)] = x4
                            [static_cast<int32_T>(static_cast<int32_T>(perm[3])
                            - 1)];
                        n = 0;
                    }
                }
            }

            wOffset_tmp = static_cast<int32_T>(vwork_size_idx_0 - bLen);
            if (n > 0) {
                perm[1] = 0;
                perm[2] = 0;
                perm[3] = 0;
                switch (n) {
                  case 1:
                    perm[0] = 1;
                    break;

                  case 2:
                    if (x4[0] <= x4[1]) {
                        perm[0] = 1;
                        perm[1] = 2;
                    } else {
                        perm[0] = 2;
                        perm[1] = 1;
                    }
                    break;

                  default:
                    if (x4[0] <= x4[1]) {
                        if (x4[1] <= x4[2]) {
                            perm[0] = 1;
                            perm[1] = 2;
                            perm[2] = 3;
                        } else if (x4[0] <= x4[2]) {
                            perm[0] = 1;
                            perm[1] = 3;
                            perm[2] = 2;
                        } else {
                            perm[0] = 3;
                            perm[1] = 1;
                            perm[2] = 2;
                        }
                    } else if (x4[0] <= x4[2]) {
                        perm[0] = 2;
                        perm[1] = 1;
                        perm[2] = 3;
                    } else if (x4[1] <= x4[2]) {
                        perm[0] = 2;
                        perm[1] = 3;
                        perm[2] = 1;
                    } else {
                        perm[0] = 3;
                        perm[1] = 2;
                        perm[2] = 1;
                    }
                    break;
                }

                for (nTail = 0; nTail <= static_cast<int32_T>(n - 1); nTail =
                        static_cast<int32_T>(nTail + 1)) {
                    i3 = static_cast<int32_T>(static_cast<int32_T>(perm[nTail])
                        - 1);
                    itmp = static_cast<int32_T>(static_cast<int32_T>(
                        static_cast<int32_T>(wOffset_tmp - n) + nTail) + 1);
                    d_data[itmp] = static_cast<int32_T>(idx4[i3]);
                    e_data[itmp] = x4[i3];
                }
            }

            n = static_cast<int32_T>(static_cast<int32_T>(static_cast<int32_T>
                (bLen - 1) >> 1) + 1);
            for (nTail = 1; static_cast<int32_T>(nTail - 1) <=
                    static_cast<int32_T>(n - 2); nTail = static_cast<int32_T>
                    (nTail + 1)) {
                i4 = static_cast<int32_T>(wOffset_tmp + nTail);
                itmp = d_data[i4];
                wOffset = static_cast<int32_T>(vwork_size_idx_0 - nTail);
                d_data[i4] = d_data[wOffset];
                d_data[wOffset] = itmp;
                e_data[i4] = g_data[wOffset];
                e_data[wOffset] = g_data[i4];
            }

            if (static_cast<uint32_T>(static_cast<uint32_T>(static_cast<int32_T>
                    (bLen - 1)) & 1U) != 0U) {
                n = static_cast<int32_T>(wOffset_tmp + n);
                e_data[n] = g_data[n];
            }

            if (static_cast<int32_T>(wOffset_tmp + 1) > 1) {
                n = f_size;
                f_size = n;
                for (bLen = 0; bLen <= static_cast<int32_T>(n - 1); bLen++) {
                    f_data[bLen] = 0;
                }

                wOffset = static_cast<int32_T>(static_cast<int32_T>(wOffset_tmp
                    + 1) >> 2);
                bLen = 4;
                while (wOffset > 1) {
                    if (static_cast<uint32_T>(static_cast<uint32_T>(wOffset) &
                                              1U) != 0U) {
                        wOffset = static_cast<int32_T>(wOffset - 1);
                        n = static_cast<int32_T>(bLen * wOffset);
                        nTail = static_cast<int32_T>(static_cast<int32_T>
                            (wOffset_tmp - n) + 1);
                        if (nTail > bLen) {
                            FlightMissionMode_merge_m(d_data, e_data, n, bLen,
                                static_cast<int32_T>(nTail - bLen), f_data,
                                g_data);
                        }
                    }

                    n = static_cast<int32_T>(bLen << 1);
                    wOffset = static_cast<int32_T>(wOffset >> 1);
                    for (nTail = 0; nTail <= static_cast<int32_T>(wOffset - 1);
                            nTail = static_cast<int32_T>(nTail + 1)) {
                        FlightMissionMode_merge_m(d_data, e_data,
                            static_cast<int32_T>(nTail * n), bLen, bLen, f_data,
                            g_data);
                    }

                    bLen = n;
                }

                if (static_cast<int32_T>(wOffset_tmp + 1) > bLen) {
                    FlightMissionMode_merge_m(d_data, e_data, 0, bLen,
                        static_cast<int32_T>(static_cast<int32_T>(wOffset_tmp -
                        bLen) + 1), f_data, g_data);
                }
            }
        }

        vwork_size_idx_0 = e_size;
        n = e_size;
        for (bLen = 0; bLen <= static_cast<int32_T>(n - 1); bLen++) {
            vwork_data[bLen] = e_data[bLen];
        }

        for (n = 0; n <= b; n = static_cast<int32_T>(n + 1)) {
            x_data[static_cast<int32_T>(dim + static_cast<int32_T>(n * vstride))]
                = e_data[n];
        }
    }
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void* FlightMissionMode::FlightMissionMode_uavDubinsBuildable_uavDubinsBuildable
    (real_T airSpeed, real_T maxRollAngle, const real_T flightPathAngle[2],
     const real_T disabledPathTypes_data[], const int32_T
     *disabledPathTypes_size)
{
    real_T b_disabledPathTypes_data[28];
    real_T b_flightPathAngle[2];
    int32_T loop_ub;
    b_flightPathAngle[0] = flightPathAngle[0];
    b_flightPathAngle[1] = flightPathAngle[1];
    loop_ub = *disabledPathTypes_size;
    for (int32_T i{0}; i <= static_cast<int32_T>(loop_ub - 1); i++) {
        b_disabledPathTypes_data[i] = disabledPathTypes_data[i];
    }

    return uavDubinsConnectionObj(airSpeed, maxRollAngle, &b_flightPathAngle[0],
        &b_disabledPathTypes_data[0], static_cast<uint32_T>
        (*disabledPathTypes_size));
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_bt4yh(const char_T a_data[],
    const int32_T a_size[2])
{
    static const char_T b[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T c[2]{ 'H', 'L' };

    boolean_T b_bool;
    b_bool = false;
    if (a_size[1] == 2) {
        int32_T kstr;
        kstr = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (kstr < 2) {
                if (b[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(a_data[kstr]))
                                           & 127)] != b[static_cast<int32_T>
                        (c[kstr])]) {
                    exitg1 = 1;
                } else {
                    kstr = static_cast<int32_T>(kstr + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    return b_bool;
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_bt4yhx(const char_T
    a_data[], const int32_T a_size[2])
{
    static const char_T b[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T c[2]{ 'H', 'R' };

    boolean_T b_bool;
    b_bool = false;
    if (a_size[1] == 2) {
        int32_T kstr;
        kstr = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (kstr < 2) {
                if (b[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(a_data[kstr]))
                                           & 127)] != b[static_cast<int32_T>
                        (c[kstr])]) {
                    exitg1 = 1;
                } else {
                    kstr = static_cast<int32_T>(kstr + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    return b_bool;
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::
    FlightMissionMode_uavDubinsPathSegment_uavDubinsPathSegment_h(const real_T
    varargin_1[4], const real_T varargin_2[4], real_T varargin_3, real_T
    varargin_4, real_T varargin_5, real_T varargin_6, const
    cell_wrap_0_FlightMissionMode_T varargin_7[4], const real_T varargin_8[4],
    uavDubinsPathSegment_FlightMissionMode_T *b_this)
{
    static const char_T d[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K',
        'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',
        'Z', '[', '\\', ']', '^', '_', '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
        'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',
        'V', 'W', 'X', 'Y', 'Z', '{', '|', '}', '~', '\x7f' };

    real_T thetaWrap;
    b_this->MinTurningRadius = varargin_5;
    b_this->StartPose[0] = varargin_1[0];
    b_this->StartPose[1] = varargin_1[1];
    b_this->StartPose[2] = varargin_1[2];
    thetaWrap = mod_d42kHWKw(varargin_1[3]);
    b_this->StartPose[3] = thetaWrap;
    if (static_cast<boolean_T>(static_cast<int32_T>((thetaWrap == 0.0) &
            (varargin_1[3] > 0.0)))) {
        b_this->StartPose[3] = 6.2831853071795862;
    }

    wrapToPi_kQV0kjUY(&b_this->StartPose[3]);
    b_this->GoalPose[0] = varargin_2[0];
    b_this->GoalPose[1] = varargin_2[1];
    b_this->GoalPose[2] = varargin_2[2];
    thetaWrap = mod_d42kHWKw(varargin_2[3]);
    b_this->GoalPose[3] = thetaWrap;
    if (static_cast<boolean_T>(static_cast<int32_T>((thetaWrap == 0.0) &
            (varargin_2[3] > 0.0)))) {
        b_this->GoalPose[3] = 6.2831853071795862;
    }

    wrapToPi_kQV0kjUY(&b_this->GoalPose[3]);
    b_this->AirSpeed = varargin_4;
    b_this->HelixRadius = varargin_6;
    b_this->FlightPathAngle = varargin_3;
    b_this->MotionLengths[0] = varargin_8[0];
    b_this->MotionTypes[0] = varargin_7[0];
    b_this->MotionLengths[1] = varargin_8[1];
    b_this->MotionTypes[1] = varargin_7[1];
    b_this->MotionLengths[2] = varargin_8[2];
    b_this->MotionTypes[2] = varargin_7[2];
    b_this->MotionLengths[3] = varargin_8[3];
    b_this->MotionTypes[3] = varargin_7[3];
    b_this->MotionTypes[0].f1.size[0] = 1;
    b_this->MotionTypes[0].f1.size[1] = varargin_7[0].f1.size[1];
    for (int32_T k{0}; k <= static_cast<int32_T>(varargin_7[0].f1.size[1] - 1);
            k = static_cast<int32_T>(k + 1)) {
        b_this->MotionTypes[0].f1.data[k] = d[static_cast<int32_T>(varargin_7[0]
            .f1.data[k])];
    }

    b_this->MotionTypes[1].f1.size[0] = 1;
    b_this->MotionTypes[1].f1.size[1] = 1;
    b_this->MotionTypes[1].f1.data[0] = d[static_cast<int32_T>
        (static_cast<int32_T>(static_cast<uint8_T>(varargin_7[1].f1.data[0])) &
         127)];
    b_this->MotionTypes[2].f1.size[0] = 1;
    b_this->MotionTypes[2].f1.size[1] = 1;
    b_this->MotionTypes[2].f1.data[0] = d[static_cast<int32_T>
        (static_cast<int32_T>(static_cast<uint8_T>(varargin_7[2].f1.data[0])) &
         127)];
    b_this->MotionTypes[3].f1.size[0] = 1;
    b_this->MotionTypes[3].f1.size[1] = varargin_7[3].f1.size[1];
    for (int32_T k{0}; k <= static_cast<int32_T>(varargin_7[3].f1.size[1] - 1);
            k = static_cast<int32_T>(k + 1)) {
        b_this->MotionTypes[3].f1.data[k] = d[static_cast<int32_T>(varargin_7[3]
            .f1.data[k])];
    }

    if (FlightMissionMode_strcmp_bt4yh(b_this->MotionTypes[0].f1.data,
            b_this->MotionTypes[0].f1.size)) {
        b_this->MotionTypes[0].f1.size[0] = 1;
        b_this->MotionTypes[0].f1.size[1] = 2;
        b_this->MotionTypes[0].f1.data[0] = 'H';
        b_this->MotionTypes[0].f1.data[1] = 'l';
    } else if (FlightMissionMode_strcmp_bt4yhx(b_this->MotionTypes[0].f1.data,
                b_this->MotionTypes[0].f1.size)) {
        b_this->MotionTypes[0].f1.size[0] = 1;
        b_this->MotionTypes[0].f1.size[1] = 2;
        b_this->MotionTypes[0].f1.data[0] = 'H';
        b_this->MotionTypes[0].f1.data[1] = 'r';
    } else if (FlightMissionMode_strcmp_bt4yhx(b_this->MotionTypes[3].f1.data,
                b_this->MotionTypes[3].f1.size)) {
        b_this->MotionTypes[3].f1.size[0] = 1;
        b_this->MotionTypes[3].f1.size[1] = 2;
        b_this->MotionTypes[3].f1.data[0] = 'H';
        b_this->MotionTypes[3].f1.data[1] = 'r';
    } else if (FlightMissionMode_strcmp_bt4yh(b_this->MotionTypes[3].f1.data,
                b_this->MotionTypes[3].f1.size)) {
        b_this->MotionTypes[3].f1.size[0] = 1;
        b_this->MotionTypes[3].f1.size[1] = 2;
        b_this->MotionTypes[3].f1.data[0] = 'H';
        b_this->MotionTypes[3].f1.data[1] = 'l';
    }

    b_this->Length = ((varargin_8[0] + varargin_8[1]) + varargin_8[2]) +
        varargin_8[3];
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_uavDubinsBuiltins_connect(const
    uavDubinsConnection_FlightMissionMode_T *obj, const real_T startPose[4],
    const real_T goalPose[4], real_T turningRadius, const real_T dpt_data[],
    const int32_T *dpt_size, uavDubinsPathSegment_FlightMissionMode_T
    *pathSegObjs, real_T *pathCosts)
{
    void* b_obj_UAVDubinsBuildableObj;
    cell_wrap_0_FlightMissionMode_T ac;
    cell_wrap_0_FlightMissionMode_T ad;
    cell_wrap_0_FlightMissionMode_T ae;
    cell_wrap_0_FlightMissionMode_T af;
    cell_wrap_0_FlightMissionMode_T bc;
    cell_wrap_0_FlightMissionMode_T bd;
    cell_wrap_0_FlightMissionMode_T be;
    cell_wrap_0_FlightMissionMode_T bf;
    cell_wrap_0_FlightMissionMode_T cc;
    cell_wrap_0_FlightMissionMode_T cd;
    cell_wrap_0_FlightMissionMode_T ce;
    cell_wrap_0_FlightMissionMode_T cf;
    cell_wrap_0_FlightMissionMode_T dc;
    cell_wrap_0_FlightMissionMode_T dd;
    cell_wrap_0_FlightMissionMode_T de;
    cell_wrap_0_FlightMissionMode_T df;
    cell_wrap_0_FlightMissionMode_T ec;
    cell_wrap_0_FlightMissionMode_T ed;
    cell_wrap_0_FlightMissionMode_T ee;
    cell_wrap_0_FlightMissionMode_T ef;
    cell_wrap_0_FlightMissionMode_T fc;
    cell_wrap_0_FlightMissionMode_T fd;
    cell_wrap_0_FlightMissionMode_T fe;
    cell_wrap_0_FlightMissionMode_T ff;
    cell_wrap_0_FlightMissionMode_T gc;
    cell_wrap_0_FlightMissionMode_T gd;
    cell_wrap_0_FlightMissionMode_T ge;
    cell_wrap_0_FlightMissionMode_T gf;
    cell_wrap_0_FlightMissionMode_T hc;
    cell_wrap_0_FlightMissionMode_T hd;
    cell_wrap_0_FlightMissionMode_T he;
    cell_wrap_0_FlightMissionMode_T hf;
    cell_wrap_0_FlightMissionMode_T ib;
    cell_wrap_0_FlightMissionMode_T ic;
    cell_wrap_0_FlightMissionMode_T id;
    cell_wrap_0_FlightMissionMode_T ie;
    cell_wrap_0_FlightMissionMode_T jb;
    cell_wrap_0_FlightMissionMode_T jc;
    cell_wrap_0_FlightMissionMode_T jd;
    cell_wrap_0_FlightMissionMode_T je;
    cell_wrap_0_FlightMissionMode_T jf;
    cell_wrap_0_FlightMissionMode_T kb;
    cell_wrap_0_FlightMissionMode_T kc;
    cell_wrap_0_FlightMissionMode_T kd;
    cell_wrap_0_FlightMissionMode_T ke;
    cell_wrap_0_FlightMissionMode_T kf;
    cell_wrap_0_FlightMissionMode_T lb;
    cell_wrap_0_FlightMissionMode_T lc;
    cell_wrap_0_FlightMissionMode_T ld;
    cell_wrap_0_FlightMissionMode_T le;
    cell_wrap_0_FlightMissionMode_T lf;
    cell_wrap_0_FlightMissionMode_T mb;
    cell_wrap_0_FlightMissionMode_T mc;
    cell_wrap_0_FlightMissionMode_T md;
    cell_wrap_0_FlightMissionMode_T me;
    cell_wrap_0_FlightMissionMode_T mf;
    cell_wrap_0_FlightMissionMode_T nb;
    cell_wrap_0_FlightMissionMode_T nc;
    cell_wrap_0_FlightMissionMode_T nd;
    cell_wrap_0_FlightMissionMode_T ne;
    cell_wrap_0_FlightMissionMode_T nf;
    cell_wrap_0_FlightMissionMode_T ob;
    cell_wrap_0_FlightMissionMode_T oc;
    cell_wrap_0_FlightMissionMode_T od;
    cell_wrap_0_FlightMissionMode_T oe;
    cell_wrap_0_FlightMissionMode_T of;
    cell_wrap_0_FlightMissionMode_T pb;
    cell_wrap_0_FlightMissionMode_T pc;
    cell_wrap_0_FlightMissionMode_T pd;
    cell_wrap_0_FlightMissionMode_T pe;
    cell_wrap_0_FlightMissionMode_T pf;
    cell_wrap_0_FlightMissionMode_T qb;
    cell_wrap_0_FlightMissionMode_T qc;
    cell_wrap_0_FlightMissionMode_T qd;
    cell_wrap_0_FlightMissionMode_T qe;
    cell_wrap_0_FlightMissionMode_T qf;
    cell_wrap_0_FlightMissionMode_T rb;
    cell_wrap_0_FlightMissionMode_T rc;
    cell_wrap_0_FlightMissionMode_T rd;
    cell_wrap_0_FlightMissionMode_T re;
    cell_wrap_0_FlightMissionMode_T rf;
    cell_wrap_0_FlightMissionMode_T sb;
    cell_wrap_0_FlightMissionMode_T sc;
    cell_wrap_0_FlightMissionMode_T sd;
    cell_wrap_0_FlightMissionMode_T se;
    cell_wrap_0_FlightMissionMode_T sf;
    cell_wrap_0_FlightMissionMode_T tb;
    cell_wrap_0_FlightMissionMode_T tc;
    cell_wrap_0_FlightMissionMode_T td;
    cell_wrap_0_FlightMissionMode_T te;
    cell_wrap_0_FlightMissionMode_T tf;
    cell_wrap_0_FlightMissionMode_T ub;
    cell_wrap_0_FlightMissionMode_T uc;
    cell_wrap_0_FlightMissionMode_T ud;
    cell_wrap_0_FlightMissionMode_T ue;
    cell_wrap_0_FlightMissionMode_T uf;
    cell_wrap_0_FlightMissionMode_T vb;
    cell_wrap_0_FlightMissionMode_T vc;
    cell_wrap_0_FlightMissionMode_T vd;
    cell_wrap_0_FlightMissionMode_T ve;
    cell_wrap_0_FlightMissionMode_T wb;
    cell_wrap_0_FlightMissionMode_T wc;
    cell_wrap_0_FlightMissionMode_T wd;
    cell_wrap_0_FlightMissionMode_T we;
    cell_wrap_0_FlightMissionMode_T xb;
    cell_wrap_0_FlightMissionMode_T xc;
    cell_wrap_0_FlightMissionMode_T xd;
    cell_wrap_0_FlightMissionMode_T xe;
    cell_wrap_0_FlightMissionMode_T yb;
    cell_wrap_0_FlightMissionMode_T yc;
    cell_wrap_0_FlightMissionMode_T yd;
    cell_wrap_0_FlightMissionMode_T ye;
    cell_wrap_22_FlightMissionMode_T motionTypes[28];
    cell_wrap_22_FlightMissionMode_T b;
    real_T g[16];
    real_T ml[16];
    real_T ml1[16];
    real_T s[16];
    real_T b_goalPose[4];
    real_T b_startPose[4];
    real_T ml1_0[4];
    real_T b_a;
    real_T b_fpa;
    real_T h;
    real_T mt;
    real_T mtr;
    int32_T tmp;
    ib.f1.size[0] = 1;
    ib.f1.size[1] = 1;
    ib.f1.data[0] = 'L';
    jb.f1.size[0] = 1;
    jb.f1.size[1] = 1;
    jb.f1.data[0] = 'S';
    kb.f1.size[0] = 1;
    kb.f1.size[1] = 1;
    kb.f1.data[0] = 'L';
    lb.f1.size[0] = 1;
    lb.f1.size[1] = 1;
    lb.f1.data[0] = 'N';
    b.f1[0] = ib;
    b.f1[1] = jb;
    b.f1[2] = kb;
    b.f1[3] = lb;
    mb.f1.size[0] = 1;
    mb.f1.size[1] = 1;
    mb.f1.data[0] = 'L';
    nb.f1.size[0] = 1;
    nb.f1.size[1] = 1;
    nb.f1.data[0] = 'S';
    ob.f1.size[0] = 1;
    ob.f1.size[1] = 1;
    ob.f1.data[0] = 'R';
    pb.f1.size[0] = 1;
    pb.f1.size[1] = 1;
    pb.f1.data[0] = 'N';
    qb.f1.size[0] = 1;
    qb.f1.size[1] = 1;
    qb.f1.data[0] = 'R';
    rb.f1.size[0] = 1;
    rb.f1.size[1] = 1;
    rb.f1.data[0] = 'S';
    sb.f1.size[0] = 1;
    sb.f1.size[1] = 1;
    sb.f1.data[0] = 'L';
    tb.f1.size[0] = 1;
    tb.f1.size[1] = 1;
    tb.f1.data[0] = 'N';
    ub.f1.size[0] = 1;
    ub.f1.size[1] = 1;
    ub.f1.data[0] = 'R';
    vb.f1.size[0] = 1;
    vb.f1.size[1] = 1;
    vb.f1.data[0] = 'S';
    wb.f1.size[0] = 1;
    wb.f1.size[1] = 1;
    wb.f1.data[0] = 'R';
    xb.f1.size[0] = 1;
    xb.f1.size[1] = 1;
    xb.f1.data[0] = 'N';
    yb.f1.size[0] = 1;
    yb.f1.size[1] = 1;
    yb.f1.data[0] = 'R';
    ac.f1.size[0] = 1;
    ac.f1.size[1] = 1;
    ac.f1.data[0] = 'L';
    bc.f1.size[0] = 1;
    bc.f1.size[1] = 1;
    bc.f1.data[0] = 'R';
    cc.f1.size[0] = 1;
    cc.f1.size[1] = 1;
    cc.f1.data[0] = 'N';
    dc.f1.size[0] = 1;
    dc.f1.size[1] = 1;
    dc.f1.data[0] = 'L';
    ec.f1.size[0] = 1;
    ec.f1.size[1] = 1;
    ec.f1.data[0] = 'R';
    fc.f1.size[0] = 1;
    fc.f1.size[1] = 1;
    fc.f1.data[0] = 'L';
    gc.f1.size[0] = 1;
    gc.f1.size[1] = 1;
    gc.f1.data[0] = 'N';
    hc.f1.size[0] = 1;
    hc.f1.size[1] = 2;
    ic.f1.size[0] = 1;
    ic.f1.size[1] = 1;
    ic.f1.data[0] = 'L';
    jc.f1.size[0] = 1;
    jc.f1.size[1] = 1;
    jc.f1.data[0] = 'S';
    kc.f1.size[0] = 1;
    kc.f1.size[1] = 1;
    kc.f1.data[0] = 'L';
    lc.f1.size[0] = 1;
    lc.f1.size[1] = 2;
    mc.f1.size[0] = 1;
    mc.f1.size[1] = 1;
    mc.f1.data[0] = 'L';
    nc.f1.size[0] = 1;
    nc.f1.size[1] = 1;
    nc.f1.data[0] = 'S';
    oc.f1.size[0] = 1;
    oc.f1.size[1] = 1;
    oc.f1.data[0] = 'R';
    pc.f1.size[0] = 1;
    pc.f1.size[1] = 2;
    qc.f1.size[0] = 1;
    qc.f1.size[1] = 1;
    qc.f1.data[0] = 'R';
    rc.f1.size[0] = 1;
    rc.f1.size[1] = 1;
    rc.f1.data[0] = 'S';
    sc.f1.size[0] = 1;
    sc.f1.size[1] = 1;
    sc.f1.data[0] = 'L';
    tc.f1.size[0] = 1;
    tc.f1.size[1] = 2;
    uc.f1.size[0] = 1;
    uc.f1.size[1] = 1;
    uc.f1.data[0] = 'R';
    vc.f1.size[0] = 1;
    vc.f1.size[1] = 1;
    vc.f1.data[0] = 'S';
    wc.f1.size[0] = 1;
    wc.f1.size[1] = 1;
    wc.f1.data[0] = 'R';
    xc.f1.size[0] = 1;
    xc.f1.size[1] = 2;
    yc.f1.size[0] = 1;
    yc.f1.size[1] = 1;
    yc.f1.data[0] = 'R';
    ad.f1.size[0] = 1;
    ad.f1.size[1] = 1;
    ad.f1.data[0] = 'L';
    bd.f1.size[0] = 1;
    bd.f1.size[1] = 1;
    bd.f1.data[0] = 'R';
    cd.f1.size[0] = 1;
    cd.f1.size[1] = 2;
    dd.f1.size[0] = 1;
    dd.f1.size[1] = 1;
    dd.f1.data[0] = 'L';
    ed.f1.size[0] = 1;
    ed.f1.size[1] = 1;
    ed.f1.data[0] = 'R';
    fd.f1.size[0] = 1;
    fd.f1.size[1] = 1;
    fd.f1.data[0] = 'L';
    gd.f1.size[0] = 1;
    gd.f1.size[1] = 1;
    gd.f1.data[0] = 'L';
    hd.f1.size[0] = 1;
    hd.f1.size[1] = 1;
    hd.f1.data[0] = 'S';
    id.f1.size[0] = 1;
    id.f1.size[1] = 1;
    id.f1.data[0] = 'L';
    jd.f1.size[0] = 1;
    jd.f1.size[1] = 2;
    kd.f1.size[0] = 1;
    kd.f1.size[1] = 1;
    kd.f1.data[0] = 'L';
    ld.f1.size[0] = 1;
    ld.f1.size[1] = 1;
    ld.f1.data[0] = 'S';
    md.f1.size[0] = 1;
    md.f1.size[1] = 1;
    md.f1.data[0] = 'R';
    nd.f1.size[0] = 1;
    nd.f1.size[1] = 2;
    od.f1.size[0] = 1;
    od.f1.size[1] = 1;
    od.f1.data[0] = 'R';
    pd.f1.size[0] = 1;
    pd.f1.size[1] = 1;
    pd.f1.data[0] = 'S';
    qd.f1.size[0] = 1;
    qd.f1.size[1] = 1;
    qd.f1.data[0] = 'L';
    rd.f1.size[0] = 1;
    rd.f1.size[1] = 2;
    sd.f1.size[0] = 1;
    sd.f1.size[1] = 1;
    sd.f1.data[0] = 'R';
    td.f1.size[0] = 1;
    td.f1.size[1] = 1;
    td.f1.data[0] = 'S';
    ud.f1.size[0] = 1;
    ud.f1.size[1] = 1;
    ud.f1.data[0] = 'R';
    vd.f1.size[0] = 1;
    vd.f1.size[1] = 2;
    wd.f1.size[0] = 1;
    wd.f1.size[1] = 1;
    wd.f1.data[0] = 'R';
    xd.f1.size[0] = 1;
    xd.f1.size[1] = 1;
    xd.f1.data[0] = 'L';
    yd.f1.size[0] = 1;
    yd.f1.size[1] = 1;
    yd.f1.data[0] = 'R';
    ae.f1.size[0] = 1;
    ae.f1.size[1] = 2;
    be.f1.size[0] = 1;
    be.f1.size[1] = 1;
    be.f1.data[0] = 'L';
    ce.f1.size[0] = 1;
    ce.f1.size[1] = 1;
    ce.f1.data[0] = 'R';
    de.f1.size[0] = 1;
    de.f1.size[1] = 1;
    de.f1.data[0] = 'L';
    ee.f1.size[0] = 1;
    ee.f1.size[1] = 2;
    hc.f1.data[0] = 'H';
    lc.f1.data[0] = 'H';
    pc.f1.data[0] = 'H';
    tc.f1.data[0] = 'H';
    xc.f1.data[0] = 'H';
    cd.f1.data[0] = 'H';
    jd.f1.data[0] = 'H';
    nd.f1.data[0] = 'H';
    rd.f1.data[0] = 'H';
    vd.f1.data[0] = 'H';
    ae.f1.data[0] = 'H';
    ee.f1.data[0] = 'H';
    hc.f1.data[1] = 'l';
    lc.f1.data[1] = 'l';
    pc.f1.data[1] = 'r';
    tc.f1.data[1] = 'r';
    xc.f1.data[1] = 'r';
    cd.f1.data[1] = 'l';
    jd.f1.data[1] = 'l';
    nd.f1.data[1] = 'r';
    rd.f1.data[1] = 'l';
    vd.f1.data[1] = 'r';
    ae.f1.data[1] = 'r';
    ee.f1.data[1] = 'l';
    fe.f1.size[0] = 1;
    fe.f1.size[1] = 1;
    fe.f1.data[0] = 'L';
    ge.f1.size[0] = 1;
    ge.f1.size[1] = 1;
    ge.f1.data[0] = 'R';
    he.f1.size[0] = 1;
    he.f1.size[1] = 1;
    he.f1.data[0] = 'S';
    ie.f1.size[0] = 1;
    ie.f1.size[1] = 1;
    ie.f1.data[0] = 'L';
    je.f1.size[0] = 1;
    je.f1.size[1] = 1;
    je.f1.data[0] = 'L';
    ke.f1.size[0] = 1;
    ke.f1.size[1] = 1;
    ke.f1.data[0] = 'R';
    le.f1.size[0] = 1;
    le.f1.size[1] = 1;
    le.f1.data[0] = 'S';
    me.f1.size[0] = 1;
    me.f1.size[1] = 1;
    me.f1.data[0] = 'R';
    ne.f1.size[0] = 1;
    ne.f1.size[1] = 1;
    ne.f1.data[0] = 'L';
    oe.f1.size[0] = 1;
    oe.f1.size[1] = 1;
    oe.f1.data[0] = 'R';
    pe.f1.size[0] = 1;
    pe.f1.size[1] = 1;
    pe.f1.data[0] = 'L';
    qe.f1.size[0] = 1;
    qe.f1.size[1] = 1;
    qe.f1.data[0] = 'R';
    re.f1.size[0] = 1;
    re.f1.size[1] = 1;
    re.f1.data[0] = 'R';
    se.f1.size[0] = 1;
    se.f1.size[1] = 1;
    se.f1.data[0] = 'L';
    te.f1.size[0] = 1;
    te.f1.size[1] = 1;
    te.f1.data[0] = 'S';
    ue.f1.size[0] = 1;
    ue.f1.size[1] = 1;
    ue.f1.data[0] = 'R';
    ve.f1.size[0] = 1;
    ve.f1.size[1] = 1;
    ve.f1.data[0] = 'R';
    we.f1.size[0] = 1;
    we.f1.size[1] = 1;
    we.f1.data[0] = 'L';
    xe.f1.size[0] = 1;
    xe.f1.size[1] = 1;
    xe.f1.data[0] = 'R';
    ye.f1.size[0] = 1;
    ye.f1.size[1] = 1;
    ye.f1.data[0] = 'L';
    af.f1.size[0] = 1;
    af.f1.size[1] = 1;
    af.f1.data[0] = 'R';
    bf.f1.size[0] = 1;
    bf.f1.size[1] = 1;
    bf.f1.data[0] = 'L';
    cf.f1.size[0] = 1;
    cf.f1.size[1] = 1;
    cf.f1.data[0] = 'S';
    df.f1.size[0] = 1;
    df.f1.size[1] = 1;
    df.f1.data[0] = 'L';
    ef.f1.size[0] = 1;
    ef.f1.size[1] = 1;
    ef.f1.data[0] = 'L';
    ff.f1.size[0] = 1;
    ff.f1.size[1] = 1;
    ff.f1.data[0] = 'S';
    gf.f1.size[0] = 1;
    gf.f1.size[1] = 1;
    gf.f1.data[0] = 'R';
    hf.f1.size[0] = 1;
    hf.f1.size[1] = 1;
    hf.f1.data[0] = 'L';
    jf.f1.size[0] = 1;
    jf.f1.size[1] = 1;
    jf.f1.data[0] = 'R';
    kf.f1.size[0] = 1;
    kf.f1.size[1] = 1;
    kf.f1.data[0] = 'S';
    lf.f1.size[0] = 1;
    lf.f1.size[1] = 1;
    lf.f1.data[0] = 'R';
    mf.f1.size[0] = 1;
    mf.f1.size[1] = 1;
    mf.f1.data[0] = 'L';
    nf.f1.size[0] = 1;
    nf.f1.size[1] = 1;
    nf.f1.data[0] = 'L';
    of.f1.size[0] = 1;
    of.f1.size[1] = 1;
    of.f1.data[0] = 'S';
    pf.f1.size[0] = 1;
    pf.f1.size[1] = 1;
    pf.f1.data[0] = 'L';
    qf.f1.size[0] = 1;
    qf.f1.size[1] = 1;
    qf.f1.data[0] = 'R';
    rf.f1.size[0] = 1;
    rf.f1.size[1] = 1;
    rf.f1.data[0] = 'R';
    sf.f1.size[0] = 1;
    sf.f1.size[1] = 1;
    sf.f1.data[0] = 'S';
    tf.f1.size[0] = 1;
    tf.f1.size[1] = 1;
    tf.f1.data[0] = 'L';
    uf.f1.size[0] = 1;
    uf.f1.size[1] = 1;
    uf.f1.data[0] = 'R';
    motionTypes[0] = b;
    b_obj_UAVDubinsBuildableObj =
        FlightMissionMode_uavDubinsBuildable_uavDubinsBuildable(obj->AirSpeed,
        obj->MaxRollAngle, obj->FlightPathAngleLimit, dpt_data, dpt_size);
    b_startPose[0] = startPose[0];
    b_goalPose[0] = goalPose[0];
    b_startPose[1] = startPose[1];
    b_goalPose[1] = goalPose[1];
    b_startPose[2] = startPose[2];
    b_goalPose[2] = goalPose[2];
    b_startPose[3] = startPose[3];
    b_goalPose[3] = goalPose[3];
    uavDubinsDistanceCodegen_real64(b_obj_UAVDubinsBuildableObj, &b_startPose[0],
        1U, &b_goalPose[0], 1U, true, turningRadius, &s[0], &g[0], &b_fpa, &b_a,
        &mtr, &h, &mt, &ml[0]);
    tmp = 0;
    for (int32_T i{0}; i < 4; i++) {
        ml1[tmp] = ml[i];
        ml1[static_cast<int32_T>(tmp + 1)] = ml[static_cast<int32_T>(i + 4)];
        ml1[static_cast<int32_T>(tmp + 2)] = ml[static_cast<int32_T>(i + 8)];
        ml1[static_cast<int32_T>(tmp + 3)] = ml[static_cast<int32_T>(i + 12)];
        tmp = static_cast<int32_T>(tmp + 4);
    }

    if (mt + 1.0 == 2.0) {
        motionTypes[0].f1[0] = mb;
        motionTypes[0].f1[1] = nb;
        motionTypes[0].f1[2] = ob;
        motionTypes[0].f1[3] = pb;
    }

    if (mt + 1.0 == 3.0) {
        motionTypes[0].f1[0] = qb;
        motionTypes[0].f1[1] = rb;
        motionTypes[0].f1[2] = sb;
        motionTypes[0].f1[3] = tb;
    }

    if (mt + 1.0 == 4.0) {
        motionTypes[0].f1[0] = ub;
        motionTypes[0].f1[1] = vb;
        motionTypes[0].f1[2] = wb;
        motionTypes[0].f1[3] = xb;
    }

    if (mt + 1.0 == 5.0) {
        motionTypes[0].f1[0] = yb;
        motionTypes[0].f1[1] = ac;
        motionTypes[0].f1[2] = bc;
        motionTypes[0].f1[3] = cc;
    }

    if (mt + 1.0 == 6.0) {
        motionTypes[0].f1[0] = dc;
        motionTypes[0].f1[1] = ec;
        motionTypes[0].f1[2] = fc;
        motionTypes[0].f1[3] = gc;
    }

    if (mt + 1.0 == 7.0) {
        motionTypes[0].f1[0] = hc;
        motionTypes[0].f1[1] = ic;
        motionTypes[0].f1[2] = jc;
        motionTypes[0].f1[3] = kc;
    }

    if (mt + 1.0 == 8.0) {
        motionTypes[0].f1[0] = lc;
        motionTypes[0].f1[1] = mc;
        motionTypes[0].f1[2] = nc;
        motionTypes[0].f1[3] = oc;
    }

    if (mt + 1.0 == 9.0) {
        motionTypes[0].f1[0] = pc;
        motionTypes[0].f1[1] = qc;
        motionTypes[0].f1[2] = rc;
        motionTypes[0].f1[3] = sc;
    }

    if (mt + 1.0 == 10.0) {
        motionTypes[0].f1[0] = tc;
        motionTypes[0].f1[1] = uc;
        motionTypes[0].f1[2] = vc;
        motionTypes[0].f1[3] = wc;
    }

    if (mt + 1.0 == 11.0) {
        motionTypes[0].f1[0] = xc;
        motionTypes[0].f1[1] = yc;
        motionTypes[0].f1[2] = ad;
        motionTypes[0].f1[3] = bd;
    }

    if (mt + 1.0 == 12.0) {
        motionTypes[0].f1[0] = cd;
        motionTypes[0].f1[1] = dd;
        motionTypes[0].f1[2] = ed;
        motionTypes[0].f1[3] = fd;
    }

    if (mt + 1.0 == 13.0) {
        motionTypes[0].f1[0] = gd;
        motionTypes[0].f1[1] = hd;
        motionTypes[0].f1[2] = id;
        motionTypes[0].f1[3] = jd;
    }

    if (mt + 1.0 == 14.0) {
        motionTypes[0].f1[0] = kd;
        motionTypes[0].f1[1] = ld;
        motionTypes[0].f1[2] = md;
        motionTypes[0].f1[3] = nd;
    }

    if (mt + 1.0 == 15.0) {
        motionTypes[0].f1[0] = od;
        motionTypes[0].f1[1] = pd;
        motionTypes[0].f1[2] = qd;
        motionTypes[0].f1[3] = rd;
    }

    if (mt + 1.0 == 16.0) {
        motionTypes[0].f1[0] = sd;
        motionTypes[0].f1[1] = td;
        motionTypes[0].f1[2] = ud;
        motionTypes[0].f1[3] = vd;
    }

    if (mt + 1.0 == 17.0) {
        motionTypes[0].f1[0] = wd;
        motionTypes[0].f1[1] = xd;
        motionTypes[0].f1[2] = yd;
        motionTypes[0].f1[3] = ae;
    }

    if (mt + 1.0 == 18.0) {
        motionTypes[0].f1[0] = be;
        motionTypes[0].f1[1] = ce;
        motionTypes[0].f1[2] = de;
        motionTypes[0].f1[3] = ee;
    }

    if (mt + 1.0 == 19.0) {
        motionTypes[0].f1[0] = fe;
        motionTypes[0].f1[1] = ge;
        motionTypes[0].f1[2] = he;
        motionTypes[0].f1[3] = ie;
    }

    if (mt + 1.0 == 20.0) {
        motionTypes[0].f1[0] = je;
        motionTypes[0].f1[1] = ke;
        motionTypes[0].f1[2] = le;
        motionTypes[0].f1[3] = me;
    }

    if (mt + 1.0 == 21.0) {
        motionTypes[0].f1[0] = ne;
        motionTypes[0].f1[1] = oe;
        motionTypes[0].f1[2] = pe;
        motionTypes[0].f1[3] = qe;
    }

    if (mt + 1.0 == 22.0) {
        motionTypes[0].f1[0] = re;
        motionTypes[0].f1[1] = se;
        motionTypes[0].f1[2] = te;
        motionTypes[0].f1[3] = ue;
    }

    if (mt + 1.0 == 23.0) {
        motionTypes[0].f1[0] = ve;
        motionTypes[0].f1[1] = we;
        motionTypes[0].f1[2] = xe;
        motionTypes[0].f1[3] = ye;
    }

    if (mt + 1.0 == 24.0) {
        motionTypes[0].f1[0] = af;
        motionTypes[0].f1[1] = bf;
        motionTypes[0].f1[2] = cf;
        motionTypes[0].f1[3] = df;
    }

    if (mt + 1.0 == 25.0) {
        motionTypes[0].f1[0] = ef;
        motionTypes[0].f1[1] = ff;
        motionTypes[0].f1[2] = gf;
        motionTypes[0].f1[3] = hf;
    }

    if (mt + 1.0 == 26.0) {
        motionTypes[0].f1[0] = jf;
        motionTypes[0].f1[1] = kf;
        motionTypes[0].f1[2] = lf;
        motionTypes[0].f1[3] = mf;
    }

    if (mt + 1.0 == 27.0) {
        motionTypes[0].f1[0] = nf;
        motionTypes[0].f1[1] = of;
        motionTypes[0].f1[2] = pf;
        motionTypes[0].f1[3] = qf;
    }

    if (mt + 1.0 == 28.0) {
        motionTypes[0].f1[0] = rf;
        motionTypes[0].f1[1] = sf;
        motionTypes[0].f1[2] = tf;
        motionTypes[0].f1[3] = uf;
    }

    b_startPose[0] = s[0];
    b_goalPose[0] = g[0];
    ml1_0[0] = ml1[0];
    b_startPose[1] = s[1];
    b_goalPose[1] = g[1];
    ml1_0[1] = ml1[4];
    b_startPose[2] = s[2];
    b_goalPose[2] = g[2];
    ml1_0[2] = ml1[8];
    b_startPose[3] = s[3];
    b_goalPose[3] = g[3];
    ml1_0[3] = ml1[12];
    FlightMissionMode_uavDubinsPathSegment_uavDubinsPathSegment_h(b_startPose,
        b_goalPose, b_fpa, b_a, mtr, h, motionTypes[0].f1, ml1_0, pathSegObjs);
    ml1_0[0] = ml1[0];
    ml1_0[1] = ml1[4];
    ml1_0[2] = ml1[8];
    ml1_0[3] = ml1[12];
    *pathCosts = sum_kSJnGZ04(ml1_0);
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_uavDubinsConnection_connect(const
    uavDubinsConnection_FlightMissionMode_T *obj, const real_T startPoses[4],
    const real_T goalPoses[4], uavDubinsPathSegment_FlightMissionMode_T
    *pathSegObjs, real_T *pathCosts)
{
    real_T a__1_data[28];
    real_T iia_data_0[28];
    int32_T iia_data[28];
    int32_T a__1_size[2];
    int32_T ib_size;
    int32_T iia_size;
    int32_T iia_size_0;
    FlightMissionMode_do_vectors(a__1_data, a__1_size, iia_data, &iia_size,
        &ib_size);
    iia_size_0 = iia_size;
    for (ib_size = 0; ib_size <= static_cast<int32_T>(iia_size - 1); ib_size++)
    {
        iia_data_0[ib_size] = static_cast<real_T>(iia_data[ib_size]);
    }

    FlightMissionMode_do_vectors_b(iia_data_0, &iia_size_0, a__1_data, a__1_size,
        iia_data, &iia_size, &ib_size);
    for (ib_size = 0; ib_size <= static_cast<int32_T>(iia_size - 1); ib_size++)
    {
        iia_data_0[ib_size] = static_cast<real_T>(iia_data[ib_size]);
    }

    FlightMissionMode_sort_l(iia_data_0, &iia_size);
    for (ib_size = 0; ib_size <= static_cast<int32_T>(iia_size - 1); ib_size++)
    {
        a__1_data[ib_size] = iia_data_0[ib_size] - 1.0;
    }

    FlightMissionMode_uavDubinsBuiltins_connect(obj, startPoses, goalPoses,
        obj->MinTurningRadius, a__1_data, &iia_size, pathSegObjs, pathCosts);
}

void FlightMissionMode::FlightMissionMode_emxInit_real_T
    (emxArray_real_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions)
{
    emxArray_real_T_FlightMissionMode_T *emxArray;
    *pEmxArray = static_cast<emxArray_real_T_FlightMissionMode_T *>(std::malloc
        (sizeof(emxArray_real_T_FlightMissionMode_T)));
    emxArray = *pEmxArray;
    emxArray->data = static_cast<real_T *>(nullptr);
    emxArray->numDimensions = numDimensions;
    emxArray->size = static_cast<int32_T *>(std::malloc(static_cast<uint32_T>
        (sizeof(int32_T) * static_cast<uint32_T>(numDimensions))));
    emxArray->allocatedSize = 0;
    emxArray->canFreeData = true;
    for (int32_T i{0}; i <= static_cast<int32_T>(numDimensions - 1); i++) {
        emxArray->size[i] = 0;
    }
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_strcmp_bt4yhx3(const
    cell_wrap_0_FlightMissionMode_T a[4], boolean_T b_bool[4])
{
    b_bool[0] = false;
    if ((a[0].f1.size[1] == 1) && (a[0].f1.data[0] == 'N')) {
        b_bool[0] = true;
    }

    b_bool[1] = false;
    if ((a[1].f1.size[1] == 1) && (a[1].f1.data[0] == 'N')) {
        b_bool[1] = true;
    }

    b_bool[2] = false;
    if ((a[2].f1.size[1] == 1) && (a[2].f1.data[0] == 'N')) {
        b_bool[2] = true;
    }

    b_bool[3] = false;
    if ((a[3].f1.size[1] == 1) && (a[3].f1.data[0] == 'N')) {
        b_bool[3] = true;
    }
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_any(const boolean_T x[4])
{
    int32_T k;
    boolean_T exitg1;
    boolean_T y;
    y = false;
    k = 0;
    exitg1 = false;
    while ((!exitg1) && (k < 4)) {
        if (x[k]) {
            y = true;
            exitg1 = true;
        } else {
            k = static_cast<int32_T>(k + 1);
        }
    }

    return y;
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_useConstantDim(const real_T
    varargin_2_data[], const int32_T varargin_2_size[2], real_T
    varargout_1_data[], int32_T varargout_1_size[2])
{
    int32_T loop_ub;
    varargout_1_size[0] = 1;
    varargout_1_size[1] = varargin_2_size[1];
    loop_ub = static_cast<int32_T>(varargin_2_size[1] - 1);
    for (int32_T varargout_1_data_tmp{0}; varargout_1_data_tmp <= loop_ub;
            varargout_1_data_tmp++) {
        varargout_1_data[varargout_1_data_tmp] =
            varargin_2_data[varargout_1_data_tmp];
    }

    for (loop_ub = 0; loop_ub <= static_cast<int32_T>(varargin_2_size[1] - 2);
            loop_ub = static_cast<int32_T>(loop_ub + 1)) {
        varargout_1_data[static_cast<int32_T>(loop_ub + 1)] +=
            varargout_1_data[loop_ub];
    }
}

void FlightMissionMode::FlightMissionMode_emxFree_real_T
    (emxArray_real_T_FlightMissionMode_T **pEmxArray)
{
    if (*pEmxArray != static_cast<emxArray_real_T_FlightMissionMode_T *>(nullptr))
    {
        if (((*pEmxArray)->data != static_cast<real_T *>(nullptr)) &&
                (*pEmxArray)->canFreeData) {
            std::free((*pEmxArray)->data);
        }

        std::free((*pEmxArray)->size);
        std::free(*pEmxArray);
        *pEmxArray = static_cast<emxArray_real_T_FlightMissionMode_T *>(nullptr);
    }
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_eml_find(boolean_T x, int32_T i_data[],
    int32_T i_size[2])
{
    if (x) {
        i_size[0] = 1;
        i_size[1] = 1;
        i_data[0] = 1;
    } else {
        i_size[0] = 0;
        i_size[1] = 0;
    }
}

void FlightMissionMode::FlightMissionMode_emxEnsureCapacity_real_T
    (emxArray_real_T_FlightMissionMode_T *emxArray, int32_T oldNumel)
{
    int32_T i;
    int32_T newNumel;
    void *newData;
    if (oldNumel < 0) {
        oldNumel = 0;
    }

    newNumel = 1;
    for (i = 0; i <= static_cast<int32_T>(emxArray->numDimensions - 1); i++) {
        newNumel = static_cast<int32_T>(newNumel * emxArray->size[i]);
    }

    if (newNumel > emxArray->allocatedSize) {
        i = emxArray->allocatedSize;
        if (i < 16) {
            i = 16;
        }

        while (i < newNumel) {
            if (i > 1073741823) {
                i = MAX_int32_T;
            } else {
                i = static_cast<int32_T>(i << 1);
            }
        }

        newData = std::calloc(static_cast<uint32_T>(i), sizeof(real_T));
        if (emxArray->data != nullptr) {
            std::memcpy(newData, emxArray->data, static_cast<uint32_T>(sizeof
                         (real_T) * static_cast<uint32_T>(oldNumel)));
            if (emxArray->canFreeData) {
                std::free(emxArray->data);
            }
        }

        emxArray->data = static_cast<real_T *>(newData);
        emxArray->allocatedSize = i;
        emxArray->canFreeData = true;
    }
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_bt4yhx33(const char_T
    a_data[], const int32_T a_size[2])
{
    boolean_T b_bool;
    b_bool = false;
    if ((a_size[1] == 1) && (a_data[0] == 'N')) {
        b_bool = true;
    }

    return b_bool;
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_bt4yhx33c(const char_T
    a_data[], const int32_T a_size[2])
{
    static const char_T b[2]{ 'H', 'l' };

    boolean_T b_bool;
    b_bool = false;
    if (a_size[1] == 2) {
        int32_T kstr;
        kstr = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (kstr < 2) {
                if (a_data[kstr] != b[kstr]) {
                    exitg1 = 1;
                } else {
                    kstr = static_cast<int32_T>(kstr + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    return b_bool;
}

void FlightMissionMode::FlightMissionMode_emxInit_boolean_T
    (emxArray_boolean_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions)
{
    emxArray_boolean_T_FlightMissionMode_T *emxArray;
    *pEmxArray = static_cast<emxArray_boolean_T_FlightMissionMode_T *>(std::
        malloc(sizeof(emxArray_boolean_T_FlightMissionMode_T)));
    emxArray = *pEmxArray;
    emxArray->data = static_cast<boolean_T *>(nullptr);
    emxArray->numDimensions = numDimensions;
    emxArray->size = static_cast<int32_T *>(std::malloc(static_cast<uint32_T>
        (sizeof(int32_T) * static_cast<uint32_T>(numDimensions))));
    emxArray->allocatedSize = 0;
    emxArray->canFreeData = true;
    for (int32_T i{0}; i <= static_cast<int32_T>(numDimensions - 1); i++) {
        emxArray->size[i] = 0;
    }
}

void FlightMissionMode::FlightMissionMode_emxEnsureCapacity_boolean_T
    (emxArray_boolean_T_FlightMissionMode_T *emxArray, int32_T oldNumel)
{
    int32_T i;
    int32_T newNumel;
    void *newData;
    if (oldNumel < 0) {
        oldNumel = 0;
    }

    newNumel = 1;
    for (i = 0; i <= static_cast<int32_T>(emxArray->numDimensions - 1); i++) {
        newNumel = static_cast<int32_T>(newNumel * emxArray->size[i]);
    }

    if (newNumel > emxArray->allocatedSize) {
        i = emxArray->allocatedSize;
        if (i < 16) {
            i = 16;
        }

        while (i < newNumel) {
            if (i > 1073741823) {
                i = MAX_int32_T;
            } else {
                i = static_cast<int32_T>(i << 1);
            }
        }

        newData = std::calloc(static_cast<uint32_T>(i), sizeof(boolean_T));
        if (emxArray->data != nullptr) {
            std::memcpy(newData, emxArray->data, static_cast<uint32_T>(sizeof
                         (boolean_T) * static_cast<uint32_T>(oldNumel)));
            if (emxArray->canFreeData) {
                std::free(emxArray->data);
            }
        }

        emxArray->data = static_cast<boolean_T *>(newData);
        emxArray->allocatedSize = i;
        emxArray->canFreeData = true;
    }
}

void FlightMissionMode::FlightMissionMode_emxFree_boolean_T
    (emxArray_boolean_T_FlightMissionMode_T **pEmxArray)
{
    if (*pEmxArray != static_cast<emxArray_boolean_T_FlightMissionMode_T *>
            (nullptr)) {
        if (((*pEmxArray)->data != static_cast<boolean_T *>(nullptr)) &&
                (*pEmxArray)->canFreeData) {
            std::free((*pEmxArray)->data);
        }

        std::free((*pEmxArray)->size);
        std::free(*pEmxArray);
        *pEmxArray = static_cast<emxArray_boolean_T_FlightMissionMode_T *>
            (nullptr);
    }
}

void FlightMissionMode::FlightMissionMode_binary_expand_op
    (emxArray_boolean_T_FlightMissionMode_T *in1, const
     emxArray_real_T_FlightMissionMode_T *in2, const
     emxArray_real_T_FlightMissionMode_T *in3)
{
    int32_T i;
    int32_T loop_ub;
    int32_T stride_0_0;
    int32_T stride_1_0;
    i = in1->size[0];
    in1->size[0] = in3->size[0] == 1 ? in2->size[0] : in3->size[0];
    FlightMissionMode_emxEnsureCapacity_boolean_T(in1, i);
    stride_0_0 = (in2->size[0] != 1);
    stride_1_0 = (in3->size[0] != 1);
    loop_ub = in3->size[0] == 1 ? in2->size[0] : in3->size[0];
    for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
        in1->data[i] = static_cast<boolean_T>(static_cast<int32_T>((in2->data[
            static_cast<int32_T>(i * stride_0_0)] == 0.0) & (in3->data[
            static_cast<int32_T>(i * stride_1_0)] > 0.0)));
    }
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_wrapToPi
    (emxArray_real_T_FlightMissionMode_T *theta)
{
    emxArray_boolean_T_FlightMissionMode_T *x;
    emxArray_real_T_FlightMissionMode_T *y;
    int32_T k;
    int32_T loop_ub;
    boolean_T b_y;
    boolean_T exitg1;
    FlightMissionMode_emxInit_real_T(&y, 1);
    k = y->size[0];
    y->size[0] = theta->size[0];
    FlightMissionMode_emxEnsureCapacity_real_T(y, k);
    for (k = 0; k <= static_cast<int32_T>(theta->size[0] - 1); k = static_cast<
            int32_T>(k + 1)) {
        y->data[k] = std::abs(theta->data[k]);
    }

    FlightMissionMode_emxInit_boolean_T(&x, 1);
    k = x->size[0];
    x->size[0] = y->size[0];
    FlightMissionMode_emxEnsureCapacity_boolean_T(x, k);
    loop_ub = y->size[0];
    for (k = 0; k <= static_cast<int32_T>(loop_ub - 1); k++) {
        x->data[k] = (y->data[k] > 3.1415926535897931);
    }

    b_y = false;
    k = 1;
    exitg1 = false;
    while ((!exitg1) && (k <= x->size[0])) {
        if (x->data[static_cast<int32_T>(k - 1)]) {
            b_y = true;
            exitg1 = true;
        } else {
            k = static_cast<int32_T>(k + 1);
        }
    }

    if (b_y) {
        k = y->size[0];
        y->size[0] = theta->size[0];
        FlightMissionMode_emxEnsureCapacity_real_T(y, k);
        loop_ub = theta->size[0];
        for (k = 0; k <= static_cast<int32_T>(loop_ub - 1); k++) {
            y->data[k] = theta->data[k] + 3.1415926535897931;
        }

        k = theta->size[0];
        theta->size[0] = y->size[0];
        FlightMissionMode_emxEnsureCapacity_real_T(theta, k);
        for (k = 0; k <= static_cast<int32_T>(y->size[0] - 1); k = static_cast<
                int32_T>(k + 1)) {
            theta->data[k] = mod_d42kHWKw(y->data[k]);
        }

        if (theta->size[0] == y->size[0]) {
            k = x->size[0];
            x->size[0] = theta->size[0];
            FlightMissionMode_emxEnsureCapacity_boolean_T(x, k);
            loop_ub = theta->size[0];
            for (k = 0; k <= static_cast<int32_T>(loop_ub - 1); k++) {
                x->data[k] = static_cast<boolean_T>(static_cast<int32_T>
                    ((theta->data[k] == 0.0) & (y->data[k] > 0.0)));
            }
        } else {
            FlightMissionMode_binary_expand_op(x, theta, y);
        }

        for (k = 0; k <= static_cast<int32_T>(x->size[0] - 1); k = static_cast<
                int32_T>(k + 1)) {
            if (x->data[k]) {
                theta->data[k] = 6.2831853071795862;
            }
        }

        loop_ub = theta->size[0];
        for (k = 0; k <= static_cast<int32_T>(loop_ub - 1); k++) {
            theta->data[k] -= 3.1415926535897931;
        }
    }

    FlightMissionMode_emxFree_boolean_T(&x);
    FlightMissionMode_emxFree_real_T(&y);
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_bt4yhx33cu(const char_T
    a_data[], const int32_T a_size[2])
{
    static const char_T b[2]{ 'H', 'r' };

    boolean_T b_bool;
    b_bool = false;
    if (a_size[1] == 2) {
        int32_T kstr;
        kstr = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (kstr < 2) {
                if (a_data[kstr] != b[kstr]) {
                    exitg1 = 1;
                } else {
                    kstr = static_cast<int32_T>(kstr + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    return b_bool;
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_bt4yhx33cua(const char_T
    a_data[], const int32_T a_size[2])
{
    boolean_T b_bool;
    b_bool = false;
    if ((a_size[1] == 1) && (a_data[0] == 'L')) {
        b_bool = true;
    }

    return b_bool;
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_bt4yhx33cuar(const char_T
    a_data[], const int32_T a_size[2])
{
    boolean_T b_bool;
    b_bool = false;
    if ((a_size[1] == 1) && (a_data[0] == 'R')) {
        b_bool = true;
    }

    return b_bool;
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_bt4yhx33cuary(const char_T
    a_data[], const int32_T a_size[2])
{
    boolean_T b_bool;
    b_bool = false;
    if ((a_size[1] == 1) && (a_data[0] == 'S')) {
        b_bool = true;
    }

    return b_bool;
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_mtimes(const
    emxArray_real_T_FlightMissionMode_T *A, const real_T B[4],
    emxArray_real_T_FlightMissionMode_T *C)
{
    int32_T i;
    int32_T m;
    m = A->size[0];
    i = static_cast<int32_T>(C->size[0] * C->size[1]);
    C->size[0] = A->size[0];
    C->size[1] = 2;
    FlightMissionMode_emxEnsureCapacity_real_T(C, i);
    for (i = 0; i <= static_cast<int32_T>(m - 1); i = static_cast<int32_T>(i + 1))
    {
        C->data[i] = A->data[static_cast<int32_T>(A->size[0] + i)] * B[1] +
            A->data[i] * B[0];
    }

    for (i = 0; i <= static_cast<int32_T>(m - 1); i = static_cast<int32_T>(i + 1))
    {
        C->data[static_cast<int32_T>(m + i)] = A->data[static_cast<int32_T>
            (A->size[0] + i)] * B[3] + A->data[i] * B[2];
    }
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_uavDubinsPathSegment_interpolate(const
    real_T b_this_StartPose[4], const real_T b_this_GoalPose[4], real_T
    b_this_FlightPathAngle, real_T b_this_AirSpeed, real_T
    b_this_MinTurningRadius, real_T b_this_HelixRadius, const
    cell_wrap_0_FlightMissionMode_T b_this_MotionTypes[4], const real_T
    b_this_MotionLengths[4], real_T b_this_Length, real_T samples, real_T
    poses_data[], int32_T poses_size[2])
{
    emxArray_real_T_FlightMissionMode_T *S;
    emxArray_real_T_FlightMissionMode_T *c_x;
    emxArray_real_T_FlightMissionMode_T *d_x;
    emxArray_real_T_FlightMissionMode_T *p;
    real_T ns_data[12];
    real_T state[6];
    real_T TransformMatrix[4];
    real_T tempMotionLength_data[4];
    real_T transLength_data[4];
    real_T S_data[2];
    real_T tempSamples_data[2];
    real_T z_data[2];
    int32_T tempMotionLength_size[2];
    int32_T transLength_size[2];
    int32_T o_data;
    boolean_T tmp[4];
    poses_size[0] = 0;
    poses_size[1] = 6;
    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(std::
            isnan(b_this_Length)) ^ 1))) {
        real_T intermediateLength;
        real_T samples_tmp;
        real_T tempStartPose_idx_2;
        int32_T count;
        int32_T loop_ub;
        int32_T ns_size_idx_0;
        int32_T tempMotionLength_data_tmp;
        tempStartPose_idx_2 = -b_this_StartPose[2];
        poses_size[0] = 1;
        poses_size[1] = 6;
        for (count = 0; count < 6; count++) {
            poses_data[count] = 0.0;
        }

        samples_tmp = std::cos(std::abs(b_this_FlightPathAngle));
        samples *= samples_tmp;
        TransformMatrix[0] = b_this_MotionLengths[0] * samples_tmp;
        TransformMatrix[1] = b_this_MotionLengths[1] * samples_tmp;
        TransformMatrix[2] = b_this_MotionLengths[2] * samples_tmp;
        tempMotionLength_size[0] = 1;
        tempMotionLength_size[1] = 4;
        tempMotionLength_data[0] = TransformMatrix[0];
        tempMotionLength_data[1] = TransformMatrix[1];
        tempMotionLength_data[2] = TransformMatrix[2];
        tempMotionLength_data[3] = b_this_MotionLengths[3] * samples_tmp;
        FlightMissionMode_strcmp_bt4yhx3(b_this_MotionTypes, tmp);
        if (FlightMissionMode_any(tmp)) {
            tempMotionLength_size[0] = 1;
            tempMotionLength_size[1] = 3;
            tempMotionLength_data[0] = TransformMatrix[0];
            tempMotionLength_data[1] = TransformMatrix[1];
            tempMotionLength_data[2] = TransformMatrix[2];
        }

        FlightMissionMode_useConstantDim(tempMotionLength_data,
            tempMotionLength_size, transLength_data, transLength_size);
        intermediateLength = 0.0;
        state[0] = b_this_StartPose[0];
        state[1] = -b_this_StartPose[1];
        state[3] = -b_this_StartPose[3];
        tempMotionLength_data_tmp = 0;
        FlightMissionMode_emxInit_real_T(&c_x, 1);
        FlightMissionMode_emxInit_real_T(&d_x, 1);
        FlightMissionMode_emxInit_real_T(&p, 2);
        FlightMissionMode_emxInit_real_T(&S, 2);
        while (tempMotionLength_data_tmp <= static_cast<int32_T>
                (tempMotionLength_size[1] - 1)) {
            boolean_T x;
            if (static_cast<int32_T>(tempMotionLength_data_tmp + 1) == 1) {
                x = static_cast<boolean_T>(static_cast<int32_T>((samples <=
                    (intermediateLength + tempMotionLength_data[0]) + 1.0E-6) &
                    (samples >= intermediateLength)));
            } else {
                x = static_cast<boolean_T>(static_cast<int32_T>((samples <=
                    (intermediateLength +
                     tempMotionLength_data[tempMotionLength_data_tmp]) + 1.0E-6)
                    & (samples > intermediateLength)));
            }

            FlightMissionMode_eml_find(x, &o_data, transLength_size);
            if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                    (FlightMissionMode_strcmp_bt4yhx33
                     (b_this_MotionTypes[tempMotionLength_data_tmp].f1.data,
                      b_this_MotionTypes[tempMotionLength_data_tmp].f1.size)) ^
                    1))) {
                real_T TransformMatrix_tmp;
                real_T TransformMatrix_tmp_0;
                real_T radius;
                int32_T tempSamples_size_idx_0;
                radius = b_this_MinTurningRadius;
                if (FlightMissionMode_strcmp_bt4yhx33c
                        (b_this_MotionTypes[tempMotionLength_data_tmp].f1.data,
                         b_this_MotionTypes[tempMotionLength_data_tmp].f1.size))
                {
                    radius = b_this_HelixRadius;
                } else if (FlightMissionMode_strcmp_bt4yhx33cu
                           (b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.data,
                            b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.size)) {
                    radius = b_this_HelixRadius;
                }

                count = 0;
                tempSamples_size_idx_0 = 1;
                tempSamples_data[0] = 0.0;
                if (static_cast<boolean_T>(static_cast<int32_T>
                                           ((transLength_size[0] != 0) &
                                            (transLength_size[1] != 0)))) {
                    tempSamples_size_idx_0 = 2;
                    tempSamples_data[1] = 0.0;
                    count = 1;
                    tempSamples_data[0] = samples;
                    samples = -1.0;
                }

                tempSamples_data[count] =
                    transLength_data[tempMotionLength_data_tmp];
                for (count = 0; count <= static_cast<int32_T>
                        (tempSamples_size_idx_0 - 1); count++) {
                    S_data[count] = (tempSamples_data[count] -
                                     intermediateLength) / radius;
                }

                ns_size_idx_0 = tempSamples_size_idx_0;
                loop_ub = static_cast<int32_T>(static_cast<int32_T>
                    (tempSamples_size_idx_0 * 6) - 1);
                for (count = 0; count <= loop_ub; count++) {
                    ns_data[count] = 0.0;
                }

                for (count = 0; count <= static_cast<int32_T>
                        (tempSamples_size_idx_0 - 1); count++) {
                    z_data[count] = tempStartPose_idx_2 + tempSamples_data[count];
                }

                TransformMatrix_tmp = std::sin(state[3]);
                TransformMatrix_tmp_0 = std::cos(state[3]);
                TransformMatrix[0] = TransformMatrix_tmp_0;
                TransformMatrix[2] = TransformMatrix_tmp;
                TransformMatrix[1] = -TransformMatrix_tmp;
                TransformMatrix[3] = TransformMatrix_tmp_0;
                if (b_this_Length != 0.0) {
                    TransformMatrix_tmp = -b_this_GoalPose[2] -
                        tempStartPose_idx_2;
                    TransformMatrix_tmp_0 = b_this_Length * samples_tmp;
                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        z_data[count] = tempSamples_data[count] /
                            TransformMatrix_tmp_0 * TransformMatrix_tmp +
                            tempStartPose_idx_2;
                    }
                }

                for (count = 0; count <= static_cast<int32_T>
                        (tempSamples_size_idx_0 - 1); count++) {
                    tempSamples_data[count] = b_this_FlightPathAngle;
                }

                if (FlightMissionMode_strcmp_bt4yhx33c
                        (b_this_MotionTypes[tempMotionLength_data_tmp].f1.data,
                         b_this_MotionTypes[tempMotionLength_data_tmp].f1.size) ||
                    FlightMissionMode_strcmp_bt4yhx33cua
                        (b_this_MotionTypes[tempMotionLength_data_tmp].f1.data,
                         b_this_MotionTypes[tempMotionLength_data_tmp].f1.size))
                {
                    real_T state_0;
                    real_T state_1;
                    ns_size_idx_0 = c_x->size[0];
                    c_x->size[0] = tempSamples_size_idx_0;
                    FlightMissionMode_emxEnsureCapacity_real_T(c_x,
                        ns_size_idx_0);
                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        c_x->data[count] = S_data[count];
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count =
                            static_cast<int32_T>(count + 1)) {
                        c_x->data[count] = std::sin(c_x->data[count]);
                    }

                    ns_size_idx_0 = d_x->size[0];
                    d_x->size[0] = tempSamples_size_idx_0;
                    FlightMissionMode_emxEnsureCapacity_real_T(d_x,
                        ns_size_idx_0);
                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        d_x->data[count] = S_data[count];
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count =
                            static_cast<int32_T>(count + 1)) {
                        d_x->data[count] = std::cos(d_x->data[count]);
                    }

                    ns_size_idx_0 = static_cast<int32_T>(S->size[0] * S->size[1]);
                    S->size[0] = c_x->size[0];
                    S->size[1] = 2;
                    FlightMissionMode_emxEnsureCapacity_real_T(S, ns_size_idx_0);
                    loop_ub = c_x->size[0];
                    for (count = 0; count <= static_cast<int32_T>(loop_ub - 1);
                            count++) {
                        S->data[count] = c_x->data[count];
                    }

                    loop_ub = d_x->size[0];
                    for (count = 0; count <= static_cast<int32_T>(loop_ub - 1);
                            count++) {
                        S->data[static_cast<int32_T>(count + c_x->size[0])] =
                            1.0 - d_x->data[count];
                    }

                    FlightMissionMode_mtimes(S, TransformMatrix, p);
                    TransformMatrix_tmp = -rt_atan2d_snf(b_this_AirSpeed *
                        b_this_AirSpeed, 9.8 * radius);
                    TransformMatrix_tmp_0 = state[0];
                    state_0 = state[1];
                    state_1 = state[3];
                    loop_ub = p->size[0];
                    ns_size_idx_0 = p->size[0];
                    for (count = 0; count <= static_cast<int32_T>(loop_ub - 1);
                            count++) {
                        ns_data[count] = p->data[count] * radius +
                            TransformMatrix_tmp_0;
                        ns_data[static_cast<int32_T>(count + ns_size_idx_0)] =
                            p->data[static_cast<int32_T>(count + p->size[0])] *
                            radius + state_0;
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        ns_data[static_cast<int32_T>(count + static_cast<int32_T>
                            (ns_size_idx_0 << 1))] = z_data[count];
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        ns_data[static_cast<int32_T>(count + static_cast<int32_T>
                            (ns_size_idx_0 * 3))] = state_1 + S_data[count];
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        ns_data[static_cast<int32_T>(count + static_cast<int32_T>
                            (ns_size_idx_0 << 2))] = tempSamples_data[count];
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        ns_data[static_cast<int32_T>(count + static_cast<int32_T>
                            (ns_size_idx_0 * 5))] = TransformMatrix_tmp;
                    }
                } else if (FlightMissionMode_strcmp_bt4yhx33cu
                           (b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.data,
                            b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.size) || FlightMissionMode_strcmp_bt4yhx33cuar
                           (b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.data,
                            b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.size)) {
                    real_T state_0;
                    real_T state_1;
                    ns_size_idx_0 = c_x->size[0];
                    c_x->size[0] = tempSamples_size_idx_0;
                    FlightMissionMode_emxEnsureCapacity_real_T(c_x,
                        ns_size_idx_0);
                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        c_x->data[count] = S_data[count];
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count =
                            static_cast<int32_T>(count + 1)) {
                        c_x->data[count] = std::sin(c_x->data[count]);
                    }

                    ns_size_idx_0 = d_x->size[0];
                    d_x->size[0] = tempSamples_size_idx_0;
                    FlightMissionMode_emxEnsureCapacity_real_T(d_x,
                        ns_size_idx_0);
                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        d_x->data[count] = S_data[count];
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count =
                            static_cast<int32_T>(count + 1)) {
                        d_x->data[count] = std::cos(d_x->data[count]);
                    }

                    ns_size_idx_0 = static_cast<int32_T>(S->size[0] * S->size[1]);
                    S->size[0] = c_x->size[0];
                    S->size[1] = 2;
                    FlightMissionMode_emxEnsureCapacity_real_T(S, ns_size_idx_0);
                    loop_ub = c_x->size[0];
                    for (count = 0; count <= static_cast<int32_T>(loop_ub - 1);
                            count++) {
                        S->data[count] = c_x->data[count];
                    }

                    loop_ub = d_x->size[0];
                    for (count = 0; count <= static_cast<int32_T>(loop_ub - 1);
                            count++) {
                        S->data[static_cast<int32_T>(count + c_x->size[0])] =
                            d_x->data[count] - 1.0;
                    }

                    FlightMissionMode_mtimes(S, TransformMatrix, p);
                    TransformMatrix_tmp = rt_atan2d_snf(b_this_AirSpeed *
                        b_this_AirSpeed, 9.8 * radius);
                    TransformMatrix_tmp_0 = state[0];
                    state_0 = state[1];
                    state_1 = state[3];
                    loop_ub = p->size[0];
                    ns_size_idx_0 = p->size[0];
                    for (count = 0; count <= static_cast<int32_T>(loop_ub - 1);
                            count++) {
                        ns_data[count] = p->data[count] * radius +
                            TransformMatrix_tmp_0;
                        ns_data[static_cast<int32_T>(count + ns_size_idx_0)] =
                            p->data[static_cast<int32_T>(count + p->size[0])] *
                            radius + state_0;
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        ns_data[static_cast<int32_T>(count + static_cast<int32_T>
                            (ns_size_idx_0 << 1))] = z_data[count];
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        ns_data[static_cast<int32_T>(count + static_cast<int32_T>
                            (ns_size_idx_0 * 3))] = state_1 - S_data[count];
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        ns_data[static_cast<int32_T>(count + static_cast<int32_T>
                            (ns_size_idx_0 << 2))] = tempSamples_data[count];
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        ns_data[static_cast<int32_T>(count + static_cast<int32_T>
                            (ns_size_idx_0 * 5))] = TransformMatrix_tmp;
                    }
                } else if (FlightMissionMode_strcmp_bt4yhx33cuary
                           (b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.data,
                            b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.size)) {
                    real_T state_0;
                    ns_size_idx_0 = static_cast<int32_T>(S->size[0] * S->size[1]);
                    S->size[0] = tempSamples_size_idx_0;
                    S->size[1] = 2;
                    FlightMissionMode_emxEnsureCapacity_real_T(S, ns_size_idx_0);
                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        S->data[count] = S_data[count];
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        S->data[static_cast<int32_T>(count +
                            tempSamples_size_idx_0)] = 0.0;
                    }

                    FlightMissionMode_mtimes(S, TransformMatrix, p);
                    TransformMatrix_tmp_0 = state[0];
                    state_0 = state[1];
                    loop_ub = p->size[0];
                    ns_size_idx_0 = p->size[0];
                    for (count = 0; count <= static_cast<int32_T>(loop_ub - 1);
                            count++) {
                        ns_data[count] = p->data[count] * radius +
                            TransformMatrix_tmp_0;
                        ns_data[static_cast<int32_T>(count + ns_size_idx_0)] =
                            p->data[static_cast<int32_T>(count + p->size[0])] *
                            radius + state_0;
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        ns_data[static_cast<int32_T>(count + static_cast<int32_T>
                            (ns_size_idx_0 << 1))] = z_data[count];
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        ns_data[static_cast<int32_T>(count + static_cast<int32_T>
                            (ns_size_idx_0 * 3))] = state[3];
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        ns_data[static_cast<int32_T>(count + static_cast<int32_T>
                            (ns_size_idx_0 << 2))] = tempSamples_data[count];
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        ns_data[static_cast<int32_T>(count + static_cast<int32_T>
                            (ns_size_idx_0 * 5))] = 0.0;
                    }
                }

                if (static_cast<boolean_T>(static_cast<int32_T>
                                           ((transLength_size[0] != 0) &
                                            (transLength_size[1] != 0)))) {
                    if (static_cast<int32_T>(ns_size_idx_0 - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = 0;
                    }

                    if (loop_ub >= 0) {
                        for (count = 0; count < 6; count++) {
                            poses_data[count] = ns_data[static_cast<int32_T>
                                (ns_size_idx_0 * count)];
                        }
                    }

                    if (static_cast<int32_T>(ns_size_idx_0 - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = 0;
                    }

                    if (loop_ub >= 0) {
                        poses_data[0] = ns_data[0];
                    }

                    if (static_cast<int32_T>(ns_size_idx_0 - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = 0;
                    }

                    if (loop_ub >= 0) {
                        poses_data[1] = -ns_data[ns_size_idx_0];
                    }

                    if (static_cast<int32_T>(ns_size_idx_0 - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = 0;
                    }

                    if (loop_ub >= 0) {
                        poses_data[2] = -ns_data[static_cast<int32_T>
                            (ns_size_idx_0 << 1)];
                    }

                    if (static_cast<int32_T>(ns_size_idx_0 - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = 0;
                    }

                    if (loop_ub >= 0) {
                        poses_data[3] = -ns_data[static_cast<int32_T>
                            (ns_size_idx_0 * 3)];
                    }
                }

                for (count = 0; count < 6; count++) {
                    state[count] = ns_data[static_cast<int32_T>
                        (static_cast<int32_T>(static_cast<int32_T>(ns_size_idx_0
                           * count) + ns_size_idx_0) - 1)];
                }
            }

            intermediateLength +=
                tempMotionLength_data[tempMotionLength_data_tmp];
            tempMotionLength_data_tmp = static_cast<int32_T>
                (tempMotionLength_data_tmp + 1);
        }

        FlightMissionMode_emxFree_real_T(&S);
        FlightMissionMode_emxFree_real_T(&p);
        FlightMissionMode_emxFree_real_T(&d_x);
        ns_size_idx_0 = c_x->size[0];
        c_x->size[0] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T(c_x, ns_size_idx_0);
        c_x->data[0] = poses_data[3];
        FlightMissionMode_wrapToPi(c_x);
        loop_ub = c_x->size[0];
        for (count = 0; count <= static_cast<int32_T>(loop_ub - 1); count++) {
            poses_data[3] = c_x->data[count];
        }

        FlightMissionMode_emxFree_real_T(&c_x);
    }
}

void FlightMissionMode::FlightMissionMode_emxInit_int32_T
    (emxArray_int32_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions)
{
    emxArray_int32_T_FlightMissionMode_T *emxArray;
    *pEmxArray = static_cast<emxArray_int32_T_FlightMissionMode_T *>(std::malloc
        (sizeof(emxArray_int32_T_FlightMissionMode_T)));
    emxArray = *pEmxArray;
    emxArray->data = static_cast<int32_T *>(nullptr);
    emxArray->numDimensions = numDimensions;
    emxArray->size = static_cast<int32_T *>(std::malloc(static_cast<uint32_T>
        (sizeof(int32_T) * static_cast<uint32_T>(numDimensions))));
    emxArray->allocatedSize = 0;
    emxArray->canFreeData = true;
    for (int32_T i{0}; i <= static_cast<int32_T>(numDimensions - 1); i++) {
        emxArray->size[i] = 0;
    }
}

void FlightMissionMode::FlightMissionMode_emxEnsureCapacity_int32_T
    (emxArray_int32_T_FlightMissionMode_T *emxArray, int32_T oldNumel)
{
    int32_T i;
    int32_T newNumel;
    void *newData;
    if (oldNumel < 0) {
        oldNumel = 0;
    }

    newNumel = 1;
    for (i = 0; i <= static_cast<int32_T>(emxArray->numDimensions - 1); i++) {
        newNumel = static_cast<int32_T>(newNumel * emxArray->size[i]);
    }

    if (newNumel > emxArray->allocatedSize) {
        i = emxArray->allocatedSize;
        if (i < 16) {
            i = 16;
        }

        while (i < newNumel) {
            if (i > 1073741823) {
                i = MAX_int32_T;
            } else {
                i = static_cast<int32_T>(i << 1);
            }
        }

        newData = std::calloc(static_cast<uint32_T>(i), sizeof(int32_T));
        if (emxArray->data != nullptr) {
            std::memcpy(newData, emxArray->data, static_cast<uint32_T>(sizeof
                         (int32_T) * static_cast<uint32_T>(oldNumel)));
            if (emxArray->canFreeData) {
                std::free(emxArray->data);
            }
        }

        emxArray->data = static_cast<int32_T *>(newData);
        emxArray->allocatedSize = i;
        emxArray->canFreeData = true;
    }
}

void FlightMissionMode::FlightMissionMode_emxFree_int32_T
    (emxArray_int32_T_FlightMissionMode_T **pEmxArray)
{
    if (*pEmxArray != static_cast<emxArray_int32_T_FlightMissionMode_T *>
            (nullptr)) {
        if (((*pEmxArray)->data != static_cast<int32_T *>(nullptr)) &&
                (*pEmxArray)->canFreeData) {
            std::free((*pEmxArray)->data);
        }

        std::free((*pEmxArray)->size);
        std::free(*pEmxArray);
        *pEmxArray = static_cast<emxArray_int32_T_FlightMissionMode_T *>(nullptr);
    }
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_merge_mi
    (emxArray_int32_T_FlightMissionMode_T *idx,
     emxArray_real_T_FlightMissionMode_T *x, int32_T offset, int32_T np, int32_T
     nq, emxArray_int32_T_FlightMissionMode_T *iwork,
     emxArray_real_T_FlightMissionMode_T *xwork)
{
    if (nq != 0) {
        int32_T iout;
        int32_T n;
        int32_T n_tmp;
        int32_T q;
        n_tmp = static_cast<int32_T>(np + nq);
        for (q = 0; q <= static_cast<int32_T>(n_tmp - 1); q =
                static_cast<int32_T>(q + 1)) {
            iout = static_cast<int32_T>(offset + q);
            iwork->data[q] = idx->data[iout];
            xwork->data[q] = x->data[iout];
        }

        n = 0;
        q = np;
        iout = static_cast<int32_T>(offset - 1);
        int32_T exitg1;
        do {
            exitg1 = 0;
            iout = static_cast<int32_T>(iout + 1);
            if (xwork->data[n] <= xwork->data[q]) {
                idx->data[iout] = iwork->data[n];
                x->data[iout] = xwork->data[n];
                if (static_cast<int32_T>(n + 1) < np) {
                    n = static_cast<int32_T>(n + 1);
                } else {
                    exitg1 = 1;
                }
            } else {
                idx->data[iout] = iwork->data[q];
                x->data[iout] = xwork->data[q];
                if (static_cast<int32_T>(q + 1) < n_tmp) {
                    q = static_cast<int32_T>(q + 1);
                } else {
                    q = static_cast<int32_T>(iout - n);
                    while (static_cast<int32_T>(n + 1) <= np) {
                        n_tmp = static_cast<int32_T>(static_cast<int32_T>(q + n)
                            + 1);
                        idx->data[n_tmp] = iwork->data[n];
                        x->data[n_tmp] = xwork->data[n];
                        n = static_cast<int32_T>(n + 1);
                    }

                    exitg1 = 1;
                }
            }
        } while (exitg1 == 0);
    }
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_merge_block
    (emxArray_int32_T_FlightMissionMode_T *idx,
     emxArray_real_T_FlightMissionMode_T *x, int32_T offset, int32_T n, int32_T
     preSortLevel, emxArray_int32_T_FlightMissionMode_T *iwork,
     emxArray_real_T_FlightMissionMode_T *xwork)
{
    int32_T bLen;
    int32_T nPairs;
    nPairs = static_cast<int32_T>(n >> preSortLevel);
    bLen = static_cast<int32_T>(1 << preSortLevel);
    while (nPairs > 1) {
        int32_T nTail;
        int32_T tailOffset;
        if (static_cast<uint32_T>(static_cast<uint32_T>(nPairs) & 1U) != 0U) {
            nPairs = static_cast<int32_T>(nPairs - 1);
            tailOffset = static_cast<int32_T>(bLen * nPairs);
            nTail = static_cast<int32_T>(n - tailOffset);
            if (nTail > bLen) {
                FlightMissionMode_merge_mi(idx, x, static_cast<int32_T>(offset +
                    tailOffset), bLen, static_cast<int32_T>(nTail - bLen), iwork,
                    xwork);
            }
        }

        tailOffset = static_cast<int32_T>(bLen << 1);
        nPairs = static_cast<int32_T>(nPairs >> 1);
        for (nTail = 0; nTail <= static_cast<int32_T>(nPairs - 1); nTail =
                static_cast<int32_T>(nTail + 1)) {
            FlightMissionMode_merge_mi(idx, x, static_cast<int32_T>(offset +
                static_cast<int32_T>(nTail * tailOffset)), bLen, bLen, iwork,
                xwork);
        }

        bLen = tailOffset;
    }

    if (n > bLen) {
        FlightMissionMode_merge_mi(idx, x, offset, bLen, static_cast<int32_T>(n
            - bLen), iwork, xwork);
    }
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_sort_ll
    (emxArray_real_T_FlightMissionMode_T *x)
{
    emxArray_int32_T_FlightMissionMode_T *c;
    emxArray_int32_T_FlightMissionMode_T *idx;
    emxArray_int32_T_FlightMissionMode_T *iwork;
    emxArray_real_T_FlightMissionMode_T *b_x;
    emxArray_real_T_FlightMissionMode_T *d;
    emxArray_real_T_FlightMissionMode_T *f;
    real_T b_xwork[256];
    real_T x4[4];
    int32_T c_iwork[256];
    int32_T idx4[4];
    int32_T c_iwork_tmp;
    int32_T i1;
    int32_T ib;
    int8_T perm[4];
    FlightMissionMode_emxInit_real_T(&b_x, 2);
    FlightMissionMode_emxInit_int32_T(&c, 2);
    FlightMissionMode_emxInit_real_T(&d, 2);
    FlightMissionMode_emxInit_real_T(&f, 1);
    c_iwork_tmp = static_cast<int32_T>(b_x->size[0] * b_x->size[1]);
    b_x->size[0] = 1;
    b_x->size[1] = x->size[1];
    FlightMissionMode_emxEnsureCapacity_real_T(b_x, c_iwork_tmp);
    i1 = static_cast<int32_T>(x->size[1] - 1);
    for (ib = 0; ib <= i1; ib++) {
        b_x->data[ib] = x->data[ib];
    }

    if (x->size[1] != 0) {
        int32_T bLen;
        int32_T bLen2;
        int32_T n;
        int32_T nBlocks;
        int32_T nPairs;
        int32_T q;
        int32_T wOffset;
        FlightMissionMode_emxInit_int32_T(&idx, 2);
        c_iwork_tmp = static_cast<int32_T>(idx->size[0] * idx->size[1]);
        idx->size[0] = 1;
        idx->size[1] = x->size[1];
        FlightMissionMode_emxEnsureCapacity_int32_T(idx, c_iwork_tmp);
        i1 = static_cast<int32_T>(x->size[1] - 1);
        for (ib = 0; ib <= i1; ib++) {
            idx->data[ib] = 0;
        }

        c_iwork_tmp = static_cast<int32_T>(b_x->size[0] * b_x->size[1]);
        b_x->size[0] = 1;
        b_x->size[1] = x->size[1];
        FlightMissionMode_emxEnsureCapacity_real_T(b_x, c_iwork_tmp);
        i1 = static_cast<int32_T>(x->size[1] - 1);
        for (ib = 0; ib <= i1; ib++) {
            b_x->data[ib] = x->data[ib];
        }

        n = x->size[1];
        x4[0] = 0.0;
        idx4[0] = 0;
        x4[1] = 0.0;
        idx4[1] = 0;
        x4[2] = 0.0;
        idx4[2] = 0;
        x4[3] = 0.0;
        idx4[3] = 0;
        c_iwork_tmp = f->size[0];
        f->size[0] = x->size[1];
        FlightMissionMode_emxEnsureCapacity_real_T(f, c_iwork_tmp);
        nBlocks = f->size[0];
        c_iwork_tmp = f->size[0];
        f->size[0] = nBlocks;
        FlightMissionMode_emxEnsureCapacity_real_T(f, c_iwork_tmp);
        for (ib = 0; ib <= static_cast<int32_T>(nBlocks - 1); ib++) {
            f->data[ib] = 0.0;
        }

        nBlocks = 1;
        ib = 0;
        for (wOffset = 0; wOffset <= static_cast<int32_T>(n - 1); wOffset =
                static_cast<int32_T>(wOffset + 1)) {
            if (std::isnan(b_x->data[wOffset])) {
                q = static_cast<int32_T>(n - nBlocks);
                idx->data[q] = static_cast<int32_T>(wOffset + 1);
                f->data[q] = b_x->data[wOffset];
                nBlocks = static_cast<int32_T>(nBlocks + 1);
            } else {
                ib = static_cast<int32_T>(ib + 1);
                idx4[static_cast<int32_T>(ib - 1)] = static_cast<int32_T>
                    (wOffset + 1);
                x4[static_cast<int32_T>(ib - 1)] = b_x->data[wOffset];
                if (ib == 4) {
                    real_T tmp;
                    real_T tmp_0;
                    ib = static_cast<int32_T>(wOffset - nBlocks);
                    if (x4[0] <= x4[1]) {
                        i1 = 1;
                        bLen = 2;
                    } else {
                        i1 = 2;
                        bLen = 1;
                    }

                    if (x4[2] <= x4[3]) {
                        bLen2 = 3;
                        nPairs = 4;
                    } else {
                        bLen2 = 4;
                        nPairs = 3;
                    }

                    tmp = x4[static_cast<int32_T>(i1 - 1)];
                    tmp_0 = x4[static_cast<int32_T>(bLen2 - 1)];
                    if (tmp <= tmp_0) {
                        tmp = x4[static_cast<int32_T>(bLen - 1)];
                        if (tmp <= tmp_0) {
                            perm[0] = static_cast<int8_T>(i1);
                            perm[1] = static_cast<int8_T>(bLen);
                            perm[2] = static_cast<int8_T>(bLen2);
                            perm[3] = static_cast<int8_T>(nPairs);
                        } else if (tmp <= x4[static_cast<int32_T>(nPairs - 1)])
                        {
                            perm[0] = static_cast<int8_T>(i1);
                            perm[1] = static_cast<int8_T>(bLen2);
                            perm[2] = static_cast<int8_T>(bLen);
                            perm[3] = static_cast<int8_T>(nPairs);
                        } else {
                            perm[0] = static_cast<int8_T>(i1);
                            perm[1] = static_cast<int8_T>(bLen2);
                            perm[2] = static_cast<int8_T>(nPairs);
                            perm[3] = static_cast<int8_T>(bLen);
                        }
                    } else {
                        tmp_0 = x4[static_cast<int32_T>(nPairs - 1)];
                        if (tmp <= tmp_0) {
                            if (x4[static_cast<int32_T>(bLen - 1)] <= tmp_0) {
                                perm[0] = static_cast<int8_T>(bLen2);
                                perm[1] = static_cast<int8_T>(i1);
                                perm[2] = static_cast<int8_T>(bLen);
                                perm[3] = static_cast<int8_T>(nPairs);
                            } else {
                                perm[0] = static_cast<int8_T>(bLen2);
                                perm[1] = static_cast<int8_T>(i1);
                                perm[2] = static_cast<int8_T>(nPairs);
                                perm[3] = static_cast<int8_T>(bLen);
                            }
                        } else {
                            perm[0] = static_cast<int8_T>(bLen2);
                            perm[1] = static_cast<int8_T>(nPairs);
                            perm[2] = static_cast<int8_T>(i1);
                            perm[3] = static_cast<int8_T>(bLen);
                        }
                    }

                    idx->data[static_cast<int32_T>(ib - 2)] = idx4[static_cast<
                        int32_T>(static_cast<int32_T>(perm[0]) - 1)];
                    idx->data[static_cast<int32_T>(ib - 1)] = idx4[static_cast<
                        int32_T>(static_cast<int32_T>(perm[1]) - 1)];
                    idx->data[ib] = idx4[static_cast<int32_T>
                        (static_cast<int32_T>(perm[2]) - 1)];
                    idx->data[static_cast<int32_T>(ib + 1)] = idx4[static_cast<
                        int32_T>(static_cast<int32_T>(perm[3]) - 1)];
                    b_x->data[static_cast<int32_T>(ib - 2)] = x4
                        [static_cast<int32_T>(static_cast<int32_T>(perm[0]) - 1)];
                    b_x->data[static_cast<int32_T>(ib - 1)] = x4
                        [static_cast<int32_T>(static_cast<int32_T>(perm[1]) - 1)];
                    b_x->data[ib] = x4[static_cast<int32_T>(static_cast<int32_T>
                        (perm[2]) - 1)];
                    b_x->data[static_cast<int32_T>(ib + 1)] = x4
                        [static_cast<int32_T>(static_cast<int32_T>(perm[3]) - 1)];
                    ib = 0;
                }
            }
        }

        wOffset = static_cast<int32_T>(x->size[1] - nBlocks);
        if (ib > 0) {
            perm[1] = 0;
            perm[2] = 0;
            perm[3] = 0;
            switch (ib) {
              case 1:
                perm[0] = 1;
                break;

              case 2:
                if (x4[0] <= x4[1]) {
                    perm[0] = 1;
                    perm[1] = 2;
                } else {
                    perm[0] = 2;
                    perm[1] = 1;
                }
                break;

              default:
                if (x4[0] <= x4[1]) {
                    if (x4[1] <= x4[2]) {
                        perm[0] = 1;
                        perm[1] = 2;
                        perm[2] = 3;
                    } else if (x4[0] <= x4[2]) {
                        perm[0] = 1;
                        perm[1] = 3;
                        perm[2] = 2;
                    } else {
                        perm[0] = 3;
                        perm[1] = 1;
                        perm[2] = 2;
                    }
                } else if (x4[0] <= x4[2]) {
                    perm[0] = 2;
                    perm[1] = 1;
                    perm[2] = 3;
                } else if (x4[1] <= x4[2]) {
                    perm[0] = 2;
                    perm[1] = 3;
                    perm[2] = 1;
                } else {
                    perm[0] = 3;
                    perm[1] = 2;
                    perm[2] = 1;
                }
                break;
            }

            for (i1 = 0; i1 <= static_cast<int32_T>(ib - 1); i1 =
                    static_cast<int32_T>(i1 + 1)) {
                q = static_cast<int32_T>(static_cast<int32_T>(perm[i1]) - 1);
                c_iwork_tmp = static_cast<int32_T>(static_cast<int32_T>(
                    static_cast<int32_T>(wOffset - ib) + i1) + 1);
                idx->data[c_iwork_tmp] = idx4[q];
                b_x->data[c_iwork_tmp] = x4[q];
            }
        }

        ib = static_cast<int32_T>(static_cast<int32_T>(static_cast<int32_T>
            (nBlocks - 1) >> 1) + 1);
        for (i1 = 1; static_cast<int32_T>(i1 - 1) <= static_cast<int32_T>(ib - 2);
             i1 = static_cast<int32_T>(i1 + 1)) {
            bLen2 = static_cast<int32_T>(wOffset + i1);
            bLen = idx->data[bLen2];
            q = static_cast<int32_T>(n - i1);
            idx->data[bLen2] = idx->data[q];
            idx->data[q] = bLen;
            b_x->data[bLen2] = f->data[q];
            b_x->data[q] = f->data[bLen2];
        }

        if (static_cast<uint32_T>(static_cast<uint32_T>(static_cast<int32_T>
                (nBlocks - 1)) & 1U) != 0U) {
            n = static_cast<int32_T>(wOffset + ib);
            b_x->data[n] = f->data[n];
        }

        FlightMissionMode_emxInit_int32_T(&iwork, 1);
        c_iwork_tmp = iwork->size[0];
        iwork->size[0] = x->size[1];
        FlightMissionMode_emxEnsureCapacity_int32_T(iwork, c_iwork_tmp);
        i1 = x->size[1];
        for (ib = 0; ib <= static_cast<int32_T>(i1 - 1); ib++) {
            iwork->data[ib] = 0;
        }

        n = static_cast<int32_T>(static_cast<int32_T>(x->size[1] - nBlocks) + 1);
        wOffset = 2;
        if (n > 1) {
            if (x->size[1] >= 256) {
                nBlocks = static_cast<int32_T>(n >> 8);
                if (nBlocks > 0) {
                    for (ib = 0; ib <= static_cast<int32_T>(nBlocks - 1); ib =
                            static_cast<int32_T>(ib + 1)) {
                        i1 = static_cast<int32_T>(static_cast<int32_T>(ib << 8)
                            - 1);
                        for (wOffset = 0; wOffset < 6; wOffset++) {
                            bLen = static_cast<int32_T>(1 << static_cast<int32_T>
                                (wOffset + 2));
                            bLen2 = static_cast<int32_T>(bLen << 1);
                            nPairs = static_cast<int32_T>(256 >>
                                static_cast<int32_T>(wOffset + 3));
                            for (int32_T d_k{0}; d_k <= static_cast<int32_T>
                                    (nPairs - 1); d_k = static_cast<int32_T>(d_k
                                  + 1)) {
                                int32_T blockOffset;
                                int32_T p;
                                blockOffset = static_cast<int32_T>
                                    (static_cast<int32_T>(d_k * bLen2) + i1);
                                for (p = 0; p <= static_cast<int32_T>(bLen2 - 1);
                                     p = static_cast<int32_T>(p + 1)) {
                                    c_iwork_tmp = static_cast<int32_T>(
                                        static_cast<int32_T>(blockOffset + p) +
                                        1);
                                    c_iwork[p] = idx->data[c_iwork_tmp];
                                    b_xwork[p] = b_x->data[c_iwork_tmp];
                                }

                                p = 0;
                                q = bLen;
                                int32_T exitg1;
                                do {
                                    exitg1 = 0;
                                    blockOffset = static_cast<int32_T>
                                        (blockOffset + 1);
                                    if (b_xwork[p] <= b_xwork[q]) {
                                        idx->data[blockOffset] = c_iwork[p];
                                        b_x->data[blockOffset] = b_xwork[p];
                                        if (static_cast<int32_T>(p + 1) < bLen)
                                        {
                                            p = static_cast<int32_T>(p + 1);
                                        } else {
                                            exitg1 = 1;
                                        }
                                    } else {
                                        idx->data[blockOffset] = c_iwork[q];
                                        b_x->data[blockOffset] = b_xwork[q];
                                        if (static_cast<int32_T>(q + 1) < bLen2)
                                        {
                                            q = static_cast<int32_T>(q + 1);
                                        } else {
                                            blockOffset = static_cast<int32_T>
                                                (blockOffset - p);
                                            while (static_cast<int32_T>(p + 1) <=
                                                   bLen) {
                                                c_iwork_tmp =
                                                    static_cast<int32_T>(
                                                    static_cast<int32_T>
                                                    (blockOffset + p) + 1);
                                                idx->data[c_iwork_tmp] =
                                                    c_iwork[p];
                                                b_x->data[c_iwork_tmp] =
                                                    b_xwork[p];
                                                p = static_cast<int32_T>(p + 1);
                                            }

                                            exitg1 = 1;
                                        }
                                    }
                                } while (exitg1 == 0);
                            }
                        }
                    }

                    nBlocks = static_cast<int32_T>(nBlocks << 8);
                    wOffset = static_cast<int32_T>(n - nBlocks);
                    if (wOffset > 0) {
                        c_iwork_tmp = static_cast<int32_T>(c->size[0] * c->size
                            [1]);
                        c->size[0] = 1;
                        c->size[1] = idx->size[1];
                        FlightMissionMode_emxEnsureCapacity_int32_T(c,
                            c_iwork_tmp);
                        i1 = static_cast<int32_T>(idx->size[1] - 1);
                        for (ib = 0; ib <= i1; ib++) {
                            c->data[ib] = idx->data[ib];
                        }

                        c_iwork_tmp = static_cast<int32_T>(d->size[0] * d->size
                            [1]);
                        d->size[0] = 1;
                        d->size[1] = b_x->size[1];
                        FlightMissionMode_emxEnsureCapacity_real_T(d,
                            c_iwork_tmp);
                        i1 = static_cast<int32_T>(b_x->size[1] - 1);
                        for (ib = 0; ib <= i1; ib++) {
                            d->data[ib] = b_x->data[ib];
                        }

                        c_iwork_tmp = iwork->size[0];
                        iwork->size[0] = x->size[1];
                        FlightMissionMode_emxEnsureCapacity_int32_T(iwork,
                            c_iwork_tmp);
                        i1 = x->size[1];
                        for (ib = 0; ib <= static_cast<int32_T>(i1 - 1); ib++) {
                            iwork->data[ib] = 0;
                        }

                        FlightMissionMode_merge_block(c, d, nBlocks, wOffset, 2,
                            iwork, f);
                        c_iwork_tmp = static_cast<int32_T>(b_x->size[0] *
                            b_x->size[1]);
                        b_x->size[0] = 1;
                        b_x->size[1] = d->size[1];
                        FlightMissionMode_emxEnsureCapacity_real_T(b_x,
                            c_iwork_tmp);
                        i1 = static_cast<int32_T>(d->size[1] - 1);
                        for (ib = 0; ib <= i1; ib++) {
                            b_x->data[ib] = d->data[ib];
                        }

                        c_iwork_tmp = static_cast<int32_T>(idx->size[0] *
                            idx->size[1]);
                        idx->size[0] = 1;
                        idx->size[1] = c->size[1];
                        FlightMissionMode_emxEnsureCapacity_int32_T(idx,
                            c_iwork_tmp);
                        i1 = static_cast<int32_T>(c->size[1] - 1);
                        for (ib = 0; ib <= i1; ib++) {
                            idx->data[ib] = c->data[ib];
                        }
                    }

                    wOffset = 8;
                }
            }

            c_iwork_tmp = static_cast<int32_T>(c->size[0] * c->size[1]);
            c->size[0] = 1;
            c->size[1] = idx->size[1];
            FlightMissionMode_emxEnsureCapacity_int32_T(c, c_iwork_tmp);
            i1 = static_cast<int32_T>(idx->size[1] - 1);
            for (ib = 0; ib <= i1; ib++) {
                c->data[ib] = idx->data[ib];
            }

            c_iwork_tmp = static_cast<int32_T>(d->size[0] * d->size[1]);
            d->size[0] = 1;
            d->size[1] = b_x->size[1];
            FlightMissionMode_emxEnsureCapacity_real_T(d, c_iwork_tmp);
            i1 = static_cast<int32_T>(b_x->size[1] - 1);
            for (ib = 0; ib <= i1; ib++) {
                d->data[ib] = b_x->data[ib];
            }

            FlightMissionMode_merge_block(c, d, 0, n, wOffset, iwork, f);
            c_iwork_tmp = static_cast<int32_T>(b_x->size[0] * b_x->size[1]);
            b_x->size[0] = 1;
            b_x->size[1] = d->size[1];
            FlightMissionMode_emxEnsureCapacity_real_T(b_x, c_iwork_tmp);
            i1 = static_cast<int32_T>(d->size[1] - 1);
            for (ib = 0; ib <= i1; ib++) {
                b_x->data[ib] = d->data[ib];
            }
        }

        FlightMissionMode_emxFree_int32_T(&idx);
        FlightMissionMode_emxFree_int32_T(&iwork);
    }

    c_iwork_tmp = static_cast<int32_T>(x->size[0] * x->size[1]);
    x->size[0] = 1;
    x->size[1] = b_x->size[1];
    FlightMissionMode_emxEnsureCapacity_real_T(x, c_iwork_tmp);
    i1 = b_x->size[1];
    for (ib = 0; ib <= static_cast<int32_T>(i1 - 1); ib++) {
        x->data[ib] = b_x->data[ib];
    }

    FlightMissionMode_emxFree_real_T(&b_x);
    FlightMissionMode_emxFree_real_T(&f);
    FlightMissionMode_emxFree_real_T(&d);
    FlightMissionMode_emxFree_int32_T(&c);
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_eml_find_n(const
    emxArray_boolean_T_FlightMissionMode_T *x,
    emxArray_int32_T_FlightMissionMode_T *i)
{
    int32_T idx;
    int32_T ii;
    int32_T nx;
    boolean_T exitg1;
    nx = x->size[1];
    idx = 0;
    ii = static_cast<int32_T>(i->size[0] * i->size[1]);
    i->size[0] = 1;
    i->size[1] = x->size[1];
    FlightMissionMode_emxEnsureCapacity_int32_T(i, ii);
    ii = 0;
    exitg1 = false;
    while ((!exitg1) && (ii <= static_cast<int32_T>(nx - 1))) {
        if (x->data[ii]) {
            idx = static_cast<int32_T>(idx + 1);
            i->data[static_cast<int32_T>(idx - 1)] = static_cast<int32_T>(ii + 1);
            if (idx >= nx) {
                exitg1 = true;
            } else {
                ii = static_cast<int32_T>(ii + 1);
            }
        } else {
            ii = static_cast<int32_T>(ii + 1);
        }
    }

    if (x->size[1] == 1) {
        if (idx == 0) {
            i->size[0] = 1;
            i->size[1] = 0;
        }
    } else if (idx < 1) {
        i->size[1] = 0;
    } else {
        ii = static_cast<int32_T>(i->size[0] * i->size[1]);
        i->size[1] = idx;
        FlightMissionMode_emxEnsureCapacity_int32_T(i, ii);
    }
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_uavDubinsPathSegment_interpolate_p(
    const real_T b_this_StartPose[4], const real_T b_this_GoalPose[4], real_T
    b_this_FlightPathAngle, real_T b_this_AirSpeed, real_T
    b_this_MinTurningRadius, real_T b_this_HelixRadius, const
    cell_wrap_0_FlightMissionMode_T b_this_MotionTypes[4], const real_T
    b_this_MotionLengths[4], real_T b_this_Length,
    emxArray_real_T_FlightMissionMode_T *samples,
    emxArray_real_T_FlightMissionMode_T *poses)
{
    emxArray_boolean_T_FlightMissionMode_T *tempSamplesIndex;
    emxArray_boolean_T_FlightMissionMode_T *tempSamplesIndex_0;
    emxArray_int32_T_FlightMissionMode_T *ab;
    emxArray_real_T_FlightMissionMode_T *S;
    emxArray_real_T_FlightMissionMode_T *S_0;
    emxArray_real_T_FlightMissionMode_T *bb;
    emxArray_real_T_FlightMissionMode_T *d_x;
    emxArray_real_T_FlightMissionMode_T *ns;
    emxArray_real_T_FlightMissionMode_T *p;
    emxArray_real_T_FlightMissionMode_T *tempSamples;
    emxArray_real_T_FlightMissionMode_T *z;
    real_T state[6];
    real_T TransformMatrix[4];
    real_T tempMotionLength_data[4];
    real_T transLength_data[4];
    int32_T tempMotionLength_size[2];
    int32_T transLength_size[2];
    boolean_T tmp[4];
    FlightMissionMode_emxInit_real_T(&bb, 1);
    poses->size[0] = 0;
    poses->size[1] = 6;
    if ((static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(std::
            isnan(b_this_Length)) ^ 1))) && (samples->size[1] != 0)) {
        real_T b_b_tmp;
        real_T intermediateLength;
        real_T startIndex;
        real_T tempStartPose_idx_2;
        int32_T loop_ub;
        int32_T poses_0;
        int32_T tempMotionLength_data_tmp;
        tempStartPose_idx_2 = -b_this_StartPose[2];
        tempMotionLength_data_tmp = static_cast<int32_T>(poses->size[0] *
            poses->size[1]);
        poses->size[0] = samples->size[1];
        poses->size[1] = 6;
        FlightMissionMode_emxEnsureCapacity_real_T(poses,
            tempMotionLength_data_tmp);
        loop_ub = static_cast<int32_T>(static_cast<int32_T>(samples->size[1] * 6)
            - 1);
        for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <= loop_ub;
             tempMotionLength_data_tmp++) {
            poses->data[tempMotionLength_data_tmp] = 0.0;
        }

        b_b_tmp = std::cos(std::abs(b_this_FlightPathAngle));
        tempMotionLength_data_tmp = static_cast<int32_T>(samples->size[0] *
            samples->size[1]);
        samples->size[0] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T(samples,
            tempMotionLength_data_tmp);
        loop_ub = static_cast<int32_T>(samples->size[1] - 1);
        for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <= loop_ub;
             tempMotionLength_data_tmp++) {
            samples->data[tempMotionLength_data_tmp] *= b_b_tmp;
        }

        TransformMatrix[0] = b_this_MotionLengths[0] * b_b_tmp;
        TransformMatrix[1] = b_this_MotionLengths[1] * b_b_tmp;
        TransformMatrix[2] = b_this_MotionLengths[2] * b_b_tmp;
        tempMotionLength_size[0] = 1;
        tempMotionLength_size[1] = 4;
        tempMotionLength_data[0] = TransformMatrix[0];
        tempMotionLength_data[1] = TransformMatrix[1];
        tempMotionLength_data[2] = TransformMatrix[2];
        tempMotionLength_data[3] = b_this_MotionLengths[3] * b_b_tmp;
        FlightMissionMode_strcmp_bt4yhx3(b_this_MotionTypes, tmp);
        if (FlightMissionMode_any(tmp)) {
            tempMotionLength_size[0] = 1;
            tempMotionLength_size[1] = 3;
            tempMotionLength_data[0] = TransformMatrix[0];
            tempMotionLength_data[1] = TransformMatrix[1];
            tempMotionLength_data[2] = TransformMatrix[2];
        }

        FlightMissionMode_useConstantDim(tempMotionLength_data,
            tempMotionLength_size, transLength_data, transLength_size);
        FlightMissionMode_sort_ll(samples);
        intermediateLength = 0.0;
        startIndex = 1.0;
        state[0] = b_this_StartPose[0];
        state[1] = -b_this_StartPose[1];
        state[3] = -b_this_StartPose[3];
        poses_0 = 0;
        FlightMissionMode_emxInit_boolean_T(&tempSamplesIndex, 2);
        FlightMissionMode_emxInit_real_T(&tempSamples, 1);
        FlightMissionMode_emxInit_real_T(&S, 1);
        FlightMissionMode_emxInit_real_T(&ns, 2);
        FlightMissionMode_emxInit_real_T(&z, 1);
        FlightMissionMode_emxInit_real_T(&p, 2);
        FlightMissionMode_emxInit_real_T(&d_x, 1);
        FlightMissionMode_emxInit_int32_T(&ab, 2);
        FlightMissionMode_emxInit_boolean_T(&tempSamplesIndex_0, 2);
        FlightMissionMode_emxInit_real_T(&S_0, 2);
        while (poses_0 <= static_cast<int32_T>(tempMotionLength_size[1] - 1)) {
            real_T radius;
            real_T samples_0;
            if (static_cast<int32_T>(poses_0 + 1) == 1) {
                tempMotionLength_data_tmp = static_cast<int32_T>
                    (tempSamplesIndex->size[0] * tempSamplesIndex->size[1]);
                tempSamplesIndex->size[0] = 1;
                tempSamplesIndex->size[1] = samples->size[1];
                FlightMissionMode_emxEnsureCapacity_boolean_T(tempSamplesIndex,
                    tempMotionLength_data_tmp);
                loop_ub = static_cast<int32_T>(samples->size[1] - 1);
                radius = (intermediateLength + tempMotionLength_data[0]) +
                    1.0E-6;
                for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <=
                     loop_ub; tempMotionLength_data_tmp++) {
                    samples_0 = samples->data[tempMotionLength_data_tmp];
                    tempSamplesIndex->data[tempMotionLength_data_tmp] =
                        static_cast<boolean_T>(static_cast<int32_T>((samples_0 >=
                        intermediateLength) & (samples_0 <= radius)));
                }
            } else {
                tempMotionLength_data_tmp = static_cast<int32_T>
                    (tempSamplesIndex->size[0] * tempSamplesIndex->size[1]);
                tempSamplesIndex->size[0] = 1;
                tempSamplesIndex->size[1] = samples->size[1];
                FlightMissionMode_emxEnsureCapacity_boolean_T(tempSamplesIndex,
                    tempMotionLength_data_tmp);
                loop_ub = static_cast<int32_T>(samples->size[1] - 1);
                radius = (intermediateLength + tempMotionLength_data[poses_0]) +
                    1.0E-6;
                for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <=
                     loop_ub; tempMotionLength_data_tmp++) {
                    samples_0 = samples->data[tempMotionLength_data_tmp];
                    tempSamplesIndex->data[tempMotionLength_data_tmp] =
                        static_cast<boolean_T>(static_cast<int32_T>((samples_0 >
                        intermediateLength) & (samples_0 <= radius)));
                }
            }

            tempMotionLength_data_tmp = static_cast<int32_T>
                (tempSamplesIndex_0->size[0] * tempSamplesIndex_0->size[1]);
            tempSamplesIndex_0->size[0] = 1;
            tempSamplesIndex_0->size[1] = tempSamplesIndex->size[1];
            FlightMissionMode_emxEnsureCapacity_boolean_T(tempSamplesIndex_0,
                tempMotionLength_data_tmp);
            loop_ub = tempSamplesIndex->size[1];
            for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <=
                    static_cast<int32_T>(loop_ub - 1); tempMotionLength_data_tmp
                    ++) {
                tempSamplesIndex_0->data[tempMotionLength_data_tmp] =
                    tempSamplesIndex->data[tempMotionLength_data_tmp];
            }

            FlightMissionMode_eml_find_n(tempSamplesIndex_0, ab);
            if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                    (FlightMissionMode_strcmp_bt4yhx33
                     (b_this_MotionTypes[poses_0].f1.data,
                      b_this_MotionTypes[poses_0].f1.size)) ^ 1))) {
                real_T TransformMatrix_tmp;
                int32_T count;
                int32_T tempMotionLength_data_tmp_0;
                radius = b_this_MinTurningRadius;
                if (FlightMissionMode_strcmp_bt4yhx33c
                        (b_this_MotionTypes[poses_0].f1.data,
                         b_this_MotionTypes[poses_0].f1.size)) {
                    radius = b_this_HelixRadius;
                } else if (FlightMissionMode_strcmp_bt4yhx33cu
                           (b_this_MotionTypes[poses_0].f1.data,
                            b_this_MotionTypes[poses_0].f1.size)) {
                    radius = b_this_HelixRadius;
                }

                count = 0;
                tempMotionLength_data_tmp = tempSamples->size[0];
                tempSamples->size[0] = 1;
                FlightMissionMode_emxEnsureCapacity_real_T(tempSamples,
                    tempMotionLength_data_tmp);
                tempSamples->data[0] = 0.0;
                if (ab->size[1] != 0) {
                    tempMotionLength_data_tmp = tempSamples->size[0];
                    tempSamples->size[0] = static_cast<int32_T>(ab->size[1] + 1);
                    FlightMissionMode_emxEnsureCapacity_real_T(tempSamples,
                        tempMotionLength_data_tmp);
                    loop_ub = ab->size[1];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= loop_ub;
                            tempMotionLength_data_tmp++) {
                        tempSamples->data[tempMotionLength_data_tmp] = 0.0;
                    }

                    count = ab->size[1];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (count - 1); tempMotionLength_data_tmp++) {
                        tempSamples->data[tempMotionLength_data_tmp] =
                            samples->data[static_cast<int32_T>(ab->
                            data[tempMotionLength_data_tmp] - 1)];
                    }

                    count = ab->size[1];
                    loop_ub = static_cast<int32_T>(ab->size[1] - 1);
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= loop_ub;
                            tempMotionLength_data_tmp++) {
                        samples->data[static_cast<int32_T>(ab->
                            data[tempMotionLength_data_tmp] - 1)] = -1.0;
                    }
                }

                tempSamples->data[count] = transLength_data[poses_0];
                tempMotionLength_data_tmp = S->size[0];
                S->size[0] = tempSamples->size[0];
                FlightMissionMode_emxEnsureCapacity_real_T(S,
                    tempMotionLength_data_tmp);
                loop_ub = tempSamples->size[0];
                for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <=
                     static_cast<int32_T>(loop_ub - 1);
                        tempMotionLength_data_tmp++) {
                    S->data[tempMotionLength_data_tmp] = (tempSamples->
                        data[tempMotionLength_data_tmp] - intermediateLength) /
                        radius;
                }

                tempMotionLength_data_tmp = static_cast<int32_T>(ns->size[0] *
                    ns->size[1]);
                ns->size[0] = S->size[0];
                ns->size[1] = 6;
                FlightMissionMode_emxEnsureCapacity_real_T(ns,
                    tempMotionLength_data_tmp);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(S->size[0] *
                    6) - 1);
                for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <=
                     loop_ub; tempMotionLength_data_tmp++) {
                    ns->data[tempMotionLength_data_tmp] = 0.0;
                }

                tempMotionLength_data_tmp = z->size[0];
                z->size[0] = tempSamples->size[0];
                FlightMissionMode_emxEnsureCapacity_real_T(z,
                    tempMotionLength_data_tmp);
                loop_ub = tempSamples->size[0];
                for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <=
                     static_cast<int32_T>(loop_ub - 1);
                        tempMotionLength_data_tmp++) {
                    z->data[tempMotionLength_data_tmp] = tempStartPose_idx_2 +
                        tempSamples->data[tempMotionLength_data_tmp];
                }

                samples_0 = std::sin(state[3]);
                TransformMatrix_tmp = std::cos(state[3]);
                TransformMatrix[0] = TransformMatrix_tmp;
                TransformMatrix[2] = samples_0;
                TransformMatrix[1] = -samples_0;
                TransformMatrix[3] = TransformMatrix_tmp;
                if (b_this_Length != 0.0) {
                    samples_0 = -b_this_GoalPose[2] - tempStartPose_idx_2;
                    TransformMatrix_tmp = b_this_Length * b_b_tmp;
                    tempMotionLength_data_tmp = z->size[0];
                    z->size[0] = tempSamples->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T(z,
                        tempMotionLength_data_tmp);
                    loop_ub = tempSamples->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        z->data[tempMotionLength_data_tmp] = tempSamples->
                            data[tempMotionLength_data_tmp] /
                            TransformMatrix_tmp * samples_0 +
                            tempStartPose_idx_2;
                    }
                }

                if (FlightMissionMode_strcmp_bt4yhx33c
                        (b_this_MotionTypes[poses_0].f1.data,
                         b_this_MotionTypes[poses_0].f1.size) ||
                        FlightMissionMode_strcmp_bt4yhx33cua
                        (b_this_MotionTypes[poses_0].f1.data,
                         b_this_MotionTypes[poses_0].f1.size)) {
                    real_T state_0;
                    real_T state_1;
                    tempMotionLength_data_tmp = tempSamples->size[0];
                    tempSamples->size[0] = S->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T(tempSamples,
                        tempMotionLength_data_tmp);
                    loop_ub = S->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        tempSamples->data[tempMotionLength_data_tmp] = S->
                            data[tempMotionLength_data_tmp];
                    }

                    for (count = 0; count <= static_cast<int32_T>(S->size[0] - 1);
                         count = static_cast<int32_T>(count + 1)) {
                        tempSamples->data[count] = std::sin(tempSamples->
                            data[count]);
                    }

                    tempMotionLength_data_tmp = d_x->size[0];
                    d_x->size[0] = S->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T(d_x,
                        tempMotionLength_data_tmp);
                    loop_ub = S->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        d_x->data[tempMotionLength_data_tmp] = S->
                            data[tempMotionLength_data_tmp];
                    }

                    for (count = 0; count <= static_cast<int32_T>(S->size[0] - 1);
                         count = static_cast<int32_T>(count + 1)) {
                        d_x->data[count] = std::cos(d_x->data[count]);
                    }

                    tempMotionLength_data_tmp = static_cast<int32_T>(S_0->size[0]
                        * S_0->size[1]);
                    S_0->size[0] = tempSamples->size[0];
                    S_0->size[1] = 2;
                    FlightMissionMode_emxEnsureCapacity_real_T(S_0,
                        tempMotionLength_data_tmp);
                    loop_ub = tempSamples->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        S_0->data[tempMotionLength_data_tmp] = tempSamples->
                            data[tempMotionLength_data_tmp];
                    }

                    loop_ub = d_x->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        S_0->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + tempSamples->size[0])] = 1.0 - d_x->
                            data[tempMotionLength_data_tmp];
                    }

                    FlightMissionMode_mtimes(S_0, TransformMatrix, p);
                    samples_0 = rt_atan2d_snf(b_this_AirSpeed * b_this_AirSpeed,
                        9.8 * radius);
                    TransformMatrix_tmp = state[0];
                    state_0 = state[1];
                    state_1 = state[3];
                    count = S->size[0];
                    tempMotionLength_data_tmp_0 = S->size[0];
                    loop_ub = p->size[0];
                    tempMotionLength_data_tmp = static_cast<int32_T>(ns->size[0]
                        * ns->size[1]);
                    ns->size[0] = p->size[0];
                    ns->size[1] = 6;
                    FlightMissionMode_emxEnsureCapacity_real_T(ns,
                        tempMotionLength_data_tmp);
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        ns->data[tempMotionLength_data_tmp] = p->
                            data[tempMotionLength_data_tmp] * radius +
                            TransformMatrix_tmp;
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + ns->size[0])] = p->data[static_cast<int32_T>
                            (tempMotionLength_data_tmp + p->size[0])] * radius +
                            state_0;
                    }

                    loop_ub = z->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] << 1))] = z->
                            data[tempMotionLength_data_tmp];
                    }

                    loop_ub = S->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] * 3))] = state_1
                            + S->data[tempMotionLength_data_tmp];
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (count - 1); tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] << 2))] =
                            b_this_FlightPathAngle;
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (tempMotionLength_data_tmp_0 - 1);
                            tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] * 5))] =
                            -samples_0;
                    }
                } else if (FlightMissionMode_strcmp_bt4yhx33cu
                           (b_this_MotionTypes[poses_0].f1.data,
                            b_this_MotionTypes[poses_0].f1.size) ||
                           FlightMissionMode_strcmp_bt4yhx33cuar
                           (b_this_MotionTypes[poses_0].f1.data,
                            b_this_MotionTypes[poses_0].f1.size)) {
                    real_T state_0;
                    real_T state_1;
                    tempMotionLength_data_tmp = tempSamples->size[0];
                    tempSamples->size[0] = S->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T(tempSamples,
                        tempMotionLength_data_tmp);
                    loop_ub = S->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        tempSamples->data[tempMotionLength_data_tmp] = S->
                            data[tempMotionLength_data_tmp];
                    }

                    for (count = 0; count <= static_cast<int32_T>(S->size[0] - 1);
                         count = static_cast<int32_T>(count + 1)) {
                        tempSamples->data[count] = std::sin(tempSamples->
                            data[count]);
                    }

                    tempMotionLength_data_tmp = d_x->size[0];
                    d_x->size[0] = S->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T(d_x,
                        tempMotionLength_data_tmp);
                    loop_ub = S->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        d_x->data[tempMotionLength_data_tmp] = S->
                            data[tempMotionLength_data_tmp];
                    }

                    for (count = 0; count <= static_cast<int32_T>(S->size[0] - 1);
                         count = static_cast<int32_T>(count + 1)) {
                        d_x->data[count] = std::cos(d_x->data[count]);
                    }

                    tempMotionLength_data_tmp = static_cast<int32_T>(S_0->size[0]
                        * S_0->size[1]);
                    S_0->size[0] = tempSamples->size[0];
                    S_0->size[1] = 2;
                    FlightMissionMode_emxEnsureCapacity_real_T(S_0,
                        tempMotionLength_data_tmp);
                    loop_ub = tempSamples->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        S_0->data[tempMotionLength_data_tmp] = tempSamples->
                            data[tempMotionLength_data_tmp];
                    }

                    loop_ub = d_x->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        S_0->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + tempSamples->size[0])] = d_x->
                            data[tempMotionLength_data_tmp] - 1.0;
                    }

                    FlightMissionMode_mtimes(S_0, TransformMatrix, p);
                    samples_0 = rt_atan2d_snf(b_this_AirSpeed * b_this_AirSpeed,
                        9.8 * radius);
                    TransformMatrix_tmp = state[0];
                    state_0 = state[1];
                    state_1 = state[3];
                    count = S->size[0];
                    tempMotionLength_data_tmp_0 = S->size[0];
                    loop_ub = p->size[0];
                    tempMotionLength_data_tmp = static_cast<int32_T>(ns->size[0]
                        * ns->size[1]);
                    ns->size[0] = p->size[0];
                    ns->size[1] = 6;
                    FlightMissionMode_emxEnsureCapacity_real_T(ns,
                        tempMotionLength_data_tmp);
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        ns->data[tempMotionLength_data_tmp] = p->
                            data[tempMotionLength_data_tmp] * radius +
                            TransformMatrix_tmp;
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + ns->size[0])] = p->data[static_cast<int32_T>
                            (tempMotionLength_data_tmp + p->size[0])] * radius +
                            state_0;
                    }

                    loop_ub = z->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] << 1))] = z->
                            data[tempMotionLength_data_tmp];
                    }

                    loop_ub = S->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] * 3))] = state_1
                            - S->data[tempMotionLength_data_tmp];
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (count - 1); tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] << 2))] =
                            b_this_FlightPathAngle;
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (tempMotionLength_data_tmp_0 - 1);
                            tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] * 5))] =
                            samples_0;
                    }
                } else if (FlightMissionMode_strcmp_bt4yhx33cuary
                           (b_this_MotionTypes[poses_0].f1.data,
                            b_this_MotionTypes[poses_0].f1.size)) {
                    real_T state_0;
                    int32_T S_idx_0;
                    count = S->size[0];
                    tempMotionLength_data_tmp = static_cast<int32_T>(S_0->size[0]
                        * S_0->size[1]);
                    S_0->size[0] = S->size[0];
                    S_0->size[1] = 2;
                    FlightMissionMode_emxEnsureCapacity_real_T(S_0,
                        tempMotionLength_data_tmp);
                    loop_ub = S->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        S_0->data[tempMotionLength_data_tmp] = S->
                            data[tempMotionLength_data_tmp];
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (count - 1); tempMotionLength_data_tmp++) {
                        S_0->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + S->size[0])] = 0.0;
                    }

                    FlightMissionMode_mtimes(S_0, TransformMatrix, p);
                    TransformMatrix_tmp = state[0];
                    state_0 = state[1];
                    count = S->size[0];
                    tempMotionLength_data_tmp_0 = S->size[0];
                    S_idx_0 = S->size[0];
                    loop_ub = p->size[0];
                    tempMotionLength_data_tmp = static_cast<int32_T>(ns->size[0]
                        * ns->size[1]);
                    ns->size[0] = p->size[0];
                    ns->size[1] = 6;
                    FlightMissionMode_emxEnsureCapacity_real_T(ns,
                        tempMotionLength_data_tmp);
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        ns->data[tempMotionLength_data_tmp] = p->
                            data[tempMotionLength_data_tmp] * radius +
                            TransformMatrix_tmp;
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + ns->size[0])] = p->data[static_cast<int32_T>
                            (tempMotionLength_data_tmp + p->size[0])] * radius +
                            state_0;
                    }

                    loop_ub = z->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] << 1))] = z->
                            data[tempMotionLength_data_tmp];
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (count - 1); tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] * 3))] = state[3];
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (tempMotionLength_data_tmp_0 - 1);
                            tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] << 2))] =
                            b_this_FlightPathAngle;
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (S_idx_0 - 1); tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] * 5))] = 0.0;
                    }
                }

                if (ab->size[1] != 0) {
                    if (startIndex > (startIndex + static_cast<real_T>(ab->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp < 6;
                            tempMotionLength_data_tmp++) {
                        for (tempMotionLength_data_tmp_0 = 0;
                                tempMotionLength_data_tmp_0 <= loop_ub;
                                tempMotionLength_data_tmp_0++) {
                            poses->data[static_cast<int32_T>(static_cast<int32_T>
                                (static_cast<int32_T>(count +
                                tempMotionLength_data_tmp_0) +
                                 static_cast<int32_T>(poses->size[0] *
                                tempMotionLength_data_tmp)) - 1)] = ns->data[
                                static_cast<int32_T>(static_cast<int32_T>
                                (ns->size[0] * tempMotionLength_data_tmp) +
                                tempMotionLength_data_tmp_0)];
                        }
                    }

                    if (startIndex > (startIndex + static_cast<real_T>(ab->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= loop_ub;
                            tempMotionLength_data_tmp++) {
                        poses->data[static_cast<int32_T>(static_cast<int32_T>
                            (count + tempMotionLength_data_tmp) - 1)] = ns->
                            data[tempMotionLength_data_tmp];
                    }

                    if (startIndex > (startIndex + static_cast<real_T>(ab->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= loop_ub;
                            tempMotionLength_data_tmp++) {
                        poses->data[static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>(count +
                            tempMotionLength_data_tmp) + poses->size[0]) - 1)] =
                            -ns->data[static_cast<int32_T>
                            (tempMotionLength_data_tmp + ns->size[0])];
                    }

                    if (startIndex > (startIndex + static_cast<real_T>(ab->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= loop_ub;
                            tempMotionLength_data_tmp++) {
                        poses->data[static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>(count +
                            tempMotionLength_data_tmp) + static_cast<int32_T>
                            (poses->size[0] << 1)) - 1)] = -ns->data[
                            static_cast<int32_T>(static_cast<int32_T>(ns->size[0]
                            << 1) + tempMotionLength_data_tmp)];
                    }

                    if (startIndex > (startIndex + static_cast<real_T>(ab->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= loop_ub;
                            tempMotionLength_data_tmp++) {
                        poses->data[static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>(count +
                            tempMotionLength_data_tmp) + static_cast<int32_T>
                            (poses->size[0] * 3)) - 1)] = -ns->data[static_cast<
                            int32_T>(static_cast<int32_T>(ns->size[0] * 3) +
                                     tempMotionLength_data_tmp)];
                    }
                }

                count = ns->size[0];
                for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <
                        6; tempMotionLength_data_tmp++) {
                    state[tempMotionLength_data_tmp] = ns->data
                        [static_cast<int32_T>(static_cast<int32_T>
                        (static_cast<int32_T>(ns->size[0] *
                        tempMotionLength_data_tmp) + count) - 1)];
                }

                startIndex += static_cast<real_T>(ab->size[1]);
            }

            intermediateLength += tempMotionLength_data[poses_0];
            poses_0 = static_cast<int32_T>(poses_0 + 1);
        }

        FlightMissionMode_emxFree_real_T(&S_0);
        FlightMissionMode_emxFree_boolean_T(&tempSamplesIndex_0);
        FlightMissionMode_emxFree_int32_T(&ab);
        FlightMissionMode_emxFree_real_T(&d_x);
        FlightMissionMode_emxFree_real_T(&p);
        FlightMissionMode_emxFree_real_T(&z);
        FlightMissionMode_emxFree_real_T(&ns);
        FlightMissionMode_emxFree_real_T(&S);
        FlightMissionMode_emxFree_real_T(&tempSamples);
        FlightMissionMode_emxFree_boolean_T(&tempSamplesIndex);
        loop_ub = poses->size[0];
        tempMotionLength_data_tmp = bb->size[0];
        bb->size[0] = poses->size[0];
        FlightMissionMode_emxEnsureCapacity_real_T(bb, tempMotionLength_data_tmp);
        for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <=
                static_cast<int32_T>(loop_ub - 1); tempMotionLength_data_tmp++)
        {
            bb->data[tempMotionLength_data_tmp] = poses->data
                [static_cast<int32_T>(static_cast<int32_T>(poses->size[0] * 3) +
                tempMotionLength_data_tmp)];
        }

        FlightMissionMode_wrapToPi(bb);
        loop_ub = bb->size[0];
        for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <=
                static_cast<int32_T>(loop_ub - 1); tempMotionLength_data_tmp++)
        {
            poses->data[static_cast<int32_T>(tempMotionLength_data_tmp +
                static_cast<int32_T>(poses->size[0] * 3))] = bb->
                data[tempMotionLength_data_tmp];
        }
    }

    FlightMissionMode_emxFree_real_T(&bb);
}

// Function for MATLAB Function: '<S96>/StartPointGenerator'
void FlightMissionMode::FlightMissionMode_genSegWP(const real_T start[4], const
    real_T ende[4], emxArray_real_T_FlightMissionMode_T *segWayPoints,
    DW_StartPointGenerator_FlightMissionMode_T *localDW)
{
    emxArray_real_T_FlightMissionMode_T *lengths;
    emxArray_real_T_FlightMissionMode_T *poses;
    uavDubinsPathSegment_FlightMissionMode_T pathSegObj;
    real_T a__1;
    int32_T n;
    int32_T nm1d2;
    FlightMissionMode_uavDubinsConnection_connect
        (FlightMissionMode_DubinsObjSingleton_getConnector(localDW), start, ende,
         &pathSegObj, &a__1);
    a__1 = pathSegObj.Length / 128.0;
    FlightMissionMode_emxInit_real_T(&lengths, 2);
    if (std::isnan(a__1)) {
        nm1d2 = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        lengths->size[1] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T(lengths, nm1d2);
        lengths->data[0] = (rtNaN);
    } else if (std::isnan(pathSegObj.Length)) {
        nm1d2 = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        lengths->size[1] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T(lengths, nm1d2);
        lengths->data[0] = (rtNaN);
    } else if (a__1 == 0.0) {
        lengths->size[0] = 1;
        lengths->size[1] = 0;
    } else if ((pathSegObj.Length > 0.0) && (a__1 < 0.0)) {
        lengths->size[0] = 1;
        lengths->size[1] = 0;
    } else if ((pathSegObj.Length < 0.0) && (a__1 > 0.0)) {
        lengths->size[0] = 1;
        lengths->size[1] = 0;
    } else if (std::isinf(pathSegObj.Length) && std::isinf(a__1)) {
        nm1d2 = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        lengths->size[1] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T(lengths, nm1d2);
        lengths->data[0] = (rtNaN);
    } else if (std::isinf(a__1)) {
        nm1d2 = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        lengths->size[1] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T(lengths, nm1d2);
        lengths->data[0] = 0.0;
    } else if (std::floor(a__1) == a__1) {
        nm1d2 = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        n = static_cast<int32_T>(pathSegObj.Length / a__1);
        lengths->size[1] = static_cast<int32_T>(n + 1);
        FlightMissionMode_emxEnsureCapacity_real_T(lengths, nm1d2);
        for (nm1d2 = 0; nm1d2 <= n; nm1d2++) {
            lengths->data[nm1d2] = a__1 * static_cast<real_T>(nm1d2);
        }
    } else {
        real_T apnd;
        real_T cdiff;
        real_T ndbl;
        ndbl = std::floor(pathSegObj.Length / a__1 + 0.5);
        apnd = ndbl * a__1;
        if (a__1 > 0.0) {
            cdiff = apnd - pathSegObj.Length;
        } else {
            cdiff = pathSegObj.Length - apnd;
        }

        if (std::abs(cdiff) < 4.4408920985006262E-16 * std::fmax(0.0, std::abs
                (pathSegObj.Length))) {
            ndbl++;
            apnd = pathSegObj.Length;
        } else if (cdiff > 0.0) {
            apnd = (ndbl - 1.0) * a__1;
        } else {
            ndbl++;
        }

        if (ndbl >= 0.0) {
            n = static_cast<int32_T>(static_cast<int32_T>(ndbl) - 1);
        } else {
            n = -1;
        }

        nm1d2 = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        lengths->size[1] = static_cast<int32_T>(n + 1);
        FlightMissionMode_emxEnsureCapacity_real_T(lengths, nm1d2);
        if (static_cast<int32_T>(n + 1) > 0) {
            lengths->data[0] = 0.0;
            if (static_cast<int32_T>(n + 1) > 1) {
                lengths->data[n] = apnd;
                nm1d2 = static_cast<int32_T>(n / 2);
                for (int32_T k{1}; static_cast<int32_T>(k - 1) <=
                        static_cast<int32_T>(nm1d2 - 2); k = static_cast<int32_T>
                        (k + 1)) {
                    ndbl = static_cast<real_T>(k) * a__1;
                    lengths->data[k] = ndbl;
                    lengths->data[static_cast<int32_T>(n - k)] = apnd - ndbl;
                }

                if (static_cast<int32_T>(nm1d2 << 1) == n) {
                    lengths->data[nm1d2] = apnd / 2.0;
                } else {
                    ndbl = static_cast<real_T>(nm1d2) * a__1;
                    lengths->data[nm1d2] = ndbl;
                    lengths->data[static_cast<int32_T>(nm1d2 + 1)] = apnd - ndbl;
                }
            }
        }
    }

    FlightMissionMode_emxInit_real_T(&poses, 2);
    FlightMissionMode_uavDubinsPathSegment_interpolate_p(pathSegObj.StartPose,
        pathSegObj.GoalPose, pathSegObj.FlightPathAngle, pathSegObj.AirSpeed,
        pathSegObj.MinTurningRadius, pathSegObj.HelixRadius,
        pathSegObj.MotionTypes, pathSegObj.MotionLengths, pathSegObj.Length,
        lengths, poses);
    n = poses->size[0];
    nm1d2 = static_cast<int32_T>(segWayPoints->size[0] * segWayPoints->size[1]);
    segWayPoints->size[0] = poses->size[0];
    segWayPoints->size[1] = 3;
    FlightMissionMode_emxEnsureCapacity_real_T(segWayPoints, nm1d2);
    FlightMissionMode_emxFree_real_T(&lengths);
    for (nm1d2 = 0; nm1d2 < 3; nm1d2++) {
        for (int32_T k{0}; k <= static_cast<int32_T>(n - 1); k++) {
            segWayPoints->data[static_cast<int32_T>(k + static_cast<int32_T>
                (segWayPoints->size[0] * nm1d2))] = poses->data
                [static_cast<int32_T>(static_cast<int32_T>(poses->size[0] *
                nm1d2) + k)];
        }
    }

    FlightMissionMode_emxFree_real_T(&poses);
}

//
// System initialize for atomic system:
//    '<S96>/StartPointGenerator'
//    '<S138>/StartPointGenerator'
//
void FlightMissionMode::FlightMissionMode_StartPointGenerator_Init
    (DW_StartPointGenerator_FlightMissionMode_T *localDW)
{
    FILE* a;
    a = NULL;
    for (int32_T i{0}; i < 20; i++) {
        localDW->eml_openfiles[i] = a;
    }
}

//
// System reset for atomic system:
//    '<S96>/StartPointGenerator'
//    '<S138>/StartPointGenerator'
//
void FlightMissionMode::FlightMissionMode_StartPointGenerator_Reset
    (DW_StartPointGenerator_FlightMissionMode_T *localDW)
{
    FILE* a;
    localDW->SingletonInstance_not_empty = false;
    a = NULL;
    for (int32_T i{0}; i < 20; i++) {
        localDW->eml_openfiles[i] = a;
    }
}

//
// Output and update for atomic system:
//    '<S96>/StartPointGenerator'
//    '<S138>/StartPointGenerator'
//
void FlightMissionMode::FlightMissionMode_StartPointGenerator(real_T rtu_Length,
    real_T rtu_RunWayUAV, real_T rtu_PosIDX, real_T rty_initWayPoint[384],
    real_T rty_startPose[5], DW_StartPointGenerator_FlightMissionMode_T *localDW)
{
    static const int8_T b[5]{ 0, 1, 2, 3, 5 };

    emxArray_real_T_FlightMissionMode_T *c;
    emxArray_real_T_FlightMissionMode_T *dummyinitWP;
    uavDubinsPathSegment_FlightMissionMode_T pathSegObj;
    real_T midpose_data[6];
    real_T LUp_0[5];
    real_T tmp[5];
    real_T LDp[4];
    real_T LUp[4];
    real_T InterUAVLength;
    real_T PosIDX;
    int32_T midpose_size[2];
    int32_T i;
    int32_T loop_ub;

    // MATLAB Function 'StartPointGenerator': '<S126>:1'
    // '<S126>:1:4'
    LUp[0] = 0.0;
    LUp[1] = rtu_Length / 2.0;
    LUp[2] = 0.0;
    LUp[3] = 1.5707963267948966;

    // '<S126>:1:5'
    LDp[0] = 0.0;
    LDp[1] = -rtu_Length / 2.0;
    LDp[2] = 0.0;
    LDp[3] = 1.5707963267948966;

    // '<S126>:1:7'
    FlightMissionMode_uavDubinsConnection_connect
        (FlightMissionMode_DubinsObjSingleton_getConnector(localDW), LUp, LDp,
         &pathSegObj, &InterUAVLength);

    // '<S126>:1:8'
    // '<S126>:1:10'
    InterUAVLength = (pathSegObj.Length + rtu_Length) / rtu_RunWayUAV;

    // '<S126>:1:13'
    // '<S126>:1:14'
    // '<S126>:1:17'
    PosIDX = (rtu_PosIDX - ((rtu_RunWayUAV - std::floor(pathSegObj.Length /
                 InterUAVLength)) - 1.0)) - 1.0;

    // '<S126>:1:21'
    FlightMissionMode_emxInit_real_T(&dummyinitWP, 2);
    FlightMissionMode_emxInit_real_T(&c, 2);
    if (PosIDX > 0.0) {
        // '<S126>:1:24'
        // '<S126>:1:26'
        FlightMissionMode_uavDubinsPathSegment_interpolate(pathSegObj.StartPose,
            pathSegObj.GoalPose, pathSegObj.FlightPathAngle, pathSegObj.AirSpeed,
            pathSegObj.MinTurningRadius, pathSegObj.HelixRadius,
            pathSegObj.MotionTypes, pathSegObj.MotionLengths, pathSegObj.Length,
            InterUAVLength * PosIDX, midpose_data, midpose_size);

        // '<S126>:1:27'
        for (i = 0; i < 5; i++) {
            rty_startPose[i] = midpose_data[static_cast<int32_T>(midpose_size[0]
                * static_cast<int32_T>(b[i]))];
        }

        // '<S126>:1:28'
        LUp[0] = midpose_data[0];
        LUp[1] = midpose_data[midpose_size[0]];
        LUp[2] = midpose_data[static_cast<int32_T>(midpose_size[0] << 1)];
        LUp[3] = midpose_data[static_cast<int32_T>(midpose_size[0] * 3)];
        FlightMissionMode_genSegWP(LUp, LDp, c, localDW);
        i = static_cast<int32_T>(dummyinitWP->size[0] * dummyinitWP->size[1]);
        dummyinitWP->size[0] = static_cast<int32_T>(c->size[0] + 1);
        dummyinitWP->size[1] = 3;
        FlightMissionMode_emxEnsureCapacity_real_T(dummyinitWP, i);
        loop_ub = c->size[0];
        for (i = 0; i < 3; i++) {
            dummyinitWP->data[static_cast<int32_T>(dummyinitWP->size[0] * i)] =
                0.0;
            for (int32_T i_0{0}; i_0 <= static_cast<int32_T>(loop_ub - 1); i_0++)
            {
                dummyinitWP->data[static_cast<int32_T>(static_cast<int32_T>(i_0
                    + static_cast<int32_T>(dummyinitWP->size[0] * i)) + 1)] =
                    c->data[static_cast<int32_T>(static_cast<int32_T>(c->size[0]
                    * i) + i_0)];
            }
        }
    } else {
        // '<S126>:1:31'
        LUp_0[0] = 0.0;
        LUp_0[1] = LUp[1];
        LUp_0[2] = 0.0;
        LUp_0[3] = 1.5707963267948966;
        LUp_0[4] = 0.0;
        tmp[0] = 0.0;
        tmp[1] = PosIDX * InterUAVLength;
        tmp[2] = 0.0;
        tmp[3] = 0.0;
        tmp[4] = 0.0;
        for (i = 0; i < 5; i++) {
            rty_startPose[i] = LUp_0[i] + tmp[i];
        }

        // '<S126>:1:32'
        FlightMissionMode_genSegWP(LUp, LDp, c, localDW);
        i = static_cast<int32_T>(dummyinitWP->size[0] * dummyinitWP->size[1]);
        dummyinitWP->size[0] = static_cast<int32_T>(c->size[0] + 1);
        dummyinitWP->size[1] = 3;
        FlightMissionMode_emxEnsureCapacity_real_T(dummyinitWP, i);
        loop_ub = c->size[0];
        for (i = 0; i < 3; i++) {
            dummyinitWP->data[static_cast<int32_T>(dummyinitWP->size[0] * i)] =
                0.0;
            for (int32_T i_0{0}; i_0 <= static_cast<int32_T>(loop_ub - 1); i_0++)
            {
                dummyinitWP->data[static_cast<int32_T>(static_cast<int32_T>(i_0
                    + static_cast<int32_T>(dummyinitWP->size[0] * i)) + 1)] =
                    c->data[static_cast<int32_T>(static_cast<int32_T>(c->size[0]
                    * i) + i_0)];
            }
        }
    }

    FlightMissionMode_emxFree_real_T(&c);

    // '<S126>:1:35'
    loop_ub = static_cast<int32_T>(dummyinitWP->size[0] - 128);
    for (i = 0; i < 3; i++) {
        for (int32_T i_0{0}; i_0 < 128; i_0++) {
            rty_initWayPoint[static_cast<int32_T>(i_0 + static_cast<int32_T>(i <<
                7))] = dummyinitWP->data[static_cast<int32_T>
                (static_cast<int32_T>(i_0 + loop_ub) + static_cast<int32_T>
                 (dummyinitWP->size[0] * i))];
        }
    }

    FlightMissionMode_emxFree_real_T(&dummyinitWP);
}

//
// Output and update for atomic system:
//    '<S127>/minus'
//    '<S170>/minus'
//
void FlightMissionMode::FlightMissionMode_minus(const real_T rtu_uP[384], const
    real_T rtu_uN[3], real_T rty_y[384])
{
    // MATLAB Function 'minus': '<S131>:1'
    // '<S131>:1:3'
    for (int32_T jcol{0}; jcol < 3; jcol++) {
        int32_T ibmat;
        ibmat = static_cast<int32_T>(jcol << 7);
        for (int32_T itilerow{0}; itilerow < 128; itilerow++) {
            rty_y[static_cast<int32_T>(ibmat + itilerow)] = rtu_uN[jcol];
        }
    }

    for (int32_T jcol{0}; jcol < 384; jcol++) {
        rty_y[jcol] = rtu_uP[jcol] - rty_y[jcol];
    }
}

//
// Output and update for atomic system:
//    '<S127>/biasNED'
//    '<S170>/biasNED'
//
void FlightMissionMode::FlightMissionMode_biasNED(const real_T rtu_MissionNED[3],
    const real_T rtu_IndivRotWP[384], real_T rty_nedWayPoint[384])
{
    real_T b[384];

    // MATLAB Function 'biasNED': '<S130>:1'
    // '<S130>:1:4'
    for (int32_T jcol{0}; jcol < 3; jcol++) {
        int32_T ibmat;
        ibmat = static_cast<int32_T>(jcol << 7);
        for (int32_T itilerow{0}; itilerow < 128; itilerow++) {
            b[static_cast<int32_T>(ibmat + itilerow)] = rtu_MissionNED[jcol];
        }
    }

    for (int32_T jcol{0}; jcol < 128; jcol++) {
        rty_nedWayPoint[jcol] = rtu_IndivRotWP[static_cast<int32_T>(jcol + 128)]
            + b[jcol];
        rty_nedWayPoint[static_cast<int32_T>(jcol + 128)] = b
            [static_cast<int32_T>(jcol + 128)] + rtu_IndivRotWP[jcol];
        rty_nedWayPoint[static_cast<int32_T>(jcol + 256)] = rtu_IndivRotWP[
            static_cast<int32_T>(jcol + 256)] + b[static_cast<int32_T>(jcol +
            256)];
    }
}

void FlightMissionMode::FlightMissionMode_emxInit_real_T_i
    (emxArray_real_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions)
{
    emxArray_real_T_FlightMissionMode_T *emxArray;
    *pEmxArray = static_cast<emxArray_real_T_FlightMissionMode_T *>(std::malloc
        (sizeof(emxArray_real_T_FlightMissionMode_T)));
    emxArray = *pEmxArray;
    emxArray->data = static_cast<real_T *>(nullptr);
    emxArray->numDimensions = numDimensions;
    emxArray->size = static_cast<int32_T *>(std::malloc(static_cast<uint32_T>
        (sizeof(int32_T) * static_cast<uint32_T>(numDimensions))));
    emxArray->allocatedSize = 0;
    emxArray->canFreeData = true;
    for (int32_T i{0}; i <= static_cast<int32_T>(numDimensions - 1); i++) {
        emxArray->size[i] = 0;
    }
}

void FlightMissionMode::FlightMissionMode_emxInit_char_T_b
    (emxArray_char_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions)
{
    emxArray_char_T_FlightMissionMode_T *emxArray;
    *pEmxArray = static_cast<emxArray_char_T_FlightMissionMode_T *>(std::malloc
        (sizeof(emxArray_char_T_FlightMissionMode_T)));
    emxArray = *pEmxArray;
    emxArray->data = static_cast<char_T *>(nullptr);
    emxArray->numDimensions = numDimensions;
    emxArray->size = static_cast<int32_T *>(std::malloc(static_cast<uint32_T>
        (sizeof(int32_T) * static_cast<uint32_T>(numDimensions))));
    emxArray->allocatedSize = 0;
    emxArray->canFreeData = true;
    for (int32_T i{0}; i <= static_cast<int32_T>(numDimensions - 1); i++) {
        emxArray->size[i] = 0;
    }
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
int8_T FlightMissionMode::FlightMissionMode_filedata_d
    (DW_WayPointGenerator_FlightMissionMode_T *localDW)
{
    int32_T k;
    int8_T f;
    boolean_T exitg1;
    f = 0;
    k = 1;
    exitg1 = false;
    while ((!exitg1) && (static_cast<int32_T>(k - 1) < 20)) {
        if (localDW->eml_openfiles[static_cast<int32_T>(static_cast<int32_T>(
                static_cast<int8_T>(k)) - 1)] == NULL) {
            f = static_cast<int8_T>(k);
            exitg1 = true;
        } else {
            k = static_cast<int32_T>(k + 1);
        }
    }

    return f;
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
int8_T FlightMissionMode::FlightMissionMode_cfopen_h(const char_T *cfilename,
    const char_T *cpermission, DW_WayPointGenerator_FlightMissionMode_T *localDW)
{
    int8_T fileid;
    int8_T j;
    fileid = -1;
    j = FlightMissionMode_filedata_d(localDW);
    if (static_cast<int32_T>(j) >= 1) {
        FILE* filestar;
        filestar = fopen(cfilename, cpermission);
        if (filestar != NULL) {
            int32_T tmp;
            localDW->eml_openfiles[static_cast<int32_T>(static_cast<int32_T>(j)
                - 1)] = filestar;
            tmp = static_cast<int32_T>(static_cast<int32_T>(j) + 2);
            if (static_cast<int32_T>(static_cast<int32_T>(j) + 2) > 127) {
                tmp = 127;
            }

            fileid = static_cast<int8_T>(tmp);
        }
    }

    return fileid;
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
real_T FlightMissionMode::FlightMissionMode_fileManager_d
    (DW_WayPointGenerator_FlightMissionMode_T *localDW)
{
    real_T f;
    int8_T fileid;
    fileid = FlightMissionMode_cfopen_h("config.ini", "rb", localDW);
    f = static_cast<real_T>(fileid);
    return f;
}

void FlightMissionMode::FlightMissionMode_emxEnsureCapacity_char_T_o
    (emxArray_char_T_FlightMissionMode_T *emxArray, int32_T oldNumel)
{
    int32_T i;
    int32_T newNumel;
    void *newData;
    if (oldNumel < 0) {
        oldNumel = 0;
    }

    newNumel = 1;
    for (i = 0; i <= static_cast<int32_T>(emxArray->numDimensions - 1); i++) {
        newNumel = static_cast<int32_T>(newNumel * emxArray->size[i]);
    }

    if (newNumel > emxArray->allocatedSize) {
        i = emxArray->allocatedSize;
        if (i < 16) {
            i = 16;
        }

        while (i < newNumel) {
            if (i > 1073741823) {
                i = MAX_int32_T;
            } else {
                i = static_cast<int32_T>(i << 1);
            }
        }

        newData = std::calloc(static_cast<uint32_T>(i), sizeof(char_T));
        if (emxArray->data != nullptr) {
            std::memcpy(newData, emxArray->data, static_cast<uint32_T>(sizeof
                         (char_T) * static_cast<uint32_T>(oldNumel)));
            if (emxArray->canFreeData) {
                std::free(emxArray->data);
            }
        }

        emxArray->data = static_cast<char_T *>(newData);
        emxArray->allocatedSize = i;
        emxArray->canFreeData = true;
    }
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_fread_o(real_T fileID,
    emxArray_char_T_FlightMissionMode_T *A,
    DW_WayPointGenerator_FlightMissionMode_T *localDW)
{
    FILE* filestar;
    size_t nBytes;
    char_T tbuf[1024];
    int8_T fileid;
    nBytes = sizeof(char_T);
    fileid = static_cast<int8_T>(std::round(fileID));
    if (fileID != static_cast<real_T>(fileid)) {
        fileid = -1;
    }

    if (static_cast<int32_T>(fileid) >= 3) {
        filestar = localDW->eml_openfiles[static_cast<int32_T>
            (static_cast<int32_T>(fileid) - 3)];
    } else {
        switch (static_cast<int32_T>(fileid)) {
          case 0:
            filestar = stdin;
            break;

          case 1:
            filestar = stdout;
            break;

          case 2:
            filestar = stderr;
            break;

          default:
            filestar = NULL;
            break;
        }
    }

    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
            static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
              static_cast<boolean_T>(static_cast<int32_T>((fileID != 0.0) ^ 1)))
             | static_cast<int32_T>(static_cast<boolean_T>(static_cast<int32_T>
               ((fileID != 1.0) ^ 1)))))) | static_cast<int32_T>
            (static_cast<boolean_T>(static_cast<int32_T>((fileID != 2.0) ^ 1))))))
    {
        filestar = NULL;
    }

    A->size[0] = 0;
    if (static_cast<boolean_T>(static_cast<int32_T>((filestar == NULL) ^ 1))) {
        int32_T c;
        c = 1;
        while (c > 0) {
            int32_T c_0;
            int32_T i;
            int32_T numRead;
            c = 0;
            numRead = 1;
            while (static_cast<boolean_T>(static_cast<int32_T>((c < 1024) &
                     (numRead > 0)))) {
                size_t numReadSizeT;
                numReadSizeT = fread(&tbuf[c], nBytes, (size_t)(1024 - c),
                                     filestar);
                numRead = (int32_T)numReadSizeT;
                c = static_cast<int32_T>(c + (int32_T)numReadSizeT);
            }

            numRead = A->size[0];
            if (c < 1) {
                c_0 = -1;
            } else {
                c_0 = static_cast<int32_T>(c - 1);
            }

            i = A->size[0];
            A->size[0] = static_cast<int32_T>(static_cast<int32_T>(c_0 + A->
                size[0]) + 1);
            FlightMissionMode_emxEnsureCapacity_char_T_o(A, i);
            if (c < 1) {
                c_0 = -1;
            } else {
                c_0 = static_cast<int32_T>(c - 1);
            }

            for (i = 0; i <= c_0; i++) {
                A->data[static_cast<int32_T>(numRead + i)] = tbuf[i];
            }
        }
    }
}

void FlightMissionMode::FlightMissionMode_emxFree_char_T_d
    (emxArray_char_T_FlightMissionMode_T **pEmxArray)
{
    if (*pEmxArray != static_cast<emxArray_char_T_FlightMissionMode_T *>(nullptr))
    {
        if (((*pEmxArray)->data != static_cast<char_T *>(nullptr)) &&
                (*pEmxArray)->canFreeData) {
            std::free((*pEmxArray)->data);
        }

        std::free((*pEmxArray)->size);
        std::free(*pEmxArray);
        *pEmxArray = static_cast<emxArray_char_T_FlightMissionMode_T *>(nullptr);
    }
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_copydigits_l
    (emxArray_char_T_FlightMissionMode_T *s1, int32_T *idx, const
     emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n, boolean_T
     allowpoint)
{
    boolean_T exitg1;
    boolean_T haspoint;
    boolean_T success;
    success = (*k <= n);
    haspoint = false;
    exitg1 = false;
    while ((!exitg1) && (static_cast<boolean_T>(static_cast<int32_T>((*k <= n) &
              static_cast<int32_T>(success))))) {
        char_T tmp;
        tmp = s->data[static_cast<int32_T>(*k - 1)];
        if ((tmp >= '0') && (tmp <= '9')) {
            s1->data[static_cast<int32_T>(*idx - 1)] = tmp;
            *idx = static_cast<int32_T>(*idx + 1);
            *k = static_cast<int32_T>(*k + 1);
        } else if (tmp == '.') {
            success = static_cast<boolean_T>(static_cast<int32_T>
                (static_cast<int32_T>(static_cast<boolean_T>(static_cast<int32_T>
                (static_cast<int32_T>(haspoint) ^ 1))) & static_cast<int32_T>
                 (allowpoint)));
            if (success) {
                s1->data[static_cast<int32_T>(*idx - 1)] = '.';
                *idx = static_cast<int32_T>(*idx + 1);
                haspoint = true;
            }

            *k = static_cast<int32_T>(*k + 1);
        } else if (tmp == ',') {
            *k = static_cast<int32_T>(*k + 1);
        } else {
            exitg1 = true;
        }
    }

    return success;
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_readfloat_e
    (emxArray_char_T_FlightMissionMode_T *s1, int32_T *idx, const
     emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n, boolean_T
     allowimag, boolean_T *isimag, boolean_T *b_finite, real_T *nfv, boolean_T
     *foundsign, boolean_T *success)
{
    static const boolean_T b[128]{ false, false, false, false, false, false,
        false, false, false, true, true, true, true, true, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, true, true, true, true, true, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false };

    emxArray_char_T_FlightMissionMode_T *d;
    int32_T b_idx;
    int32_T b_k;
    int32_T g_k;
    char_T c_idx_0;
    boolean_T a__3;
    boolean_T exitg1;
    boolean_T isneg;
    FlightMissionMode_emxInit_char_T_b(&d, 2);
    *isimag = false;
    *b_finite = true;
    *nfv = 0.0;
    b_idx = *idx;
    b_k = *k;
    isneg = false;
    *foundsign = false;
    exitg1 = false;
    while ((!exitg1) && (b_k <= n)) {
        c_idx_0 = s->data[static_cast<int32_T>(b_k - 1)];
        if (c_idx_0 == '-') {
            isneg = static_cast<boolean_T>(static_cast<int32_T>
                (static_cast<int32_T>(isneg) ^ 1));
            *foundsign = true;
            b_k = static_cast<int32_T>(b_k + 1);
        } else if (c_idx_0 == ',') {
            b_k = static_cast<int32_T>(b_k + 1);
        } else if (c_idx_0 == '+') {
            *foundsign = true;
            b_k = static_cast<int32_T>(b_k + 1);
        } else if (static_cast<boolean_T>(static_cast<int32_T>
                    (static_cast<int32_T>(b[static_cast<int32_T>
                      (static_cast<int32_T>(static_cast<uint8_T>(c_idx_0)) & 127)])
                     ^ 1))) {
            exitg1 = true;
        } else {
            b_k = static_cast<int32_T>(b_k + 1);
        }
    }

    *success = (b_k <= n);
    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
            (*success) & static_cast<int32_T>(isneg)))) {
        if ((*idx >= 2) && (s1->data[static_cast<int32_T>(*idx - 2)] == '-')) {
            s1->data[static_cast<int32_T>(*idx - 2)] = ' ';
        } else {
            s1->data[static_cast<int32_T>(*idx - 1)] = '-';
            b_idx = static_cast<int32_T>(*idx + 1);
        }
    }

    *idx = b_idx;
    *k = b_k;
    if (*success) {
        char_T c_idx_1;
        char_T c_idx_2;
        isneg = false;
        if (b_k <= n) {
            c_idx_0 = s->data[static_cast<int32_T>(b_k - 1)];
            if (c_idx_0 == 'j') {
                isneg = true;
            } else if (c_idx_0 == 'i') {
                if (b_k >= static_cast<int32_T>(n - 1)) {
                    isneg = true;
                } else {
                    g_k = b_k;
                    c_idx_0 = '\x00';
                    while ((g_k <= n) && (s->data[static_cast<int32_T>(g_k - 1)]
                                          == ',')) {
                        g_k = static_cast<int32_T>(g_k + 1);
                    }

                    if (g_k <= n) {
                        c_idx_0 = s->data[static_cast<int32_T>(g_k - 1)];
                    }

                    g_k = static_cast<int32_T>(g_k + 1);
                    c_idx_1 = '\x00';
                    while ((g_k <= n) && (s->data[static_cast<int32_T>(g_k - 1)]
                                          == ',')) {
                        g_k = static_cast<int32_T>(g_k + 1);
                    }

                    if (g_k <= n) {
                        c_idx_1 = s->data[static_cast<int32_T>(g_k - 1)];
                    }

                    g_k = static_cast<int32_T>(g_k + 1);
                    c_idx_2 = '\x00';
                    while ((g_k <= n) && (s->data[static_cast<int32_T>(g_k - 1)]
                                          == ',')) {
                        g_k = static_cast<int32_T>(g_k + 1);
                    }

                    if (g_k <= n) {
                        c_idx_2 = s->data[static_cast<int32_T>(g_k - 1)];
                    }

                    if (((c_idx_0 == 'I') || (c_idx_0 == 'i')) && ((c_idx_1 ==
                            'N') || (c_idx_1 == 'n')) && ((c_idx_2 == 'F') ||
                            (c_idx_2 == 'f'))) {
                    } else if ((c_idx_0 == 'N') || (c_idx_0 == 'n')) {
                        if ((c_idx_1 == 'A') || (c_idx_1 == 'a')) {
                            if ((c_idx_2 != 'N') && (c_idx_2 != 'n')) {
                                isneg = true;
                            }
                        } else {
                            isneg = true;
                        }
                    } else {
                        isneg = true;
                    }
                }
            }
        }

        if (isneg) {
            if (allowimag) {
                *isimag = true;
                *k = static_cast<int32_T>(b_k + 1);
                exitg1 = false;
                while ((!exitg1) && (*k <= n)) {
                    if (b[static_cast<int32_T>(static_cast<int32_T>
                                               (static_cast<uint8_T>(s->data[
                            static_cast<int32_T>(*k - 1)])) & 127)]) {
                        *k = static_cast<int32_T>(*k + 1);
                    } else {
                        c_idx_0 = s->data[static_cast<int32_T>(*k - 1)];
                        if ((c_idx_0 == '\x00') || (c_idx_0 == ',')) {
                            *k = static_cast<int32_T>(*k + 1);
                        } else {
                            exitg1 = true;
                        }
                    }
                }

                if ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == '*'))
                {
                    *k = static_cast<int32_T>(*k + 1);
                    FlightMissionMode_readfloat_e(s1, idx, s, k, n, false,
                        &isneg, b_finite, nfv, &a__3, success);
                } else {
                    s1->data[static_cast<int32_T>(b_idx - 1)] = '1';
                    *idx = static_cast<int32_T>(b_idx + 1);
                }
            } else {
                *success = false;
            }
        } else {
            g_k = b_k;
            c_idx_0 = '\x00';
            while ((g_k <= n) && (s->data[static_cast<int32_T>(g_k - 1)] == ','))
            {
                g_k = static_cast<int32_T>(g_k + 1);
            }

            if (g_k <= n) {
                c_idx_0 = s->data[static_cast<int32_T>(g_k - 1)];
            }

            g_k = static_cast<int32_T>(g_k + 1);
            c_idx_1 = '\x00';
            while ((g_k <= n) && (s->data[static_cast<int32_T>(g_k - 1)] == ','))
            {
                g_k = static_cast<int32_T>(g_k + 1);
            }

            if (g_k <= n) {
                c_idx_1 = s->data[static_cast<int32_T>(g_k - 1)];
            }

            g_k = static_cast<int32_T>(g_k + 1);
            c_idx_2 = '\x00';
            while ((g_k <= n) && (s->data[static_cast<int32_T>(g_k - 1)] == ','))
            {
                g_k = static_cast<int32_T>(g_k + 1);
            }

            if (g_k <= n) {
                c_idx_2 = s->data[static_cast<int32_T>(g_k - 1)];
            }

            g_k = static_cast<int32_T>(g_k + 1);
            if (((c_idx_0 == 'I') || (c_idx_0 == 'i')) && ((c_idx_1 == 'N') ||
                    (c_idx_1 == 'n')) && ((c_idx_2 == 'F') || (c_idx_2 == 'f')))
            {
                *b_finite = false;
                *nfv = (rtInf);
            } else if (((c_idx_0 == 'N') || (c_idx_0 == 'n')) && ((c_idx_1 ==
                         'A') || (c_idx_1 == 'a')) && ((c_idx_2 == 'N') ||
                        (c_idx_2 == 'n'))) {
                *b_finite = false;
                *nfv = (rtNaN);
            } else {
                g_k = b_k;
            }

            *k = g_k;
            if (*b_finite) {
                int32_T loop_ub;
                b_k = static_cast<int32_T>(d->size[0] * d->size[1]);
                d->size[0] = 1;
                d->size[1] = s1->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_o(d, b_k);
                loop_ub = static_cast<int32_T>(s1->size[1] - 1);
                for (b_k = 0; b_k <= loop_ub; b_k++) {
                    d->data[b_k] = s1->data[b_k];
                }

                *success = FlightMissionMode_copydigits_l(d, &b_idx, s, &g_k, n,
                    true);
                b_k = static_cast<int32_T>(s1->size[0] * s1->size[1]);
                s1->size[0] = 1;
                s1->size[1] = d->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_o(s1, b_k);
                loop_ub = d->size[1];
                for (b_k = 0; b_k <= static_cast<int32_T>(loop_ub - 1); b_k++) {
                    s1->data[b_k] = d->data[b_k];
                }

                *idx = b_idx;
                *k = g_k;
                if ((*success) && (g_k <= n)) {
                    c_idx_0 = s->data[static_cast<int32_T>(g_k - 1)];
                    if ((c_idx_0 == 'E') || (c_idx_0 == 'e')) {
                        s1->data[static_cast<int32_T>(b_idx - 1)] = 'e';
                        *idx = static_cast<int32_T>(b_idx + 1);
                        while ((static_cast<int32_T>(g_k + 1) <= n) && (s->
                                data[g_k] == ',')) {
                            g_k = static_cast<int32_T>(g_k + 1);
                        }

                        if (static_cast<int32_T>(g_k + 1) <= n) {
                            if (s->data[g_k] == '-') {
                                s1->data[b_idx] = '-';
                                *idx = static_cast<int32_T>(b_idx + 2);
                                g_k = static_cast<int32_T>(g_k + 1);
                            } else if (s->data[g_k] == '+') {
                                g_k = static_cast<int32_T>(g_k + 1);
                            }
                        }

                        b_k = static_cast<int32_T>(d->size[0] * d->size[1]);
                        d->size[0] = 1;
                        d->size[1] = s1->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_o(d, b_k);
                        loop_ub = static_cast<int32_T>(s1->size[1] - 1);
                        for (b_k = 0; b_k <= loop_ub; b_k++) {
                            d->data[b_k] = s1->data[b_k];
                        }

                        b_idx = static_cast<int32_T>(g_k + 1);
                        isneg = FlightMissionMode_copydigits_l(d, idx, s, &b_idx,
                            n, false);
                        b_k = static_cast<int32_T>(s1->size[0] * s1->size[1]);
                        s1->size[0] = 1;
                        s1->size[1] = d->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_o(s1, b_k);
                        loop_ub = d->size[1];
                        for (b_k = 0; b_k <= static_cast<int32_T>(loop_ub - 1);
                                b_k++) {
                            s1->data[b_k] = d->data[b_k];
                        }

                        *k = b_idx;
                        if (static_cast<boolean_T>(static_cast<int32_T>((b_idx <=
                               static_cast<int32_T>(g_k + 1)) |
                                static_cast<int32_T>(static_cast<boolean_T>(
                                static_cast<int32_T>(static_cast<int32_T>(isneg)
                                 ^ 1)))))) {
                            *success = false;
                        }
                    }
                }
            } else if ((b_idx >= 2) && (s1->data[static_cast<int32_T>(b_idx - 2)]
                        == '-')) {
                *idx = static_cast<int32_T>(b_idx - 1);
                s1->data[static_cast<int32_T>(b_idx - 2)] = ' ';
                *nfv = -*nfv;
            }

            exitg1 = false;
            while ((!exitg1) && (*k <= n)) {
                if (b[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(s->data[
                        static_cast<int32_T>(*k - 1)])) & 127)]) {
                    *k = static_cast<int32_T>(*k + 1);
                } else {
                    c_idx_0 = s->data[static_cast<int32_T>(*k - 1)];
                    if ((c_idx_0 == '\x00') || (c_idx_0 == ',')) {
                        *k = static_cast<int32_T>(*k + 1);
                    } else {
                        exitg1 = true;
                    }
                }
            }

            if ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == '*')) {
                *k = static_cast<int32_T>(*k + 1);
                while ((*k <= n) && (b[static_cast<int32_T>(static_cast<int32_T>
                         (static_cast<uint8_T>(s->data[static_cast<int32_T>(*k -
                            1)])) & 127)] || (s->data[static_cast<int32_T>(*k -
                          1)] == '\x00') || (s->data[static_cast<int32_T>(*k - 1)]
                         == ','))) {
                    *k = static_cast<int32_T>(*k + 1);
                }
            }

            if (*k <= n) {
                c_idx_0 = s->data[static_cast<int32_T>(*k - 1)];
                if ((c_idx_0 == 'i') || (c_idx_0 == 'j')) {
                    *k = static_cast<int32_T>(*k + 1);
                    *isimag = true;
                }
            }
        }

        exitg1 = false;
        while ((!exitg1) && (*k <= n)) {
            c_idx_0 = s->data[static_cast<int32_T>(*k - 1)];
            if (b[static_cast<int32_T>(static_cast<int32_T>(static_cast<uint8_T>
                    (c_idx_0)) & 127)] || (c_idx_0 == '\x00') || (c_idx_0 == ','))
            {
                *k = static_cast<int32_T>(*k + 1);
            } else {
                exitg1 = true;
            }
        }
    }

    FlightMissionMode_emxFree_char_T_d(&d);
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
creal_T FlightMissionMode::FlightMissionMode_str2double_o(const
    emxArray_char_T_FlightMissionMode_T *s)
{
    static const boolean_T c[128]{ false, false, false, false, false, false,
        false, false, false, true, true, true, true, true, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, true, true, true, true, true, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false };

    emxArray_char_T_FlightMissionMode_T *d;
    emxArray_char_T_FlightMissionMode_T *s1;
    creal_T x;
    real_T b_scanned1;
    real_T scanned1;
    real_T scanned2;
    int32_T idx;
    int32_T k;
    boolean_T a__1;
    boolean_T c_success;
    boolean_T foundsign;
    boolean_T isfinite1;
    boolean_T isimag1;
    boolean_T success;
    FlightMissionMode_emxInit_char_T_b(&d, 2);
    x.re = (rtNaN);
    x.im = 0.0;
    if (s->size[1] >= 1) {
        int32_T i;
        int32_T loop_ub;
        int32_T ntoread;
        boolean_T exitg1;
        FlightMissionMode_emxInit_char_T_b(&s1, 2);
        ntoread = 0;
        k = 1;
        exitg1 = false;
        while ((!exitg1) && (k <= s->size[1])) {
            char_T tmp;
            tmp = s->data[static_cast<int32_T>(k - 1)];
            if (c[static_cast<int32_T>(static_cast<int32_T>(static_cast<uint8_T>
                    (tmp)) & 127)] || (tmp == '\x00')) {
                k = static_cast<int32_T>(k + 1);
            } else {
                exitg1 = true;
            }
        }

        i = static_cast<int32_T>(d->size[0] * d->size[1]);
        d->size[0] = 1;
        d->size[1] = static_cast<int32_T>(s->size[1] + 2);
        FlightMissionMode_emxEnsureCapacity_char_T_o(d, i);
        loop_ub = s->size[1];
        for (i = 0; i <= static_cast<int32_T>(loop_ub + 1); i++) {
            d->data[i] = '\x00';
        }

        idx = 1;
        FlightMissionMode_readfloat_e(d, &idx, s, &k, s->size[1], true, &isimag1,
            &isfinite1, &scanned1, &a__1, &success);
        i = static_cast<int32_T>(s1->size[0] * s1->size[1]);
        s1->size[0] = 1;
        s1->size[1] = d->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_o(s1, i);
        loop_ub = static_cast<int32_T>(d->size[1] - 1);
        for (i = 0; i <= loop_ub; i++) {
            s1->data[i] = d->data[i];
        }

        if (isfinite1) {
            ntoread = 1;
        }

        if (success) {
            if (k <= s->size[1]) {
                s1->data[static_cast<int32_T>(idx - 1)] = ' ';
                i = static_cast<int32_T>(d->size[0] * d->size[1]);
                d->size[0] = 1;
                d->size[1] = s1->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_o(d, i);
                loop_ub = static_cast<int32_T>(s1->size[1] - 1);
                for (i = 0; i <= loop_ub; i++) {
                    d->data[i] = s1->data[i];
                }

                idx = static_cast<int32_T>(idx + 1);
                FlightMissionMode_readfloat_e(d, &idx, s, &k, s->size[1], true,
                    &a__1, &success, &scanned2, &foundsign, &c_success);
                i = static_cast<int32_T>(s1->size[0] * s1->size[1]);
                s1->size[0] = 1;
                s1->size[1] = d->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_o(s1, i);
                loop_ub = static_cast<int32_T>(d->size[1] - 1);
                for (i = 0; i <= loop_ub; i++) {
                    s1->data[i] = d->data[i];
                }

                if (success) {
                    ntoread = static_cast<int32_T>(ntoread + 1);
                }

                success = static_cast<boolean_T>(static_cast<int32_T>(
                    static_cast<int32_T>(static_cast<boolean_T>
                    (static_cast<int32_T>(static_cast<int32_T>
                    (static_cast<boolean_T>(static_cast<int32_T>
                    (static_cast<int32_T>(static_cast<boolean_T>
                    (static_cast<int32_T>(static_cast<int32_T>(isimag1) ^
                    static_cast<int32_T>(a__1)))) & static_cast<int32_T>
                     (foundsign)))) & (k > s->size[1])))) & static_cast<int32_T>
                    (c_success)));
            } else {
                scanned2 = 0.0;
            }
        } else {
            scanned2 = 0.0;
        }

        if (success) {
            s1->data[static_cast<int32_T>(idx - 1)] = '\x00';
            switch (ntoread) {
              case 2:
                ntoread = sscanf(&s1->data[0], "%lf %lf", &scanned1, &scanned2);
                if (ntoread != 2) {
                    scanned1 = (rtNaN);
                    scanned2 = (rtNaN);
                }
                break;

              case 1:
                ntoread = sscanf(&s1->data[0], "%lf", &b_scanned1);
                if (isfinite1) {
                    if (ntoread == 1) {
                        scanned1 = b_scanned1;
                    } else {
                        scanned1 = (rtNaN);
                    }
                } else if (ntoread == 1) {
                    scanned2 = b_scanned1;
                } else {
                    scanned2 = (rtNaN);
                }
                break;
            }

            if (isimag1) {
                x.re = scanned2;
                x.im = scanned1;
            } else {
                x.re = scanned1;
                x.im = scanned2;
            }
        }

        FlightMissionMode_emxFree_char_T_d(&s1);
    }

    FlightMissionMode_emxFree_char_T_d(&d);
    return x;
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
int32_T FlightMissionMode::FlightMissionMode_cfclose_i(real_T fid,
    DW_WayPointGenerator_FlightMissionMode_T *localDW)
{
    FILE* filestar;
    int32_T st;
    int8_T b_fileid;
    int8_T fileid;
    st = -1;
    fileid = static_cast<int8_T>(std::round(fid));
    if (fid != static_cast<real_T>(fileid)) {
        fileid = -1;
    }

    b_fileid = fileid;
    if (static_cast<int32_T>(fileid) < 0) {
        b_fileid = -1;
    }

    if (static_cast<int32_T>(b_fileid) >= 3) {
        filestar = localDW->eml_openfiles[static_cast<int32_T>
            (static_cast<int32_T>(b_fileid) - 3)];
    } else {
        switch (static_cast<int32_T>(b_fileid)) {
          case 0:
            filestar = stdin;
            break;

          case 1:
            filestar = stdout;
            break;

          case 2:
            filestar = stderr;
            break;

          default:
            filestar = NULL;
            break;
        }
    }

    if (static_cast<boolean_T>(static_cast<int32_T>((filestar != NULL) & (
            static_cast<int32_T>(fileid) >= 3)))) {
        int32_T cst;
        cst = fclose(filestar);
        if (cst == 0) {
            st = 0;
            localDW->eml_openfiles[static_cast<int32_T>(static_cast<int32_T>
                (fileid) - 3)] = NULL;
        }
    }

    return st;
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_strtok_m(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token, emxArray_char_T_FlightMissionMode_T *remain)
{
    int32_T b;
    int32_T i;
    int32_T itoken;
    int32_T k;
    int32_T n;
    n = x->size[1];
    k = 0;
    while ((static_cast<int32_T>(k + 1) <= n) && (x->data[k] == '\x0a')) {
        k = static_cast<int32_T>(k + 1);
    }

    itoken = static_cast<int32_T>(k + 1);
    while ((static_cast<int32_T>(k + 1) <= n) && (x->data[k] != '\x0a')) {
        k = static_cast<int32_T>(k + 1);
    }

    if (static_cast<int32_T>(k + 1) > x->size[1]) {
        n = 0;
        b = 0;
    } else {
        n = k;
        b = x->size[1];
    }

    i = static_cast<int32_T>(remain->size[0] * remain->size[1]);
    remain->size[0] = 1;
    b = static_cast<int32_T>(b - n);
    remain->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T_o(remain, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        remain->data[i] = x->data[static_cast<int32_T>(n + i)];
    }

    if (itoken > k) {
        itoken = 0;
        k = 0;
    } else {
        itoken = static_cast<int32_T>(itoken - 1);
    }

    i = static_cast<int32_T>(token->size[0] * token->size[1]);
    token->size[0] = 1;
    b = static_cast<int32_T>(k - itoken);
    token->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T_o(token, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        token->data[i] = x->data[static_cast<int32_T>(itoken + i)];
    }
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_strtok_mv(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token)
{
    int32_T itoken;
    int32_T k;
    int32_T n;
    n = x->size[1];
    k = 1;
    while ((k <= n) && (x->data[static_cast<int32_T>(k - 1)] == ';')) {
        k = static_cast<int32_T>(k + 1);
    }

    itoken = k;
    while ((k <= n) && (x->data[static_cast<int32_T>(k - 1)] != ';')) {
        k = static_cast<int32_T>(k + 1);
    }

    if (itoken > static_cast<int32_T>(k - 1)) {
        n = 0;
        k = 0;
    } else {
        n = static_cast<int32_T>(itoken - 1);
        k = static_cast<int32_T>(k - 1);
    }

    itoken = static_cast<int32_T>(token->size[0] * token->size[1]);
    token->size[0] = 1;
    k = static_cast<int32_T>(k - n);
    token->size[1] = k;
    FlightMissionMode_emxEnsureCapacity_char_T_o(token, itoken);
    for (itoken = 0; itoken <= static_cast<int32_T>(k - 1); itoken++) {
        token->data[itoken] = x->data[static_cast<int32_T>(n + itoken)];
    }
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_strtrim_c(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    y)
{
    static const boolean_T d[128]{ false, false, false, false, false, false,
        false, false, false, true, true, true, true, true, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, true, true, true, true, true, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false };

    int32_T b_j1;
    int32_T i;
    int32_T j2;
    b_j1 = 0;
    while ((static_cast<int32_T>(b_j1 + 1) <= x->size[1]) &&
            (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(d[
               static_cast<int32_T>(static_cast<int32_T>(static_cast<uint8_T>
                 (x->data[b_j1])) & 127)]) & (x->data[b_j1] != '\x00'))))) {
        b_j1 = static_cast<int32_T>(b_j1 + 1);
    }

    j2 = static_cast<int32_T>(x->size[1] - 1);
    while ((static_cast<int32_T>(j2 + 1) > 0) && (static_cast<boolean_T>(
             static_cast<int32_T>(static_cast<int32_T>(d[static_cast<int32_T>(
                static_cast<int32_T>(static_cast<uint8_T>(x->data[j2])) & 127)])
              & (x->data[j2] != '\x00'))))) {
        j2 = static_cast<int32_T>(j2 - 1);
    }

    if (static_cast<int32_T>(b_j1 + 1) > static_cast<int32_T>(j2 + 1)) {
        b_j1 = 0;
        j2 = -1;
    }

    i = static_cast<int32_T>(y->size[0] * y->size[1]);
    y->size[0] = 1;
    j2 = static_cast<int32_T>(j2 - b_j1);
    y->size[1] = static_cast<int32_T>(j2 + 1);
    FlightMissionMode_emxEnsureCapacity_char_T_o(y, i);
    for (i = 0; i <= j2; i++) {
        y->data[i] = x->data[static_cast<int32_T>(b_j1 + i)];
    }
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_o(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[3]{ 'U', 'A', 'V' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_b(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_o(aTmp, i);
        loop_ub = static_cast<int32_T>(a->size[1] - 1);
        for (i = 0; i <= loop_ub; i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 3) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 3) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_d(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_oq(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[10]{ 'N', 'o', 'r', 'm', 'A', 'i', 'r', 'S', 'p', 'd'
    };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_b(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_o(aTmp, i);
        loop_ub = static_cast<int32_T>(a->size[1] - 1);
        for (i = 0; i <= loop_ub; i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 10) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 10) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_d(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_contains_o(const
    emxArray_char_T_FlightMissionMode_T *str)
{
    int32_T matchPos;
    matchPos = 0;
    int32_T exitg1;
    do {
        exitg1 = 0;
        if (matchPos <= static_cast<int32_T>(str->size[1] - 1)) {
            if (str->data[matchPos] == '=') {
                exitg1 = 1;
            } else {
                matchPos = static_cast<int32_T>(matchPos + 1);
            }
        } else {
            matchPos = -1;
            exitg1 = 1;
        }
    } while (exitg1 == 0);

    return static_cast<int32_T>(matchPos + 1) > 0;
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_find_token_g(const
    emxArray_char_T_FlightMissionMode_T *x, int32_T *itoken, int32_T *iremain)
{
    int32_T n;
    n = x->size[1];
    *iremain = 1;
    while ((*iremain <= n) && (x->data[static_cast<int32_T>(*iremain - 1)] ==
                               '=')) {
        *iremain = static_cast<int32_T>(*iremain + 1);
    }

    *itoken = *iremain;
    while ((*iremain <= n) && (x->data[static_cast<int32_T>(*iremain - 1)] !=
                               '=')) {
        *iremain = static_cast<int32_T>(*iremain + 1);
    }
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_strtok_mv4(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token, emxArray_char_T_FlightMissionMode_T *remain)
{
    int32_T b;
    int32_T c;
    int32_T i;
    int32_T iremain;
    int32_T itoken;
    FlightMissionMode_find_token_g(x, &itoken, &iremain);
    if (iremain > x->size[1]) {
        c = 0;
        b = 0;
    } else {
        c = static_cast<int32_T>(iremain - 1);
        b = x->size[1];
    }

    i = static_cast<int32_T>(remain->size[0] * remain->size[1]);
    remain->size[0] = 1;
    b = static_cast<int32_T>(b - c);
    remain->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T_o(remain, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        remain->data[i] = x->data[static_cast<int32_T>(c + i)];
    }

    if (itoken > static_cast<int32_T>(iremain - 1)) {
        itoken = 0;
        iremain = 0;
    } else {
        itoken = static_cast<int32_T>(itoken - 1);
        iremain = static_cast<int32_T>(iremain - 1);
    }

    i = static_cast<int32_T>(token->size[0] * token->size[1]);
    token->size[0] = 1;
    b = static_cast<int32_T>(iremain - itoken);
    token->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T_o(token, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        token->data[i] = x->data[static_cast<int32_T>(itoken + i)];
    }
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_strtok_mv4j(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token)
{
    int32_T i;
    int32_T iremain;
    int32_T itoken;
    FlightMissionMode_find_token_g(x, &itoken, &iremain);
    if (itoken > static_cast<int32_T>(iremain - 1)) {
        itoken = 0;
        iremain = 0;
    } else {
        itoken = static_cast<int32_T>(itoken - 1);
        iremain = static_cast<int32_T>(iremain - 1);
    }

    i = static_cast<int32_T>(token->size[0] * token->size[1]);
    token->size[0] = 1;
    iremain = static_cast<int32_T>(iremain - itoken);
    token->size[1] = iremain;
    FlightMissionMode_emxEnsureCapacity_char_T_o(token, i);
    for (i = 0; i <= static_cast<int32_T>(iremain - 1); i++) {
        token->data[i] = x->data[static_cast<int32_T>(itoken + i)];
    }
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_oqn(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[9]{ 'M', 'a', 'x', 'A', 'i', 'r', 'S', 'p', 'd' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_b(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_o(aTmp, i);
        loop_ub = static_cast<int32_T>(a->size[1] - 1);
        for (i = 0; i <= loop_ub; i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 9) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 9) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_d(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_readINI_c
    (emxArray_char_T_FlightMissionMode_T *ret,
     DW_WayPointGenerator_FlightMissionMode_T *localDW)
{
    static const char_T h[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T i[15]{ 'C', 'l', 'i', 'm', 'b', 'A', 'n', 'g', 'l', 'e',
        'L', 'i', 'm', 'i', 't' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    emxArray_char_T_FlightMissionMode_T *curKey;
    emxArray_char_T_FlightMissionMode_T *curLine;
    emxArray_char_T_FlightMissionMode_T *curSection;
    emxArray_char_T_FlightMissionMode_T *curVal;
    emxArray_char_T_FlightMissionMode_T *data;
    emxArray_char_T_FlightMissionMode_T *data_0;
    emxArray_char_T_FlightMissionMode_T *j;
    emxArray_char_T_FlightMissionMode_T *tmp;
    int32_T iremain;
    int32_T itoken;
    int8_T fileid;
    ret->size[0] = 1;
    ret->size[1] = 0;
    fileid = FlightMissionMode_cfopen_h("config.ini", "rb", localDW);
    if (static_cast<int32_T>(fileid) < 0) {
        printf("INI-file \"%s\" was not found or could not be read.\n",
               "config.ini");
        fflush(stdout);
    } else {
        int32_T itoken_0;
        int32_T loop_ub;
        FlightMissionMode_emxInit_char_T_b(&data, 2);
        FlightMissionMode_emxInit_char_T_b(&j, 1);
        FlightMissionMode_fread_o(static_cast<real_T>(fileid), j, localDW);
        itoken_0 = static_cast<int32_T>(data->size[0] * data->size[1]);
        data->size[0] = 1;
        data->size[1] = j->size[0];
        FlightMissionMode_emxEnsureCapacity_char_T_o(data, itoken_0);
        loop_ub = j->size[0];
        for (itoken_0 = 0; itoken_0 <= static_cast<int32_T>(loop_ub - 1);
                itoken_0++) {
            data->data[itoken_0] = j->data[itoken_0];
        }

        FlightMissionMode_emxFree_char_T_d(&j);
        FlightMissionMode_emxInit_char_T_b(&curSection, 2);
        FlightMissionMode_emxInit_char_T_b(&curKey, 2);
        FlightMissionMode_emxInit_char_T_b(&curVal, 2);
        FlightMissionMode_cfclose_i(static_cast<real_T>(fileid), localDW);
        curSection->size[0] = 1;
        curSection->size[1] = 0;
        curKey->size[0] = 1;
        curKey->size[1] = 0;
        curVal->size[0] = 1;
        curVal->size[1] = 0;
        FlightMissionMode_emxInit_char_T_b(&curLine, 2);
        FlightMissionMode_emxInit_char_T_b(&aTmp, 2);
        FlightMissionMode_emxInit_char_T_b(&tmp, 2);
        FlightMissionMode_emxInit_char_T_b(&data_0, 2);
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (data->size[1] != 0) {
                boolean_T b_bool;
                itoken_0 = static_cast<int32_T>(data_0->size[0] * data_0->size[1]);
                data_0->size[0] = 1;
                data_0->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_o(data_0, itoken_0);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (itoken_0 = 0; itoken_0 <= loop_ub; itoken_0++) {
                    itoken = itoken_0;
                    data_0->data[itoken_0] = data->data[itoken_0];
                }

                FlightMissionMode_strtok_m(data_0, curLine, data);
                FlightMissionMode_strtok_mv(curLine, tmp);
                FlightMissionMode_strtrim_c(tmp, curLine);
                if (curLine->size[1] >= 2) {
                    boolean_T guard1{ false };

                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                iremain = 0;
                                itoken = 0;
                            } else {
                                iremain = 1;
                                itoken = static_cast<int32_T>(curLine->size[1] -
                                    1);
                            }

                            itoken_0 = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(itoken - iremain);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_o
                                (curSection, itoken_0);
                            for (itoken_0 = 0; itoken_0 <= static_cast<int32_T>
                                    (loop_ub - 1); itoken_0++) {
                                curSection->data[itoken_0] = curLine->data[
                                    static_cast<int32_T>(iremain + itoken_0)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains_o(curLine)) {
                            FlightMissionMode_strtok_mv4(curLine, aTmp, curVal);
                            FlightMissionMode_find_token_g(curVal, &itoken,
                                &iremain);
                            if (itoken > static_cast<int32_T>(iremain - 1)) {
                                itoken = 0;
                                iremain = 0;
                            } else {
                                itoken = static_cast<int32_T>(itoken - 1);
                                iremain = static_cast<int32_T>(iremain - 1);
                            }

                            FlightMissionMode_strtrim_c(aTmp, curKey);
                            itoken_0 = static_cast<int32_T>(curLine->size[0] *
                                curLine->size[1]);
                            curLine->size[0] = 1;
                            loop_ub = static_cast<int32_T>(iremain - itoken);
                            curLine->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_o(curLine,
                                itoken_0);
                            for (itoken_0 = 0; itoken_0 <= static_cast<int32_T>
                                    (loop_ub - 1); itoken_0++) {
                                curLine->data[itoken_0] = curVal->data[
                                    static_cast<int32_T>(itoken + itoken_0)];
                            }

                            FlightMissionMode_strtrim_c(curLine, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp_o(curSection)) {
                    if (curKey->size[1] == 0) {
                        aTmp->size[0] = 1;
                        aTmp->size[1] = 0;
                    } else {
                        itoken_0 = static_cast<int32_T>(aTmp->size[0] *
                            aTmp->size[1]);
                        aTmp->size[0] = 1;
                        aTmp->size[1] = curKey->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_o(aTmp,
                            itoken_0);
                        loop_ub = static_cast<int32_T>(curKey->size[1] - 1);
                        for (itoken_0 = 0; itoken_0 <= loop_ub; itoken_0++) {
                            itoken = itoken_0;
                            aTmp->data[itoken_0] = curKey->data[itoken_0];
                        }
                    }

                    b_bool = false;
                    if (aTmp->size[1] == 15) {
                        iremain = 0;
                        int32_T exitg2;
                        do {
                            exitg2 = 0;
                            if (iremain < 15) {
                                if (h[static_cast<int32_T>(static_cast<int32_T>(
                                        static_cast<uint8_T>(aTmp->data[iremain]))
                                     & 127)] != h[static_cast<int32_T>(i[iremain])])
                                {
                                    exitg2 = 1;
                                } else {
                                    iremain = static_cast<int32_T>(iremain + 1);
                                }
                            } else {
                                b_bool = true;
                                exitg2 = 1;
                            }
                        } while (exitg2 == 0);
                    }

                    if (b_bool) {
                        itoken_0 = static_cast<int32_T>(ret->size[0] * ret->
                            size[1]);
                        ret->size[0] = 1;
                        ret->size[1] = curVal->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_o(ret,
                            itoken_0);
                        loop_ub = static_cast<int32_T>(curVal->size[1] - 1);
                        for (itoken_0 = 0; itoken_0 <= loop_ub; itoken_0++) {
                            ret->data[itoken_0] = curVal->data[itoken_0];
                        }

                        exitg1 = 1;
                    }
                }
            } else {
                exitg1 = 1;
            }
        } while (exitg1 == 0);

        FlightMissionMode_emxFree_char_T_d(&data_0);
        FlightMissionMode_emxFree_char_T_d(&tmp);
        FlightMissionMode_emxFree_char_T_d(&aTmp);
        FlightMissionMode_emxFree_char_T_d(&curLine);
        FlightMissionMode_emxFree_char_T_d(&curVal);
        FlightMissionMode_emxFree_char_T_d(&curKey);
        FlightMissionMode_emxFree_char_T_d(&curSection);
        FlightMissionMode_emxFree_char_T_d(&data);
    }
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_readINI_co
    (emxArray_char_T_FlightMissionMode_T *ret,
     DW_WayPointGenerator_FlightMissionMode_T *localDW)
{
    static const char_T h[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T i[14]{ 'D', 'i', 'v', 'e', 'A', 'n', 'g', 'l', 'e', 'L',
        'i', 'm', 'i', 't' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    emxArray_char_T_FlightMissionMode_T *curKey;
    emxArray_char_T_FlightMissionMode_T *curLine;
    emxArray_char_T_FlightMissionMode_T *curSection;
    emxArray_char_T_FlightMissionMode_T *curVal;
    emxArray_char_T_FlightMissionMode_T *data;
    emxArray_char_T_FlightMissionMode_T *data_0;
    emxArray_char_T_FlightMissionMode_T *j;
    emxArray_char_T_FlightMissionMode_T *tmp;
    int32_T iremain;
    int32_T itoken;
    int8_T fileid;
    ret->size[0] = 1;
    ret->size[1] = 0;
    fileid = FlightMissionMode_cfopen_h("config.ini", "rb", localDW);
    if (static_cast<int32_T>(fileid) < 0) {
        printf("INI-file \"%s\" was not found or could not be read.\n",
               "config.ini");
        fflush(stdout);
    } else {
        int32_T itoken_0;
        int32_T loop_ub;
        FlightMissionMode_emxInit_char_T_b(&data, 2);
        FlightMissionMode_emxInit_char_T_b(&j, 1);
        FlightMissionMode_fread_o(static_cast<real_T>(fileid), j, localDW);
        itoken_0 = static_cast<int32_T>(data->size[0] * data->size[1]);
        data->size[0] = 1;
        data->size[1] = j->size[0];
        FlightMissionMode_emxEnsureCapacity_char_T_o(data, itoken_0);
        loop_ub = j->size[0];
        for (itoken_0 = 0; itoken_0 <= static_cast<int32_T>(loop_ub - 1);
                itoken_0++) {
            data->data[itoken_0] = j->data[itoken_0];
        }

        FlightMissionMode_emxFree_char_T_d(&j);
        FlightMissionMode_emxInit_char_T_b(&curSection, 2);
        FlightMissionMode_emxInit_char_T_b(&curKey, 2);
        FlightMissionMode_emxInit_char_T_b(&curVal, 2);
        FlightMissionMode_cfclose_i(static_cast<real_T>(fileid), localDW);
        curSection->size[0] = 1;
        curSection->size[1] = 0;
        curKey->size[0] = 1;
        curKey->size[1] = 0;
        curVal->size[0] = 1;
        curVal->size[1] = 0;
        FlightMissionMode_emxInit_char_T_b(&curLine, 2);
        FlightMissionMode_emxInit_char_T_b(&aTmp, 2);
        FlightMissionMode_emxInit_char_T_b(&tmp, 2);
        FlightMissionMode_emxInit_char_T_b(&data_0, 2);
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (data->size[1] != 0) {
                boolean_T b_bool;
                itoken_0 = static_cast<int32_T>(data_0->size[0] * data_0->size[1]);
                data_0->size[0] = 1;
                data_0->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_o(data_0, itoken_0);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (itoken_0 = 0; itoken_0 <= loop_ub; itoken_0++) {
                    itoken = itoken_0;
                    data_0->data[itoken_0] = data->data[itoken_0];
                }

                FlightMissionMode_strtok_m(data_0, curLine, data);
                FlightMissionMode_strtok_mv(curLine, tmp);
                FlightMissionMode_strtrim_c(tmp, curLine);
                if (curLine->size[1] >= 2) {
                    boolean_T guard1{ false };

                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                iremain = 0;
                                itoken = 0;
                            } else {
                                iremain = 1;
                                itoken = static_cast<int32_T>(curLine->size[1] -
                                    1);
                            }

                            itoken_0 = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(itoken - iremain);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_o
                                (curSection, itoken_0);
                            for (itoken_0 = 0; itoken_0 <= static_cast<int32_T>
                                    (loop_ub - 1); itoken_0++) {
                                curSection->data[itoken_0] = curLine->data[
                                    static_cast<int32_T>(iremain + itoken_0)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains_o(curLine)) {
                            FlightMissionMode_strtok_mv4(curLine, aTmp, curVal);
                            FlightMissionMode_find_token_g(curVal, &itoken,
                                &iremain);
                            if (itoken > static_cast<int32_T>(iremain - 1)) {
                                itoken = 0;
                                iremain = 0;
                            } else {
                                itoken = static_cast<int32_T>(itoken - 1);
                                iremain = static_cast<int32_T>(iremain - 1);
                            }

                            FlightMissionMode_strtrim_c(aTmp, curKey);
                            itoken_0 = static_cast<int32_T>(curLine->size[0] *
                                curLine->size[1]);
                            curLine->size[0] = 1;
                            loop_ub = static_cast<int32_T>(iremain - itoken);
                            curLine->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_o(curLine,
                                itoken_0);
                            for (itoken_0 = 0; itoken_0 <= static_cast<int32_T>
                                    (loop_ub - 1); itoken_0++) {
                                curLine->data[itoken_0] = curVal->data[
                                    static_cast<int32_T>(itoken + itoken_0)];
                            }

                            FlightMissionMode_strtrim_c(curLine, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp_o(curSection)) {
                    if (curKey->size[1] == 0) {
                        aTmp->size[0] = 1;
                        aTmp->size[1] = 0;
                    } else {
                        itoken_0 = static_cast<int32_T>(aTmp->size[0] *
                            aTmp->size[1]);
                        aTmp->size[0] = 1;
                        aTmp->size[1] = curKey->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_o(aTmp,
                            itoken_0);
                        loop_ub = static_cast<int32_T>(curKey->size[1] - 1);
                        for (itoken_0 = 0; itoken_0 <= loop_ub; itoken_0++) {
                            itoken = itoken_0;
                            aTmp->data[itoken_0] = curKey->data[itoken_0];
                        }
                    }

                    b_bool = false;
                    if (aTmp->size[1] == 14) {
                        iremain = 0;
                        int32_T exitg2;
                        do {
                            exitg2 = 0;
                            if (iremain < 14) {
                                if (h[static_cast<int32_T>(static_cast<int32_T>(
                                        static_cast<uint8_T>(aTmp->data[iremain]))
                                     & 127)] != h[static_cast<int32_T>(i[iremain])])
                                {
                                    exitg2 = 1;
                                } else {
                                    iremain = static_cast<int32_T>(iremain + 1);
                                }
                            } else {
                                b_bool = true;
                                exitg2 = 1;
                            }
                        } while (exitg2 == 0);
                    }

                    if (b_bool) {
                        itoken_0 = static_cast<int32_T>(ret->size[0] * ret->
                            size[1]);
                        ret->size[0] = 1;
                        ret->size[1] = curVal->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_o(ret,
                            itoken_0);
                        loop_ub = static_cast<int32_T>(curVal->size[1] - 1);
                        for (itoken_0 = 0; itoken_0 <= loop_ub; itoken_0++) {
                            ret->data[itoken_0] = curVal->data[itoken_0];
                        }

                        exitg1 = 1;
                    }
                }
            } else {
                exitg1 = 1;
            }
        } while (exitg1 == 0);

        FlightMissionMode_emxFree_char_T_d(&data_0);
        FlightMissionMode_emxFree_char_T_d(&tmp);
        FlightMissionMode_emxFree_char_T_d(&aTmp);
        FlightMissionMode_emxFree_char_T_d(&curLine);
        FlightMissionMode_emxFree_char_T_d(&curVal);
        FlightMissionMode_emxFree_char_T_d(&curKey);
        FlightMissionMode_emxFree_char_T_d(&curSection);
        FlightMissionMode_emxFree_char_T_d(&data);
    }
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_oqn4(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[9]{ 'M', 'i', 'n', 'A', 'i', 'r', 'S', 'p', 'd' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_b(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_o(aTmp, i);
        loop_ub = static_cast<int32_T>(a->size[1] - 1);
        for (i = 0; i <= loop_ub; i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 9) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 9) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_d(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_oqn4q(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[12]{ 'M', 'a', 'x', 'R', 'o', 'l', 'l', 'A', 'n', 'g',
        'l', 'e' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_b(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_o(aTmp, i);
        loop_ub = static_cast<int32_T>(a->size[1] - 1);
        for (i = 0; i <= loop_ub; i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 12) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 12) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_d(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
uavDubinsConnection_FlightMissionMode_c_T *FlightMissionMode::
    FlightMissionMode_uavDubinsConnection_uavDubinsConnection_e
    (uavDubinsConnection_FlightMissionMode_c_T *b_this, real_T varargin_2,
     real_T varargin_4, const real_T varargin_6[2])
{
    uavDubinsConnection_FlightMissionMode_c_T *c_this;
    real_T b_x;
    c_this = b_this;
    b_this->AirSpeed = 10.0;
    b_this->FlightPathAngleLimit[0] = varargin_6[0];
    b_this->FlightPathAngleLimit[1] = varargin_6[1];
    b_this->MaxRollAngle = varargin_4;
    b_x = b_this->MaxRollAngle;
    b_this->MinTurningRadius = b_this->AirSpeed * b_this->AirSpeed / (9.8 * std::
        tan(b_x));
    b_this->AirSpeed = varargin_2;
    b_x = b_this->MaxRollAngle;
    b_this->MinTurningRadius = b_this->AirSpeed * b_this->AirSpeed / (9.8 * std::
        tan(b_x));
    b_x = b_this->MaxRollAngle;
    b_this->MinTurningRadius = b_this->AirSpeed * b_this->AirSpeed / (9.8 * std::
        tan(b_x));
    return c_this;
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
uavDubinsConnection_FlightMissionMode_c_T *FlightMissionMode::
    FlightMissionMode_DubinsObjSingleton_getConnector_g
    (DW_WayPointGenerator_FlightMissionMode_T *localDW)
{
    emxArray_char_T_FlightMissionMode_T *b_remainder;
    emxArray_char_T_FlightMissionMode_T *curKey;
    emxArray_char_T_FlightMissionMode_T *curLine;
    emxArray_char_T_FlightMissionMode_T *curSection;
    emxArray_char_T_FlightMissionMode_T *curVal;
    emxArray_char_T_FlightMissionMode_T *data;
    emxArray_char_T_FlightMissionMode_T *data_0;
    emxArray_char_T_FlightMissionMode_T *data_1;
    emxArray_char_T_FlightMissionMode_T *data_2;
    emxArray_char_T_FlightMissionMode_T *data_3;
    emxArray_char_T_FlightMissionMode_T *k;
    emxArray_char_T_FlightMissionMode_T *ret;
    emxArray_char_T_FlightMissionMode_T *tmp_1;
    emxArray_char_T_FlightMissionMode_T *tmp_2;
    emxArray_char_T_FlightMissionMode_T *tmp_3;
    emxArray_char_T_FlightMissionMode_T *tmp_4;
    emxArray_char_T_FlightMissionMode_T *tmp_5;
    emxArray_char_T_FlightMissionMode_T *tmp_6;
    emxArray_char_T_FlightMissionMode_T *tmp_7;
    emxArray_char_T_FlightMissionMode_T *tmp_8;
    uavDubinsConnection_FlightMissionMode_c_T *outputArg;
    real_T tmp_9[2];
    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
            (localDW->SingletonInstance_not_empty) ^ 1))) {
        creal_T tmp;
        creal_T tmp_0;
        real_T ClimbAngleLimit;
        real_T DiveAngleLimit;
        real_T fid;
        int32_T b;
        int32_T b_0;
        int32_T c;
        int32_T loop_ub;
        boolean_T b_bool;
        boolean_T exitg1;
        boolean_T guard1{ false };

        FlightMissionMode_emxInit_char_T_b(&ret, 2);
        localDW->SingletonInstance.AirSpeed = 35.0;
        localDW->SingletonInstance.MaxRollAngle = 0.3490658503988659;
        localDW->SingletonInstance.FlightPathAngleLimit[0] = -0.175;
        localDW->SingletonInstance.FlightPathAngleLimit[1] = 0.175;
        ret->size[0] = 1;
        ret->size[1] = 0;
        fid = FlightMissionMode_fileManager_d(localDW);
        FlightMissionMode_emxInit_char_T_b(&data, 2);
        FlightMissionMode_emxInit_char_T_b(&curSection, 2);
        FlightMissionMode_emxInit_char_T_b(&curKey, 2);
        FlightMissionMode_emxInit_char_T_b(&curVal, 2);
        FlightMissionMode_emxInit_char_T_b(&curLine, 2);
        FlightMissionMode_emxInit_char_T_b(&b_remainder, 2);
        FlightMissionMode_emxInit_char_T_b(&k, 1);
        if (fid < 0.0) {
            printf("INI-file \"%s\" was not found or could not be read.\n",
                   "config.ini");
            fflush(stdout);
        } else {
            FlightMissionMode_fread_o(fid, k, localDW);
            b_0 = static_cast<int32_T>(data->size[0] * data->size[1]);
            data->size[0] = 1;
            data->size[1] = k->size[0];
            FlightMissionMode_emxEnsureCapacity_char_T_o(data, b_0);
            loop_ub = k->size[0];
            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                data->data[b] = k->data[b];
            }

            FlightMissionMode_cfclose_i(fid, localDW);
            curSection->size[0] = 1;
            curSection->size[1] = 0;
            curKey->size[0] = 1;
            curKey->size[1] = 0;
            curVal->size[0] = 1;
            curVal->size[1] = 0;
            FlightMissionMode_emxInit_char_T_b(&tmp_7, 2);
            FlightMissionMode_emxInit_char_T_b(&tmp_8, 2);
            FlightMissionMode_emxInit_char_T_b(&data_3, 2);
            exitg1 = false;
            while ((!exitg1) && (data->size[1] != 0)) {
                b_0 = static_cast<int32_T>(data_3->size[0] * data_3->size[1]);
                data_3->size[0] = 1;
                data_3->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_o(data_3, b_0);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (b_0 = 0; b_0 <= loop_ub; b_0++) {
                    data_3->data[b_0] = data->data[b_0];
                }

                FlightMissionMode_strtok_m(data_3, curLine, data);
                FlightMissionMode_strtok_mv(curLine, tmp_8);
                FlightMissionMode_strtrim_c(tmp_8, curLine);
                if (curLine->size[1] >= 2) {
                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                c = 0;
                                b = 0;
                            } else {
                                c = 1;
                                b = static_cast<int32_T>(curLine->size[1] - 1);
                            }

                            b_0 = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(b - c);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_o
                                (curSection, b_0);
                            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1);
                                    b++) {
                                curSection->data[b] = curLine->data[static_cast<
                                    int32_T>(c + b)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains_o(curLine)) {
                            FlightMissionMode_strtok_mv4(curLine, curVal,
                                b_remainder);
                            FlightMissionMode_strtrim_c(curVal, curKey);
                            FlightMissionMode_strtok_mv4j(b_remainder, tmp_7);
                            FlightMissionMode_strtrim_c(tmp_7, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp_o(curSection) &&
                        FlightMissionMode_strcmp_oq(curKey)) {
                    b_0 = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                    ret->size[0] = 1;
                    ret->size[1] = curVal->size[1];
                    FlightMissionMode_emxEnsureCapacity_char_T_o(ret, b_0);
                    loop_ub = static_cast<int32_T>(curVal->size[1] - 1);
                    for (b = 0; b <= loop_ub; b++) {
                        ret->data[b] = curVal->data[b];
                    }

                    exitg1 = true;
                }
            }

            FlightMissionMode_emxFree_char_T_d(&data_3);
            FlightMissionMode_emxFree_char_T_d(&tmp_8);
            FlightMissionMode_emxFree_char_T_d(&tmp_7);
        }

        tmp = FlightMissionMode_str2double_o(ret);
        printf("Set UAV NormAirSpeed:\t\t%f\n", tmp.re);
        fflush(stdout);
        ret->size[0] = 1;
        ret->size[1] = 0;
        fid = FlightMissionMode_fileManager_d(localDW);
        if (fid < 0.0) {
            printf("INI-file \"%s\" was not found or could not be read.\n",
                   "config.ini");
            fflush(stdout);
        } else {
            FlightMissionMode_fread_o(fid, k, localDW);
            b_0 = static_cast<int32_T>(data->size[0] * data->size[1]);
            data->size[0] = 1;
            data->size[1] = k->size[0];
            FlightMissionMode_emxEnsureCapacity_char_T_o(data, b_0);
            loop_ub = k->size[0];
            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                data->data[b] = k->data[b];
            }

            FlightMissionMode_cfclose_i(fid, localDW);
            curSection->size[0] = 1;
            curSection->size[1] = 0;
            curKey->size[0] = 1;
            curKey->size[1] = 0;
            curVal->size[0] = 1;
            curVal->size[1] = 0;
            FlightMissionMode_emxInit_char_T_b(&tmp_5, 2);
            FlightMissionMode_emxInit_char_T_b(&tmp_6, 2);
            FlightMissionMode_emxInit_char_T_b(&data_2, 2);
            exitg1 = false;
            while ((!exitg1) && (data->size[1] != 0)) {
                b_0 = static_cast<int32_T>(data_2->size[0] * data_2->size[1]);
                data_2->size[0] = 1;
                data_2->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_o(data_2, b_0);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (b_0 = 0; b_0 <= loop_ub; b_0++) {
                    data_2->data[b_0] = data->data[b_0];
                }

                FlightMissionMode_strtok_m(data_2, curLine, data);
                FlightMissionMode_strtok_mv(curLine, tmp_6);
                FlightMissionMode_strtrim_c(tmp_6, curLine);
                if (curLine->size[1] >= 2) {
                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                c = 0;
                                b = 0;
                            } else {
                                c = 1;
                                b = static_cast<int32_T>(curLine->size[1] - 1);
                            }

                            b_0 = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(b - c);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_o
                                (curSection, b_0);
                            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1);
                                    b++) {
                                curSection->data[b] = curLine->data[static_cast<
                                    int32_T>(c + b)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains_o(curLine)) {
                            FlightMissionMode_strtok_mv4(curLine, curVal,
                                b_remainder);
                            FlightMissionMode_strtrim_c(curVal, curKey);
                            FlightMissionMode_strtok_mv4j(b_remainder, tmp_5);
                            FlightMissionMode_strtrim_c(tmp_5, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp_o(curSection) &&
                        FlightMissionMode_strcmp_oqn(curKey)) {
                    b_0 = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                    ret->size[0] = 1;
                    ret->size[1] = curVal->size[1];
                    FlightMissionMode_emxEnsureCapacity_char_T_o(ret, b_0);
                    loop_ub = static_cast<int32_T>(curVal->size[1] - 1);
                    for (b = 0; b <= loop_ub; b++) {
                        ret->data[b] = curVal->data[b];
                    }

                    exitg1 = true;
                }
            }

            FlightMissionMode_emxFree_char_T_d(&data_2);
            FlightMissionMode_emxFree_char_T_d(&tmp_6);
            FlightMissionMode_emxFree_char_T_d(&tmp_5);
        }

        tmp_0 = FlightMissionMode_str2double_o(ret);
        printf("Set UAV MaxAirSpeed:\t\t%f\n", tmp_0.re);
        fflush(stdout);
        ret->size[0] = 1;
        ret->size[1] = 0;
        fid = FlightMissionMode_fileManager_d(localDW);
        if (fid < 0.0) {
            printf("INI-file \"%s\" was not found or could not be read.\n",
                   "config.ini");
            fflush(stdout);
        } else {
            FlightMissionMode_fread_o(fid, k, localDW);
            b_0 = static_cast<int32_T>(data->size[0] * data->size[1]);
            data->size[0] = 1;
            data->size[1] = k->size[0];
            FlightMissionMode_emxEnsureCapacity_char_T_o(data, b_0);
            loop_ub = k->size[0];
            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                data->data[b] = k->data[b];
            }

            FlightMissionMode_cfclose_i(fid, localDW);
            curSection->size[0] = 1;
            curSection->size[1] = 0;
            curKey->size[0] = 1;
            curKey->size[1] = 0;
            curVal->size[0] = 1;
            curVal->size[1] = 0;
            FlightMissionMode_emxInit_char_T_b(&tmp_3, 2);
            FlightMissionMode_emxInit_char_T_b(&tmp_4, 2);
            FlightMissionMode_emxInit_char_T_b(&data_1, 2);
            exitg1 = false;
            while ((!exitg1) && (data->size[1] != 0)) {
                b_0 = static_cast<int32_T>(data_1->size[0] * data_1->size[1]);
                data_1->size[0] = 1;
                data_1->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_o(data_1, b_0);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (b_0 = 0; b_0 <= loop_ub; b_0++) {
                    data_1->data[b_0] = data->data[b_0];
                }

                FlightMissionMode_strtok_m(data_1, curLine, data);
                FlightMissionMode_strtok_mv(curLine, tmp_4);
                FlightMissionMode_strtrim_c(tmp_4, curLine);
                if (curLine->size[1] >= 2) {
                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                c = 0;
                                b = 0;
                            } else {
                                c = 1;
                                b = static_cast<int32_T>(curLine->size[1] - 1);
                            }

                            b_0 = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(b - c);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_o
                                (curSection, b_0);
                            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1);
                                    b++) {
                                curSection->data[b] = curLine->data[static_cast<
                                    int32_T>(c + b)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains_o(curLine)) {
                            FlightMissionMode_strtok_mv4(curLine, curVal,
                                b_remainder);
                            FlightMissionMode_strtrim_c(curVal, curKey);
                            FlightMissionMode_strtok_mv4j(b_remainder, tmp_3);
                            FlightMissionMode_strtrim_c(tmp_3, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp_o(curSection) &&
                        FlightMissionMode_strcmp_oqn4(curKey)) {
                    b_0 = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                    ret->size[0] = 1;
                    ret->size[1] = curVal->size[1];
                    FlightMissionMode_emxEnsureCapacity_char_T_o(ret, b_0);
                    loop_ub = static_cast<int32_T>(curVal->size[1] - 1);
                    for (b = 0; b <= loop_ub; b++) {
                        ret->data[b] = curVal->data[b];
                    }

                    exitg1 = true;
                }
            }

            FlightMissionMode_emxFree_char_T_d(&data_1);
            FlightMissionMode_emxFree_char_T_d(&tmp_4);
            FlightMissionMode_emxFree_char_T_d(&tmp_3);
        }

        tmp_0 = FlightMissionMode_str2double_o(ret);
        printf("Set UAV MinAirSpeed:\t\t%f\n", tmp_0.re);
        fflush(stdout);
        ret->size[0] = 1;
        ret->size[1] = 0;
        fid = FlightMissionMode_fileManager_d(localDW);
        if (fid < 0.0) {
            printf("INI-file \"%s\" was not found or could not be read.\n",
                   "config.ini");
            fflush(stdout);
        } else {
            FlightMissionMode_fread_o(fid, k, localDW);
            b_0 = static_cast<int32_T>(data->size[0] * data->size[1]);
            data->size[0] = 1;
            data->size[1] = k->size[0];
            FlightMissionMode_emxEnsureCapacity_char_T_o(data, b_0);
            loop_ub = k->size[0];
            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                data->data[b] = k->data[b];
            }

            FlightMissionMode_cfclose_i(fid, localDW);
            curSection->size[0] = 1;
            curSection->size[1] = 0;
            curKey->size[0] = 1;
            curKey->size[1] = 0;
            curVal->size[0] = 1;
            curVal->size[1] = 0;
            FlightMissionMode_emxInit_char_T_b(&tmp_1, 2);
            FlightMissionMode_emxInit_char_T_b(&tmp_2, 2);
            FlightMissionMode_emxInit_char_T_b(&data_0, 2);
            exitg1 = false;
            while ((!exitg1) && (data->size[1] != 0)) {
                b_0 = static_cast<int32_T>(data_0->size[0] * data_0->size[1]);
                data_0->size[0] = 1;
                data_0->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_o(data_0, b_0);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (b_0 = 0; b_0 <= loop_ub; b_0++) {
                    data_0->data[b_0] = data->data[b_0];
                }

                FlightMissionMode_strtok_m(data_0, curLine, data);
                FlightMissionMode_strtok_mv(curLine, tmp_2);
                FlightMissionMode_strtrim_c(tmp_2, curLine);
                if (curLine->size[1] >= 2) {
                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                c = 0;
                                b = 0;
                            } else {
                                c = 1;
                                b = static_cast<int32_T>(curLine->size[1] - 1);
                            }

                            b_0 = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(b - c);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_o
                                (curSection, b_0);
                            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1);
                                    b++) {
                                curSection->data[b] = curLine->data[static_cast<
                                    int32_T>(c + b)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains_o(curLine)) {
                            FlightMissionMode_strtok_mv4(curLine, curVal,
                                b_remainder);
                            FlightMissionMode_strtrim_c(curVal, curKey);
                            FlightMissionMode_strtok_mv4j(b_remainder, tmp_1);
                            FlightMissionMode_strtrim_c(tmp_1, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp_o(curSection) &&
                        FlightMissionMode_strcmp_oqn4q(curKey)) {
                    b_0 = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                    ret->size[0] = 1;
                    ret->size[1] = curVal->size[1];
                    FlightMissionMode_emxEnsureCapacity_char_T_o(ret, b_0);
                    loop_ub = static_cast<int32_T>(curVal->size[1] - 1);
                    for (b = 0; b <= loop_ub; b++) {
                        ret->data[b] = curVal->data[b];
                    }

                    exitg1 = true;
                }
            }

            FlightMissionMode_emxFree_char_T_d(&data_0);
            FlightMissionMode_emxFree_char_T_d(&tmp_2);
            FlightMissionMode_emxFree_char_T_d(&tmp_1);
        }

        FlightMissionMode_emxFree_char_T_d(&k);
        FlightMissionMode_emxFree_char_T_d(&b_remainder);
        FlightMissionMode_emxFree_char_T_d(&curLine);
        FlightMissionMode_emxFree_char_T_d(&curVal);
        FlightMissionMode_emxFree_char_T_d(&curKey);
        FlightMissionMode_emxFree_char_T_d(&curSection);
        FlightMissionMode_emxFree_char_T_d(&data);
        tmp_0 = FlightMissionMode_str2double_o(ret);
        fid = 0.017453292519943295 * tmp_0.re;
        printf("Set UAV MaxRollAngle:\t\t%f\n", fid);
        fflush(stdout);
        FlightMissionMode_readINI_c(ret, localDW);
        tmp_0 = FlightMissionMode_str2double_o(ret);
        ClimbAngleLimit = 0.017453292519943295 * tmp_0.re;
        printf("Set UAV ClimbAngleLimit:\t%f\n", ClimbAngleLimit);
        fflush(stdout);
        FlightMissionMode_readINI_co(ret, localDW);
        tmp_0 = FlightMissionMode_str2double_o(ret);
        DiveAngleLimit = 0.017453292519943295 * tmp_0.re;
        printf("Set UAV DiveAngleLimit:\t\t%f\n", DiveAngleLimit);
        fflush(stdout);
        FlightMissionMode_emxFree_char_T_d(&ret);
        if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(std::
                isnan(tmp.re)) ^ 1))) {
            localDW->SingletonInstance.AirSpeed = tmp.re;
        }

        if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(std::
                isnan(fid)) ^ 1))) {
            localDW->SingletonInstance.MaxRollAngle = fid;
        }

        if ((static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                (std::isnan(ClimbAngleLimit)) ^ 1))) && (static_cast<boolean_T>(
                static_cast<int32_T>(static_cast<int32_T>(std::isnan
                (DiveAngleLimit)) ^ 1)))) {
            localDW->SingletonInstance.FlightPathAngleLimit[0] = DiveAngleLimit;
            localDW->SingletonInstance.FlightPathAngleLimit[1] = ClimbAngleLimit;
        }

        for (b_0 = 0; b_0 < 2; b_0++) {
            tmp_9[b_0] = localDW->SingletonInstance.FlightPathAngleLimit[b_0];
        }

        FlightMissionMode_uavDubinsConnection_uavDubinsConnection_e
            (&localDW->SingletonInstance.Connector,
             localDW->SingletonInstance.AirSpeed,
             localDW->SingletonInstance.MaxRollAngle, tmp_9);
        localDW->SingletonInstance_not_empty = true;
    }

    outputArg = &localDW->SingletonInstance.Connector;
    return outputArg;
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_merge_p(int32_T idx_data[], int32_T
    x_data[], int32_T offset, int32_T np, int32_T nq, int32_T iwork_data[],
    int32_T xwork_data[])
{
    if (nq != 0) {
        int32_T iout;
        int32_T n;
        int32_T n_tmp;
        int32_T q;
        n_tmp = static_cast<int32_T>(np + nq);
        for (q = 0; q <= static_cast<int32_T>(n_tmp - 1); q =
                static_cast<int32_T>(q + 1)) {
            iout = static_cast<int32_T>(offset + q);
            iwork_data[q] = idx_data[iout];
            xwork_data[q] = x_data[iout];
        }

        n = 0;
        q = np;
        iout = static_cast<int32_T>(offset - 1);
        int32_T exitg1;
        do {
            exitg1 = 0;
            iout = static_cast<int32_T>(iout + 1);
            if (xwork_data[n] <= xwork_data[q]) {
                idx_data[iout] = iwork_data[n];
                x_data[iout] = xwork_data[n];
                if (static_cast<int32_T>(n + 1) < np) {
                    n = static_cast<int32_T>(n + 1);
                } else {
                    exitg1 = 1;
                }
            } else {
                idx_data[iout] = iwork_data[q];
                x_data[iout] = xwork_data[q];
                if (static_cast<int32_T>(q + 1) < n_tmp) {
                    q = static_cast<int32_T>(q + 1);
                } else {
                    q = static_cast<int32_T>(iout - n);
                    while (static_cast<int32_T>(n + 1) <= np) {
                        iout = static_cast<int32_T>(static_cast<int32_T>(q + n)
                            + 1);
                        idx_data[iout] = iwork_data[n];
                        x_data[iout] = xwork_data[n];
                        n = static_cast<int32_T>(n + 1);
                    }

                    exitg1 = 1;
                }
            }
        } while (exitg1 == 0);
    }
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_sort_o(int32_T x_data[], const int32_T
    *x_size, int32_T idx_data[], int32_T *idx_size)
{
    int32_T d_data[28];
    int32_T e_data[28];
    int32_T f_data[28];
    int32_T g_data[28];
    int32_T vwork_data[28];
    int32_T x4[4];
    int32_T b;
    int32_T c_k;
    int32_T d_size;
    int32_T dim;
    int32_T e_size;
    int32_T f_size;
    int32_T g_size;
    int32_T vstride;
    int32_T vwork_size_idx_0;
    int8_T idx4[4];
    int8_T perm[4];
    dim = 2;
    if (*x_size != 1) {
        dim = 1;
        b = static_cast<int32_T>(*x_size - 1);
    } else {
        b = 0;
    }

    vwork_size_idx_0 = static_cast<int32_T>(b + 1);
    *idx_size = *x_size;
    vstride = 1;
    c_k = 0;
    while (c_k <= static_cast<int32_T>(dim - 2)) {
        vstride = static_cast<int32_T>(vstride * *x_size);
        c_k = 1;
    }

    for (dim = 0; dim <= static_cast<int32_T>(vstride - 1); dim =
            static_cast<int32_T>(dim + 1)) {
        int32_T nQuartets;
        for (nQuartets = 0; nQuartets <= b; nQuartets = static_cast<int32_T>
                (nQuartets + 1)) {
            vwork_data[nQuartets] = x_data[static_cast<int32_T>
                (static_cast<int32_T>(nQuartets * vstride) + dim)];
        }

        e_size = vwork_size_idx_0;
        for (c_k = 0; c_k <= static_cast<int32_T>(vwork_size_idx_0 - 1); c_k++)
        {
            e_data[c_k] = vwork_data[c_k];
        }

        d_size = static_cast<int32_T>(static_cast<int8_T>(vwork_size_idx_0));
        nQuartets = static_cast<int32_T>(static_cast<int8_T>(vwork_size_idx_0));
        for (c_k = 0; c_k <= static_cast<int32_T>(nQuartets - 1); c_k++) {
            d_data[c_k] = 0;
        }

        if (vwork_size_idx_0 != 0) {
            int32_T nLeft;
            int32_T nQuartets_tmp;
            int32_T nTail;
            int32_T tailOffset;
            d_size = static_cast<int32_T>(static_cast<int8_T>(vwork_size_idx_0));
            nQuartets = static_cast<int32_T>(static_cast<int8_T>
                (vwork_size_idx_0));
            for (c_k = 0; c_k <= static_cast<int32_T>(nQuartets - 1); c_k++) {
                d_data[c_k] = 0;
            }

            x4[0] = 0;
            idx4[0] = 0;
            x4[1] = 0;
            idx4[1] = 0;
            x4[2] = 0;
            idx4[2] = 0;
            x4[3] = 0;
            idx4[3] = 0;
            f_size = static_cast<int32_T>(static_cast<int8_T>(vwork_size_idx_0));
            g_size = vwork_size_idx_0;
            nQuartets_tmp = static_cast<int32_T>(vwork_size_idx_0 >> 2);
            for (nLeft = 0; nLeft <= static_cast<int32_T>(nQuartets_tmp - 1);
                    nLeft = static_cast<int32_T>(nLeft + 1)) {
                int32_T i3;
                int32_T i4;
                int32_T tmp;
                tailOffset = static_cast<int32_T>(nLeft << 2);
                idx4[0] = static_cast<int8_T>(static_cast<int32_T>(tailOffset +
                    1));
                idx4[1] = static_cast<int8_T>(static_cast<int32_T>(tailOffset +
                    2));
                idx4[2] = static_cast<int8_T>(static_cast<int32_T>(tailOffset +
                    3));
                idx4[3] = static_cast<int8_T>(static_cast<int32_T>(tailOffset +
                    4));
                x4[0] = e_data[tailOffset];
                x4[1] = e_data[static_cast<int32_T>(tailOffset + 1)];
                x4[2] = e_data[static_cast<int32_T>(tailOffset + 2)];
                x4[3] = e_data[static_cast<int32_T>(tailOffset + 3)];
                if (e_data[tailOffset] <= e_data[static_cast<int32_T>(tailOffset
                     + 1)]) {
                    nTail = 1;
                    nQuartets = 2;
                } else {
                    nTail = 2;
                    nQuartets = 1;
                }

                if (e_data[static_cast<int32_T>(tailOffset + 2)] <= e_data[
                        static_cast<int32_T>(tailOffset + 3)]) {
                    i3 = 3;
                    i4 = 4;
                } else {
                    i3 = 4;
                    i4 = 3;
                }

                c_k = x4[static_cast<int32_T>(nTail - 1)];
                tmp = x4[static_cast<int32_T>(i3 - 1)];
                if (c_k <= tmp) {
                    c_k = x4[static_cast<int32_T>(nQuartets - 1)];
                    if (c_k <= tmp) {
                        perm[0] = static_cast<int8_T>(nTail);
                        perm[1] = static_cast<int8_T>(nQuartets);
                        perm[2] = static_cast<int8_T>(i3);
                        perm[3] = static_cast<int8_T>(i4);
                    } else if (c_k <= x4[static_cast<int32_T>(i4 - 1)]) {
                        perm[0] = static_cast<int8_T>(nTail);
                        perm[1] = static_cast<int8_T>(i3);
                        perm[2] = static_cast<int8_T>(nQuartets);
                        perm[3] = static_cast<int8_T>(i4);
                    } else {
                        perm[0] = static_cast<int8_T>(nTail);
                        perm[1] = static_cast<int8_T>(i3);
                        perm[2] = static_cast<int8_T>(i4);
                        perm[3] = static_cast<int8_T>(nQuartets);
                    }
                } else {
                    tmp = x4[static_cast<int32_T>(i4 - 1)];
                    if (c_k <= tmp) {
                        if (x4[static_cast<int32_T>(nQuartets - 1)] <= tmp) {
                            perm[0] = static_cast<int8_T>(i3);
                            perm[1] = static_cast<int8_T>(nTail);
                            perm[2] = static_cast<int8_T>(nQuartets);
                            perm[3] = static_cast<int8_T>(i4);
                        } else {
                            perm[0] = static_cast<int8_T>(i3);
                            perm[1] = static_cast<int8_T>(nTail);
                            perm[2] = static_cast<int8_T>(i4);
                            perm[3] = static_cast<int8_T>(nQuartets);
                        }
                    } else {
                        perm[0] = static_cast<int8_T>(i3);
                        perm[1] = static_cast<int8_T>(i4);
                        perm[2] = static_cast<int8_T>(nTail);
                        perm[3] = static_cast<int8_T>(nQuartets);
                    }
                }

                d_data[tailOffset] = static_cast<int32_T>(idx4
                    [static_cast<int32_T>(static_cast<int32_T>(perm[0]) - 1)]);
                d_data[static_cast<int32_T>(tailOffset + 1)] =
                    static_cast<int32_T>(idx4[static_cast<int32_T>
                    (static_cast<int32_T>(perm[1]) - 1)]);
                d_data[static_cast<int32_T>(tailOffset + 2)] =
                    static_cast<int32_T>(idx4[static_cast<int32_T>
                    (static_cast<int32_T>(perm[2]) - 1)]);
                d_data[static_cast<int32_T>(tailOffset + 3)] =
                    static_cast<int32_T>(idx4[static_cast<int32_T>
                    (static_cast<int32_T>(perm[3]) - 1)]);
                e_data[tailOffset] = x4[static_cast<int32_T>(static_cast<int32_T>
                    (perm[0]) - 1)];
                e_data[static_cast<int32_T>(tailOffset + 1)] = x4
                    [static_cast<int32_T>(static_cast<int32_T>(perm[1]) - 1)];
                e_data[static_cast<int32_T>(tailOffset + 2)] = x4
                    [static_cast<int32_T>(static_cast<int32_T>(perm[2]) - 1)];
                e_data[static_cast<int32_T>(tailOffset + 3)] = x4
                    [static_cast<int32_T>(static_cast<int32_T>(perm[3]) - 1)];
            }

            nQuartets = static_cast<int32_T>(nQuartets_tmp << 2);
            nLeft = static_cast<int32_T>(vwork_size_idx_0 - nQuartets);
            if (nLeft > 0) {
                for (tailOffset = 0; tailOffset <= static_cast<int32_T>(nLeft -
                        1); tailOffset = static_cast<int32_T>(tailOffset + 1)) {
                    c_k = static_cast<int32_T>(nQuartets + tailOffset);
                    idx4[tailOffset] = static_cast<int8_T>(static_cast<int32_T>
                        (c_k + 1));
                    x4[tailOffset] = e_data[c_k];
                }

                perm[1] = 0;
                perm[2] = 0;
                perm[3] = 0;
                switch (nLeft) {
                  case 1:
                    perm[0] = 1;
                    break;

                  case 2:
                    if (x4[0] <= x4[1]) {
                        perm[0] = 1;
                        perm[1] = 2;
                    } else {
                        perm[0] = 2;
                        perm[1] = 1;
                    }
                    break;

                  default:
                    if (x4[0] <= x4[1]) {
                        if (x4[1] <= x4[2]) {
                            perm[0] = 1;
                            perm[1] = 2;
                            perm[2] = 3;
                        } else if (x4[0] <= x4[2]) {
                            perm[0] = 1;
                            perm[1] = 3;
                            perm[2] = 2;
                        } else {
                            perm[0] = 3;
                            perm[1] = 1;
                            perm[2] = 2;
                        }
                    } else if (x4[0] <= x4[2]) {
                        perm[0] = 2;
                        perm[1] = 1;
                        perm[2] = 3;
                    } else if (x4[1] <= x4[2]) {
                        perm[0] = 2;
                        perm[1] = 3;
                        perm[2] = 1;
                    } else {
                        perm[0] = 3;
                        perm[1] = 2;
                        perm[2] = 1;
                    }
                    break;
                }

                for (tailOffset = 0; tailOffset <= static_cast<int32_T>(nLeft -
                        1); tailOffset = static_cast<int32_T>(tailOffset + 1)) {
                    c_k = static_cast<int32_T>(static_cast<int32_T>
                        (perm[tailOffset]) - 1);
                    nTail = static_cast<int32_T>(nQuartets + tailOffset);
                    d_data[nTail] = static_cast<int32_T>(idx4[c_k]);
                    e_data[nTail] = x4[c_k];
                }
            }

            if (vwork_size_idx_0 > 1) {
                nQuartets = f_size;
                f_size = nQuartets;
                for (c_k = 0; c_k <= static_cast<int32_T>(nQuartets - 1); c_k++)
                {
                    f_data[c_k] = 0;
                }

                nQuartets = g_size;
                g_size = nQuartets;
                for (c_k = 0; c_k <= static_cast<int32_T>(nQuartets - 1); c_k++)
                {
                    g_data[c_k] = 0;
                }

                nLeft = nQuartets_tmp;
                nQuartets = 4;
                while (nLeft > 1) {
                    if (static_cast<uint32_T>(static_cast<uint32_T>(nLeft) & 1U)
                        != 0U) {
                        nLeft = static_cast<int32_T>(nLeft - 1);
                        tailOffset = static_cast<int32_T>(nQuartets * nLeft);
                        nTail = static_cast<int32_T>(vwork_size_idx_0 -
                            tailOffset);
                        if (nTail > nQuartets) {
                            FlightMissionMode_merge_p(d_data, e_data, tailOffset,
                                nQuartets, static_cast<int32_T>(nTail -
                                nQuartets), f_data, g_data);
                        }
                    }

                    tailOffset = static_cast<int32_T>(nQuartets << 1);
                    nLeft = static_cast<int32_T>(nLeft >> 1);
                    for (nTail = 0; nTail <= static_cast<int32_T>(nLeft - 1);
                            nTail = static_cast<int32_T>(nTail + 1)) {
                        FlightMissionMode_merge_p(d_data, e_data,
                            static_cast<int32_T>(nTail * tailOffset), nQuartets,
                            nQuartets, f_data, g_data);
                    }

                    nQuartets = tailOffset;
                }

                if (vwork_size_idx_0 > nQuartets) {
                    FlightMissionMode_merge_p(d_data, e_data, 0, nQuartets,
                        static_cast<int32_T>(vwork_size_idx_0 - nQuartets),
                        f_data, g_data);
                }
            }
        }

        vwork_size_idx_0 = e_size;
        nQuartets = e_size;
        for (c_k = 0; c_k <= static_cast<int32_T>(nQuartets - 1); c_k++) {
            vwork_data[c_k] = e_data[c_k];
        }

        for (nQuartets = 0; nQuartets <= b; nQuartets = static_cast<int32_T>
                (nQuartets + 1)) {
            c_k = static_cast<int32_T>(static_cast<int32_T>(nQuartets * vstride)
                + dim);
            x_data[c_k] = e_data[nQuartets];
            idx_data[c_k] = d_data[nQuartets];
        }
    }
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_do_vectors_d(real_T c_data[], int32_T
    c_size[2], int32_T ia_data[], int32_T *ia_size, int32_T *ib_size)
{
    static const real_T f[28]{ 6.384265086E+9, 6.384265284E+9, 6.384480708E+9,
        6.384480906E+9, 6.384473283E+9, 6.384263997E+9, 2.1067690282E+11,
        2.10676902826E+11, 2.10677124976E+11, 2.10677124982E+11,
        2.10677124751E+11, 2.10676902787E+11, 2.10680747748E+11,
        2.10680754288E+11, 2.10687863274E+11, 2.10687869814E+11,
        2.10687618255E+11, 2.10680711811E+11, 6.384264226E+9, 6.384264232E+9,
        6.384264001E+9, 6.38447332E+9, 6.384473281E+9, 6.384473314E+9,
        6.384265282E+9, 6.384480904E+9, 6.38426509E+9, 6.384480712E+9 };

    static const int8_T e[28]{ 6, 21, 19, 20, 1, 27, 25, 2, 23, 5, 24, 22, 3, 28,
        26, 4, 12, 7, 8, 11, 9, 10, 18, 13, 14, 17, 15, 16 };

    emxArray_int32_T_28_FlightMissionMode_T ia_data_0;
    int32_T iafirst;
    int32_T ialast;
    int32_T nc;
    int32_T nia;
    c_size[0] = 1;
    *ib_size = 0;
    nc = 0;
    nia = -1;
    iafirst = 0;
    ialast = 1;
    while (ialast <= 28) {
        int32_T b_ialast;
        b_ialast = ialast;
        while ((b_ialast < 28) && (f[static_cast<int32_T>(static_cast<int32_T>
                 (e[static_cast<int32_T>(ialast - 1)]) - 1)] == f
                                   [static_cast<int32_T>(static_cast<int32_T>
                 (e[b_ialast]) - 1)])) {
            b_ialast = static_cast<int32_T>(b_ialast + 1);
        }

        nc = static_cast<int32_T>(nc + 1);
        nia = static_cast<int32_T>(nia + 1);
        ia_data[nia] = static_cast<int32_T>(e[iafirst]);
        ialast = static_cast<int32_T>(b_ialast + 1);
        iafirst = b_ialast;
    }

    if (static_cast<int32_T>(nia + 1) < 1) {
        iafirst = -1;
    } else {
        iafirst = nia;
    }

    *ia_size = static_cast<int32_T>(iafirst + 1);
    FlightMissionMode_sort_o(ia_data, ia_size, ia_data_0.data, &ia_data_0.size);
    for (iafirst = 0; iafirst <= nia; iafirst = static_cast<int32_T>(iafirst + 1))
    {
        c_data[iafirst] = f[static_cast<int32_T>(ia_data[iafirst] - 1)];
    }

    if (nc < 1) {
        c_size[1] = 0;
    } else {
        c_size[1] = nc;
    }
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_do_vectors_dl(const real_T b_data[],
    const int32_T *b_size, real_T c_data[], int32_T c_size[2], int32_T ia_data[],
    int32_T *ia_size, int32_T *ib_size)
{
    emxArray_int32_T_28_FlightMissionMode_T ia_data_0;
    real_T bk;
    int32_T bperm_data[28];
    int32_T iwork_data[28];
    int32_T b_p;
    int32_T i;
    int32_T i2;
    int32_T j;
    int32_T kEnd;
    int32_T n;
    int32_T pEnd;
    int32_T qEnd;
    c_size[0] = 1;
    *ib_size = 0;
    i = static_cast<int32_T>(static_cast<int8_T>(*b_size));
    for (n = 0; n <= static_cast<int32_T>(i - 1); n++) {
        bperm_data[n] = 0;
    }

    if (*b_size != 0) {
        for (i = 1; i <= static_cast<int32_T>(static_cast<int32_T>(*b_size + 1)
                - 2); i = static_cast<int32_T>(i + 2)) {
            if (static_cast<boolean_T>(static_cast<int32_T>((b_data[static_cast<
                    int32_T>(i - 1)] <= b_data[i]) | static_cast<int32_T>(std::
                    isnan(b_data[i]))))) {
                bperm_data[static_cast<int32_T>(i - 1)] = i;
                bperm_data[i] = static_cast<int32_T>(i + 1);
            } else {
                bperm_data[static_cast<int32_T>(i - 1)] = static_cast<int32_T>(i
                    + 1);
                bperm_data[i] = i;
            }
        }

        if (static_cast<uint32_T>(static_cast<uint32_T>(*b_size) & 1U) != 0U) {
            bperm_data[static_cast<int32_T>(*b_size - 1)] = *b_size;
        }

        i = 2;
        while (i < static_cast<int32_T>(static_cast<int32_T>(*b_size + 1) - 1))
        {
            i2 = static_cast<int32_T>(i << 1);
            j = 1;
            pEnd = static_cast<int32_T>(i + 1);
            while (pEnd < static_cast<int32_T>(*b_size + 1)) {
                int32_T c_k;
                int32_T q;
                b_p = j;
                q = static_cast<int32_T>(pEnd - 1);
                qEnd = static_cast<int32_T>(j + i2);
                if (qEnd > static_cast<int32_T>(*b_size + 1)) {
                    qEnd = static_cast<int32_T>(*b_size + 1);
                }

                c_k = 0;
                kEnd = static_cast<int32_T>(qEnd - j);
                while (static_cast<int32_T>(c_k + 1) <= kEnd) {
                    bk = b_data[static_cast<int32_T>(bperm_data[q] - 1)];
                    n = bperm_data[static_cast<int32_T>(b_p - 1)];
                    if (static_cast<boolean_T>(static_cast<int32_T>((b_data[
                            static_cast<int32_T>(n - 1)] <= bk) |
                            static_cast<int32_T>(std::isnan(bk))))) {
                        iwork_data[c_k] = n;
                        b_p = static_cast<int32_T>(b_p + 1);
                        if (b_p == pEnd) {
                            while (static_cast<int32_T>(q + 1) < qEnd) {
                                c_k = static_cast<int32_T>(c_k + 1);
                                iwork_data[c_k] = bperm_data[q];
                                q = static_cast<int32_T>(q + 1);
                            }
                        }
                    } else {
                        iwork_data[c_k] = bperm_data[q];
                        q = static_cast<int32_T>(q + 1);
                        if (static_cast<int32_T>(q + 1) == qEnd) {
                            while (b_p < pEnd) {
                                c_k = static_cast<int32_T>(c_k + 1);
                                iwork_data[c_k] = bperm_data[static_cast<int32_T>
                                    (b_p - 1)];
                                b_p = static_cast<int32_T>(b_p + 1);
                            }
                        }
                    }

                    c_k = static_cast<int32_T>(c_k + 1);
                }

                for (pEnd = 0; pEnd <= static_cast<int32_T>(kEnd - 1); pEnd =
                        static_cast<int32_T>(pEnd + 1)) {
                    bperm_data[static_cast<int32_T>(static_cast<int32_T>(j +
                        pEnd) - 1)] = iwork_data[pEnd];
                }

                j = qEnd;
                pEnd = static_cast<int32_T>(qEnd + i);
            }

            i = i2;
        }
    }

    n = 0;
    i = -1;
    i2 = 0;
    j = 1;
    qEnd = 1;
    while ((j <= 28) && (qEnd <= *b_size)) {
        kEnd = j;
        pEnd = j;
        while (static_cast<boolean_T>(static_cast<int32_T>((static_cast<int32_T>
                  (kEnd + 1) == j) & (kEnd < 28)))) {
            kEnd = static_cast<int32_T>(kEnd + 1);
        }

        j = kEnd;
        b_p = qEnd;
        bk = b_data[static_cast<int32_T>(bperm_data[static_cast<int32_T>(qEnd -
            1)] - 1)];
        while ((b_p < *b_size) && (b_data[static_cast<int32_T>(bperm_data[b_p] -
                 1)] == bk)) {
            b_p = static_cast<int32_T>(b_p + 1);
        }

        qEnd = b_p;
        if (static_cast<real_T>(pEnd) == bk) {
            j = static_cast<int32_T>(kEnd + 1);
            i2 = kEnd;
            qEnd = static_cast<int32_T>(b_p + 1);
        } else if (static_cast<boolean_T>(static_cast<int32_T>
                    ((static_cast<real_T>(pEnd) < bk) | static_cast<int32_T>(std::
                      isnan(bk))))) {
            n = static_cast<int32_T>(n + 1);
            i = static_cast<int32_T>(i + 1);
            ia_data[i] = static_cast<int32_T>(i2 + 1);
            j = static_cast<int32_T>(kEnd + 1);
            i2 = kEnd;
        } else {
            qEnd = static_cast<int32_T>(b_p + 1);
        }
    }

    while (j <= 28) {
        qEnd = j;
        while (static_cast<boolean_T>(static_cast<int32_T>((static_cast<int32_T>
                  (qEnd + 1) == j) & (qEnd < 28)))) {
            qEnd = static_cast<int32_T>(qEnd + 1);
        }

        n = static_cast<int32_T>(n + 1);
        i = static_cast<int32_T>(i + 1);
        ia_data[i] = static_cast<int32_T>(i2 + 1);
        j = static_cast<int32_T>(qEnd + 1);
        i2 = qEnd;
    }

    if (static_cast<int32_T>(i + 1) < 1) {
        i2 = -1;
    } else {
        i2 = i;
    }

    *ia_size = static_cast<int32_T>(i2 + 1);
    FlightMissionMode_sort_o(ia_data, ia_size, ia_data_0.data, &ia_data_0.size);
    for (i2 = 0; i2 <= i; i2 = static_cast<int32_T>(i2 + 1)) {
        c_data[i2] = static_cast<real_T>(static_cast<int32_T>(ia_data[i2] - 1))
            + 1.0;
    }

    if (n < 1) {
        c_size[1] = 0;
    } else {
        c_size[1] = n;
    }
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_merge_p2(int32_T idx_data[], real_T
    x_data[], int32_T offset, int32_T np, int32_T nq, int32_T iwork_data[],
    real_T xwork_data[])
{
    if (nq != 0) {
        int32_T iout;
        int32_T n;
        int32_T n_tmp;
        int32_T q;
        n_tmp = static_cast<int32_T>(np + nq);
        for (q = 0; q <= static_cast<int32_T>(n_tmp - 1); q =
                static_cast<int32_T>(q + 1)) {
            iout = static_cast<int32_T>(offset + q);
            iwork_data[q] = idx_data[iout];
            xwork_data[q] = x_data[iout];
        }

        n = 0;
        q = np;
        iout = static_cast<int32_T>(offset - 1);
        int32_T exitg1;
        do {
            exitg1 = 0;
            iout = static_cast<int32_T>(iout + 1);
            if (xwork_data[n] <= xwork_data[q]) {
                idx_data[iout] = iwork_data[n];
                x_data[iout] = xwork_data[n];
                if (static_cast<int32_T>(n + 1) < np) {
                    n = static_cast<int32_T>(n + 1);
                } else {
                    exitg1 = 1;
                }
            } else {
                idx_data[iout] = iwork_data[q];
                x_data[iout] = xwork_data[q];
                if (static_cast<int32_T>(q + 1) < n_tmp) {
                    q = static_cast<int32_T>(q + 1);
                } else {
                    q = static_cast<int32_T>(iout - n);
                    while (static_cast<int32_T>(n + 1) <= np) {
                        iout = static_cast<int32_T>(static_cast<int32_T>(q + n)
                            + 1);
                        idx_data[iout] = iwork_data[n];
                        x_data[iout] = xwork_data[n];
                        n = static_cast<int32_T>(n + 1);
                    }

                    exitg1 = 1;
                }
            }
        } while (exitg1 == 0);
    }
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_sort_oi(real_T x_data[], const int32_T
    *x_size)
{
    real_T e_data[28];
    real_T g_data[28];
    real_T vwork_data[28];
    real_T x4[4];
    int32_T d_data[28];
    int32_T f_data[28];
    int32_T b;
    int32_T d_size;
    int32_T dim;
    int32_T e_size;
    int32_T f_size;
    int32_T g_size;
    int32_T n;
    int32_T vstride;
    int32_T vwork_size_idx_0;
    int8_T idx4[4];
    int8_T perm[4];
    dim = 2;
    if (*x_size != 1) {
        dim = 1;
        b = static_cast<int32_T>(*x_size - 1);
    } else {
        b = 0;
    }

    vwork_size_idx_0 = static_cast<int32_T>(b + 1);
    vstride = 1;
    n = 0;
    while (n <= static_cast<int32_T>(dim - 2)) {
        vstride = static_cast<int32_T>(vstride * *x_size);
        n = 1;
    }

    for (dim = 0; dim <= static_cast<int32_T>(vstride - 1); dim =
            static_cast<int32_T>(dim + 1)) {
        int32_T bLen;
        for (n = 0; n <= b; n = static_cast<int32_T>(n + 1)) {
            vwork_data[n] = x_data[static_cast<int32_T>(static_cast<int32_T>(n *
                vstride) + dim)];
        }

        e_size = vwork_size_idx_0;
        for (bLen = 0; bLen <= static_cast<int32_T>(vwork_size_idx_0 - 1); bLen
                ++) {
            e_data[bLen] = vwork_data[bLen];
        }

        if (vwork_size_idx_0 != 0) {
            int32_T i3;
            int32_T i4;
            int32_T itmp;
            int32_T nTail;
            int32_T wOffset;
            int32_T wOffset_tmp;
            d_size = static_cast<int32_T>(static_cast<int8_T>(vwork_size_idx_0));
            n = static_cast<int32_T>(static_cast<int8_T>(vwork_size_idx_0));
            for (bLen = 0; bLen <= static_cast<int32_T>(n - 1); bLen++) {
                d_data[bLen] = 0;
            }

            x4[0] = 0.0;
            idx4[0] = 0;
            x4[1] = 0.0;
            idx4[1] = 0;
            x4[2] = 0.0;
            idx4[2] = 0;
            x4[3] = 0.0;
            idx4[3] = 0;
            f_size = static_cast<int32_T>(static_cast<int8_T>(vwork_size_idx_0));
            g_size = vwork_size_idx_0;
            n = g_size;
            g_size = n;
            for (bLen = 0; bLen <= static_cast<int32_T>(n - 1); bLen++) {
                g_data[bLen] = 0.0;
            }

            bLen = 1;
            n = 0;
            for (wOffset = 0; wOffset <= static_cast<int32_T>(vwork_size_idx_0 -
                  1); wOffset = static_cast<int32_T>(wOffset + 1)) {
                if (std::isnan(e_data[wOffset])) {
                    i3 = static_cast<int32_T>(vwork_size_idx_0 - bLen);
                    d_data[i3] = static_cast<int32_T>(wOffset + 1);
                    g_data[i3] = e_data[wOffset];
                    bLen = static_cast<int32_T>(bLen + 1);
                } else {
                    n = static_cast<int32_T>(n + 1);
                    idx4[static_cast<int32_T>(n - 1)] = static_cast<int8_T>(
                        static_cast<int32_T>(wOffset + 1));
                    x4[static_cast<int32_T>(n - 1)] = e_data[wOffset];
                    if (n == 4) {
                        real_T tmp;
                        real_T tmp_0;
                        n = static_cast<int32_T>(wOffset - bLen);
                        if (x4[0] <= x4[1]) {
                            nTail = 1;
                            itmp = 2;
                        } else {
                            nTail = 2;
                            itmp = 1;
                        }

                        if (x4[2] <= x4[3]) {
                            i3 = 3;
                            i4 = 4;
                        } else {
                            i3 = 4;
                            i4 = 3;
                        }

                        tmp = x4[static_cast<int32_T>(nTail - 1)];
                        tmp_0 = x4[static_cast<int32_T>(i3 - 1)];
                        if (tmp <= tmp_0) {
                            tmp = x4[static_cast<int32_T>(itmp - 1)];
                            if (tmp <= tmp_0) {
                                perm[0] = static_cast<int8_T>(nTail);
                                perm[1] = static_cast<int8_T>(itmp);
                                perm[2] = static_cast<int8_T>(i3);
                                perm[3] = static_cast<int8_T>(i4);
                            } else if (tmp <= x4[static_cast<int32_T>(i4 - 1)])
                            {
                                perm[0] = static_cast<int8_T>(nTail);
                                perm[1] = static_cast<int8_T>(i3);
                                perm[2] = static_cast<int8_T>(itmp);
                                perm[3] = static_cast<int8_T>(i4);
                            } else {
                                perm[0] = static_cast<int8_T>(nTail);
                                perm[1] = static_cast<int8_T>(i3);
                                perm[2] = static_cast<int8_T>(i4);
                                perm[3] = static_cast<int8_T>(itmp);
                            }
                        } else {
                            tmp_0 = x4[static_cast<int32_T>(i4 - 1)];
                            if (tmp <= tmp_0) {
                                if (x4[static_cast<int32_T>(itmp - 1)] <= tmp_0)
                                {
                                    perm[0] = static_cast<int8_T>(i3);
                                    perm[1] = static_cast<int8_T>(nTail);
                                    perm[2] = static_cast<int8_T>(itmp);
                                    perm[3] = static_cast<int8_T>(i4);
                                } else {
                                    perm[0] = static_cast<int8_T>(i3);
                                    perm[1] = static_cast<int8_T>(nTail);
                                    perm[2] = static_cast<int8_T>(i4);
                                    perm[3] = static_cast<int8_T>(itmp);
                                }
                            } else {
                                perm[0] = static_cast<int8_T>(i3);
                                perm[1] = static_cast<int8_T>(i4);
                                perm[2] = static_cast<int8_T>(nTail);
                                perm[3] = static_cast<int8_T>(itmp);
                            }
                        }

                        d_data[static_cast<int32_T>(n - 2)] = static_cast<
                            int32_T>(idx4[static_cast<int32_T>
                                     (static_cast<int32_T>(perm[0]) - 1)]);
                        d_data[static_cast<int32_T>(n - 1)] =
                            static_cast<int32_T>(idx4[static_cast<int32_T>(
                            static_cast<int32_T>(perm[1]) - 1)]);
                        d_data[n] = static_cast<int32_T>(idx4
                            [static_cast<int32_T>(static_cast<int32_T>(perm[2])
                            - 1)]);
                        d_data[static_cast<int32_T>(n + 1)] =
                            static_cast<int32_T>(idx4[static_cast<int32_T>(
                            static_cast<int32_T>(perm[3]) - 1)]);
                        e_data[static_cast<int32_T>(n - 2)] = x4
                            [static_cast<int32_T>(static_cast<int32_T>(perm[0])
                            - 1)];
                        e_data[static_cast<int32_T>(n - 1)] = x4
                            [static_cast<int32_T>(static_cast<int32_T>(perm[1])
                            - 1)];
                        e_data[n] = x4[static_cast<int32_T>(static_cast<int32_T>
                            (perm[2]) - 1)];
                        e_data[static_cast<int32_T>(n + 1)] = x4
                            [static_cast<int32_T>(static_cast<int32_T>(perm[3])
                            - 1)];
                        n = 0;
                    }
                }
            }

            wOffset_tmp = static_cast<int32_T>(vwork_size_idx_0 - bLen);
            if (n > 0) {
                perm[1] = 0;
                perm[2] = 0;
                perm[3] = 0;
                switch (n) {
                  case 1:
                    perm[0] = 1;
                    break;

                  case 2:
                    if (x4[0] <= x4[1]) {
                        perm[0] = 1;
                        perm[1] = 2;
                    } else {
                        perm[0] = 2;
                        perm[1] = 1;
                    }
                    break;

                  default:
                    if (x4[0] <= x4[1]) {
                        if (x4[1] <= x4[2]) {
                            perm[0] = 1;
                            perm[1] = 2;
                            perm[2] = 3;
                        } else if (x4[0] <= x4[2]) {
                            perm[0] = 1;
                            perm[1] = 3;
                            perm[2] = 2;
                        } else {
                            perm[0] = 3;
                            perm[1] = 1;
                            perm[2] = 2;
                        }
                    } else if (x4[0] <= x4[2]) {
                        perm[0] = 2;
                        perm[1] = 1;
                        perm[2] = 3;
                    } else if (x4[1] <= x4[2]) {
                        perm[0] = 2;
                        perm[1] = 3;
                        perm[2] = 1;
                    } else {
                        perm[0] = 3;
                        perm[1] = 2;
                        perm[2] = 1;
                    }
                    break;
                }

                for (nTail = 0; nTail <= static_cast<int32_T>(n - 1); nTail =
                        static_cast<int32_T>(nTail + 1)) {
                    i3 = static_cast<int32_T>(static_cast<int32_T>(perm[nTail])
                        - 1);
                    itmp = static_cast<int32_T>(static_cast<int32_T>(
                        static_cast<int32_T>(wOffset_tmp - n) + nTail) + 1);
                    d_data[itmp] = static_cast<int32_T>(idx4[i3]);
                    e_data[itmp] = x4[i3];
                }
            }

            n = static_cast<int32_T>(static_cast<int32_T>(static_cast<int32_T>
                (bLen - 1) >> 1) + 1);
            for (nTail = 1; static_cast<int32_T>(nTail - 1) <=
                    static_cast<int32_T>(n - 2); nTail = static_cast<int32_T>
                    (nTail + 1)) {
                i4 = static_cast<int32_T>(wOffset_tmp + nTail);
                itmp = d_data[i4];
                wOffset = static_cast<int32_T>(vwork_size_idx_0 - nTail);
                d_data[i4] = d_data[wOffset];
                d_data[wOffset] = itmp;
                e_data[i4] = g_data[wOffset];
                e_data[wOffset] = g_data[i4];
            }

            if (static_cast<uint32_T>(static_cast<uint32_T>(static_cast<int32_T>
                    (bLen - 1)) & 1U) != 0U) {
                n = static_cast<int32_T>(wOffset_tmp + n);
                e_data[n] = g_data[n];
            }

            if (static_cast<int32_T>(wOffset_tmp + 1) > 1) {
                n = f_size;
                f_size = n;
                for (bLen = 0; bLen <= static_cast<int32_T>(n - 1); bLen++) {
                    f_data[bLen] = 0;
                }

                wOffset = static_cast<int32_T>(static_cast<int32_T>(wOffset_tmp
                    + 1) >> 2);
                bLen = 4;
                while (wOffset > 1) {
                    if (static_cast<uint32_T>(static_cast<uint32_T>(wOffset) &
                                              1U) != 0U) {
                        wOffset = static_cast<int32_T>(wOffset - 1);
                        n = static_cast<int32_T>(bLen * wOffset);
                        nTail = static_cast<int32_T>(static_cast<int32_T>
                            (wOffset_tmp - n) + 1);
                        if (nTail > bLen) {
                            FlightMissionMode_merge_p2(d_data, e_data, n, bLen,
                                static_cast<int32_T>(nTail - bLen), f_data,
                                g_data);
                        }
                    }

                    n = static_cast<int32_T>(bLen << 1);
                    wOffset = static_cast<int32_T>(wOffset >> 1);
                    for (nTail = 0; nTail <= static_cast<int32_T>(wOffset - 1);
                            nTail = static_cast<int32_T>(nTail + 1)) {
                        FlightMissionMode_merge_p2(d_data, e_data,
                            static_cast<int32_T>(nTail * n), bLen, bLen, f_data,
                            g_data);
                    }

                    bLen = n;
                }

                if (static_cast<int32_T>(wOffset_tmp + 1) > bLen) {
                    FlightMissionMode_merge_p2(d_data, e_data, 0, bLen,
                        static_cast<int32_T>(static_cast<int32_T>(wOffset_tmp -
                        bLen) + 1), f_data, g_data);
                }
            }
        }

        vwork_size_idx_0 = e_size;
        n = e_size;
        for (bLen = 0; bLen <= static_cast<int32_T>(n - 1); bLen++) {
            vwork_data[bLen] = e_data[bLen];
        }

        for (n = 0; n <= b; n = static_cast<int32_T>(n + 1)) {
            x_data[static_cast<int32_T>(dim + static_cast<int32_T>(n * vstride))]
                = e_data[n];
        }
    }
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void* FlightMissionMode::
    FlightMissionMode_uavDubinsBuildable_uavDubinsBuildable_i(real_T airSpeed,
    real_T maxRollAngle, const real_T flightPathAngle[2], const real_T
    disabledPathTypes_data[], const int32_T *disabledPathTypes_size)
{
    real_T b_disabledPathTypes_data[28];
    real_T b_flightPathAngle[2];
    int32_T loop_ub;
    b_flightPathAngle[0] = flightPathAngle[0];
    b_flightPathAngle[1] = flightPathAngle[1];
    loop_ub = *disabledPathTypes_size;
    for (int32_T i{0}; i <= static_cast<int32_T>(loop_ub - 1); i++) {
        b_disabledPathTypes_data[i] = disabledPathTypes_data[i];
    }

    return uavDubinsConnectionObj(airSpeed, maxRollAngle, &b_flightPathAngle[0],
        &b_disabledPathTypes_data[0], static_cast<uint32_T>
        (*disabledPathTypes_size));
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_oqn4q5(const char_T
    a_data[], const int32_T a_size[2])
{
    static const char_T b[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T c[2]{ 'H', 'L' };

    boolean_T b_bool;
    b_bool = false;
    if (a_size[1] == 2) {
        int32_T kstr;
        kstr = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (kstr < 2) {
                if (b[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(a_data[kstr]))
                                           & 127)] != b[static_cast<int32_T>
                        (c[kstr])]) {
                    exitg1 = 1;
                } else {
                    kstr = static_cast<int32_T>(kstr + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    return b_bool;
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_oqn4q52(const char_T
    a_data[], const int32_T a_size[2])
{
    static const char_T b[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T c[2]{ 'H', 'R' };

    boolean_T b_bool;
    b_bool = false;
    if (a_size[1] == 2) {
        int32_T kstr;
        kstr = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (kstr < 2) {
                if (b[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(a_data[kstr]))
                                           & 127)] != b[static_cast<int32_T>
                        (c[kstr])]) {
                    exitg1 = 1;
                } else {
                    kstr = static_cast<int32_T>(kstr + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    return b_bool;
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::
    FlightMissionMode_uavDubinsPathSegment_uavDubinsPathSegment_n1(const real_T
    varargin_1[4], const real_T varargin_2[4], real_T varargin_3, real_T
    varargin_4, real_T varargin_5, real_T varargin_6, const
    cell_wrap_11_FlightMissionMode_T varargin_7[4], const real_T varargin_8[4],
    uavDubinsPathSegment_FlightMissionMode_g_T *b_this)
{
    static const char_T d[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K',
        'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',
        'Z', '[', '\\', ']', '^', '_', '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
        'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',
        'V', 'W', 'X', 'Y', 'Z', '{', '|', '}', '~', '\x7f' };

    real_T thetaWrap;
    b_this->MinTurningRadius = varargin_5;
    b_this->StartPose[0] = varargin_1[0];
    b_this->StartPose[1] = varargin_1[1];
    b_this->StartPose[2] = varargin_1[2];
    thetaWrap = mod_d42kHWKw(varargin_1[3]);
    b_this->StartPose[3] = thetaWrap;
    if (static_cast<boolean_T>(static_cast<int32_T>((thetaWrap == 0.0) &
            (varargin_1[3] > 0.0)))) {
        b_this->StartPose[3] = 6.2831853071795862;
    }

    wrapToPi_kQV0kjUY(&b_this->StartPose[3]);
    b_this->GoalPose[0] = varargin_2[0];
    b_this->GoalPose[1] = varargin_2[1];
    b_this->GoalPose[2] = varargin_2[2];
    thetaWrap = mod_d42kHWKw(varargin_2[3]);
    b_this->GoalPose[3] = thetaWrap;
    if (static_cast<boolean_T>(static_cast<int32_T>((thetaWrap == 0.0) &
            (varargin_2[3] > 0.0)))) {
        b_this->GoalPose[3] = 6.2831853071795862;
    }

    wrapToPi_kQV0kjUY(&b_this->GoalPose[3]);
    b_this->AirSpeed = varargin_4;
    b_this->HelixRadius = varargin_6;
    b_this->FlightPathAngle = varargin_3;
    b_this->MotionLengths[0] = varargin_8[0];
    b_this->MotionTypes[0] = varargin_7[0];
    b_this->MotionLengths[1] = varargin_8[1];
    b_this->MotionTypes[1] = varargin_7[1];
    b_this->MotionLengths[2] = varargin_8[2];
    b_this->MotionTypes[2] = varargin_7[2];
    b_this->MotionLengths[3] = varargin_8[3];
    b_this->MotionTypes[3] = varargin_7[3];
    b_this->MotionTypes[0].f1.size[0] = 1;
    b_this->MotionTypes[0].f1.size[1] = varargin_7[0].f1.size[1];
    for (int32_T k{0}; k <= static_cast<int32_T>(varargin_7[0].f1.size[1] - 1);
            k = static_cast<int32_T>(k + 1)) {
        b_this->MotionTypes[0].f1.data[k] = d[static_cast<int32_T>(varargin_7[0]
            .f1.data[k])];
    }

    b_this->MotionTypes[1].f1.size[0] = 1;
    b_this->MotionTypes[1].f1.size[1] = 1;
    b_this->MotionTypes[1].f1.data[0] = d[static_cast<int32_T>
        (static_cast<int32_T>(static_cast<uint8_T>(varargin_7[1].f1.data[0])) &
         127)];
    b_this->MotionTypes[2].f1.size[0] = 1;
    b_this->MotionTypes[2].f1.size[1] = 1;
    b_this->MotionTypes[2].f1.data[0] = d[static_cast<int32_T>
        (static_cast<int32_T>(static_cast<uint8_T>(varargin_7[2].f1.data[0])) &
         127)];
    b_this->MotionTypes[3].f1.size[0] = 1;
    b_this->MotionTypes[3].f1.size[1] = varargin_7[3].f1.size[1];
    for (int32_T k{0}; k <= static_cast<int32_T>(varargin_7[3].f1.size[1] - 1);
            k = static_cast<int32_T>(k + 1)) {
        b_this->MotionTypes[3].f1.data[k] = d[static_cast<int32_T>(varargin_7[3]
            .f1.data[k])];
    }

    if (FlightMissionMode_strcmp_oqn4q5(b_this->MotionTypes[0].f1.data,
            b_this->MotionTypes[0].f1.size)) {
        b_this->MotionTypes[0].f1.size[0] = 1;
        b_this->MotionTypes[0].f1.size[1] = 2;
        b_this->MotionTypes[0].f1.data[0] = 'H';
        b_this->MotionTypes[0].f1.data[1] = 'l';
    } else if (FlightMissionMode_strcmp_oqn4q52(b_this->MotionTypes[0].f1.data,
                b_this->MotionTypes[0].f1.size)) {
        b_this->MotionTypes[0].f1.size[0] = 1;
        b_this->MotionTypes[0].f1.size[1] = 2;
        b_this->MotionTypes[0].f1.data[0] = 'H';
        b_this->MotionTypes[0].f1.data[1] = 'r';
    } else if (FlightMissionMode_strcmp_oqn4q52(b_this->MotionTypes[3].f1.data,
                b_this->MotionTypes[3].f1.size)) {
        b_this->MotionTypes[3].f1.size[0] = 1;
        b_this->MotionTypes[3].f1.size[1] = 2;
        b_this->MotionTypes[3].f1.data[0] = 'H';
        b_this->MotionTypes[3].f1.data[1] = 'r';
    } else if (FlightMissionMode_strcmp_oqn4q5(b_this->MotionTypes[3].f1.data,
                b_this->MotionTypes[3].f1.size)) {
        b_this->MotionTypes[3].f1.size[0] = 1;
        b_this->MotionTypes[3].f1.size[1] = 2;
        b_this->MotionTypes[3].f1.data[0] = 'H';
        b_this->MotionTypes[3].f1.data[1] = 'l';
    }

    b_this->Length = ((varargin_8[0] + varargin_8[1]) + varargin_8[2]) +
        varargin_8[3];
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_uavDubinsBuiltins_connect_d(const
    uavDubinsConnection_FlightMissionMode_c_T *obj, const real_T startPose[4],
    const real_T goalPose[4], real_T turningRadius, const real_T dpt_data[],
    const int32_T *dpt_size, uavDubinsPathSegment_FlightMissionMode_g_T
    *pathSegObjs, real_T *pathCosts)
{
    void* b_obj_UAVDubinsBuildableObj;
    cell_wrap_11_FlightMissionMode_T ac;
    cell_wrap_11_FlightMissionMode_T ad;
    cell_wrap_11_FlightMissionMode_T ae;
    cell_wrap_11_FlightMissionMode_T af;
    cell_wrap_11_FlightMissionMode_T bc;
    cell_wrap_11_FlightMissionMode_T bd;
    cell_wrap_11_FlightMissionMode_T be;
    cell_wrap_11_FlightMissionMode_T bf;
    cell_wrap_11_FlightMissionMode_T cc;
    cell_wrap_11_FlightMissionMode_T cd;
    cell_wrap_11_FlightMissionMode_T ce;
    cell_wrap_11_FlightMissionMode_T cf;
    cell_wrap_11_FlightMissionMode_T dc;
    cell_wrap_11_FlightMissionMode_T dd;
    cell_wrap_11_FlightMissionMode_T de;
    cell_wrap_11_FlightMissionMode_T df;
    cell_wrap_11_FlightMissionMode_T ec;
    cell_wrap_11_FlightMissionMode_T ed;
    cell_wrap_11_FlightMissionMode_T ee;
    cell_wrap_11_FlightMissionMode_T ef;
    cell_wrap_11_FlightMissionMode_T fc;
    cell_wrap_11_FlightMissionMode_T fd;
    cell_wrap_11_FlightMissionMode_T fe;
    cell_wrap_11_FlightMissionMode_T ff;
    cell_wrap_11_FlightMissionMode_T gc;
    cell_wrap_11_FlightMissionMode_T gd;
    cell_wrap_11_FlightMissionMode_T ge;
    cell_wrap_11_FlightMissionMode_T gf;
    cell_wrap_11_FlightMissionMode_T hc;
    cell_wrap_11_FlightMissionMode_T hd;
    cell_wrap_11_FlightMissionMode_T he;
    cell_wrap_11_FlightMissionMode_T hf;
    cell_wrap_11_FlightMissionMode_T ib;
    cell_wrap_11_FlightMissionMode_T ic;
    cell_wrap_11_FlightMissionMode_T id;
    cell_wrap_11_FlightMissionMode_T ie;
    cell_wrap_11_FlightMissionMode_T jb;
    cell_wrap_11_FlightMissionMode_T jc;
    cell_wrap_11_FlightMissionMode_T jd;
    cell_wrap_11_FlightMissionMode_T je;
    cell_wrap_11_FlightMissionMode_T jf;
    cell_wrap_11_FlightMissionMode_T kb;
    cell_wrap_11_FlightMissionMode_T kc;
    cell_wrap_11_FlightMissionMode_T kd;
    cell_wrap_11_FlightMissionMode_T ke;
    cell_wrap_11_FlightMissionMode_T kf;
    cell_wrap_11_FlightMissionMode_T lb;
    cell_wrap_11_FlightMissionMode_T lc;
    cell_wrap_11_FlightMissionMode_T ld;
    cell_wrap_11_FlightMissionMode_T le;
    cell_wrap_11_FlightMissionMode_T lf;
    cell_wrap_11_FlightMissionMode_T mb;
    cell_wrap_11_FlightMissionMode_T mc;
    cell_wrap_11_FlightMissionMode_T md;
    cell_wrap_11_FlightMissionMode_T me;
    cell_wrap_11_FlightMissionMode_T mf;
    cell_wrap_11_FlightMissionMode_T nb;
    cell_wrap_11_FlightMissionMode_T nc;
    cell_wrap_11_FlightMissionMode_T nd;
    cell_wrap_11_FlightMissionMode_T ne;
    cell_wrap_11_FlightMissionMode_T nf;
    cell_wrap_11_FlightMissionMode_T ob;
    cell_wrap_11_FlightMissionMode_T oc;
    cell_wrap_11_FlightMissionMode_T od;
    cell_wrap_11_FlightMissionMode_T oe;
    cell_wrap_11_FlightMissionMode_T of;
    cell_wrap_11_FlightMissionMode_T pb;
    cell_wrap_11_FlightMissionMode_T pc;
    cell_wrap_11_FlightMissionMode_T pd;
    cell_wrap_11_FlightMissionMode_T pe;
    cell_wrap_11_FlightMissionMode_T pf;
    cell_wrap_11_FlightMissionMode_T qb;
    cell_wrap_11_FlightMissionMode_T qc;
    cell_wrap_11_FlightMissionMode_T qd;
    cell_wrap_11_FlightMissionMode_T qe;
    cell_wrap_11_FlightMissionMode_T qf;
    cell_wrap_11_FlightMissionMode_T rb;
    cell_wrap_11_FlightMissionMode_T rc;
    cell_wrap_11_FlightMissionMode_T rd;
    cell_wrap_11_FlightMissionMode_T re;
    cell_wrap_11_FlightMissionMode_T rf;
    cell_wrap_11_FlightMissionMode_T sb;
    cell_wrap_11_FlightMissionMode_T sc;
    cell_wrap_11_FlightMissionMode_T sd;
    cell_wrap_11_FlightMissionMode_T se;
    cell_wrap_11_FlightMissionMode_T sf;
    cell_wrap_11_FlightMissionMode_T tb;
    cell_wrap_11_FlightMissionMode_T tc;
    cell_wrap_11_FlightMissionMode_T td;
    cell_wrap_11_FlightMissionMode_T te;
    cell_wrap_11_FlightMissionMode_T tf;
    cell_wrap_11_FlightMissionMode_T ub;
    cell_wrap_11_FlightMissionMode_T uc;
    cell_wrap_11_FlightMissionMode_T ud;
    cell_wrap_11_FlightMissionMode_T ue;
    cell_wrap_11_FlightMissionMode_T uf;
    cell_wrap_11_FlightMissionMode_T vb;
    cell_wrap_11_FlightMissionMode_T vc;
    cell_wrap_11_FlightMissionMode_T vd;
    cell_wrap_11_FlightMissionMode_T ve;
    cell_wrap_11_FlightMissionMode_T wb;
    cell_wrap_11_FlightMissionMode_T wc;
    cell_wrap_11_FlightMissionMode_T wd;
    cell_wrap_11_FlightMissionMode_T we;
    cell_wrap_11_FlightMissionMode_T xb;
    cell_wrap_11_FlightMissionMode_T xc;
    cell_wrap_11_FlightMissionMode_T xd;
    cell_wrap_11_FlightMissionMode_T xe;
    cell_wrap_11_FlightMissionMode_T yb;
    cell_wrap_11_FlightMissionMode_T yc;
    cell_wrap_11_FlightMissionMode_T yd;
    cell_wrap_11_FlightMissionMode_T ye;
    cell_wrap_22_FlightMissionMode_h_T motionTypes[28];
    cell_wrap_22_FlightMissionMode_h_T b;
    real_T g[16];
    real_T ml[16];
    real_T ml1[16];
    real_T s[16];
    real_T b_goalPose[4];
    real_T b_startPose[4];
    real_T ml1_0[4];
    real_T b_a;
    real_T b_fpa;
    real_T h;
    real_T mt;
    real_T mtr;
    int32_T tmp;
    ib.f1.size[0] = 1;
    ib.f1.size[1] = 1;
    ib.f1.data[0] = 'L';
    jb.f1.size[0] = 1;
    jb.f1.size[1] = 1;
    jb.f1.data[0] = 'S';
    kb.f1.size[0] = 1;
    kb.f1.size[1] = 1;
    kb.f1.data[0] = 'L';
    lb.f1.size[0] = 1;
    lb.f1.size[1] = 1;
    lb.f1.data[0] = 'N';
    b.f1[0] = ib;
    b.f1[1] = jb;
    b.f1[2] = kb;
    b.f1[3] = lb;
    mb.f1.size[0] = 1;
    mb.f1.size[1] = 1;
    mb.f1.data[0] = 'L';
    nb.f1.size[0] = 1;
    nb.f1.size[1] = 1;
    nb.f1.data[0] = 'S';
    ob.f1.size[0] = 1;
    ob.f1.size[1] = 1;
    ob.f1.data[0] = 'R';
    pb.f1.size[0] = 1;
    pb.f1.size[1] = 1;
    pb.f1.data[0] = 'N';
    qb.f1.size[0] = 1;
    qb.f1.size[1] = 1;
    qb.f1.data[0] = 'R';
    rb.f1.size[0] = 1;
    rb.f1.size[1] = 1;
    rb.f1.data[0] = 'S';
    sb.f1.size[0] = 1;
    sb.f1.size[1] = 1;
    sb.f1.data[0] = 'L';
    tb.f1.size[0] = 1;
    tb.f1.size[1] = 1;
    tb.f1.data[0] = 'N';
    ub.f1.size[0] = 1;
    ub.f1.size[1] = 1;
    ub.f1.data[0] = 'R';
    vb.f1.size[0] = 1;
    vb.f1.size[1] = 1;
    vb.f1.data[0] = 'S';
    wb.f1.size[0] = 1;
    wb.f1.size[1] = 1;
    wb.f1.data[0] = 'R';
    xb.f1.size[0] = 1;
    xb.f1.size[1] = 1;
    xb.f1.data[0] = 'N';
    yb.f1.size[0] = 1;
    yb.f1.size[1] = 1;
    yb.f1.data[0] = 'R';
    ac.f1.size[0] = 1;
    ac.f1.size[1] = 1;
    ac.f1.data[0] = 'L';
    bc.f1.size[0] = 1;
    bc.f1.size[1] = 1;
    bc.f1.data[0] = 'R';
    cc.f1.size[0] = 1;
    cc.f1.size[1] = 1;
    cc.f1.data[0] = 'N';
    dc.f1.size[0] = 1;
    dc.f1.size[1] = 1;
    dc.f1.data[0] = 'L';
    ec.f1.size[0] = 1;
    ec.f1.size[1] = 1;
    ec.f1.data[0] = 'R';
    fc.f1.size[0] = 1;
    fc.f1.size[1] = 1;
    fc.f1.data[0] = 'L';
    gc.f1.size[0] = 1;
    gc.f1.size[1] = 1;
    gc.f1.data[0] = 'N';
    hc.f1.size[0] = 1;
    hc.f1.size[1] = 2;
    ic.f1.size[0] = 1;
    ic.f1.size[1] = 1;
    ic.f1.data[0] = 'L';
    jc.f1.size[0] = 1;
    jc.f1.size[1] = 1;
    jc.f1.data[0] = 'S';
    kc.f1.size[0] = 1;
    kc.f1.size[1] = 1;
    kc.f1.data[0] = 'L';
    lc.f1.size[0] = 1;
    lc.f1.size[1] = 2;
    mc.f1.size[0] = 1;
    mc.f1.size[1] = 1;
    mc.f1.data[0] = 'L';
    nc.f1.size[0] = 1;
    nc.f1.size[1] = 1;
    nc.f1.data[0] = 'S';
    oc.f1.size[0] = 1;
    oc.f1.size[1] = 1;
    oc.f1.data[0] = 'R';
    pc.f1.size[0] = 1;
    pc.f1.size[1] = 2;
    qc.f1.size[0] = 1;
    qc.f1.size[1] = 1;
    qc.f1.data[0] = 'R';
    rc.f1.size[0] = 1;
    rc.f1.size[1] = 1;
    rc.f1.data[0] = 'S';
    sc.f1.size[0] = 1;
    sc.f1.size[1] = 1;
    sc.f1.data[0] = 'L';
    tc.f1.size[0] = 1;
    tc.f1.size[1] = 2;
    uc.f1.size[0] = 1;
    uc.f1.size[1] = 1;
    uc.f1.data[0] = 'R';
    vc.f1.size[0] = 1;
    vc.f1.size[1] = 1;
    vc.f1.data[0] = 'S';
    wc.f1.size[0] = 1;
    wc.f1.size[1] = 1;
    wc.f1.data[0] = 'R';
    xc.f1.size[0] = 1;
    xc.f1.size[1] = 2;
    yc.f1.size[0] = 1;
    yc.f1.size[1] = 1;
    yc.f1.data[0] = 'R';
    ad.f1.size[0] = 1;
    ad.f1.size[1] = 1;
    ad.f1.data[0] = 'L';
    bd.f1.size[0] = 1;
    bd.f1.size[1] = 1;
    bd.f1.data[0] = 'R';
    cd.f1.size[0] = 1;
    cd.f1.size[1] = 2;
    dd.f1.size[0] = 1;
    dd.f1.size[1] = 1;
    dd.f1.data[0] = 'L';
    ed.f1.size[0] = 1;
    ed.f1.size[1] = 1;
    ed.f1.data[0] = 'R';
    fd.f1.size[0] = 1;
    fd.f1.size[1] = 1;
    fd.f1.data[0] = 'L';
    gd.f1.size[0] = 1;
    gd.f1.size[1] = 1;
    gd.f1.data[0] = 'L';
    hd.f1.size[0] = 1;
    hd.f1.size[1] = 1;
    hd.f1.data[0] = 'S';
    id.f1.size[0] = 1;
    id.f1.size[1] = 1;
    id.f1.data[0] = 'L';
    jd.f1.size[0] = 1;
    jd.f1.size[1] = 2;
    kd.f1.size[0] = 1;
    kd.f1.size[1] = 1;
    kd.f1.data[0] = 'L';
    ld.f1.size[0] = 1;
    ld.f1.size[1] = 1;
    ld.f1.data[0] = 'S';
    md.f1.size[0] = 1;
    md.f1.size[1] = 1;
    md.f1.data[0] = 'R';
    nd.f1.size[0] = 1;
    nd.f1.size[1] = 2;
    od.f1.size[0] = 1;
    od.f1.size[1] = 1;
    od.f1.data[0] = 'R';
    pd.f1.size[0] = 1;
    pd.f1.size[1] = 1;
    pd.f1.data[0] = 'S';
    qd.f1.size[0] = 1;
    qd.f1.size[1] = 1;
    qd.f1.data[0] = 'L';
    rd.f1.size[0] = 1;
    rd.f1.size[1] = 2;
    sd.f1.size[0] = 1;
    sd.f1.size[1] = 1;
    sd.f1.data[0] = 'R';
    td.f1.size[0] = 1;
    td.f1.size[1] = 1;
    td.f1.data[0] = 'S';
    ud.f1.size[0] = 1;
    ud.f1.size[1] = 1;
    ud.f1.data[0] = 'R';
    vd.f1.size[0] = 1;
    vd.f1.size[1] = 2;
    wd.f1.size[0] = 1;
    wd.f1.size[1] = 1;
    wd.f1.data[0] = 'R';
    xd.f1.size[0] = 1;
    xd.f1.size[1] = 1;
    xd.f1.data[0] = 'L';
    yd.f1.size[0] = 1;
    yd.f1.size[1] = 1;
    yd.f1.data[0] = 'R';
    ae.f1.size[0] = 1;
    ae.f1.size[1] = 2;
    be.f1.size[0] = 1;
    be.f1.size[1] = 1;
    be.f1.data[0] = 'L';
    ce.f1.size[0] = 1;
    ce.f1.size[1] = 1;
    ce.f1.data[0] = 'R';
    de.f1.size[0] = 1;
    de.f1.size[1] = 1;
    de.f1.data[0] = 'L';
    ee.f1.size[0] = 1;
    ee.f1.size[1] = 2;
    hc.f1.data[0] = 'H';
    lc.f1.data[0] = 'H';
    pc.f1.data[0] = 'H';
    tc.f1.data[0] = 'H';
    xc.f1.data[0] = 'H';
    cd.f1.data[0] = 'H';
    jd.f1.data[0] = 'H';
    nd.f1.data[0] = 'H';
    rd.f1.data[0] = 'H';
    vd.f1.data[0] = 'H';
    ae.f1.data[0] = 'H';
    ee.f1.data[0] = 'H';
    hc.f1.data[1] = 'l';
    lc.f1.data[1] = 'l';
    pc.f1.data[1] = 'r';
    tc.f1.data[1] = 'r';
    xc.f1.data[1] = 'r';
    cd.f1.data[1] = 'l';
    jd.f1.data[1] = 'l';
    nd.f1.data[1] = 'r';
    rd.f1.data[1] = 'l';
    vd.f1.data[1] = 'r';
    ae.f1.data[1] = 'r';
    ee.f1.data[1] = 'l';
    fe.f1.size[0] = 1;
    fe.f1.size[1] = 1;
    fe.f1.data[0] = 'L';
    ge.f1.size[0] = 1;
    ge.f1.size[1] = 1;
    ge.f1.data[0] = 'R';
    he.f1.size[0] = 1;
    he.f1.size[1] = 1;
    he.f1.data[0] = 'S';
    ie.f1.size[0] = 1;
    ie.f1.size[1] = 1;
    ie.f1.data[0] = 'L';
    je.f1.size[0] = 1;
    je.f1.size[1] = 1;
    je.f1.data[0] = 'L';
    ke.f1.size[0] = 1;
    ke.f1.size[1] = 1;
    ke.f1.data[0] = 'R';
    le.f1.size[0] = 1;
    le.f1.size[1] = 1;
    le.f1.data[0] = 'S';
    me.f1.size[0] = 1;
    me.f1.size[1] = 1;
    me.f1.data[0] = 'R';
    ne.f1.size[0] = 1;
    ne.f1.size[1] = 1;
    ne.f1.data[0] = 'L';
    oe.f1.size[0] = 1;
    oe.f1.size[1] = 1;
    oe.f1.data[0] = 'R';
    pe.f1.size[0] = 1;
    pe.f1.size[1] = 1;
    pe.f1.data[0] = 'L';
    qe.f1.size[0] = 1;
    qe.f1.size[1] = 1;
    qe.f1.data[0] = 'R';
    re.f1.size[0] = 1;
    re.f1.size[1] = 1;
    re.f1.data[0] = 'R';
    se.f1.size[0] = 1;
    se.f1.size[1] = 1;
    se.f1.data[0] = 'L';
    te.f1.size[0] = 1;
    te.f1.size[1] = 1;
    te.f1.data[0] = 'S';
    ue.f1.size[0] = 1;
    ue.f1.size[1] = 1;
    ue.f1.data[0] = 'R';
    ve.f1.size[0] = 1;
    ve.f1.size[1] = 1;
    ve.f1.data[0] = 'R';
    we.f1.size[0] = 1;
    we.f1.size[1] = 1;
    we.f1.data[0] = 'L';
    xe.f1.size[0] = 1;
    xe.f1.size[1] = 1;
    xe.f1.data[0] = 'R';
    ye.f1.size[0] = 1;
    ye.f1.size[1] = 1;
    ye.f1.data[0] = 'L';
    af.f1.size[0] = 1;
    af.f1.size[1] = 1;
    af.f1.data[0] = 'R';
    bf.f1.size[0] = 1;
    bf.f1.size[1] = 1;
    bf.f1.data[0] = 'L';
    cf.f1.size[0] = 1;
    cf.f1.size[1] = 1;
    cf.f1.data[0] = 'S';
    df.f1.size[0] = 1;
    df.f1.size[1] = 1;
    df.f1.data[0] = 'L';
    ef.f1.size[0] = 1;
    ef.f1.size[1] = 1;
    ef.f1.data[0] = 'L';
    ff.f1.size[0] = 1;
    ff.f1.size[1] = 1;
    ff.f1.data[0] = 'S';
    gf.f1.size[0] = 1;
    gf.f1.size[1] = 1;
    gf.f1.data[0] = 'R';
    hf.f1.size[0] = 1;
    hf.f1.size[1] = 1;
    hf.f1.data[0] = 'L';
    jf.f1.size[0] = 1;
    jf.f1.size[1] = 1;
    jf.f1.data[0] = 'R';
    kf.f1.size[0] = 1;
    kf.f1.size[1] = 1;
    kf.f1.data[0] = 'S';
    lf.f1.size[0] = 1;
    lf.f1.size[1] = 1;
    lf.f1.data[0] = 'R';
    mf.f1.size[0] = 1;
    mf.f1.size[1] = 1;
    mf.f1.data[0] = 'L';
    nf.f1.size[0] = 1;
    nf.f1.size[1] = 1;
    nf.f1.data[0] = 'L';
    of.f1.size[0] = 1;
    of.f1.size[1] = 1;
    of.f1.data[0] = 'S';
    pf.f1.size[0] = 1;
    pf.f1.size[1] = 1;
    pf.f1.data[0] = 'L';
    qf.f1.size[0] = 1;
    qf.f1.size[1] = 1;
    qf.f1.data[0] = 'R';
    rf.f1.size[0] = 1;
    rf.f1.size[1] = 1;
    rf.f1.data[0] = 'R';
    sf.f1.size[0] = 1;
    sf.f1.size[1] = 1;
    sf.f1.data[0] = 'S';
    tf.f1.size[0] = 1;
    tf.f1.size[1] = 1;
    tf.f1.data[0] = 'L';
    uf.f1.size[0] = 1;
    uf.f1.size[1] = 1;
    uf.f1.data[0] = 'R';
    motionTypes[0] = b;
    b_obj_UAVDubinsBuildableObj =
        FlightMissionMode_uavDubinsBuildable_uavDubinsBuildable_i(obj->AirSpeed,
        obj->MaxRollAngle, obj->FlightPathAngleLimit, dpt_data, dpt_size);
    b_startPose[0] = startPose[0];
    b_goalPose[0] = goalPose[0];
    b_startPose[1] = startPose[1];
    b_goalPose[1] = goalPose[1];
    b_startPose[2] = startPose[2];
    b_goalPose[2] = goalPose[2];
    b_startPose[3] = startPose[3];
    b_goalPose[3] = goalPose[3];
    uavDubinsDistanceCodegen_real64(b_obj_UAVDubinsBuildableObj, &b_startPose[0],
        1U, &b_goalPose[0], 1U, true, turningRadius, &s[0], &g[0], &b_fpa, &b_a,
        &mtr, &h, &mt, &ml[0]);
    tmp = 0;
    for (int32_T i{0}; i < 4; i++) {
        ml1[tmp] = ml[i];
        ml1[static_cast<int32_T>(tmp + 1)] = ml[static_cast<int32_T>(i + 4)];
        ml1[static_cast<int32_T>(tmp + 2)] = ml[static_cast<int32_T>(i + 8)];
        ml1[static_cast<int32_T>(tmp + 3)] = ml[static_cast<int32_T>(i + 12)];
        tmp = static_cast<int32_T>(tmp + 4);
    }

    if (mt + 1.0 == 2.0) {
        motionTypes[0].f1[0] = mb;
        motionTypes[0].f1[1] = nb;
        motionTypes[0].f1[2] = ob;
        motionTypes[0].f1[3] = pb;
    }

    if (mt + 1.0 == 3.0) {
        motionTypes[0].f1[0] = qb;
        motionTypes[0].f1[1] = rb;
        motionTypes[0].f1[2] = sb;
        motionTypes[0].f1[3] = tb;
    }

    if (mt + 1.0 == 4.0) {
        motionTypes[0].f1[0] = ub;
        motionTypes[0].f1[1] = vb;
        motionTypes[0].f1[2] = wb;
        motionTypes[0].f1[3] = xb;
    }

    if (mt + 1.0 == 5.0) {
        motionTypes[0].f1[0] = yb;
        motionTypes[0].f1[1] = ac;
        motionTypes[0].f1[2] = bc;
        motionTypes[0].f1[3] = cc;
    }

    if (mt + 1.0 == 6.0) {
        motionTypes[0].f1[0] = dc;
        motionTypes[0].f1[1] = ec;
        motionTypes[0].f1[2] = fc;
        motionTypes[0].f1[3] = gc;
    }

    if (mt + 1.0 == 7.0) {
        motionTypes[0].f1[0] = hc;
        motionTypes[0].f1[1] = ic;
        motionTypes[0].f1[2] = jc;
        motionTypes[0].f1[3] = kc;
    }

    if (mt + 1.0 == 8.0) {
        motionTypes[0].f1[0] = lc;
        motionTypes[0].f1[1] = mc;
        motionTypes[0].f1[2] = nc;
        motionTypes[0].f1[3] = oc;
    }

    if (mt + 1.0 == 9.0) {
        motionTypes[0].f1[0] = pc;
        motionTypes[0].f1[1] = qc;
        motionTypes[0].f1[2] = rc;
        motionTypes[0].f1[3] = sc;
    }

    if (mt + 1.0 == 10.0) {
        motionTypes[0].f1[0] = tc;
        motionTypes[0].f1[1] = uc;
        motionTypes[0].f1[2] = vc;
        motionTypes[0].f1[3] = wc;
    }

    if (mt + 1.0 == 11.0) {
        motionTypes[0].f1[0] = xc;
        motionTypes[0].f1[1] = yc;
        motionTypes[0].f1[2] = ad;
        motionTypes[0].f1[3] = bd;
    }

    if (mt + 1.0 == 12.0) {
        motionTypes[0].f1[0] = cd;
        motionTypes[0].f1[1] = dd;
        motionTypes[0].f1[2] = ed;
        motionTypes[0].f1[3] = fd;
    }

    if (mt + 1.0 == 13.0) {
        motionTypes[0].f1[0] = gd;
        motionTypes[0].f1[1] = hd;
        motionTypes[0].f1[2] = id;
        motionTypes[0].f1[3] = jd;
    }

    if (mt + 1.0 == 14.0) {
        motionTypes[0].f1[0] = kd;
        motionTypes[0].f1[1] = ld;
        motionTypes[0].f1[2] = md;
        motionTypes[0].f1[3] = nd;
    }

    if (mt + 1.0 == 15.0) {
        motionTypes[0].f1[0] = od;
        motionTypes[0].f1[1] = pd;
        motionTypes[0].f1[2] = qd;
        motionTypes[0].f1[3] = rd;
    }

    if (mt + 1.0 == 16.0) {
        motionTypes[0].f1[0] = sd;
        motionTypes[0].f1[1] = td;
        motionTypes[0].f1[2] = ud;
        motionTypes[0].f1[3] = vd;
    }

    if (mt + 1.0 == 17.0) {
        motionTypes[0].f1[0] = wd;
        motionTypes[0].f1[1] = xd;
        motionTypes[0].f1[2] = yd;
        motionTypes[0].f1[3] = ae;
    }

    if (mt + 1.0 == 18.0) {
        motionTypes[0].f1[0] = be;
        motionTypes[0].f1[1] = ce;
        motionTypes[0].f1[2] = de;
        motionTypes[0].f1[3] = ee;
    }

    if (mt + 1.0 == 19.0) {
        motionTypes[0].f1[0] = fe;
        motionTypes[0].f1[1] = ge;
        motionTypes[0].f1[2] = he;
        motionTypes[0].f1[3] = ie;
    }

    if (mt + 1.0 == 20.0) {
        motionTypes[0].f1[0] = je;
        motionTypes[0].f1[1] = ke;
        motionTypes[0].f1[2] = le;
        motionTypes[0].f1[3] = me;
    }

    if (mt + 1.0 == 21.0) {
        motionTypes[0].f1[0] = ne;
        motionTypes[0].f1[1] = oe;
        motionTypes[0].f1[2] = pe;
        motionTypes[0].f1[3] = qe;
    }

    if (mt + 1.0 == 22.0) {
        motionTypes[0].f1[0] = re;
        motionTypes[0].f1[1] = se;
        motionTypes[0].f1[2] = te;
        motionTypes[0].f1[3] = ue;
    }

    if (mt + 1.0 == 23.0) {
        motionTypes[0].f1[0] = ve;
        motionTypes[0].f1[1] = we;
        motionTypes[0].f1[2] = xe;
        motionTypes[0].f1[3] = ye;
    }

    if (mt + 1.0 == 24.0) {
        motionTypes[0].f1[0] = af;
        motionTypes[0].f1[1] = bf;
        motionTypes[0].f1[2] = cf;
        motionTypes[0].f1[3] = df;
    }

    if (mt + 1.0 == 25.0) {
        motionTypes[0].f1[0] = ef;
        motionTypes[0].f1[1] = ff;
        motionTypes[0].f1[2] = gf;
        motionTypes[0].f1[3] = hf;
    }

    if (mt + 1.0 == 26.0) {
        motionTypes[0].f1[0] = jf;
        motionTypes[0].f1[1] = kf;
        motionTypes[0].f1[2] = lf;
        motionTypes[0].f1[3] = mf;
    }

    if (mt + 1.0 == 27.0) {
        motionTypes[0].f1[0] = nf;
        motionTypes[0].f1[1] = of;
        motionTypes[0].f1[2] = pf;
        motionTypes[0].f1[3] = qf;
    }

    if (mt + 1.0 == 28.0) {
        motionTypes[0].f1[0] = rf;
        motionTypes[0].f1[1] = sf;
        motionTypes[0].f1[2] = tf;
        motionTypes[0].f1[3] = uf;
    }

    b_startPose[0] = s[0];
    b_goalPose[0] = g[0];
    ml1_0[0] = ml1[0];
    b_startPose[1] = s[1];
    b_goalPose[1] = g[1];
    ml1_0[1] = ml1[4];
    b_startPose[2] = s[2];
    b_goalPose[2] = g[2];
    ml1_0[2] = ml1[8];
    b_startPose[3] = s[3];
    b_goalPose[3] = g[3];
    ml1_0[3] = ml1[12];
    FlightMissionMode_uavDubinsPathSegment_uavDubinsPathSegment_n1(b_startPose,
        b_goalPose, b_fpa, b_a, mtr, h, motionTypes[0].f1, ml1_0, pathSegObjs);
    ml1_0[0] = ml1[0];
    ml1_0[1] = ml1[4];
    ml1_0[2] = ml1[8];
    ml1_0[3] = ml1[12];
    *pathCosts = sum_kSJnGZ04(ml1_0);
}

void FlightMissionMode::FlightMissionMode_emxEnsureCapacity_real_T_a
    (emxArray_real_T_FlightMissionMode_T *emxArray, int32_T oldNumel)
{
    int32_T i;
    int32_T newNumel;
    void *newData;
    if (oldNumel < 0) {
        oldNumel = 0;
    }

    newNumel = 1;
    for (i = 0; i <= static_cast<int32_T>(emxArray->numDimensions - 1); i++) {
        newNumel = static_cast<int32_T>(newNumel * emxArray->size[i]);
    }

    if (newNumel > emxArray->allocatedSize) {
        i = emxArray->allocatedSize;
        if (i < 16) {
            i = 16;
        }

        while (i < newNumel) {
            if (i > 1073741823) {
                i = MAX_int32_T;
            } else {
                i = static_cast<int32_T>(i << 1);
            }
        }

        newData = std::calloc(static_cast<uint32_T>(i), sizeof(real_T));
        if (emxArray->data != nullptr) {
            std::memcpy(newData, emxArray->data, static_cast<uint32_T>(sizeof
                         (real_T) * static_cast<uint32_T>(oldNumel)));
            if (emxArray->canFreeData) {
                std::free(emxArray->data);
            }
        }

        emxArray->data = static_cast<real_T *>(newData);
        emxArray->allocatedSize = i;
        emxArray->canFreeData = true;
    }
}

void FlightMissionMode::FlightMissionMode_emxFree_real_T_c
    (emxArray_real_T_FlightMissionMode_T **pEmxArray)
{
    if (*pEmxArray != static_cast<emxArray_real_T_FlightMissionMode_T *>(nullptr))
    {
        if (((*pEmxArray)->data != static_cast<real_T *>(nullptr)) &&
                (*pEmxArray)->canFreeData) {
            std::free((*pEmxArray)->data);
        }

        std::free((*pEmxArray)->size);
        std::free(*pEmxArray);
        *pEmxArray = static_cast<emxArray_real_T_FlightMissionMode_T *>(nullptr);
    }
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_strcmp_oqn4q52h(const
    cell_wrap_11_FlightMissionMode_T a[4], boolean_T b_bool[4])
{
    b_bool[0] = false;
    if ((a[0].f1.size[1] == 1) && (a[0].f1.data[0] == 'N')) {
        b_bool[0] = true;
    }

    b_bool[1] = false;
    if ((a[1].f1.size[1] == 1) && (a[1].f1.data[0] == 'N')) {
        b_bool[1] = true;
    }

    b_bool[2] = false;
    if ((a[2].f1.size[1] == 1) && (a[2].f1.data[0] == 'N')) {
        b_bool[2] = true;
    }

    b_bool[3] = false;
    if ((a[3].f1.size[1] == 1) && (a[3].f1.data[0] == 'N')) {
        b_bool[3] = true;
    }
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_any_l(const boolean_T x[4])
{
    int32_T k;
    boolean_T exitg1;
    boolean_T y;
    y = false;
    k = 0;
    exitg1 = false;
    while ((!exitg1) && (k < 4)) {
        if (x[k]) {
            y = true;
            exitg1 = true;
        } else {
            k = static_cast<int32_T>(k + 1);
        }
    }

    return y;
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_useConstantDim_c(const real_T
    varargin_2_data[], const int32_T varargin_2_size[2], real_T
    varargout_1_data[], int32_T varargout_1_size[2])
{
    int32_T loop_ub;
    varargout_1_size[0] = 1;
    varargout_1_size[1] = varargin_2_size[1];
    loop_ub = static_cast<int32_T>(varargin_2_size[1] - 1);
    for (int32_T varargout_1_data_tmp{0}; varargout_1_data_tmp <= loop_ub;
            varargout_1_data_tmp++) {
        varargout_1_data[varargout_1_data_tmp] =
            varargin_2_data[varargout_1_data_tmp];
    }

    for (loop_ub = 0; loop_ub <= static_cast<int32_T>(varargin_2_size[1] - 2);
            loop_ub = static_cast<int32_T>(loop_ub + 1)) {
        varargout_1_data[static_cast<int32_T>(loop_ub + 1)] +=
            varargout_1_data[loop_ub];
    }
}

void FlightMissionMode::FlightMissionMode_emxInit_int32_T_j
    (emxArray_int32_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions)
{
    emxArray_int32_T_FlightMissionMode_T *emxArray;
    *pEmxArray = static_cast<emxArray_int32_T_FlightMissionMode_T *>(std::malloc
        (sizeof(emxArray_int32_T_FlightMissionMode_T)));
    emxArray = *pEmxArray;
    emxArray->data = static_cast<int32_T *>(nullptr);
    emxArray->numDimensions = numDimensions;
    emxArray->size = static_cast<int32_T *>(std::malloc(static_cast<uint32_T>
        (sizeof(int32_T) * static_cast<uint32_T>(numDimensions))));
    emxArray->allocatedSize = 0;
    emxArray->canFreeData = true;
    for (int32_T i{0}; i <= static_cast<int32_T>(numDimensions - 1); i++) {
        emxArray->size[i] = 0;
    }
}

void FlightMissionMode::FlightMissionMode_emxEnsureCapacity_int32_T_c
    (emxArray_int32_T_FlightMissionMode_T *emxArray, int32_T oldNumel)
{
    int32_T i;
    int32_T newNumel;
    void *newData;
    if (oldNumel < 0) {
        oldNumel = 0;
    }

    newNumel = 1;
    for (i = 0; i <= static_cast<int32_T>(emxArray->numDimensions - 1); i++) {
        newNumel = static_cast<int32_T>(newNumel * emxArray->size[i]);
    }

    if (newNumel > emxArray->allocatedSize) {
        i = emxArray->allocatedSize;
        if (i < 16) {
            i = 16;
        }

        while (i < newNumel) {
            if (i > 1073741823) {
                i = MAX_int32_T;
            } else {
                i = static_cast<int32_T>(i << 1);
            }
        }

        newData = std::calloc(static_cast<uint32_T>(i), sizeof(int32_T));
        if (emxArray->data != nullptr) {
            std::memcpy(newData, emxArray->data, static_cast<uint32_T>(sizeof
                         (int32_T) * static_cast<uint32_T>(oldNumel)));
            if (emxArray->canFreeData) {
                std::free(emxArray->data);
            }
        }

        emxArray->data = static_cast<int32_T *>(newData);
        emxArray->allocatedSize = i;
        emxArray->canFreeData = true;
    }
}

void FlightMissionMode::FlightMissionMode_emxFree_int32_T_k
    (emxArray_int32_T_FlightMissionMode_T **pEmxArray)
{
    if (*pEmxArray != static_cast<emxArray_int32_T_FlightMissionMode_T *>
            (nullptr)) {
        if (((*pEmxArray)->data != static_cast<int32_T *>(nullptr)) &&
                (*pEmxArray)->canFreeData) {
            std::free((*pEmxArray)->data);
        }

        std::free((*pEmxArray)->size);
        std::free(*pEmxArray);
        *pEmxArray = static_cast<emxArray_int32_T_FlightMissionMode_T *>(nullptr);
    }
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_merge_p2m
    (emxArray_int32_T_FlightMissionMode_T *idx,
     emxArray_real_T_FlightMissionMode_T *x, int32_T offset, int32_T np, int32_T
     nq, emxArray_int32_T_FlightMissionMode_T *iwork,
     emxArray_real_T_FlightMissionMode_T *xwork)
{
    if (nq != 0) {
        int32_T iout;
        int32_T n;
        int32_T n_tmp;
        int32_T q;
        n_tmp = static_cast<int32_T>(np + nq);
        for (q = 0; q <= static_cast<int32_T>(n_tmp - 1); q =
                static_cast<int32_T>(q + 1)) {
            iout = static_cast<int32_T>(offset + q);
            iwork->data[q] = idx->data[iout];
            xwork->data[q] = x->data[iout];
        }

        n = 0;
        q = np;
        iout = static_cast<int32_T>(offset - 1);
        int32_T exitg1;
        do {
            exitg1 = 0;
            iout = static_cast<int32_T>(iout + 1);
            if (xwork->data[n] <= xwork->data[q]) {
                idx->data[iout] = iwork->data[n];
                x->data[iout] = xwork->data[n];
                if (static_cast<int32_T>(n + 1) < np) {
                    n = static_cast<int32_T>(n + 1);
                } else {
                    exitg1 = 1;
                }
            } else {
                idx->data[iout] = iwork->data[q];
                x->data[iout] = xwork->data[q];
                if (static_cast<int32_T>(q + 1) < n_tmp) {
                    q = static_cast<int32_T>(q + 1);
                } else {
                    q = static_cast<int32_T>(iout - n);
                    while (static_cast<int32_T>(n + 1) <= np) {
                        n_tmp = static_cast<int32_T>(static_cast<int32_T>(q + n)
                            + 1);
                        idx->data[n_tmp] = iwork->data[n];
                        x->data[n_tmp] = xwork->data[n];
                        n = static_cast<int32_T>(n + 1);
                    }

                    exitg1 = 1;
                }
            }
        } while (exitg1 == 0);
    }
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_merge_block_n
    (emxArray_int32_T_FlightMissionMode_T *idx,
     emxArray_real_T_FlightMissionMode_T *x, int32_T offset, int32_T n, int32_T
     preSortLevel, emxArray_int32_T_FlightMissionMode_T *iwork,
     emxArray_real_T_FlightMissionMode_T *xwork)
{
    int32_T bLen;
    int32_T nPairs;
    nPairs = static_cast<int32_T>(n >> preSortLevel);
    bLen = static_cast<int32_T>(1 << preSortLevel);
    while (nPairs > 1) {
        int32_T nTail;
        int32_T tailOffset;
        if (static_cast<uint32_T>(static_cast<uint32_T>(nPairs) & 1U) != 0U) {
            nPairs = static_cast<int32_T>(nPairs - 1);
            tailOffset = static_cast<int32_T>(bLen * nPairs);
            nTail = static_cast<int32_T>(n - tailOffset);
            if (nTail > bLen) {
                FlightMissionMode_merge_p2m(idx, x, static_cast<int32_T>(offset
                    + tailOffset), bLen, static_cast<int32_T>(nTail - bLen),
                    iwork, xwork);
            }
        }

        tailOffset = static_cast<int32_T>(bLen << 1);
        nPairs = static_cast<int32_T>(nPairs >> 1);
        for (nTail = 0; nTail <= static_cast<int32_T>(nPairs - 1); nTail =
                static_cast<int32_T>(nTail + 1)) {
            FlightMissionMode_merge_p2m(idx, x, static_cast<int32_T>(offset +
                static_cast<int32_T>(nTail * tailOffset)), bLen, bLen, iwork,
                xwork);
        }

        bLen = tailOffset;
    }

    if (n > bLen) {
        FlightMissionMode_merge_p2m(idx, x, offset, bLen, static_cast<int32_T>(n
            - bLen), iwork, xwork);
    }
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_sort_oi4
    (emxArray_real_T_FlightMissionMode_T *x)
{
    emxArray_int32_T_FlightMissionMode_T *c;
    emxArray_int32_T_FlightMissionMode_T *idx;
    emxArray_int32_T_FlightMissionMode_T *iwork;
    emxArray_real_T_FlightMissionMode_T *b_x;
    emxArray_real_T_FlightMissionMode_T *d;
    emxArray_real_T_FlightMissionMode_T *f;
    real_T b_xwork[256];
    real_T x4[4];
    int32_T c_iwork[256];
    int32_T idx4[4];
    int32_T c_iwork_tmp;
    int32_T i1;
    int32_T ib;
    int8_T perm[4];
    FlightMissionMode_emxInit_real_T_i(&b_x, 2);
    FlightMissionMode_emxInit_int32_T_j(&c, 2);
    FlightMissionMode_emxInit_real_T_i(&d, 2);
    FlightMissionMode_emxInit_real_T_i(&f, 1);
    c_iwork_tmp = static_cast<int32_T>(b_x->size[0] * b_x->size[1]);
    b_x->size[0] = 1;
    b_x->size[1] = x->size[1];
    FlightMissionMode_emxEnsureCapacity_real_T_a(b_x, c_iwork_tmp);
    i1 = static_cast<int32_T>(x->size[1] - 1);
    for (ib = 0; ib <= i1; ib++) {
        b_x->data[ib] = x->data[ib];
    }

    if (x->size[1] != 0) {
        int32_T bLen;
        int32_T bLen2;
        int32_T n;
        int32_T nBlocks;
        int32_T nPairs;
        int32_T q;
        int32_T wOffset;
        FlightMissionMode_emxInit_int32_T_j(&idx, 2);
        c_iwork_tmp = static_cast<int32_T>(idx->size[0] * idx->size[1]);
        idx->size[0] = 1;
        idx->size[1] = x->size[1];
        FlightMissionMode_emxEnsureCapacity_int32_T_c(idx, c_iwork_tmp);
        i1 = static_cast<int32_T>(x->size[1] - 1);
        for (ib = 0; ib <= i1; ib++) {
            idx->data[ib] = 0;
        }

        c_iwork_tmp = static_cast<int32_T>(b_x->size[0] * b_x->size[1]);
        b_x->size[0] = 1;
        b_x->size[1] = x->size[1];
        FlightMissionMode_emxEnsureCapacity_real_T_a(b_x, c_iwork_tmp);
        i1 = static_cast<int32_T>(x->size[1] - 1);
        for (ib = 0; ib <= i1; ib++) {
            b_x->data[ib] = x->data[ib];
        }

        n = x->size[1];
        x4[0] = 0.0;
        idx4[0] = 0;
        x4[1] = 0.0;
        idx4[1] = 0;
        x4[2] = 0.0;
        idx4[2] = 0;
        x4[3] = 0.0;
        idx4[3] = 0;
        c_iwork_tmp = f->size[0];
        f->size[0] = x->size[1];
        FlightMissionMode_emxEnsureCapacity_real_T_a(f, c_iwork_tmp);
        nBlocks = f->size[0];
        c_iwork_tmp = f->size[0];
        f->size[0] = nBlocks;
        FlightMissionMode_emxEnsureCapacity_real_T_a(f, c_iwork_tmp);
        for (ib = 0; ib <= static_cast<int32_T>(nBlocks - 1); ib++) {
            f->data[ib] = 0.0;
        }

        nBlocks = 1;
        ib = 0;
        for (wOffset = 0; wOffset <= static_cast<int32_T>(n - 1); wOffset =
                static_cast<int32_T>(wOffset + 1)) {
            if (std::isnan(b_x->data[wOffset])) {
                q = static_cast<int32_T>(n - nBlocks);
                idx->data[q] = static_cast<int32_T>(wOffset + 1);
                f->data[q] = b_x->data[wOffset];
                nBlocks = static_cast<int32_T>(nBlocks + 1);
            } else {
                ib = static_cast<int32_T>(ib + 1);
                idx4[static_cast<int32_T>(ib - 1)] = static_cast<int32_T>
                    (wOffset + 1);
                x4[static_cast<int32_T>(ib - 1)] = b_x->data[wOffset];
                if (ib == 4) {
                    real_T tmp;
                    real_T tmp_0;
                    ib = static_cast<int32_T>(wOffset - nBlocks);
                    if (x4[0] <= x4[1]) {
                        i1 = 1;
                        bLen = 2;
                    } else {
                        i1 = 2;
                        bLen = 1;
                    }

                    if (x4[2] <= x4[3]) {
                        bLen2 = 3;
                        nPairs = 4;
                    } else {
                        bLen2 = 4;
                        nPairs = 3;
                    }

                    tmp = x4[static_cast<int32_T>(i1 - 1)];
                    tmp_0 = x4[static_cast<int32_T>(bLen2 - 1)];
                    if (tmp <= tmp_0) {
                        tmp = x4[static_cast<int32_T>(bLen - 1)];
                        if (tmp <= tmp_0) {
                            perm[0] = static_cast<int8_T>(i1);
                            perm[1] = static_cast<int8_T>(bLen);
                            perm[2] = static_cast<int8_T>(bLen2);
                            perm[3] = static_cast<int8_T>(nPairs);
                        } else if (tmp <= x4[static_cast<int32_T>(nPairs - 1)])
                        {
                            perm[0] = static_cast<int8_T>(i1);
                            perm[1] = static_cast<int8_T>(bLen2);
                            perm[2] = static_cast<int8_T>(bLen);
                            perm[3] = static_cast<int8_T>(nPairs);
                        } else {
                            perm[0] = static_cast<int8_T>(i1);
                            perm[1] = static_cast<int8_T>(bLen2);
                            perm[2] = static_cast<int8_T>(nPairs);
                            perm[3] = static_cast<int8_T>(bLen);
                        }
                    } else {
                        tmp_0 = x4[static_cast<int32_T>(nPairs - 1)];
                        if (tmp <= tmp_0) {
                            if (x4[static_cast<int32_T>(bLen - 1)] <= tmp_0) {
                                perm[0] = static_cast<int8_T>(bLen2);
                                perm[1] = static_cast<int8_T>(i1);
                                perm[2] = static_cast<int8_T>(bLen);
                                perm[3] = static_cast<int8_T>(nPairs);
                            } else {
                                perm[0] = static_cast<int8_T>(bLen2);
                                perm[1] = static_cast<int8_T>(i1);
                                perm[2] = static_cast<int8_T>(nPairs);
                                perm[3] = static_cast<int8_T>(bLen);
                            }
                        } else {
                            perm[0] = static_cast<int8_T>(bLen2);
                            perm[1] = static_cast<int8_T>(nPairs);
                            perm[2] = static_cast<int8_T>(i1);
                            perm[3] = static_cast<int8_T>(bLen);
                        }
                    }

                    idx->data[static_cast<int32_T>(ib - 2)] = idx4[static_cast<
                        int32_T>(static_cast<int32_T>(perm[0]) - 1)];
                    idx->data[static_cast<int32_T>(ib - 1)] = idx4[static_cast<
                        int32_T>(static_cast<int32_T>(perm[1]) - 1)];
                    idx->data[ib] = idx4[static_cast<int32_T>
                        (static_cast<int32_T>(perm[2]) - 1)];
                    idx->data[static_cast<int32_T>(ib + 1)] = idx4[static_cast<
                        int32_T>(static_cast<int32_T>(perm[3]) - 1)];
                    b_x->data[static_cast<int32_T>(ib - 2)] = x4
                        [static_cast<int32_T>(static_cast<int32_T>(perm[0]) - 1)];
                    b_x->data[static_cast<int32_T>(ib - 1)] = x4
                        [static_cast<int32_T>(static_cast<int32_T>(perm[1]) - 1)];
                    b_x->data[ib] = x4[static_cast<int32_T>(static_cast<int32_T>
                        (perm[2]) - 1)];
                    b_x->data[static_cast<int32_T>(ib + 1)] = x4
                        [static_cast<int32_T>(static_cast<int32_T>(perm[3]) - 1)];
                    ib = 0;
                }
            }
        }

        wOffset = static_cast<int32_T>(x->size[1] - nBlocks);
        if (ib > 0) {
            perm[1] = 0;
            perm[2] = 0;
            perm[3] = 0;
            switch (ib) {
              case 1:
                perm[0] = 1;
                break;

              case 2:
                if (x4[0] <= x4[1]) {
                    perm[0] = 1;
                    perm[1] = 2;
                } else {
                    perm[0] = 2;
                    perm[1] = 1;
                }
                break;

              default:
                if (x4[0] <= x4[1]) {
                    if (x4[1] <= x4[2]) {
                        perm[0] = 1;
                        perm[1] = 2;
                        perm[2] = 3;
                    } else if (x4[0] <= x4[2]) {
                        perm[0] = 1;
                        perm[1] = 3;
                        perm[2] = 2;
                    } else {
                        perm[0] = 3;
                        perm[1] = 1;
                        perm[2] = 2;
                    }
                } else if (x4[0] <= x4[2]) {
                    perm[0] = 2;
                    perm[1] = 1;
                    perm[2] = 3;
                } else if (x4[1] <= x4[2]) {
                    perm[0] = 2;
                    perm[1] = 3;
                    perm[2] = 1;
                } else {
                    perm[0] = 3;
                    perm[1] = 2;
                    perm[2] = 1;
                }
                break;
            }

            for (i1 = 0; i1 <= static_cast<int32_T>(ib - 1); i1 =
                    static_cast<int32_T>(i1 + 1)) {
                q = static_cast<int32_T>(static_cast<int32_T>(perm[i1]) - 1);
                c_iwork_tmp = static_cast<int32_T>(static_cast<int32_T>(
                    static_cast<int32_T>(wOffset - ib) + i1) + 1);
                idx->data[c_iwork_tmp] = idx4[q];
                b_x->data[c_iwork_tmp] = x4[q];
            }
        }

        ib = static_cast<int32_T>(static_cast<int32_T>(static_cast<int32_T>
            (nBlocks - 1) >> 1) + 1);
        for (i1 = 1; static_cast<int32_T>(i1 - 1) <= static_cast<int32_T>(ib - 2);
             i1 = static_cast<int32_T>(i1 + 1)) {
            bLen2 = static_cast<int32_T>(wOffset + i1);
            bLen = idx->data[bLen2];
            q = static_cast<int32_T>(n - i1);
            idx->data[bLen2] = idx->data[q];
            idx->data[q] = bLen;
            b_x->data[bLen2] = f->data[q];
            b_x->data[q] = f->data[bLen2];
        }

        if (static_cast<uint32_T>(static_cast<uint32_T>(static_cast<int32_T>
                (nBlocks - 1)) & 1U) != 0U) {
            n = static_cast<int32_T>(wOffset + ib);
            b_x->data[n] = f->data[n];
        }

        FlightMissionMode_emxInit_int32_T_j(&iwork, 1);
        c_iwork_tmp = iwork->size[0];
        iwork->size[0] = x->size[1];
        FlightMissionMode_emxEnsureCapacity_int32_T_c(iwork, c_iwork_tmp);
        i1 = x->size[1];
        for (ib = 0; ib <= static_cast<int32_T>(i1 - 1); ib++) {
            iwork->data[ib] = 0;
        }

        n = static_cast<int32_T>(static_cast<int32_T>(x->size[1] - nBlocks) + 1);
        wOffset = 2;
        if (n > 1) {
            if (x->size[1] >= 256) {
                nBlocks = static_cast<int32_T>(n >> 8);
                if (nBlocks > 0) {
                    for (ib = 0; ib <= static_cast<int32_T>(nBlocks - 1); ib =
                            static_cast<int32_T>(ib + 1)) {
                        i1 = static_cast<int32_T>(static_cast<int32_T>(ib << 8)
                            - 1);
                        for (wOffset = 0; wOffset < 6; wOffset++) {
                            bLen = static_cast<int32_T>(1 << static_cast<int32_T>
                                (wOffset + 2));
                            bLen2 = static_cast<int32_T>(bLen << 1);
                            nPairs = static_cast<int32_T>(256 >>
                                static_cast<int32_T>(wOffset + 3));
                            for (int32_T d_k{0}; d_k <= static_cast<int32_T>
                                    (nPairs - 1); d_k = static_cast<int32_T>(d_k
                                  + 1)) {
                                int32_T blockOffset;
                                int32_T p;
                                blockOffset = static_cast<int32_T>
                                    (static_cast<int32_T>(d_k * bLen2) + i1);
                                for (p = 0; p <= static_cast<int32_T>(bLen2 - 1);
                                     p = static_cast<int32_T>(p + 1)) {
                                    c_iwork_tmp = static_cast<int32_T>(
                                        static_cast<int32_T>(blockOffset + p) +
                                        1);
                                    c_iwork[p] = idx->data[c_iwork_tmp];
                                    b_xwork[p] = b_x->data[c_iwork_tmp];
                                }

                                p = 0;
                                q = bLen;
                                int32_T exitg1;
                                do {
                                    exitg1 = 0;
                                    blockOffset = static_cast<int32_T>
                                        (blockOffset + 1);
                                    if (b_xwork[p] <= b_xwork[q]) {
                                        idx->data[blockOffset] = c_iwork[p];
                                        b_x->data[blockOffset] = b_xwork[p];
                                        if (static_cast<int32_T>(p + 1) < bLen)
                                        {
                                            p = static_cast<int32_T>(p + 1);
                                        } else {
                                            exitg1 = 1;
                                        }
                                    } else {
                                        idx->data[blockOffset] = c_iwork[q];
                                        b_x->data[blockOffset] = b_xwork[q];
                                        if (static_cast<int32_T>(q + 1) < bLen2)
                                        {
                                            q = static_cast<int32_T>(q + 1);
                                        } else {
                                            blockOffset = static_cast<int32_T>
                                                (blockOffset - p);
                                            while (static_cast<int32_T>(p + 1) <=
                                                   bLen) {
                                                c_iwork_tmp =
                                                    static_cast<int32_T>(
                                                    static_cast<int32_T>
                                                    (blockOffset + p) + 1);
                                                idx->data[c_iwork_tmp] =
                                                    c_iwork[p];
                                                b_x->data[c_iwork_tmp] =
                                                    b_xwork[p];
                                                p = static_cast<int32_T>(p + 1);
                                            }

                                            exitg1 = 1;
                                        }
                                    }
                                } while (exitg1 == 0);
                            }
                        }
                    }

                    nBlocks = static_cast<int32_T>(nBlocks << 8);
                    wOffset = static_cast<int32_T>(n - nBlocks);
                    if (wOffset > 0) {
                        c_iwork_tmp = static_cast<int32_T>(c->size[0] * c->size
                            [1]);
                        c->size[0] = 1;
                        c->size[1] = idx->size[1];
                        FlightMissionMode_emxEnsureCapacity_int32_T_c(c,
                            c_iwork_tmp);
                        i1 = static_cast<int32_T>(idx->size[1] - 1);
                        for (ib = 0; ib <= i1; ib++) {
                            c->data[ib] = idx->data[ib];
                        }

                        c_iwork_tmp = static_cast<int32_T>(d->size[0] * d->size
                            [1]);
                        d->size[0] = 1;
                        d->size[1] = b_x->size[1];
                        FlightMissionMode_emxEnsureCapacity_real_T_a(d,
                            c_iwork_tmp);
                        i1 = static_cast<int32_T>(b_x->size[1] - 1);
                        for (ib = 0; ib <= i1; ib++) {
                            d->data[ib] = b_x->data[ib];
                        }

                        c_iwork_tmp = iwork->size[0];
                        iwork->size[0] = x->size[1];
                        FlightMissionMode_emxEnsureCapacity_int32_T_c(iwork,
                            c_iwork_tmp);
                        i1 = x->size[1];
                        for (ib = 0; ib <= static_cast<int32_T>(i1 - 1); ib++) {
                            iwork->data[ib] = 0;
                        }

                        FlightMissionMode_merge_block_n(c, d, nBlocks, wOffset,
                            2, iwork, f);
                        c_iwork_tmp = static_cast<int32_T>(b_x->size[0] *
                            b_x->size[1]);
                        b_x->size[0] = 1;
                        b_x->size[1] = d->size[1];
                        FlightMissionMode_emxEnsureCapacity_real_T_a(b_x,
                            c_iwork_tmp);
                        i1 = static_cast<int32_T>(d->size[1] - 1);
                        for (ib = 0; ib <= i1; ib++) {
                            b_x->data[ib] = d->data[ib];
                        }

                        c_iwork_tmp = static_cast<int32_T>(idx->size[0] *
                            idx->size[1]);
                        idx->size[0] = 1;
                        idx->size[1] = c->size[1];
                        FlightMissionMode_emxEnsureCapacity_int32_T_c(idx,
                            c_iwork_tmp);
                        i1 = static_cast<int32_T>(c->size[1] - 1);
                        for (ib = 0; ib <= i1; ib++) {
                            idx->data[ib] = c->data[ib];
                        }
                    }

                    wOffset = 8;
                }
            }

            c_iwork_tmp = static_cast<int32_T>(c->size[0] * c->size[1]);
            c->size[0] = 1;
            c->size[1] = idx->size[1];
            FlightMissionMode_emxEnsureCapacity_int32_T_c(c, c_iwork_tmp);
            i1 = static_cast<int32_T>(idx->size[1] - 1);
            for (ib = 0; ib <= i1; ib++) {
                c->data[ib] = idx->data[ib];
            }

            c_iwork_tmp = static_cast<int32_T>(d->size[0] * d->size[1]);
            d->size[0] = 1;
            d->size[1] = b_x->size[1];
            FlightMissionMode_emxEnsureCapacity_real_T_a(d, c_iwork_tmp);
            i1 = static_cast<int32_T>(b_x->size[1] - 1);
            for (ib = 0; ib <= i1; ib++) {
                d->data[ib] = b_x->data[ib];
            }

            FlightMissionMode_merge_block_n(c, d, 0, n, wOffset, iwork, f);
            c_iwork_tmp = static_cast<int32_T>(b_x->size[0] * b_x->size[1]);
            b_x->size[0] = 1;
            b_x->size[1] = d->size[1];
            FlightMissionMode_emxEnsureCapacity_real_T_a(b_x, c_iwork_tmp);
            i1 = static_cast<int32_T>(d->size[1] - 1);
            for (ib = 0; ib <= i1; ib++) {
                b_x->data[ib] = d->data[ib];
            }
        }

        FlightMissionMode_emxFree_int32_T_k(&idx);
        FlightMissionMode_emxFree_int32_T_k(&iwork);
    }

    c_iwork_tmp = static_cast<int32_T>(x->size[0] * x->size[1]);
    x->size[0] = 1;
    x->size[1] = b_x->size[1];
    FlightMissionMode_emxEnsureCapacity_real_T_a(x, c_iwork_tmp);
    i1 = b_x->size[1];
    for (ib = 0; ib <= static_cast<int32_T>(i1 - 1); ib++) {
        x->data[ib] = b_x->data[ib];
    }

    FlightMissionMode_emxFree_real_T_c(&b_x);
    FlightMissionMode_emxFree_real_T_c(&f);
    FlightMissionMode_emxFree_real_T_c(&d);
    FlightMissionMode_emxFree_int32_T_k(&c);
}

void FlightMissionMode::FlightMissionMode_emxInit_boolean_T_k
    (emxArray_boolean_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions)
{
    emxArray_boolean_T_FlightMissionMode_T *emxArray;
    *pEmxArray = static_cast<emxArray_boolean_T_FlightMissionMode_T *>(std::
        malloc(sizeof(emxArray_boolean_T_FlightMissionMode_T)));
    emxArray = *pEmxArray;
    emxArray->data = static_cast<boolean_T *>(nullptr);
    emxArray->numDimensions = numDimensions;
    emxArray->size = static_cast<int32_T *>(std::malloc(static_cast<uint32_T>
        (sizeof(int32_T) * static_cast<uint32_T>(numDimensions))));
    emxArray->allocatedSize = 0;
    emxArray->canFreeData = true;
    for (int32_T i{0}; i <= static_cast<int32_T>(numDimensions - 1); i++) {
        emxArray->size[i] = 0;
    }
}

void FlightMissionMode::FlightMissionMode_emxFree_boolean_T_d
    (emxArray_boolean_T_FlightMissionMode_T **pEmxArray)
{
    if (*pEmxArray != static_cast<emxArray_boolean_T_FlightMissionMode_T *>
            (nullptr)) {
        if (((*pEmxArray)->data != static_cast<boolean_T *>(nullptr)) &&
                (*pEmxArray)->canFreeData) {
            std::free((*pEmxArray)->data);
        }

        std::free((*pEmxArray)->size);
        std::free(*pEmxArray);
        *pEmxArray = static_cast<emxArray_boolean_T_FlightMissionMode_T *>
            (nullptr);
    }
}

void FlightMissionMode::FlightMissionMode_emxEnsureCapacity_boolean_T_p
    (emxArray_boolean_T_FlightMissionMode_T *emxArray, int32_T oldNumel)
{
    int32_T i;
    int32_T newNumel;
    void *newData;
    if (oldNumel < 0) {
        oldNumel = 0;
    }

    newNumel = 1;
    for (i = 0; i <= static_cast<int32_T>(emxArray->numDimensions - 1); i++) {
        newNumel = static_cast<int32_T>(newNumel * emxArray->size[i]);
    }

    if (newNumel > emxArray->allocatedSize) {
        i = emxArray->allocatedSize;
        if (i < 16) {
            i = 16;
        }

        while (i < newNumel) {
            if (i > 1073741823) {
                i = MAX_int32_T;
            } else {
                i = static_cast<int32_T>(i << 1);
            }
        }

        newData = std::calloc(static_cast<uint32_T>(i), sizeof(boolean_T));
        if (emxArray->data != nullptr) {
            std::memcpy(newData, emxArray->data, static_cast<uint32_T>(sizeof
                         (boolean_T) * static_cast<uint32_T>(oldNumel)));
            if (emxArray->canFreeData) {
                std::free(emxArray->data);
            }
        }

        emxArray->data = static_cast<boolean_T *>(newData);
        emxArray->allocatedSize = i;
        emxArray->canFreeData = true;
    }
}

void FlightMissionMode::FlightMissionMode_binary_expand_op_h
    (emxArray_boolean_T_FlightMissionMode_T *in1, const
     emxArray_real_T_FlightMissionMode_T *in2, const
     emxArray_real_T_FlightMissionMode_T *in3)
{
    int32_T i;
    int32_T loop_ub;
    int32_T stride_0_0;
    int32_T stride_1_0;
    i = in1->size[0];
    in1->size[0] = in3->size[0] == 1 ? in2->size[0] : in3->size[0];
    FlightMissionMode_emxEnsureCapacity_boolean_T_p(in1, i);
    stride_0_0 = (in2->size[0] != 1);
    stride_1_0 = (in3->size[0] != 1);
    loop_ub = in3->size[0] == 1 ? in2->size[0] : in3->size[0];
    for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
        in1->data[i] = static_cast<boolean_T>(static_cast<int32_T>((in2->data[
            static_cast<int32_T>(i * stride_0_0)] == 0.0) & (in3->data[
            static_cast<int32_T>(i * stride_1_0)] > 0.0)));
    }
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_wrapToPi_i
    (emxArray_real_T_FlightMissionMode_T *theta)
{
    emxArray_boolean_T_FlightMissionMode_T *x;
    emxArray_real_T_FlightMissionMode_T *y;
    int32_T k;
    int32_T loop_ub;
    boolean_T b_y;
    boolean_T exitg1;
    FlightMissionMode_emxInit_real_T_i(&y, 1);
    k = y->size[0];
    y->size[0] = theta->size[0];
    FlightMissionMode_emxEnsureCapacity_real_T_a(y, k);
    for (k = 0; k <= static_cast<int32_T>(theta->size[0] - 1); k = static_cast<
            int32_T>(k + 1)) {
        y->data[k] = std::abs(theta->data[k]);
    }

    FlightMissionMode_emxInit_boolean_T_k(&x, 1);
    k = x->size[0];
    x->size[0] = y->size[0];
    FlightMissionMode_emxEnsureCapacity_boolean_T_p(x, k);
    loop_ub = y->size[0];
    for (k = 0; k <= static_cast<int32_T>(loop_ub - 1); k++) {
        x->data[k] = (y->data[k] > 3.1415926535897931);
    }

    b_y = false;
    k = 1;
    exitg1 = false;
    while ((!exitg1) && (k <= x->size[0])) {
        if (x->data[static_cast<int32_T>(k - 1)]) {
            b_y = true;
            exitg1 = true;
        } else {
            k = static_cast<int32_T>(k + 1);
        }
    }

    if (b_y) {
        k = y->size[0];
        y->size[0] = theta->size[0];
        FlightMissionMode_emxEnsureCapacity_real_T_a(y, k);
        loop_ub = theta->size[0];
        for (k = 0; k <= static_cast<int32_T>(loop_ub - 1); k++) {
            y->data[k] = theta->data[k] + 3.1415926535897931;
        }

        k = theta->size[0];
        theta->size[0] = y->size[0];
        FlightMissionMode_emxEnsureCapacity_real_T_a(theta, k);
        for (k = 0; k <= static_cast<int32_T>(y->size[0] - 1); k = static_cast<
                int32_T>(k + 1)) {
            theta->data[k] = mod_d42kHWKw(y->data[k]);
        }

        if (theta->size[0] == y->size[0]) {
            k = x->size[0];
            x->size[0] = theta->size[0];
            FlightMissionMode_emxEnsureCapacity_boolean_T_p(x, k);
            loop_ub = theta->size[0];
            for (k = 0; k <= static_cast<int32_T>(loop_ub - 1); k++) {
                x->data[k] = static_cast<boolean_T>(static_cast<int32_T>
                    ((theta->data[k] == 0.0) & (y->data[k] > 0.0)));
            }
        } else {
            FlightMissionMode_binary_expand_op_h(x, theta, y);
        }

        for (k = 0; k <= static_cast<int32_T>(x->size[0] - 1); k = static_cast<
                int32_T>(k + 1)) {
            if (x->data[k]) {
                theta->data[k] = 6.2831853071795862;
            }
        }

        loop_ub = theta->size[0];
        for (k = 0; k <= static_cast<int32_T>(loop_ub - 1); k++) {
            theta->data[k] -= 3.1415926535897931;
        }
    }

    FlightMissionMode_emxFree_boolean_T_d(&x);
    FlightMissionMode_emxFree_real_T_c(&y);
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_eml_find_p(const
    emxArray_boolean_T_FlightMissionMode_T *x,
    emxArray_int32_T_FlightMissionMode_T *i)
{
    int32_T idx;
    int32_T ii;
    int32_T nx;
    boolean_T exitg1;
    nx = x->size[1];
    idx = 0;
    ii = static_cast<int32_T>(i->size[0] * i->size[1]);
    i->size[0] = 1;
    i->size[1] = x->size[1];
    FlightMissionMode_emxEnsureCapacity_int32_T_c(i, ii);
    ii = 0;
    exitg1 = false;
    while ((!exitg1) && (ii <= static_cast<int32_T>(nx - 1))) {
        if (x->data[ii]) {
            idx = static_cast<int32_T>(idx + 1);
            i->data[static_cast<int32_T>(idx - 1)] = static_cast<int32_T>(ii + 1);
            if (idx >= nx) {
                exitg1 = true;
            } else {
                ii = static_cast<int32_T>(ii + 1);
            }
        } else {
            ii = static_cast<int32_T>(ii + 1);
        }
    }

    if (x->size[1] == 1) {
        if (idx == 0) {
            i->size[0] = 1;
            i->size[1] = 0;
        }
    } else if (idx < 1) {
        i->size[1] = 0;
    } else {
        ii = static_cast<int32_T>(i->size[0] * i->size[1]);
        i->size[1] = idx;
        FlightMissionMode_emxEnsureCapacity_int32_T_c(i, ii);
    }
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_oqn4q52hk(const char_T
    a_data[], const int32_T a_size[2])
{
    boolean_T b_bool;
    b_bool = false;
    if ((a_size[1] == 1) && (a_data[0] == 'N')) {
        b_bool = true;
    }

    return b_bool;
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_oqn4q52hkt(const char_T
    a_data[], const int32_T a_size[2])
{
    static const char_T b[2]{ 'H', 'l' };

    boolean_T b_bool;
    b_bool = false;
    if (a_size[1] == 2) {
        int32_T kstr;
        kstr = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (kstr < 2) {
                if (a_data[kstr] != b[kstr]) {
                    exitg1 = 1;
                } else {
                    kstr = static_cast<int32_T>(kstr + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    return b_bool;
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_oqn4q52hktu(const char_T
    a_data[], const int32_T a_size[2])
{
    static const char_T b[2]{ 'H', 'r' };

    boolean_T b_bool;
    b_bool = false;
    if (a_size[1] == 2) {
        int32_T kstr;
        kstr = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (kstr < 2) {
                if (a_data[kstr] != b[kstr]) {
                    exitg1 = 1;
                } else {
                    kstr = static_cast<int32_T>(kstr + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    return b_bool;
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_oqn4q52hktuw(const char_T
    a_data[], const int32_T a_size[2])
{
    boolean_T b_bool;
    b_bool = false;
    if ((a_size[1] == 1) && (a_data[0] == 'L')) {
        b_bool = true;
    }

    return b_bool;
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_oqn4q52hktuwa(const char_T
    a_data[], const int32_T a_size[2])
{
    boolean_T b_bool;
    b_bool = false;
    if ((a_size[1] == 1) && (a_data[0] == 'R')) {
        b_bool = true;
    }

    return b_bool;
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_oqn4q52hktuwav(const
    char_T a_data[], const int32_T a_size[2])
{
    boolean_T b_bool;
    b_bool = false;
    if ((a_size[1] == 1) && (a_data[0] == 'S')) {
        b_bool = true;
    }

    return b_bool;
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_mtimes_n(const
    emxArray_real_T_FlightMissionMode_T *A, const real_T B[4],
    emxArray_real_T_FlightMissionMode_T *C)
{
    int32_T i;
    int32_T m;
    m = A->size[0];
    i = static_cast<int32_T>(C->size[0] * C->size[1]);
    C->size[0] = A->size[0];
    C->size[1] = 2;
    FlightMissionMode_emxEnsureCapacity_real_T_a(C, i);
    for (i = 0; i <= static_cast<int32_T>(m - 1); i = static_cast<int32_T>(i + 1))
    {
        C->data[i] = A->data[static_cast<int32_T>(A->size[0] + i)] * B[1] +
            A->data[i] * B[0];
    }

    for (i = 0; i <= static_cast<int32_T>(m - 1); i = static_cast<int32_T>(i + 1))
    {
        C->data[static_cast<int32_T>(m + i)] = A->data[static_cast<int32_T>
            (A->size[0] + i)] * B[3] + A->data[i] * B[2];
    }
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_uavDubinsPathSegment_interpolate_d(
    const real_T b_this_StartPose[4], const real_T b_this_GoalPose[4], real_T
    b_this_FlightPathAngle, real_T b_this_AirSpeed, real_T
    b_this_MinTurningRadius, real_T b_this_HelixRadius, const
    cell_wrap_11_FlightMissionMode_T b_this_MotionTypes[4], const real_T
    b_this_MotionLengths[4], real_T b_this_Length,
    emxArray_real_T_FlightMissionMode_T *samples,
    emxArray_real_T_FlightMissionMode_T *poses)
{
    emxArray_boolean_T_FlightMissionMode_T *tempSamplesIndex;
    emxArray_boolean_T_FlightMissionMode_T *tempSamplesIndex_0;
    emxArray_int32_T_FlightMissionMode_T *ab;
    emxArray_real_T_FlightMissionMode_T *S;
    emxArray_real_T_FlightMissionMode_T *S_0;
    emxArray_real_T_FlightMissionMode_T *bb;
    emxArray_real_T_FlightMissionMode_T *d_x;
    emxArray_real_T_FlightMissionMode_T *ns;
    emxArray_real_T_FlightMissionMode_T *p;
    emxArray_real_T_FlightMissionMode_T *tempSamples;
    emxArray_real_T_FlightMissionMode_T *z;
    real_T state[6];
    real_T TransformMatrix[4];
    real_T tempMotionLength_data[4];
    real_T transLength_data[4];
    int32_T tempMotionLength_size[2];
    int32_T transLength_size[2];
    boolean_T tmp[4];
    FlightMissionMode_emxInit_real_T_i(&bb, 1);
    poses->size[0] = 0;
    poses->size[1] = 6;
    if ((static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(std::
            isnan(b_this_Length)) ^ 1))) && (samples->size[1] != 0)) {
        real_T b_b_tmp;
        real_T intermediateLength;
        real_T startIndex;
        real_T tempStartPose_idx_2;
        int32_T loop_ub;
        int32_T poses_0;
        int32_T tempMotionLength_data_tmp;
        tempStartPose_idx_2 = -b_this_StartPose[2];
        tempMotionLength_data_tmp = static_cast<int32_T>(poses->size[0] *
            poses->size[1]);
        poses->size[0] = samples->size[1];
        poses->size[1] = 6;
        FlightMissionMode_emxEnsureCapacity_real_T_a(poses,
            tempMotionLength_data_tmp);
        loop_ub = static_cast<int32_T>(static_cast<int32_T>(samples->size[1] * 6)
            - 1);
        for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <= loop_ub;
             tempMotionLength_data_tmp++) {
            poses->data[tempMotionLength_data_tmp] = 0.0;
        }

        b_b_tmp = std::cos(std::abs(b_this_FlightPathAngle));
        tempMotionLength_data_tmp = static_cast<int32_T>(samples->size[0] *
            samples->size[1]);
        samples->size[0] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T_a(samples,
            tempMotionLength_data_tmp);
        loop_ub = static_cast<int32_T>(samples->size[1] - 1);
        for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <= loop_ub;
             tempMotionLength_data_tmp++) {
            samples->data[tempMotionLength_data_tmp] *= b_b_tmp;
        }

        TransformMatrix[0] = b_this_MotionLengths[0] * b_b_tmp;
        TransformMatrix[1] = b_this_MotionLengths[1] * b_b_tmp;
        TransformMatrix[2] = b_this_MotionLengths[2] * b_b_tmp;
        tempMotionLength_size[0] = 1;
        tempMotionLength_size[1] = 4;
        tempMotionLength_data[0] = TransformMatrix[0];
        tempMotionLength_data[1] = TransformMatrix[1];
        tempMotionLength_data[2] = TransformMatrix[2];
        tempMotionLength_data[3] = b_this_MotionLengths[3] * b_b_tmp;
        FlightMissionMode_strcmp_oqn4q52h(b_this_MotionTypes, tmp);
        if (FlightMissionMode_any_l(tmp)) {
            tempMotionLength_size[0] = 1;
            tempMotionLength_size[1] = 3;
            tempMotionLength_data[0] = TransformMatrix[0];
            tempMotionLength_data[1] = TransformMatrix[1];
            tempMotionLength_data[2] = TransformMatrix[2];
        }

        FlightMissionMode_useConstantDim_c(tempMotionLength_data,
            tempMotionLength_size, transLength_data, transLength_size);
        FlightMissionMode_sort_oi4(samples);
        intermediateLength = 0.0;
        startIndex = 1.0;
        state[0] = b_this_StartPose[0];
        state[1] = -b_this_StartPose[1];
        state[3] = -b_this_StartPose[3];
        poses_0 = 0;
        FlightMissionMode_emxInit_boolean_T_k(&tempSamplesIndex, 2);
        FlightMissionMode_emxInit_real_T_i(&tempSamples, 1);
        FlightMissionMode_emxInit_real_T_i(&S, 1);
        FlightMissionMode_emxInit_real_T_i(&ns, 2);
        FlightMissionMode_emxInit_real_T_i(&z, 1);
        FlightMissionMode_emxInit_real_T_i(&p, 2);
        FlightMissionMode_emxInit_real_T_i(&d_x, 1);
        FlightMissionMode_emxInit_int32_T_j(&ab, 2);
        FlightMissionMode_emxInit_boolean_T_k(&tempSamplesIndex_0, 2);
        FlightMissionMode_emxInit_real_T_i(&S_0, 2);
        while (poses_0 <= static_cast<int32_T>(tempMotionLength_size[1] - 1)) {
            real_T radius;
            real_T samples_0;
            if (static_cast<int32_T>(poses_0 + 1) == 1) {
                tempMotionLength_data_tmp = static_cast<int32_T>
                    (tempSamplesIndex->size[0] * tempSamplesIndex->size[1]);
                tempSamplesIndex->size[0] = 1;
                tempSamplesIndex->size[1] = samples->size[1];
                FlightMissionMode_emxEnsureCapacity_boolean_T_p(tempSamplesIndex,
                    tempMotionLength_data_tmp);
                loop_ub = static_cast<int32_T>(samples->size[1] - 1);
                radius = (intermediateLength + tempMotionLength_data[0]) +
                    1.0E-6;
                for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <=
                     loop_ub; tempMotionLength_data_tmp++) {
                    samples_0 = samples->data[tempMotionLength_data_tmp];
                    tempSamplesIndex->data[tempMotionLength_data_tmp] =
                        static_cast<boolean_T>(static_cast<int32_T>((samples_0 >=
                        intermediateLength) & (samples_0 <= radius)));
                }
            } else {
                tempMotionLength_data_tmp = static_cast<int32_T>
                    (tempSamplesIndex->size[0] * tempSamplesIndex->size[1]);
                tempSamplesIndex->size[0] = 1;
                tempSamplesIndex->size[1] = samples->size[1];
                FlightMissionMode_emxEnsureCapacity_boolean_T_p(tempSamplesIndex,
                    tempMotionLength_data_tmp);
                loop_ub = static_cast<int32_T>(samples->size[1] - 1);
                radius = (intermediateLength + tempMotionLength_data[poses_0]) +
                    1.0E-6;
                for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <=
                     loop_ub; tempMotionLength_data_tmp++) {
                    samples_0 = samples->data[tempMotionLength_data_tmp];
                    tempSamplesIndex->data[tempMotionLength_data_tmp] =
                        static_cast<boolean_T>(static_cast<int32_T>((samples_0 >
                        intermediateLength) & (samples_0 <= radius)));
                }
            }

            tempMotionLength_data_tmp = static_cast<int32_T>
                (tempSamplesIndex_0->size[0] * tempSamplesIndex_0->size[1]);
            tempSamplesIndex_0->size[0] = 1;
            tempSamplesIndex_0->size[1] = tempSamplesIndex->size[1];
            FlightMissionMode_emxEnsureCapacity_boolean_T_p(tempSamplesIndex_0,
                tempMotionLength_data_tmp);
            loop_ub = tempSamplesIndex->size[1];
            for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <=
                    static_cast<int32_T>(loop_ub - 1); tempMotionLength_data_tmp
                    ++) {
                tempSamplesIndex_0->data[tempMotionLength_data_tmp] =
                    tempSamplesIndex->data[tempMotionLength_data_tmp];
            }

            FlightMissionMode_eml_find_p(tempSamplesIndex_0, ab);
            if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                    (FlightMissionMode_strcmp_oqn4q52hk
                     (b_this_MotionTypes[poses_0].f1.data,
                      b_this_MotionTypes[poses_0].f1.size)) ^ 1))) {
                real_T TransformMatrix_tmp;
                int32_T count;
                int32_T tempMotionLength_data_tmp_0;
                radius = b_this_MinTurningRadius;
                if (FlightMissionMode_strcmp_oqn4q52hkt
                        (b_this_MotionTypes[poses_0].f1.data,
                         b_this_MotionTypes[poses_0].f1.size)) {
                    radius = b_this_HelixRadius;
                } else if (FlightMissionMode_strcmp_oqn4q52hktu
                           (b_this_MotionTypes[poses_0].f1.data,
                            b_this_MotionTypes[poses_0].f1.size)) {
                    radius = b_this_HelixRadius;
                }

                count = 0;
                tempMotionLength_data_tmp = tempSamples->size[0];
                tempSamples->size[0] = 1;
                FlightMissionMode_emxEnsureCapacity_real_T_a(tempSamples,
                    tempMotionLength_data_tmp);
                tempSamples->data[0] = 0.0;
                if (ab->size[1] != 0) {
                    tempMotionLength_data_tmp = tempSamples->size[0];
                    tempSamples->size[0] = static_cast<int32_T>(ab->size[1] + 1);
                    FlightMissionMode_emxEnsureCapacity_real_T_a(tempSamples,
                        tempMotionLength_data_tmp);
                    loop_ub = ab->size[1];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= loop_ub;
                            tempMotionLength_data_tmp++) {
                        tempSamples->data[tempMotionLength_data_tmp] = 0.0;
                    }

                    count = ab->size[1];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (count - 1); tempMotionLength_data_tmp++) {
                        tempSamples->data[tempMotionLength_data_tmp] =
                            samples->data[static_cast<int32_T>(ab->
                            data[tempMotionLength_data_tmp] - 1)];
                    }

                    count = ab->size[1];
                    loop_ub = static_cast<int32_T>(ab->size[1] - 1);
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= loop_ub;
                            tempMotionLength_data_tmp++) {
                        samples->data[static_cast<int32_T>(ab->
                            data[tempMotionLength_data_tmp] - 1)] = -1.0;
                    }
                }

                tempSamples->data[count] = transLength_data[poses_0];
                tempMotionLength_data_tmp = S->size[0];
                S->size[0] = tempSamples->size[0];
                FlightMissionMode_emxEnsureCapacity_real_T_a(S,
                    tempMotionLength_data_tmp);
                loop_ub = tempSamples->size[0];
                for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <=
                     static_cast<int32_T>(loop_ub - 1);
                        tempMotionLength_data_tmp++) {
                    S->data[tempMotionLength_data_tmp] = (tempSamples->
                        data[tempMotionLength_data_tmp] - intermediateLength) /
                        radius;
                }

                tempMotionLength_data_tmp = static_cast<int32_T>(ns->size[0] *
                    ns->size[1]);
                ns->size[0] = S->size[0];
                ns->size[1] = 6;
                FlightMissionMode_emxEnsureCapacity_real_T_a(ns,
                    tempMotionLength_data_tmp);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(S->size[0] *
                    6) - 1);
                for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <=
                     loop_ub; tempMotionLength_data_tmp++) {
                    ns->data[tempMotionLength_data_tmp] = 0.0;
                }

                tempMotionLength_data_tmp = z->size[0];
                z->size[0] = tempSamples->size[0];
                FlightMissionMode_emxEnsureCapacity_real_T_a(z,
                    tempMotionLength_data_tmp);
                loop_ub = tempSamples->size[0];
                for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <=
                     static_cast<int32_T>(loop_ub - 1);
                        tempMotionLength_data_tmp++) {
                    z->data[tempMotionLength_data_tmp] = tempStartPose_idx_2 +
                        tempSamples->data[tempMotionLength_data_tmp];
                }

                samples_0 = std::sin(state[3]);
                TransformMatrix_tmp = std::cos(state[3]);
                TransformMatrix[0] = TransformMatrix_tmp;
                TransformMatrix[2] = samples_0;
                TransformMatrix[1] = -samples_0;
                TransformMatrix[3] = TransformMatrix_tmp;
                if (b_this_Length != 0.0) {
                    samples_0 = -b_this_GoalPose[2] - tempStartPose_idx_2;
                    TransformMatrix_tmp = b_this_Length * b_b_tmp;
                    tempMotionLength_data_tmp = z->size[0];
                    z->size[0] = tempSamples->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T_a(z,
                        tempMotionLength_data_tmp);
                    loop_ub = tempSamples->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        z->data[tempMotionLength_data_tmp] = tempSamples->
                            data[tempMotionLength_data_tmp] /
                            TransformMatrix_tmp * samples_0 +
                            tempStartPose_idx_2;
                    }
                }

                if (FlightMissionMode_strcmp_oqn4q52hkt
                        (b_this_MotionTypes[poses_0].f1.data,
                         b_this_MotionTypes[poses_0].f1.size) ||
                        FlightMissionMode_strcmp_oqn4q52hktuw
                        (b_this_MotionTypes[poses_0].f1.data,
                         b_this_MotionTypes[poses_0].f1.size)) {
                    real_T state_0;
                    real_T state_1;
                    tempMotionLength_data_tmp = tempSamples->size[0];
                    tempSamples->size[0] = S->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T_a(tempSamples,
                        tempMotionLength_data_tmp);
                    loop_ub = S->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        tempSamples->data[tempMotionLength_data_tmp] = S->
                            data[tempMotionLength_data_tmp];
                    }

                    for (count = 0; count <= static_cast<int32_T>(S->size[0] - 1);
                         count = static_cast<int32_T>(count + 1)) {
                        tempSamples->data[count] = std::sin(tempSamples->
                            data[count]);
                    }

                    tempMotionLength_data_tmp = d_x->size[0];
                    d_x->size[0] = S->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T_a(d_x,
                        tempMotionLength_data_tmp);
                    loop_ub = S->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        d_x->data[tempMotionLength_data_tmp] = S->
                            data[tempMotionLength_data_tmp];
                    }

                    for (count = 0; count <= static_cast<int32_T>(S->size[0] - 1);
                         count = static_cast<int32_T>(count + 1)) {
                        d_x->data[count] = std::cos(d_x->data[count]);
                    }

                    tempMotionLength_data_tmp = static_cast<int32_T>(S_0->size[0]
                        * S_0->size[1]);
                    S_0->size[0] = tempSamples->size[0];
                    S_0->size[1] = 2;
                    FlightMissionMode_emxEnsureCapacity_real_T_a(S_0,
                        tempMotionLength_data_tmp);
                    loop_ub = tempSamples->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        S_0->data[tempMotionLength_data_tmp] = tempSamples->
                            data[tempMotionLength_data_tmp];
                    }

                    loop_ub = d_x->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        S_0->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + tempSamples->size[0])] = 1.0 - d_x->
                            data[tempMotionLength_data_tmp];
                    }

                    FlightMissionMode_mtimes_n(S_0, TransformMatrix, p);
                    samples_0 = rt_atan2d_snf(b_this_AirSpeed * b_this_AirSpeed,
                        9.8 * radius);
                    TransformMatrix_tmp = state[0];
                    state_0 = state[1];
                    state_1 = state[3];
                    count = S->size[0];
                    tempMotionLength_data_tmp_0 = S->size[0];
                    loop_ub = p->size[0];
                    tempMotionLength_data_tmp = static_cast<int32_T>(ns->size[0]
                        * ns->size[1]);
                    ns->size[0] = p->size[0];
                    ns->size[1] = 6;
                    FlightMissionMode_emxEnsureCapacity_real_T_a(ns,
                        tempMotionLength_data_tmp);
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        ns->data[tempMotionLength_data_tmp] = p->
                            data[tempMotionLength_data_tmp] * radius +
                            TransformMatrix_tmp;
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + ns->size[0])] = p->data[static_cast<int32_T>
                            (tempMotionLength_data_tmp + p->size[0])] * radius +
                            state_0;
                    }

                    loop_ub = z->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] << 1))] = z->
                            data[tempMotionLength_data_tmp];
                    }

                    loop_ub = S->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] * 3))] = state_1
                            + S->data[tempMotionLength_data_tmp];
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (count - 1); tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] << 2))] =
                            b_this_FlightPathAngle;
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (tempMotionLength_data_tmp_0 - 1);
                            tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] * 5))] =
                            -samples_0;
                    }
                } else if (FlightMissionMode_strcmp_oqn4q52hktu
                           (b_this_MotionTypes[poses_0].f1.data,
                            b_this_MotionTypes[poses_0].f1.size) ||
                           FlightMissionMode_strcmp_oqn4q52hktuwa
                           (b_this_MotionTypes[poses_0].f1.data,
                            b_this_MotionTypes[poses_0].f1.size)) {
                    real_T state_0;
                    real_T state_1;
                    tempMotionLength_data_tmp = tempSamples->size[0];
                    tempSamples->size[0] = S->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T_a(tempSamples,
                        tempMotionLength_data_tmp);
                    loop_ub = S->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        tempSamples->data[tempMotionLength_data_tmp] = S->
                            data[tempMotionLength_data_tmp];
                    }

                    for (count = 0; count <= static_cast<int32_T>(S->size[0] - 1);
                         count = static_cast<int32_T>(count + 1)) {
                        tempSamples->data[count] = std::sin(tempSamples->
                            data[count]);
                    }

                    tempMotionLength_data_tmp = d_x->size[0];
                    d_x->size[0] = S->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T_a(d_x,
                        tempMotionLength_data_tmp);
                    loop_ub = S->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        d_x->data[tempMotionLength_data_tmp] = S->
                            data[tempMotionLength_data_tmp];
                    }

                    for (count = 0; count <= static_cast<int32_T>(S->size[0] - 1);
                         count = static_cast<int32_T>(count + 1)) {
                        d_x->data[count] = std::cos(d_x->data[count]);
                    }

                    tempMotionLength_data_tmp = static_cast<int32_T>(S_0->size[0]
                        * S_0->size[1]);
                    S_0->size[0] = tempSamples->size[0];
                    S_0->size[1] = 2;
                    FlightMissionMode_emxEnsureCapacity_real_T_a(S_0,
                        tempMotionLength_data_tmp);
                    loop_ub = tempSamples->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        S_0->data[tempMotionLength_data_tmp] = tempSamples->
                            data[tempMotionLength_data_tmp];
                    }

                    loop_ub = d_x->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        S_0->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + tempSamples->size[0])] = d_x->
                            data[tempMotionLength_data_tmp] - 1.0;
                    }

                    FlightMissionMode_mtimes_n(S_0, TransformMatrix, p);
                    samples_0 = rt_atan2d_snf(b_this_AirSpeed * b_this_AirSpeed,
                        9.8 * radius);
                    TransformMatrix_tmp = state[0];
                    state_0 = state[1];
                    state_1 = state[3];
                    count = S->size[0];
                    tempMotionLength_data_tmp_0 = S->size[0];
                    loop_ub = p->size[0];
                    tempMotionLength_data_tmp = static_cast<int32_T>(ns->size[0]
                        * ns->size[1]);
                    ns->size[0] = p->size[0];
                    ns->size[1] = 6;
                    FlightMissionMode_emxEnsureCapacity_real_T_a(ns,
                        tempMotionLength_data_tmp);
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        ns->data[tempMotionLength_data_tmp] = p->
                            data[tempMotionLength_data_tmp] * radius +
                            TransformMatrix_tmp;
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + ns->size[0])] = p->data[static_cast<int32_T>
                            (tempMotionLength_data_tmp + p->size[0])] * radius +
                            state_0;
                    }

                    loop_ub = z->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] << 1))] = z->
                            data[tempMotionLength_data_tmp];
                    }

                    loop_ub = S->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] * 3))] = state_1
                            - S->data[tempMotionLength_data_tmp];
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (count - 1); tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] << 2))] =
                            b_this_FlightPathAngle;
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (tempMotionLength_data_tmp_0 - 1);
                            tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] * 5))] =
                            samples_0;
                    }
                } else if (FlightMissionMode_strcmp_oqn4q52hktuwav
                           (b_this_MotionTypes[poses_0].f1.data,
                            b_this_MotionTypes[poses_0].f1.size)) {
                    real_T state_0;
                    int32_T S_idx_0;
                    count = S->size[0];
                    tempMotionLength_data_tmp = static_cast<int32_T>(S_0->size[0]
                        * S_0->size[1]);
                    S_0->size[0] = S->size[0];
                    S_0->size[1] = 2;
                    FlightMissionMode_emxEnsureCapacity_real_T_a(S_0,
                        tempMotionLength_data_tmp);
                    loop_ub = S->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        S_0->data[tempMotionLength_data_tmp] = S->
                            data[tempMotionLength_data_tmp];
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (count - 1); tempMotionLength_data_tmp++) {
                        S_0->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + S->size[0])] = 0.0;
                    }

                    FlightMissionMode_mtimes_n(S_0, TransformMatrix, p);
                    TransformMatrix_tmp = state[0];
                    state_0 = state[1];
                    count = S->size[0];
                    tempMotionLength_data_tmp_0 = S->size[0];
                    S_idx_0 = S->size[0];
                    loop_ub = p->size[0];
                    tempMotionLength_data_tmp = static_cast<int32_T>(ns->size[0]
                        * ns->size[1]);
                    ns->size[0] = p->size[0];
                    ns->size[1] = 6;
                    FlightMissionMode_emxEnsureCapacity_real_T_a(ns,
                        tempMotionLength_data_tmp);
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        ns->data[tempMotionLength_data_tmp] = p->
                            data[tempMotionLength_data_tmp] * radius +
                            TransformMatrix_tmp;
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + ns->size[0])] = p->data[static_cast<int32_T>
                            (tempMotionLength_data_tmp + p->size[0])] * radius +
                            state_0;
                    }

                    loop_ub = z->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] << 1))] = z->
                            data[tempMotionLength_data_tmp];
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (count - 1); tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] * 3))] = state[3];
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (tempMotionLength_data_tmp_0 - 1);
                            tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] << 2))] =
                            b_this_FlightPathAngle;
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (S_idx_0 - 1); tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] * 5))] = 0.0;
                    }
                }

                if (ab->size[1] != 0) {
                    if (startIndex > (startIndex + static_cast<real_T>(ab->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp < 6;
                            tempMotionLength_data_tmp++) {
                        for (tempMotionLength_data_tmp_0 = 0;
                                tempMotionLength_data_tmp_0 <= loop_ub;
                                tempMotionLength_data_tmp_0++) {
                            poses->data[static_cast<int32_T>(static_cast<int32_T>
                                (static_cast<int32_T>(count +
                                tempMotionLength_data_tmp_0) +
                                 static_cast<int32_T>(poses->size[0] *
                                tempMotionLength_data_tmp)) - 1)] = ns->data[
                                static_cast<int32_T>(static_cast<int32_T>
                                (ns->size[0] * tempMotionLength_data_tmp) +
                                tempMotionLength_data_tmp_0)];
                        }
                    }

                    if (startIndex > (startIndex + static_cast<real_T>(ab->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= loop_ub;
                            tempMotionLength_data_tmp++) {
                        poses->data[static_cast<int32_T>(static_cast<int32_T>
                            (count + tempMotionLength_data_tmp) - 1)] = ns->
                            data[tempMotionLength_data_tmp];
                    }

                    if (startIndex > (startIndex + static_cast<real_T>(ab->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= loop_ub;
                            tempMotionLength_data_tmp++) {
                        poses->data[static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>(count +
                            tempMotionLength_data_tmp) + poses->size[0]) - 1)] =
                            -ns->data[static_cast<int32_T>
                            (tempMotionLength_data_tmp + ns->size[0])];
                    }

                    if (startIndex > (startIndex + static_cast<real_T>(ab->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= loop_ub;
                            tempMotionLength_data_tmp++) {
                        poses->data[static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>(count +
                            tempMotionLength_data_tmp) + static_cast<int32_T>
                            (poses->size[0] << 1)) - 1)] = -ns->data[
                            static_cast<int32_T>(static_cast<int32_T>(ns->size[0]
                            << 1) + tempMotionLength_data_tmp)];
                    }

                    if (startIndex > (startIndex + static_cast<real_T>(ab->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= loop_ub;
                            tempMotionLength_data_tmp++) {
                        poses->data[static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>(count +
                            tempMotionLength_data_tmp) + static_cast<int32_T>
                            (poses->size[0] * 3)) - 1)] = -ns->data[static_cast<
                            int32_T>(static_cast<int32_T>(ns->size[0] * 3) +
                                     tempMotionLength_data_tmp)];
                    }
                }

                count = ns->size[0];
                for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <
                        6; tempMotionLength_data_tmp++) {
                    state[tempMotionLength_data_tmp] = ns->data
                        [static_cast<int32_T>(static_cast<int32_T>
                        (static_cast<int32_T>(ns->size[0] *
                        tempMotionLength_data_tmp) + count) - 1)];
                }

                startIndex += static_cast<real_T>(ab->size[1]);
            }

            intermediateLength += tempMotionLength_data[poses_0];
            poses_0 = static_cast<int32_T>(poses_0 + 1);
        }

        FlightMissionMode_emxFree_real_T_c(&S_0);
        FlightMissionMode_emxFree_boolean_T_d(&tempSamplesIndex_0);
        FlightMissionMode_emxFree_int32_T_k(&ab);
        FlightMissionMode_emxFree_real_T_c(&d_x);
        FlightMissionMode_emxFree_real_T_c(&p);
        FlightMissionMode_emxFree_real_T_c(&z);
        FlightMissionMode_emxFree_real_T_c(&ns);
        FlightMissionMode_emxFree_real_T_c(&S);
        FlightMissionMode_emxFree_real_T_c(&tempSamples);
        FlightMissionMode_emxFree_boolean_T_d(&tempSamplesIndex);
        loop_ub = poses->size[0];
        tempMotionLength_data_tmp = bb->size[0];
        bb->size[0] = poses->size[0];
        FlightMissionMode_emxEnsureCapacity_real_T_a(bb,
            tempMotionLength_data_tmp);
        for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <=
                static_cast<int32_T>(loop_ub - 1); tempMotionLength_data_tmp++)
        {
            bb->data[tempMotionLength_data_tmp] = poses->data
                [static_cast<int32_T>(static_cast<int32_T>(poses->size[0] * 3) +
                tempMotionLength_data_tmp)];
        }

        FlightMissionMode_wrapToPi_i(bb);
        loop_ub = bb->size[0];
        for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <=
                static_cast<int32_T>(loop_ub - 1); tempMotionLength_data_tmp++)
        {
            poses->data[static_cast<int32_T>(tempMotionLength_data_tmp +
                static_cast<int32_T>(poses->size[0] * 3))] = bb->
                data[tempMotionLength_data_tmp];
        }
    }

    FlightMissionMode_emxFree_real_T_c(&bb);
}

// Function for MATLAB Function: '<S96>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_genSegWP_p(const real_T start[4],
    const real_T ende[4], emxArray_real_T_FlightMissionMode_T *segWayPoints,
    DW_WayPointGenerator_FlightMissionMode_T *localDW)
{
    emxArray_real_T_FlightMissionMode_T *lengths;
    emxArray_real_T_FlightMissionMode_T *poses;
    uavDubinsConnection_FlightMissionMode_c_T *obj;
    uavDubinsPathSegment_FlightMissionMode_g_T pathSegObj;
    real_T b_a__1_data[28];
    real_T iia_data_0[28];
    real_T a__1;
    int32_T iia_data[28];
    int32_T b_a__1_size[2];
    int32_T ib_size;
    int32_T iia_size;
    int32_T nm1d2;
    obj = FlightMissionMode_DubinsObjSingleton_getConnector_g(localDW);
    FlightMissionMode_do_vectors_d(b_a__1_data, b_a__1_size, iia_data, &nm1d2,
        &ib_size);
    iia_size = nm1d2;
    for (ib_size = 0; ib_size <= static_cast<int32_T>(nm1d2 - 1); ib_size++) {
        iia_data_0[ib_size] = static_cast<real_T>(iia_data[ib_size]);
    }

    FlightMissionMode_do_vectors_dl(iia_data_0, &iia_size, b_a__1_data,
        b_a__1_size, iia_data, &nm1d2, &ib_size);
    for (ib_size = 0; ib_size <= static_cast<int32_T>(nm1d2 - 1); ib_size++) {
        iia_data_0[ib_size] = static_cast<real_T>(iia_data[ib_size]);
    }

    FlightMissionMode_sort_oi(iia_data_0, &nm1d2);
    for (ib_size = 0; ib_size <= static_cast<int32_T>(nm1d2 - 1); ib_size++) {
        b_a__1_data[ib_size] = iia_data_0[ib_size] - 1.0;
    }

    FlightMissionMode_uavDubinsBuiltins_connect_d(obj, start, ende,
        obj->MinTurningRadius, b_a__1_data, &nm1d2, &pathSegObj, &a__1);
    a__1 = pathSegObj.Length / 128.0;
    FlightMissionMode_emxInit_real_T_i(&lengths, 2);
    if (std::isnan(a__1)) {
        nm1d2 = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        lengths->size[1] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T_a(lengths, nm1d2);
        lengths->data[0] = (rtNaN);
    } else if (std::isnan(pathSegObj.Length)) {
        nm1d2 = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        lengths->size[1] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T_a(lengths, nm1d2);
        lengths->data[0] = (rtNaN);
    } else if (a__1 == 0.0) {
        lengths->size[0] = 1;
        lengths->size[1] = 0;
    } else if ((pathSegObj.Length > 0.0) && (a__1 < 0.0)) {
        lengths->size[0] = 1;
        lengths->size[1] = 0;
    } else if ((pathSegObj.Length < 0.0) && (a__1 > 0.0)) {
        lengths->size[0] = 1;
        lengths->size[1] = 0;
    } else if (std::isinf(pathSegObj.Length) && std::isinf(a__1)) {
        nm1d2 = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        lengths->size[1] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T_a(lengths, nm1d2);
        lengths->data[0] = (rtNaN);
    } else if (std::isinf(a__1)) {
        nm1d2 = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        lengths->size[1] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T_a(lengths, nm1d2);
        lengths->data[0] = 0.0;
    } else if (std::floor(a__1) == a__1) {
        nm1d2 = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        iia_size = static_cast<int32_T>(pathSegObj.Length / a__1);
        lengths->size[1] = static_cast<int32_T>(iia_size + 1);
        FlightMissionMode_emxEnsureCapacity_real_T_a(lengths, nm1d2);
        for (ib_size = 0; ib_size <= iia_size; ib_size++) {
            lengths->data[ib_size] = a__1 * static_cast<real_T>(ib_size);
        }
    } else {
        real_T apnd;
        real_T cdiff;
        real_T ndbl;
        ndbl = std::floor(pathSegObj.Length / a__1 + 0.5);
        apnd = ndbl * a__1;
        if (a__1 > 0.0) {
            cdiff = apnd - pathSegObj.Length;
        } else {
            cdiff = pathSegObj.Length - apnd;
        }

        if (std::abs(cdiff) < 4.4408920985006262E-16 * std::fmax(0.0, std::abs
                (pathSegObj.Length))) {
            ndbl++;
            apnd = pathSegObj.Length;
        } else if (cdiff > 0.0) {
            apnd = (ndbl - 1.0) * a__1;
        } else {
            ndbl++;
        }

        if (ndbl >= 0.0) {
            ib_size = static_cast<int32_T>(static_cast<int32_T>(ndbl) - 1);
        } else {
            ib_size = -1;
        }

        nm1d2 = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        lengths->size[1] = static_cast<int32_T>(ib_size + 1);
        FlightMissionMode_emxEnsureCapacity_real_T_a(lengths, nm1d2);
        if (static_cast<int32_T>(ib_size + 1) > 0) {
            lengths->data[0] = 0.0;
            if (static_cast<int32_T>(ib_size + 1) > 1) {
                lengths->data[ib_size] = apnd;
                nm1d2 = static_cast<int32_T>(ib_size / 2);
                for (iia_size = 1; static_cast<int32_T>(iia_size - 1) <=
                        static_cast<int32_T>(nm1d2 - 2); iia_size = static_cast<
                        int32_T>(iia_size + 1)) {
                    ndbl = static_cast<real_T>(iia_size) * a__1;
                    lengths->data[iia_size] = ndbl;
                    lengths->data[static_cast<int32_T>(ib_size - iia_size)] =
                        apnd - ndbl;
                }

                if (static_cast<int32_T>(nm1d2 << 1) == ib_size) {
                    lengths->data[nm1d2] = apnd / 2.0;
                } else {
                    ndbl = static_cast<real_T>(nm1d2) * a__1;
                    lengths->data[nm1d2] = ndbl;
                    lengths->data[static_cast<int32_T>(nm1d2 + 1)] = apnd - ndbl;
                }
            }
        }
    }

    FlightMissionMode_emxInit_real_T_i(&poses, 2);
    FlightMissionMode_uavDubinsPathSegment_interpolate_d(pathSegObj.StartPose,
        pathSegObj.GoalPose, pathSegObj.FlightPathAngle, pathSegObj.AirSpeed,
        pathSegObj.MinTurningRadius, pathSegObj.HelixRadius,
        pathSegObj.MotionTypes, pathSegObj.MotionLengths, pathSegObj.Length,
        lengths, poses);
    iia_size = poses->size[0];
    nm1d2 = static_cast<int32_T>(segWayPoints->size[0] * segWayPoints->size[1]);
    segWayPoints->size[0] = poses->size[0];
    segWayPoints->size[1] = 3;
    FlightMissionMode_emxEnsureCapacity_real_T_a(segWayPoints, nm1d2);
    FlightMissionMode_emxFree_real_T_c(&lengths);
    for (ib_size = 0; ib_size < 3; ib_size++) {
        for (nm1d2 = 0; nm1d2 <= static_cast<int32_T>(iia_size - 1); nm1d2++) {
            segWayPoints->data[static_cast<int32_T>(nm1d2 + static_cast<int32_T>
                (segWayPoints->size[0] * ib_size))] = poses->data
                [static_cast<int32_T>(static_cast<int32_T>(poses->size[0] *
                ib_size) + nm1d2)];
        }
    }

    FlightMissionMode_emxFree_real_T_c(&poses);
}

//
// System initialize for atomic system:
//    '<S96>/WayPointGenerator'
//    '<S138>/WayPointGenerator'
//
void FlightMissionMode::FlightMissionMode_WayPointGenerator_Init
    (DW_WayPointGenerator_FlightMissionMode_T *localDW)
{
    FILE* a;
    a = NULL;
    for (int32_T i{0}; i < 20; i++) {
        localDW->eml_openfiles[i] = a;
    }
}

//
// System reset for atomic system:
//    '<S96>/WayPointGenerator'
//    '<S138>/WayPointGenerator'
//
void FlightMissionMode::FlightMissionMode_WayPointGenerator_Reset
    (DW_WayPointGenerator_FlightMissionMode_T *localDW)
{
    FILE* a;
    localDW->SingletonInstance_not_empty = false;
    a = NULL;
    for (int32_T i{0}; i < 20; i++) {
        localDW->eml_openfiles[i] = a;
    }
}

//
// Output and update for atomic system:
//    '<S96>/WayPointGenerator'
//    '<S138>/WayPointGenerator'
//
void FlightMissionMode::FlightMissionMode_WayPointGenerator(real_T rtu_Length,
    real_T rty_left[384], real_T rty_top[384], real_T rty_right[384], real_T
    rty_bottom[384], DW_WayPointGenerator_FlightMissionMode_T *localDW)
{
    emxArray_real_T_FlightMissionMode_T *SegWP;
    real_T LDp[4];
    real_T LUp[4];
    real_T RDp[4];
    real_T RUp[4];
    real_T LDp_tmp;
    real_T outputArg;
    int32_T tmp;
    FlightMissionMode_emxInit_real_T_i(&SegWP, 2);

    // MATLAB Function 'WayPointGenerator': '<S128>:1'
    // '<S128>:1:4'
    LUp[0] = 0.0;
    LUp[1] = rtu_Length / 2.0;
    LUp[2] = 0.0;
    LUp[3] = 1.5707963267948966;

    // '<S128>:1:5'
    LDp[0] = 0.0;
    LDp_tmp = -rtu_Length / 2.0;
    LDp[1] = LDp_tmp;
    LDp[2] = 0.0;
    LDp[3] = 1.5707963267948966;

    // '<S128>:1:6'
    outputArg = (FlightMissionMode_DubinsObjSingleton_getConnector_g(localDW))
        ->MinTurningRadius;
    RUp[0] = 2.0 * outputArg;
    RUp[1] = rtu_Length / 2.0;
    RUp[2] = 0.0;
    RUp[3] = -1.5707963267948966;

    // '<S128>:1:7'
    outputArg = (FlightMissionMode_DubinsObjSingleton_getConnector_g(localDW))
        ->MinTurningRadius;
    RDp[0] = 2.0 * outputArg;
    RDp[1] = LDp_tmp;
    RDp[2] = 0.0;
    RDp[3] = -1.5707963267948966;

    // '<S128>:1:13'
    FlightMissionMode_genSegWP_p(LDp, LUp, SegWP, localDW);

    // '<S128>:1:14'
    tmp = 0;
    for (int32_T i_0{0}; i_0 < 3; i_0++) {
        for (int32_T i{0}; i < 128; i++) {
            rty_left[static_cast<int32_T>(i + tmp)] = SegWP->data
                [static_cast<int32_T>(static_cast<int32_T>(SegWP->size[0] * i_0)
                + i)];
        }

        tmp = static_cast<int32_T>(tmp + 128);
    }

    // '<S128>:1:17'
    FlightMissionMode_genSegWP_p(LUp, RUp, SegWP, localDW);

    // '<S128>:1:18'
    tmp = 0;
    for (int32_T i_0{0}; i_0 < 3; i_0++) {
        for (int32_T i{0}; i < 128; i++) {
            rty_top[static_cast<int32_T>(i + tmp)] = SegWP->data
                [static_cast<int32_T>(static_cast<int32_T>(SegWP->size[0] * i_0)
                + i)];
        }

        tmp = static_cast<int32_T>(tmp + 128);
    }

    // '<S128>:1:21'
    FlightMissionMode_genSegWP_p(RUp, RDp, SegWP, localDW);

    // '<S128>:1:22'
    tmp = 0;
    for (int32_T i_0{0}; i_0 < 3; i_0++) {
        for (int32_T i{0}; i < 128; i++) {
            rty_right[static_cast<int32_T>(i + tmp)] = SegWP->data
                [static_cast<int32_T>(static_cast<int32_T>(SegWP->size[0] * i_0)
                + i)];
        }

        tmp = static_cast<int32_T>(tmp + 128);
    }

    // '<S128>:1:25'
    FlightMissionMode_genSegWP_p(RDp, LDp, SegWP, localDW);

    // '<S128>:1:26'
    tmp = 0;
    for (int32_T i_0{0}; i_0 < 3; i_0++) {
        for (int32_T i{0}; i < 128; i++) {
            rty_bottom[static_cast<int32_T>(i + tmp)] = SegWP->data
                [static_cast<int32_T>(static_cast<int32_T>(SegWP->size[0] * i_0)
                + i)];
        }

        tmp = static_cast<int32_T>(tmp + 128);
    }

    FlightMissionMode_emxFree_real_T_c(&SegWP);
}

//
// Output and update for atomic system:
//    '<S96>/biasNEDstartpose'
//    '<S138>/biasNEDstartpose1'
//
void FlightMissionMode::FlightMissionMode_biasNEDstartpose(const real_T
    rtu_MissionNED[3], const real_T rtu_IndivRotWP[3], real_T rty_nedWayPoint[3])
{
    // MATLAB Function 'biasNED': '<S129>:1'
    // '<S129>:1:4'
    rty_nedWayPoint[0] = rtu_MissionNED[0] + rtu_IndivRotWP[1];
    rty_nedWayPoint[1] = rtu_IndivRotWP[0] + rtu_MissionNED[1];
    rty_nedWayPoint[2] = rtu_IndivRotWP[2] + rtu_MissionNED[2];
}

void FlightMissionMode::FlightMissionMode_emxInit_char_T_e
    (emxArray_char_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions)
{
    emxArray_char_T_FlightMissionMode_T *emxArray;
    *pEmxArray = static_cast<emxArray_char_T_FlightMissionMode_T *>(std::malloc
        (sizeof(emxArray_char_T_FlightMissionMode_T)));
    emxArray = *pEmxArray;
    emxArray->data = static_cast<char_T *>(nullptr);
    emxArray->numDimensions = numDimensions;
    emxArray->size = static_cast<int32_T *>(std::malloc(static_cast<uint32_T>
        (sizeof(int32_T) * static_cast<uint32_T>(numDimensions))));
    emxArray->allocatedSize = 0;
    emxArray->canFreeData = true;
    for (int32_T i{0}; i <= static_cast<int32_T>(numDimensions - 1); i++) {
        emxArray->size[i] = 0;
    }
}

void FlightMissionMode::FlightMissionMode_emxInit_real_T_h
    (emxArray_real_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions)
{
    emxArray_real_T_FlightMissionMode_T *emxArray;
    *pEmxArray = static_cast<emxArray_real_T_FlightMissionMode_T *>(std::malloc
        (sizeof(emxArray_real_T_FlightMissionMode_T)));
    emxArray = *pEmxArray;
    emxArray->data = static_cast<real_T *>(nullptr);
    emxArray->numDimensions = numDimensions;
    emxArray->size = static_cast<int32_T *>(std::malloc(static_cast<uint32_T>
        (sizeof(int32_T) * static_cast<uint32_T>(numDimensions))));
    emxArray->allocatedSize = 0;
    emxArray->canFreeData = true;
    for (int32_T i{0}; i <= static_cast<int32_T>(numDimensions - 1); i++) {
        emxArray->size[i] = 0;
    }
}

void FlightMissionMode::FlightMissionMode_emxFree_real_T_n
    (emxArray_real_T_FlightMissionMode_T **pEmxArray)
{
    if (*pEmxArray != static_cast<emxArray_real_T_FlightMissionMode_T *>(nullptr))
    {
        if (((*pEmxArray)->data != static_cast<real_T *>(nullptr)) &&
                (*pEmxArray)->canFreeData) {
            std::free((*pEmxArray)->data);
        }

        std::free((*pEmxArray)->size);
        std::free(*pEmxArray);
        *pEmxArray = static_cast<emxArray_real_T_FlightMissionMode_T *>(nullptr);
    }
}

void FlightMissionMode::FlightMissionMode_emxFree_char_T_o
    (emxArray_char_T_FlightMissionMode_T **pEmxArray)
{
    if (*pEmxArray != static_cast<emxArray_char_T_FlightMissionMode_T *>(nullptr))
    {
        if (((*pEmxArray)->data != static_cast<char_T *>(nullptr)) &&
                (*pEmxArray)->canFreeData) {
            std::free((*pEmxArray)->data);
        }

        std::free((*pEmxArray)->size);
        std::free(*pEmxArray);
        *pEmxArray = static_cast<emxArray_char_T_FlightMissionMode_T *>(nullptr);
    }
}

// Function for MATLAB Function: '<S181>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_string_string(real_T val, char_T
    obj_Value_data[], int32_T obj_Value_size[2])
{
    int32_T resCount;
    char_T st[24];
    char_T str_data[23];
    if (val == 0.0) {
        resCount = 1;
        str_data[0] = '0';
    } else if (std::isinf(val)) {
        if (val > 0.0) {
            resCount = 3;
            str_data[0] = 'I';
            str_data[1] = 'n';
            str_data[2] = 'f';
        } else {
            resCount = 4;
            str_data[0] = '-';
            str_data[1] = 'I';
            str_data[2] = 'n';
            str_data[3] = 'f';
        }
    } else if (std::isnan(val)) {
        resCount = 3;
        str_data[0] = 'N';
        str_data[1] = 'a';
        str_data[2] = 'N';
    } else {
        resCount = sprintf(&st[0], "%.16g", val);
        for (int32_T b_k{0}; b_k <= static_cast<int32_T>(resCount - 1); b_k =
                static_cast<int32_T>(b_k + 1)) {
            str_data[b_k] = st[b_k];
        }
    }

    obj_Value_size[0] = 1;
    obj_Value_size[1] = resCount;
    resCount = static_cast<int32_T>(resCount - 1);
    for (int32_T b_k{0}; b_k <= resCount; b_k++) {
        obj_Value_data[b_k] = str_data[b_k];
    }
}

void FlightMissionMode::FlightMissionMode_emxEnsureCapacity_real_T_c
    (emxArray_real_T_FlightMissionMode_T *emxArray, int32_T oldNumel)
{
    int32_T i;
    int32_T newNumel;
    void *newData;
    if (oldNumel < 0) {
        oldNumel = 0;
    }

    newNumel = 1;
    for (i = 0; i <= static_cast<int32_T>(emxArray->numDimensions - 1); i++) {
        newNumel = static_cast<int32_T>(newNumel * emxArray->size[i]);
    }

    if (newNumel > emxArray->allocatedSize) {
        i = emxArray->allocatedSize;
        if (i < 16) {
            i = 16;
        }

        while (i < newNumel) {
            if (i > 1073741823) {
                i = MAX_int32_T;
            } else {
                i = static_cast<int32_T>(i << 1);
            }
        }

        newData = std::calloc(static_cast<uint32_T>(i), sizeof(real_T));
        if (emxArray->data != nullptr) {
            std::memcpy(newData, emxArray->data, static_cast<uint32_T>(sizeof
                         (real_T) * static_cast<uint32_T>(oldNumel)));
            if (emxArray->canFreeData) {
                std::free(emxArray->data);
            }
        }

        emxArray->data = static_cast<real_T *>(newData);
        emxArray->allocatedSize = i;
        emxArray->canFreeData = true;
    }
}

real_T FlightMissionMode::FlightMissionMode_norm_pv(const real_T x[3])
{
    real_T absxk;
    real_T scale;
    real_T t;
    real_T y;
    scale = 3.3121686421112381E-170;
    absxk = std::abs(x[0]);
    if (absxk > 3.3121686421112381E-170) {
        y = 1.0;
        scale = absxk;
    } else {
        t = absxk / 3.3121686421112381E-170;
        y = t * t;
    }

    absxk = std::abs(x[1]);
    if (absxk > scale) {
        t = scale / absxk;
        y = y * t * t + 1.0;
        scale = absxk;
    } else {
        t = absxk / scale;
        y += t * t;
    }

    absxk = std::abs(x[2]);
    if (absxk > scale) {
        t = scale / absxk;
        y = y * t * t + 1.0;
        scale = absxk;
    } else {
        t = absxk / scale;
        y += t * t;
    }

    return scale * std::sqrt(y);
}

void FlightMissionMode::FlightMissionMode_WaypointFollower_stepImpl
    (uav_sluav_internal_system_WaypointFollower_FlightMissionMode_cc_T *obj,
     const real_T currentPose[4], const real_T waypoints[24576], real_T
     lookaheadDistance, real_T varargout_1[3], real_T *varargout_2, real_T
     *varargout_3, uint8_T *varargout_4, uint8_T *varargout_5)
{
    emxArray_real_T_FlightMissionMode_T *b_waypointsIn;
    emxArray_real_T_FlightMissionMode_T *d;
    emxArray_real_T_FlightMissionMode_T *waypoints_0;
    real_T virtualWaypoint[3];
    real_T waypoints_1[3];
    real_T lambda;
    real_T virtualWaypoint_tmp_tmp;
    real_T virtualWaypoint_tmp_tmp_0;
    real_T virtualWaypoint_tmp_tmp_1;
    int32_T b_exponent;
    int32_T b_exponent_0;
    int32_T i1;
    int32_T i2;
    int32_T iy;
    int32_T j;
    boolean_T exitg1;
    boolean_T p;
    boolean_T p_0;
    lambda = lookaheadDistance;
    obj->LookaheadDistFlag = 0U;
    if (lookaheadDistance < 0.1) {
        lambda = 0.1;
        obj->LookaheadDistFlag = 1U;
    }

    *varargout_4 = obj->LookaheadDistFlag;
    obj->InitialPose[0] = 0.0;
    obj->InitialPose[1] = 0.0;
    obj->InitialPose[2] = 0.0;
    obj->InitialPose[3] = 0.0;
    for (iy = 0; iy < 24576; iy++) {
        FlightMissionMode_DW.paddedWaypts[iy] = (rtNaN);
    }

    iy = 0;
    for (j = 0; j < 3; j++) {
        std::memcpy(&FlightMissionMode_DW.paddedWaypts[iy], &waypoints[iy],
                    static_cast<uint32_T>(sizeof(real_T) << 13U));
        iy = static_cast<int32_T>(iy + 8192);
    }

    p = false;
    p_0 = true;
    iy = 0;
    exitg1 = false;
    while ((!exitg1) && (iy < 24576)) {
        if ((obj->WaypointsInternal[iy] == FlightMissionMode_DW.paddedWaypts[iy])
            || (std::isnan(obj->WaypointsInternal[iy]) && std::isnan
                (FlightMissionMode_DW.paddedWaypts[iy]))) {
            iy = static_cast<int32_T>(iy + 1);
        } else {
            p_0 = false;
            exitg1 = true;
        }
    }

    if (p_0) {
        p = true;
    }

    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(p) ^ 1)))
    {
        std::memcpy(&obj->WaypointsInternal[0],
                    &FlightMissionMode_DW.paddedWaypts[0], static_cast<uint32_T>
                    (24576U * sizeof(real_T)));
        obj->WaypointIndex = 1.0;
        obj->SearchFlag = true;
    }

    iy = 0;
    for (j = 0; j < 3; j++) {
        for (i1 = 0; i1 < 8191; i1++) {
            i2 = static_cast<int32_T>(i1 + iy);
            FlightMissionMode_DW.x_m[i2] = (waypoints[static_cast<int32_T>(i2 +
                1)] != waypoints[i2]);
        }

        FlightMissionMode_DW.x_m[static_cast<int32_T>(iy + 8191)] = true;
        iy = static_cast<int32_T>(iy + 8192);
    }

    i1 = 0;
    i2 = 16384;
    for (j = 0; j < 8192; j++) {
        FlightMissionMode_DW.b_g[j] = false;
        i1 = static_cast<int32_T>(i1 + 1);
        i2 = static_cast<int32_T>(i2 + 1);
        iy = i1;
        exitg1 = false;
        while ((!exitg1) && (iy <= i2)) {
            if (FlightMissionMode_DW.x_m[static_cast<int32_T>(iy - 1)]) {
                FlightMissionMode_DW.b_g[j] = true;
                exitg1 = true;
            } else {
                iy = static_cast<int32_T>(iy + 8192);
            }
        }
    }

    i1 = 0;
    for (iy = 0; iy < 8192; iy++) {
        if (FlightMissionMode_DW.b_g[iy]) {
            i1 = static_cast<int32_T>(i1 + 1);
        }
    }

    i2 = i1;
    i1 = 0;
    for (iy = 0; iy < 8192; iy++) {
        if (FlightMissionMode_DW.b_g[iy]) {
            FlightMissionMode_DW.c_data_g[i1] = static_cast<int16_T>(
                static_cast<int32_T>(iy + 1));
            i1 = static_cast<int32_T>(i1 + 1);
        }
    }

    FlightMissionMode_emxInit_real_T_h(&b_waypointsIn, 2);
    i1 = static_cast<int32_T>(b_waypointsIn->size[0] * b_waypointsIn->size[1]);
    b_waypointsIn->size[0] = i2;
    b_waypointsIn->size[1] = 3;
    FlightMissionMode_emxEnsureCapacity_real_T_c(b_waypointsIn, i1);
    for (iy = 0; iy < 3; iy++) {
        for (j = 0; j <= static_cast<int32_T>(i2 - 1); j++) {
            b_waypointsIn->data[static_cast<int32_T>(j + static_cast<int32_T>
                (b_waypointsIn->size[0] * iy))] = waypoints[static_cast<int32_T>
                (static_cast<int32_T>(static_cast<int32_T>(iy << 13) +
                  static_cast<int32_T>(FlightMissionMode_DW.c_data_g[j])) - 1)];
        }
    }

    obj->NumWaypoints = static_cast<real_T>(i2);
    obj->LookaheadDistance = lambda;
    FlightMissionMode_emxInit_real_T_h(&waypoints_0, 2);
    FlightMissionMode_emxInit_real_T_h(&d, 2);
    if (i2 == 0) {
        varargout_1[0] = lambda * std::cos(currentPose[3]) + currentPose[0];
        varargout_1[1] = lambda * std::sin(currentPose[3]) + currentPose[1];
        varargout_1[2] = lambda * 0.0 + currentPose[2];
        *varargout_2 = currentPose[3];
        *varargout_3 = currentPose[3];
        *varargout_5 = 1U;
    } else {
        boolean_T guard1{ false };

        guard1 = false;
        if (i2 == 1) {
            if (obj->StartFlag) {
                obj->InitialPose[0] = currentPose[0];
                obj->InitialPose[1] = currentPose[1];
                obj->InitialPose[2] = currentPose[2];
                obj->InitialPose[3] = currentPose[3];
            }

            virtualWaypoint[0] = b_waypointsIn->data[0] - currentPose[0];
            virtualWaypoint[1] = b_waypointsIn->data[1] - currentPose[1];
            virtualWaypoint[2] = b_waypointsIn->data[2] - currentPose[2];
            if (FlightMissionMode_norm_pv(virtualWaypoint) <
                    1.4901161193847656E-8) {
                varargout_1[0] = lambda * std::cos(currentPose[3]) +
                    currentPose[0];
                varargout_1[1] = lambda * std::sin(currentPose[3]) +
                    currentPose[1];
                varargout_1[2] = lambda * 0.0 + currentPose[2];
                *varargout_2 = currentPose[3];
                *varargout_3 = currentPose[3];
                *varargout_5 = 1U;
                obj->StartFlag = false;
            } else {
                obj->StartFlag = false;
                obj->NumWaypoints = 2.0;
                i1 = static_cast<int32_T>(waypoints_0->size[0] *
                    waypoints_0->size[1]);
                waypoints_0->size[0] = static_cast<int32_T>(b_waypointsIn->size
                    [0] + 1);
                waypoints_0->size[1] = 3;
                FlightMissionMode_emxEnsureCapacity_real_T_c(waypoints_0, i1);
                i1 = b_waypointsIn->size[0];
                for (iy = 0; iy < 3; iy++) {
                    waypoints_0->data[static_cast<int32_T>(waypoints_0->size[0] *
                        iy)] = obj->InitialPose[iy];
                    for (j = 0; j <= static_cast<int32_T>(i1 - 1); j++) {
                        waypoints_0->data[static_cast<int32_T>
                            (static_cast<int32_T>(j + static_cast<int32_T>
                              (waypoints_0->size[0] * iy)) + 1)] =
                            b_waypointsIn->data[static_cast<int32_T>(
                            static_cast<int32_T>(b_waypointsIn->size[0] * iy) +
                            j)];
                    }
                }

                guard1 = true;
            }
        } else {
            i1 = static_cast<int32_T>(waypoints_0->size[0] * waypoints_0->size[1]);
            waypoints_0->size[0] = b_waypointsIn->size[0];
            waypoints_0->size[1] = 3;
            FlightMissionMode_emxEnsureCapacity_real_T_c(waypoints_0, i1);
            i1 = static_cast<int32_T>(b_waypointsIn->size[0] * 3);
            for (iy = 0; iy <= static_cast<int32_T>(i1 - 1); iy++) {
                waypoints_0->data[iy] = b_waypointsIn->data[iy];
            }

            guard1 = true;
        }

        if (guard1) {
            real_T b;
            real_T lambda_tmp;
            real_T lambda_tmp_0;
            real_T virtualWaypoint_tmp;
            real_T virtualWaypoint_tmp_0;
            real_T virtualWaypoint_tmp_1;
            real_T waypoints_tmp;
            boolean_T guard2{ false };

            if (obj->SearchFlag) {
                i1 = static_cast<int32_T>(d->size[0] * d->size[1]);
                d->size[0] = 1;
                d->size[1] = static_cast<int32_T>(obj->NumWaypoints - 1.0);
                FlightMissionMode_emxEnsureCapacity_real_T_c(d, i1);
                j = static_cast<int32_T>(static_cast<int32_T>(obj->NumWaypoints
                    - 1.0) - 1);
                for (iy = 0; iy <= j; iy++) {
                    d->data[iy] = 0.0;
                    virtualWaypoint_tmp_tmp = waypoints_0->data
                        [static_cast<int32_T>(static_cast<int32_T>((static_cast<
                        real_T>(iy) + 1.0) + 1.0) - 1)];
                    virtualWaypoint_tmp = virtualWaypoint_tmp_tmp -
                        waypoints_0->data[iy];
                    virtualWaypoint_tmp_tmp_0 = waypoints_0->data
                        [static_cast<int32_T>(static_cast<int32_T>
                        (static_cast<int32_T>((static_cast<real_T>(iy) + 1.0) +
                        1.0) + waypoints_0->size[0]) - 1)];
                    virtualWaypoint_tmp_0 = virtualWaypoint_tmp_tmp_0 -
                        waypoints_0->data[static_cast<int32_T>(iy +
                        waypoints_0->size[0])];
                    virtualWaypoint_tmp_tmp_1 = waypoints_0->data
                        [static_cast<int32_T>(static_cast<int32_T>
                        (static_cast<int32_T>((static_cast<real_T>(iy) + 1.0) +
                        1.0) + static_cast<int32_T>(waypoints_0->size[0] << 1))
                        - 1)];
                    virtualWaypoint_tmp_1 = virtualWaypoint_tmp_tmp_1 -
                        waypoints_0->data[static_cast<int32_T>
                        (static_cast<int32_T>(waypoints_0->size[0] << 1) + iy)];
                    b = currentPose[0] - waypoints_0->data[iy];
                    lambda_tmp = currentPose[1] - waypoints_0->data
                        [static_cast<int32_T>(iy + waypoints_0->size[0])];
                    lambda_tmp_0 = currentPose[2] - waypoints_0->data[
                        static_cast<int32_T>(static_cast<int32_T>
                        (waypoints_0->size[0] << 1) + iy)];
                    lambda = ((b * virtualWaypoint_tmp + lambda_tmp *
                               virtualWaypoint_tmp_0) + lambda_tmp_0 *
                              virtualWaypoint_tmp_1) / ((virtualWaypoint_tmp *
                        virtualWaypoint_tmp + virtualWaypoint_tmp_0 *
                        virtualWaypoint_tmp_0) + virtualWaypoint_tmp_1 *
                        virtualWaypoint_tmp_1);
                    if (lambda < 0.0) {
                        virtualWaypoint[0] = b;
                        virtualWaypoint[1] = lambda_tmp;
                        virtualWaypoint[2] = lambda_tmp_0;
                        d->data[iy] = FlightMissionMode_norm_pv(virtualWaypoint);
                    } else if (lambda > 1.0) {
                        virtualWaypoint[0] = currentPose[0] -
                            virtualWaypoint_tmp_tmp;
                        virtualWaypoint[1] = currentPose[1] -
                            virtualWaypoint_tmp_tmp_0;
                        virtualWaypoint[2] = currentPose[2] -
                            virtualWaypoint_tmp_tmp_1;
                        d->data[iy] = FlightMissionMode_norm_pv(virtualWaypoint);
                    } else {
                        virtualWaypoint[0] = currentPose[0] - (lambda *
                            virtualWaypoint_tmp + waypoints_0->data[iy]);
                        virtualWaypoint[1] = currentPose[1] - (lambda *
                            virtualWaypoint_tmp_0 + waypoints_0->data[
                            static_cast<int32_T>(iy + waypoints_0->size[0])]);
                        virtualWaypoint[2] = currentPose[2] - (waypoints_0->
                            data[static_cast<int32_T>(static_cast<int32_T>
                            (waypoints_0->size[0] << 1) + iy)] + lambda *
                            virtualWaypoint_tmp_1);
                        d->data[iy] = FlightMissionMode_norm_pv(virtualWaypoint);
                    }
                }

                iy = d->size[1];
                if (d->size[1] <= 2) {
                    if (d->size[1] == 1) {
                        i1 = 1;
                    } else if ((d->data[0] > d->data[static_cast<int32_T>
                                (d->size[1] - 1)]) || (std::isnan(d->data[0]) &&
                                (static_cast<boolean_T>(static_cast<int32_T>(
                                   static_cast<int32_T>(std::isnan(d->data[
                                     static_cast<int32_T>(d->size[1] - 1)])) ^ 1)))))
                    {
                        i1 = d->size[1];
                    } else {
                        i1 = 1;
                    }
                } else {
                    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<
                            int32_T>(std::isnan(d->data[0])) ^ 1))) {
                        i1 = 1;
                    } else {
                        i1 = 0;
                        j = 2;
                        exitg1 = false;
                        while ((!exitg1) && (j <= iy)) {
                            if (static_cast<boolean_T>(static_cast<int32_T>(
                                    static_cast<int32_T>(std::isnan(d->data[
                                    static_cast<int32_T>(j - 1)])) ^ 1))) {
                                i1 = j;
                                exitg1 = true;
                            } else {
                                j = static_cast<int32_T>(j + 1);
                            }
                        }
                    }

                    if (i1 == 0) {
                        i1 = 1;
                    } else {
                        lambda = d->data[static_cast<int32_T>(i1 - 1)];
                        i2 = i1;
                        for (j = static_cast<int32_T>(i2 + 1); j <= iy; j++) {
                            b = d->data[static_cast<int32_T>(j - 1)];
                            if (lambda > b) {
                                lambda = b;
                                i1 = j;
                            }
                        }
                    }
                }

                obj->WaypointIndex = static_cast<real_T>(i1);
                obj->SearchFlag = false;
            }

            p = false;
            if (obj->WaypointIndex == obj->NumWaypoints) {
                p = true;
            }

            if (p) {
                obj->LastWaypointFlag = true;
                obj->WaypointIndex--;
            }

            virtualWaypoint_tmp = waypoints_0->data[static_cast<int32_T>(
                static_cast<int32_T>(obj->WaypointIndex + 1.0) - 1)];
            virtualWaypoint[0] = currentPose[0] - virtualWaypoint_tmp;
            virtualWaypoint_tmp_0 = waypoints_0->data[static_cast<int32_T>(
                static_cast<int32_T>(static_cast<int32_T>(obj->WaypointIndex +
                1.0) + waypoints_0->size[0]) - 1)];
            virtualWaypoint[1] = currentPose[1] - virtualWaypoint_tmp_0;
            virtualWaypoint_tmp_1 = waypoints_0->data[static_cast<int32_T>(
                static_cast<int32_T>(static_cast<int32_T>(obj->WaypointIndex +
                1.0) + static_cast<int32_T>(waypoints_0->size[0] << 1)) - 1)];
            virtualWaypoint[2] = currentPose[2] - virtualWaypoint_tmp_1;
            lambda = FlightMissionMode_norm_pv(virtualWaypoint);
            guard2 = false;
            if (lambda <= 30.0) {
                guard2 = true;
            } else {
                virtualWaypoint_tmp_tmp_1 = waypoints_0->data
                    [static_cast<int32_T>(static_cast<int32_T>
                    (obj->WaypointIndex) - 1)];
                lambda_tmp = virtualWaypoint_tmp - virtualWaypoint_tmp_tmp_1;
                waypoints_1[0] = lambda_tmp;
                virtualWaypoint_tmp_tmp_0 = waypoints_0->data
                    [static_cast<int32_T>(static_cast<int32_T>
                    (static_cast<int32_T>(obj->WaypointIndex) +
                     waypoints_0->size[0]) - 1)];
                lambda_tmp_0 = virtualWaypoint_tmp_0 - virtualWaypoint_tmp_tmp_0;
                waypoints_1[1] = lambda_tmp_0;
                virtualWaypoint_tmp_tmp = waypoints_0->data[static_cast<int32_T>
                    (static_cast<int32_T>(static_cast<int32_T>(waypoints_0->
                       size[0] << 1) + static_cast<int32_T>(obj->WaypointIndex))
                     - 1)];
                waypoints_tmp = virtualWaypoint_tmp_1 - virtualWaypoint_tmp_tmp;
                waypoints_1[2] = waypoints_tmp;
                b = FlightMissionMode_norm_pv(waypoints_1);
                lambda = (lambda_tmp / b * (virtualWaypoint[0] / lambda) +
                          lambda_tmp_0 / b * (virtualWaypoint[1] / lambda)) +
                    waypoints_tmp / b * (virtualWaypoint[2] / lambda);
                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>(std::isnan
                        (lambda)) ^ 1))) {
                    if (lambda < 0.0) {
                        lambda = -1.0;
                    } else {
                        lambda = static_cast<real_T>(lambda > 0.0);
                    }
                }

                if (lambda >= 0.0) {
                    guard2 = true;
                } else {
                    varargout_1[0] = virtualWaypoint_tmp;
                    varargout_1[1] = virtualWaypoint_tmp_0;
                    varargout_1[2] = virtualWaypoint_tmp_1;
                }
            }

            if (guard2) {
                obj->WaypointIndex++;
                p = false;
                if (obj->WaypointIndex == obj->NumWaypoints) {
                    p = true;
                }

                if (p) {
                    obj->LastWaypointFlag = true;
                    obj->WaypointIndex--;
                }

                virtualWaypoint_tmp_tmp_1 = waypoints_0->data
                    [static_cast<int32_T>(static_cast<int32_T>
                    (obj->WaypointIndex) - 1)];
                varargout_1[0] = waypoints_0->data[static_cast<int32_T>(
                    static_cast<int32_T>(obj->WaypointIndex + 1.0) - 1)];
                virtualWaypoint_tmp_tmp_0 = waypoints_0->data[static_cast<
                    int32_T>(static_cast<int32_T>(static_cast<int32_T>
                              (obj->WaypointIndex) + waypoints_0->size[0]) - 1)];
                varargout_1[1] = waypoints_0->data[static_cast<int32_T>(
                    static_cast<int32_T>(static_cast<int32_T>(obj->WaypointIndex
                    + 1.0) + waypoints_0->size[0]) - 1)];
                virtualWaypoint_tmp_tmp = waypoints_0->data[static_cast<int32_T>
                    (static_cast<int32_T>(static_cast<int32_T>(waypoints_0->
                       size[0] << 1) + static_cast<int32_T>(obj->WaypointIndex))
                     - 1)];
                varargout_1[2] = waypoints_0->data[static_cast<int32_T>(
                    static_cast<int32_T>(static_cast<int32_T>(obj->WaypointIndex
                    + 1.0) + static_cast<int32_T>(waypoints_0->size[0] << 1)) -
                    1)];
            }

            virtualWaypoint_tmp = varargout_1[0] - virtualWaypoint_tmp_tmp_1;
            lambda_tmp = currentPose[0] - virtualWaypoint_tmp_tmp_1;
            virtualWaypoint_tmp_0 = varargout_1[1] - virtualWaypoint_tmp_tmp_0;
            lambda_tmp_0 = currentPose[1] - virtualWaypoint_tmp_tmp_0;
            virtualWaypoint_tmp_1 = varargout_1[2] - virtualWaypoint_tmp_tmp;
            b = currentPose[2] - virtualWaypoint_tmp_tmp;
            lambda = ((lambda_tmp_0 * virtualWaypoint_tmp_0 + lambda_tmp *
                       virtualWaypoint_tmp) + b * virtualWaypoint_tmp_1) /
                ((virtualWaypoint_tmp_0 * virtualWaypoint_tmp_0 +
                  virtualWaypoint_tmp * virtualWaypoint_tmp) +
                 virtualWaypoint_tmp_1 * virtualWaypoint_tmp_1);
            if (lambda < 0.0) {
                virtualWaypoint[0] = lambda_tmp;
                virtualWaypoint[1] = lambda_tmp_0;
                virtualWaypoint[2] = b;
                lambda = FlightMissionMode_norm_pv(virtualWaypoint);
            } else if (lambda > 1.0) {
                virtualWaypoint[0] = currentPose[0] - varargout_1[0];
                virtualWaypoint[1] = currentPose[1] - varargout_1[1];
                virtualWaypoint[2] = currentPose[2] - varargout_1[2];
                lambda = FlightMissionMode_norm_pv(virtualWaypoint);
            } else {
                virtualWaypoint[0] = currentPose[0] - (lambda *
                    virtualWaypoint_tmp + virtualWaypoint_tmp_tmp_1);
                virtualWaypoint[1] = currentPose[1] - (lambda *
                    virtualWaypoint_tmp_0 + virtualWaypoint_tmp_tmp_0);
                virtualWaypoint[2] = currentPose[2] - (lambda *
                    virtualWaypoint_tmp_1 + virtualWaypoint_tmp_tmp);
                lambda = FlightMissionMode_norm_pv(virtualWaypoint);
            }

            if (obj->LastWaypointFlag) {
                lambda = (((currentPose[0] - virtualWaypoint_tmp_tmp_1) *
                           (varargout_1[0] - virtualWaypoint_tmp_tmp_1) +
                           (currentPose[1] - virtualWaypoint_tmp_tmp_0) *
                           (varargout_1[1] - virtualWaypoint_tmp_tmp_0)) +
                          (currentPose[2] - virtualWaypoint_tmp_tmp) *
                          (varargout_1[2] - virtualWaypoint_tmp_tmp)) /
                    (((varargout_1[0] - virtualWaypoint_tmp_tmp_1) *
                      (varargout_1[0] - virtualWaypoint_tmp_tmp_1) +
                      (varargout_1[1] - virtualWaypoint_tmp_tmp_0) *
                      (varargout_1[1] - virtualWaypoint_tmp_tmp_0)) +
                     (varargout_1[2] - virtualWaypoint_tmp_tmp) * (varargout_1[2]
                      - virtualWaypoint_tmp_tmp));
                virtualWaypoint[0] = currentPose[0] - (lambda *
                    virtualWaypoint_tmp + virtualWaypoint_tmp_tmp_1);
                virtualWaypoint[1] = currentPose[1] - (lambda *
                    virtualWaypoint_tmp_0 + virtualWaypoint_tmp_tmp_0);
                virtualWaypoint[2] = currentPose[2] - (lambda *
                    virtualWaypoint_tmp_1 + virtualWaypoint_tmp_tmp);
                lambda = FlightMissionMode_norm_pv(virtualWaypoint);
            }

            lambda_tmp = std::abs(lambda);
            if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                    (static_cast<boolean_T>(static_cast<int32_T>
                    (static_cast<int32_T>(std::isinf(lambda_tmp)) ^ 1))) &
                    static_cast<int32_T>(static_cast<boolean_T>
                    (static_cast<int32_T>(static_cast<int32_T>(std::isnan
                      (lambda_tmp)) ^ 1)))))) {
                if (lambda_tmp <= 2.2250738585072014E-308) {
                    b = 4.94065645841247E-324;
                    lambda_tmp = 4.94065645841247E-324;
                } else {
                    frexp(lambda_tmp, &b_exponent);
                    b = std::ldexp(1.0, static_cast<int32_T>(b_exponent - 53));
                    frexp(lambda_tmp, &b_exponent_0);
                    lambda_tmp = std::ldexp(1.0, static_cast<int32_T>
                                            (b_exponent_0 - 53));
                }
            } else {
                b = (rtNaN);
                lambda_tmp = (rtNaN);
            }

            if (obj->LookaheadDistance <= std::fmax(std::sqrt(b), 5.0 *
                    lambda_tmp) + lambda) {
                obj->LookaheadDistance = obj->LookaheadFactor * lambda;
            }

            lambda_tmp = virtualWaypoint_tmp_tmp_1 - currentPose[0];
            lambda_tmp_0 = virtualWaypoint_tmp_tmp_0 - currentPose[1];
            lambda = ((varargout_1[0] - virtualWaypoint_tmp_tmp_1) *
                      (varargout_1[0] - virtualWaypoint_tmp_tmp_1) +
                      (varargout_1[1] - virtualWaypoint_tmp_tmp_0) *
                      (varargout_1[1] - virtualWaypoint_tmp_tmp_0)) +
                (varargout_1[2] - virtualWaypoint_tmp_tmp) * (varargout_1[2] -
                virtualWaypoint_tmp_tmp);
            waypoints_tmp = virtualWaypoint_tmp_tmp - currentPose[2];
            b = ((virtualWaypoint_tmp * lambda_tmp + virtualWaypoint_tmp_0 *
                  lambda_tmp_0) + virtualWaypoint_tmp_1 * waypoints_tmp) * 2.0;
            lambda_tmp = std::sqrt(b * b - (((lambda_tmp * lambda_tmp +
                lambda_tmp_0 * lambda_tmp_0) + waypoints_tmp * waypoints_tmp) -
                                    obj->LookaheadDistance *
                                    obj->LookaheadDistance) * (4.0 * lambda));
            lambda = std::fmax((-b + lambda_tmp) / 2.0 / lambda, (-b -
                                lambda_tmp) / 2.0 / lambda);
            virtualWaypoint_tmp = (1.0 - lambda) * virtualWaypoint_tmp_tmp_1 +
                lambda * varargout_1[0];
            varargout_1[0] = virtualWaypoint_tmp;
            virtualWaypoint_tmp_0 = (1.0 - lambda) * virtualWaypoint_tmp_tmp_0 +
                lambda * varargout_1[1];
            varargout_1[1] = virtualWaypoint_tmp_0;
            varargout_1[2] = (1.0 - lambda) * virtualWaypoint_tmp_tmp + lambda *
                varargout_1[2];
            *varargout_2 = rt_atan2d_snf(virtualWaypoint_tmp_0 - currentPose[1],
                virtualWaypoint_tmp - currentPose[0]);
            *varargout_3 = *varargout_2;
            *varargout_5 = 0U;
            p = false;
            if (obj->LastWaypointFlag) {
                p = true;
            }

            if (p) {
                *varargout_5 = 1U;
            }

            obj->LastWaypointFlag = false;
        }
    }

    FlightMissionMode_emxFree_real_T_n(&d);
    FlightMissionMode_emxFree_real_T_n(&b_waypointsIn);
    FlightMissionMode_emxFree_real_T_n(&waypoints_0);
}

// Function for MATLAB Function: '<S181>/WayPointGenerator'
int8_T FlightMissionMode::FlightMissionMode_filedata_g(void) const
{
    int32_T k;
    int8_T f;
    boolean_T exitg1;
    f = 0;
    k = 1;
    exitg1 = false;
    while ((!exitg1) && (static_cast<int32_T>(k - 1) < 20)) {
        if (FlightMissionMode_DW.eml_openfiles_n[static_cast<int32_T>(
                static_cast<int32_T>(static_cast<int8_T>(k)) - 1)] == NULL) {
            f = static_cast<int8_T>(k);
            exitg1 = true;
        } else {
            k = static_cast<int32_T>(k + 1);
        }
    }

    return f;
}

// Function for MATLAB Function: '<S181>/WayPointGenerator'
int8_T FlightMissionMode::FlightMissionMode_cfopen_f(const char_T
    cfilename_data[], const int32_T cfilename_size[2], const char_T *cpermission)
{
    char_T ccfilename_data[38];
    int8_T fileid;
    int8_T j;
    fileid = -1;
    j = FlightMissionMode_filedata_g();
    if (static_cast<int32_T>(j) >= 1) {
        FILE* filestar;
        int32_T ccfilename_data_tmp;
        int32_T loop_ub;
        loop_ub = cfilename_size[1];
        for (ccfilename_data_tmp = 0; ccfilename_data_tmp <= static_cast<int32_T>
                (loop_ub - 1); ccfilename_data_tmp++) {
            ccfilename_data[ccfilename_data_tmp] =
                cfilename_data[ccfilename_data_tmp];
        }

        ccfilename_data[cfilename_size[1]] = '\x00';
        filestar = fopen(&ccfilename_data[0], cpermission);
        if (filestar != NULL) {
            FlightMissionMode_DW.eml_openfiles_n[static_cast<int32_T>(
                static_cast<int32_T>(j) - 1)] = filestar;
            ccfilename_data_tmp = static_cast<int32_T>(static_cast<int32_T>(j) +
                2);
            if (static_cast<int32_T>(static_cast<int32_T>(j) + 2) > 127) {
                ccfilename_data_tmp = 127;
            }

            fileid = static_cast<int8_T>(ccfilename_data_tmp);
        }
    }

    return fileid;
}

// Function for MATLAB Function: '<S181>/WayPointGenerator'
int32_T FlightMissionMode::FlightMissionMode_cfclose_m(real_T fid)
{
    FILE* filestar;
    int32_T st;
    int8_T b_fileid;
    int8_T fileid;
    st = -1;
    fileid = static_cast<int8_T>(std::round(fid));
    if (static_cast<boolean_T>(static_cast<int32_T>((static_cast<int32_T>(fileid)
           < 0) | (fid != static_cast<real_T>(fileid))))) {
        fileid = -1;
    }

    b_fileid = fileid;
    if (static_cast<int32_T>(fileid) < 0) {
        b_fileid = -1;
    }

    if (static_cast<int32_T>(b_fileid) >= 3) {
        filestar = FlightMissionMode_DW.eml_openfiles_n[static_cast<int32_T>(
            static_cast<int32_T>(b_fileid) - 3)];
    } else {
        switch (static_cast<int32_T>(b_fileid)) {
          case 0:
            filestar = stdin;
            break;

          case 1:
            filestar = stdout;
            break;

          case 2:
            filestar = stderr;
            break;

          default:
            filestar = NULL;
            break;
        }
    }

    if (static_cast<boolean_T>(static_cast<int32_T>((filestar != NULL) & (
            static_cast<int32_T>(fileid) >= 3)))) {
        int32_T cst;
        cst = fclose(filestar);
        if (cst == 0) {
            st = 0;
            FlightMissionMode_DW.eml_openfiles_n[static_cast<int32_T>(
                static_cast<int32_T>(fileid) - 3)] = NULL;
        }
    }

    return st;
}

// Function for MATLAB Function: '<S181>/WayPointGenerator'
FILE* FlightMissionMode::FlightMissionMode_fileManager_l(real_T varargin_1)
{
    FILE* f;
    int8_T fileid;
    fileid = static_cast<int8_T>(std::round(varargin_1));
    if (static_cast<boolean_T>(static_cast<int32_T>((static_cast<int32_T>(fileid)
           < 0) | (varargin_1 != static_cast<real_T>(fileid))))) {
        fileid = -1;
    }

    if (static_cast<int32_T>(fileid) >= 3) {
        f = FlightMissionMode_DW.eml_openfiles_n[static_cast<int32_T>(
            static_cast<int32_T>(fileid) - 3)];
    } else {
        switch (static_cast<int32_T>(fileid)) {
          case 0:
            f = stdin;
            break;

          case 1:
            f = stdout;
            break;

          case 2:
            f = stderr;
            break;

          default:
            f = NULL;
            break;
        }
    }

    return f;
}

void FlightMissionMode::FlightMissionMode_emxEnsureCapacity_char_T_g
    (emxArray_char_T_FlightMissionMode_T *emxArray, int32_T oldNumel)
{
    int32_T i;
    int32_T newNumel;
    void *newData;
    if (oldNumel < 0) {
        oldNumel = 0;
    }

    newNumel = 1;
    for (i = 0; i <= static_cast<int32_T>(emxArray->numDimensions - 1); i++) {
        newNumel = static_cast<int32_T>(newNumel * emxArray->size[i]);
    }

    if (newNumel > emxArray->allocatedSize) {
        i = emxArray->allocatedSize;
        if (i < 16) {
            i = 16;
        }

        while (i < newNumel) {
            if (i > 1073741823) {
                i = MAX_int32_T;
            } else {
                i = static_cast<int32_T>(i << 1);
            }
        }

        newData = std::calloc(static_cast<uint32_T>(i), sizeof(char_T));
        if (emxArray->data != nullptr) {
            std::memcpy(newData, emxArray->data, static_cast<uint32_T>(sizeof
                         (char_T) * static_cast<uint32_T>(oldNumel)));
            if (emxArray->canFreeData) {
                std::free(emxArray->data);
            }
        }

        emxArray->data = static_cast<char_T *>(newData);
        emxArray->allocatedSize = i;
        emxArray->canFreeData = true;
    }
}

// Function for MATLAB Function: '<S181>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_fgetl(real_T fileID,
    emxArray_char_T_FlightMissionMode_T *out)
{
    FILE* filestar;
    emxArray_char_T_FlightMissionMode_T *outBuff;
    int32_T i;
    int32_T idx_0;
    int32_T reachedEndOfFile;
    char_T ReadBuff[1024];
    uint8_T buf;
    filestar = FlightMissionMode_fileManager_l(fileID);
    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
            static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
              static_cast<boolean_T>(static_cast<int32_T>((fileID != 0.0) ^ 1)))
             | static_cast<int32_T>(static_cast<boolean_T>(static_cast<int32_T>
               ((fileID != 1.0) ^ 1)))))) | static_cast<int32_T>
            (static_cast<boolean_T>(static_cast<int32_T>((fileID != 2.0) ^ 1))))))
    {
        filestar = NULL;
    }

    FlightMissionMode_emxInit_char_T_e(&outBuff, 2);
    outBuff->size[0] = 1;
    outBuff->size[1] = 0;
    if (static_cast<boolean_T>(static_cast<int32_T>((filestar == NULL) ^ 1))) {
        FILE* b_NULL;
        FILE* b_filestar;
        char* cOut;
        int b_wherefrom;
        int st;
        int32_T exitg1;
        boolean_T readNewline;
        do {
            exitg1 = 0;
            cOut = fgets(&ReadBuff[0], 1024, filestar);
            readNewline = false;
            b_NULL = NULL;
            b_filestar = FlightMissionMode_fileManager_l(fileID);
            if (b_filestar == b_NULL) {
                reachedEndOfFile = 0;
            } else {
                st = feof(b_filestar);
                reachedEndOfFile = ((int32_T)st != 0);
            }

            if (cOut == NULL) {
                exitg1 = 1;
            } else {
                int32_T b_i;
                int32_T carriageReturnAt;
                int32_T idx;
                boolean_T fileEndAfterCarriageReturn;
                boolean_T newLineAfterCarriageReturn;
                idx = 1;
                carriageReturnAt = 0;
                if (reachedEndOfFile != 0) {
                    boolean_T exitg2;
                    b_i = 0;
                    exitg2 = false;
                    while ((!exitg2) && (b_i < 1024)) {
                        if (ReadBuff[b_i] == '\x00') {
                            idx = static_cast<int32_T>(b_i + 1);
                            exitg2 = true;
                        } else {
                            if ((carriageReturnAt == 0) && (ReadBuff[b_i] ==
                                    '\x0d')) {
                                carriageReturnAt = static_cast<int32_T>(b_i + 1);
                            }

                            b_i = static_cast<int32_T>(b_i + 1);
                        }
                    }

                    if (ReadBuff[static_cast<int32_T>(idx - 1)] == '\x00') {
                        idx = static_cast<int32_T>(idx - 1);
                    }
                } else {
                    boolean_T exitg2;
                    b_i = 0;
                    exitg2 = false;
                    while ((!exitg2) && (b_i < 1025)) {
                        if (static_cast<int32_T>(b_i + 1) > 1024) {
                            idx = 1023;
                            exitg2 = true;
                        } else if (ReadBuff[b_i] == '\x0a') {
                            idx = static_cast<int32_T>(b_i + 1);
                            exitg2 = true;
                        } else {
                            if ((carriageReturnAt == 0) && (ReadBuff[b_i] ==
                                    '\x0d')) {
                                carriageReturnAt = static_cast<int32_T>(b_i + 1);
                            }

                            b_i = static_cast<int32_T>(b_i + 1);
                        }
                    }

                    readNewline = (ReadBuff[static_cast<int32_T>(idx - 1)] ==
                                   '\x0a');
                }

                if (static_cast<boolean_T>(static_cast<int32_T>
                                           ((carriageReturnAt > 0) &
                                            (carriageReturnAt < 1024)))) {
                    newLineAfterCarriageReturn = (ReadBuff[carriageReturnAt] ==
                        '\x0a');
                    if (reachedEndOfFile != 0) {
                        fileEndAfterCarriageReturn = (ReadBuff[carriageReturnAt]
                            == '\x00');
                    } else {
                        fileEndAfterCarriageReturn = false;
                    }
                } else {
                    newLineAfterCarriageReturn = false;
                    fileEndAfterCarriageReturn = false;
                }

                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>
                                            (static_cast<boolean_T>
                        (static_cast<int32_T>((carriageReturnAt == 0) |
                         static_cast<int32_T>(newLineAfterCarriageReturn)))) |
                                            static_cast<int32_T>
                                            (fileEndAfterCarriageReturn)))) {
                    if (idx < 1) {
                        idx_0 = -1;
                        idx = -1;
                    } else {
                        idx_0 = static_cast<int32_T>(idx - 1);
                        idx = static_cast<int32_T>(idx - 1);
                    }

                    b_i = static_cast<int32_T>(idx_0 + 1);
                    idx_0 = outBuff->size[1];
                    i = static_cast<int32_T>(outBuff->size[0] * outBuff->size[1]);
                    outBuff->size[1] = static_cast<int32_T>(static_cast<int32_T>
                        (idx + outBuff->size[1]) + 1);
                    FlightMissionMode_emxEnsureCapacity_char_T_g(outBuff, i);
                    for (i = 0; i <= static_cast<int32_T>(b_i - 1); i++) {
                        outBuff->data[static_cast<int32_T>(idx_0 + i)] =
                            ReadBuff[i];
                    }
                } else {
                    idx_0 = outBuff->size[1];
                    i = static_cast<int32_T>(outBuff->size[0] * outBuff->size[1]);
                    outBuff->size[1] = static_cast<int32_T>(outBuff->size[1] +
                        carriageReturnAt);
                    FlightMissionMode_emxEnsureCapacity_char_T_g(outBuff, i);
                    for (i = 0; i <= static_cast<int32_T>(carriageReturnAt - 1);
                         i++) {
                        outBuff->data[static_cast<int32_T>(idx_0 + i)] =
                            ReadBuff[i];
                    }

                    b_wherefrom = SEEK_CUR;
                    b_NULL = FlightMissionMode_fileManager_l(fileID);
                    if (static_cast<boolean_T>(static_cast<int32_T>
                                               (static_cast<int32_T>(
                            static_cast<boolean_T>(static_cast<int32_T>(
                             static_cast<int32_T>(static_cast<boolean_T>(
                               static_cast<int32_T>((fileID != 0.0) ^ 1))) |
                             static_cast<int32_T>(static_cast<boolean_T>(
                               static_cast<int32_T>((fileID != 1.0) ^ 1)))))) |
                                                static_cast<int32_T>(
                            static_cast<boolean_T>(static_cast<int32_T>((fileID
                              != 2.0) ^ 1)))))) {
                        b_NULL = NULL;
                    }

                    if (static_cast<boolean_T>(static_cast<int32_T>((b_NULL ==
                            NULL) ^ 1))) {
                        fseek(b_NULL, (long int)(carriageReturnAt - idx),
                              b_wherefrom);
                    }
                }

                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>
                                            (static_cast<boolean_T>(static_cast<
                        int32_T>((reachedEndOfFile != 0) | static_cast<int32_T>
                                 (readNewline)))) | (carriageReturnAt > 0)))) {
                    exitg1 = 1;
                }
            }
        } while (exitg1 == 0);

        filestar = NULL;
        b_NULL = FlightMissionMode_fileManager_l(fileID);
        if (b_NULL == filestar) {
            reachedEndOfFile = 0;
        } else {
            st = feof(b_NULL);
            reachedEndOfFile = ((int32_T)st != 0);
        }

        if (reachedEndOfFile == 0) {
            filestar = FlightMissionMode_fileManager_l(fileID);
            if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                    (static_cast<boolean_T>(static_cast<int32_T>
                    (static_cast<int32_T>(static_cast<boolean_T>
                      (static_cast<int32_T>((fileID != 0.0) ^ 1))) |
                     static_cast<int32_T>(static_cast<boolean_T>
                      (static_cast<int32_T>((fileID != 1.0) ^ 1)))))) |
                    static_cast<int32_T>(static_cast<boolean_T>
                    (static_cast<int32_T>((fileID != 2.0) ^ 1)))))) {
                filestar = NULL;
            }

            if (static_cast<boolean_T>(static_cast<int32_T>((filestar == NULL) ^
                  1))) {
                fread(&buf, sizeof(uint8_T), (size_t)1, filestar);
            }

            filestar = NULL;
            b_NULL = FlightMissionMode_fileManager_l(fileID);
            if (static_cast<boolean_T>(static_cast<int32_T>((b_NULL == filestar)
                  ^ 1))) {
                st = feof(b_NULL);
                reachedEndOfFile = ((int32_T)st != 0);
            }

            if (reachedEndOfFile == 0) {
                b_wherefrom = SEEK_CUR;
                filestar = FlightMissionMode_fileManager_l(fileID);
                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>
                                            (static_cast<boolean_T>
                        (static_cast<int32_T>(static_cast<int32_T>
                         (static_cast<boolean_T>(static_cast<int32_T>((fileID !=
                             0.0) ^ 1))) | static_cast<int32_T>
                         (static_cast<boolean_T>(static_cast<int32_T>((fileID !=
                             1.0) ^ 1)))))) | static_cast<int32_T>
                                            (static_cast<boolean_T>
                        (static_cast<int32_T>((fileID != 2.0) ^ 1)))))) {
                    filestar = NULL;
                }

                if (static_cast<boolean_T>(static_cast<int32_T>((filestar ==
                        NULL) ^ 1))) {
                    fseek(filestar, (long int)-1.0, b_wherefrom);
                }
            }
        }
    }

    if (outBuff->size[1] == 0) {
        out->size[0] = 1;
        out->size[1] = 0;
    } else if (outBuff->data[static_cast<int32_T>(outBuff->size[1] - 1)] ==
               '\x0a') {
        if ((outBuff->size[1] > 1) && (outBuff->data[static_cast<int32_T>
                (outBuff->size[1] - 2)] == '\x0d')) {
            if (static_cast<int32_T>(outBuff->size[1] - 2) < 1) {
                reachedEndOfFile = -1;
            } else {
                reachedEndOfFile = static_cast<int32_T>(outBuff->size[1] - 3);
            }

            i = static_cast<int32_T>(out->size[0] * out->size[1]);
            out->size[0] = 1;
            out->size[1] = static_cast<int32_T>(reachedEndOfFile + 1);
            FlightMissionMode_emxEnsureCapacity_char_T_g(out, i);
            for (idx_0 = 0; idx_0 <= reachedEndOfFile; idx_0++) {
                out->data[idx_0] = outBuff->data[idx_0];
            }
        } else {
            if (static_cast<int32_T>(outBuff->size[1] - 1) < 1) {
                reachedEndOfFile = -1;
            } else {
                reachedEndOfFile = static_cast<int32_T>(outBuff->size[1] - 2);
            }

            i = static_cast<int32_T>(out->size[0] * out->size[1]);
            out->size[0] = 1;
            out->size[1] = static_cast<int32_T>(reachedEndOfFile + 1);
            FlightMissionMode_emxEnsureCapacity_char_T_g(out, i);
            for (idx_0 = 0; idx_0 <= reachedEndOfFile; idx_0++) {
                out->data[idx_0] = outBuff->data[idx_0];
            }
        }
    } else if (outBuff->data[static_cast<int32_T>(outBuff->size[1] - 1)] ==
               '\x0d') {
        if (static_cast<int32_T>(outBuff->size[1] - 1) < 1) {
            reachedEndOfFile = -1;
        } else {
            reachedEndOfFile = static_cast<int32_T>(outBuff->size[1] - 2);
        }

        i = static_cast<int32_T>(out->size[0] * out->size[1]);
        out->size[0] = 1;
        out->size[1] = static_cast<int32_T>(reachedEndOfFile + 1);
        FlightMissionMode_emxEnsureCapacity_char_T_g(out, i);
        for (idx_0 = 0; idx_0 <= reachedEndOfFile; idx_0++) {
            out->data[idx_0] = outBuff->data[idx_0];
        }
    } else {
        i = static_cast<int32_T>(out->size[0] * out->size[1]);
        out->size[0] = 1;
        out->size[1] = outBuff->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_g(out, i);
        reachedEndOfFile = static_cast<int32_T>(outBuff->size[1] - 1);
        for (idx_0 = 0; idx_0 <= reachedEndOfFile; idx_0++) {
            out->data[idx_0] = outBuff->data[idx_0];
        }
    }

    FlightMissionMode_emxFree_char_T_o(&outBuff);
}

real_T FlightMissionMode::FlightMissionMode_norm_p(const real_T x[2])
{
    real_T absxk;
    real_T scale;
    real_T t;
    real_T y;
    scale = 3.3121686421112381E-170;
    absxk = std::abs(x[0]);
    if (absxk > 3.3121686421112381E-170) {
        y = 1.0;
        scale = absxk;
    } else {
        t = absxk / 3.3121686421112381E-170;
        y = t * t;
    }

    absxk = std::abs(x[1]);
    if (absxk > scale) {
        t = scale / absxk;
        y = y * t * t + 1.0;
        scale = absxk;
    } else {
        t = absxk / scale;
        y += t * t;
    }

    return scale * std::sqrt(y);
}

// Function for MATLAB Function: '<S181>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_circshift(real_T a_data[], const
    int32_T a_size[2], real_T p)
{
    real_T a__1_data[512];
    int32_T dim;
    dim = (a_size[0] == 1);
    if (a_size[0] != 0) {
        int32_T a;
        int32_T b_k;
        int32_T npages;
        int32_T ns;
        int32_T stride;
        boolean_T shiftright;
        if (p < 0.0) {
            ns = static_cast<int32_T>(-p);
            shiftright = false;
        } else {
            ns = static_cast<int32_T>(p);
            shiftright = true;
        }

        if (ns > a_size[dim]) {
            ns = static_cast<int32_T>(ns - static_cast<int32_T>(div_s32_sat(ns,
                a_size[dim]) * a_size[dim]));
        }

        if (ns > static_cast<int32_T>(a_size[dim] >> 1)) {
            ns = static_cast<int32_T>(a_size[dim] - ns);
            shiftright = static_cast<boolean_T>(static_cast<int32_T>(
                static_cast<int32_T>(shiftright) ^ 1));
        }

        if (a_size[0] == 0) {
            a = 0;
        } else if (a_size[0] >= 3) {
            a = a_size[0];
        } else {
            a = 3;
        }

        stride = static_cast<int32_T>(static_cast<int32_T>(static_cast<int16_T>(
            static_cast<int32_T>(std::floor(static_cast<real_T>(a) / 2.0)))) - 1);
        for (a = 0; a <= stride; a++) {
            a__1_data[a] = 0.0;
        }

        a = static_cast<int32_T>(a_size[dim] - 1);
        stride = 1;
        npages = 0;
        while (npages <= static_cast<int32_T>(dim - 1)) {
            stride = static_cast<int32_T>(stride * a_size[0]);
            npages = 1;
        }

        npages = 1;
        b_k = static_cast<int32_T>(dim + 2);
        while (b_k < 3) {
            npages = static_cast<int32_T>(npages * 3);
            b_k = 3;
        }

        b_k = static_cast<int32_T>(stride * a_size[dim]);
        if ((a_size[dim] > 1) && (ns > 0)) {
            for (dim = 0; dim <= static_cast<int32_T>(npages - 1); dim =
                    static_cast<int32_T>(dim + 1)) {
                int32_T pageroot;
                pageroot = static_cast<int32_T>(dim * b_k);
                for (int32_T j{0}; j <= static_cast<int32_T>(stride - 1); j =
                        static_cast<int32_T>(j + 1)) {
                    int32_T i1;
                    i1 = static_cast<int32_T>(pageroot + j);
                    if (shiftright) {
                        for (int32_T f_k{0}; f_k <= static_cast<int32_T>(ns - 1);
                             f_k = static_cast<int32_T>(f_k + 1)) {
                            a__1_data[f_k] = a_data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>(f_k +
                                a) - ns) + 1) * stride) + i1)];
                        }

                        for (int32_T f_k{a}; static_cast<int32_T>(f_k + 1) >=
                                static_cast<int32_T>(ns + 1); f_k = static_cast<
                                int32_T>(f_k - 1)) {
                            a_data[static_cast<int32_T>(i1 + static_cast<int32_T>
                                (f_k * stride))] = a_data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>(f_k -
                                ns) * stride) + i1)];
                        }

                        for (int32_T f_k{0}; f_k <= static_cast<int32_T>(ns - 1);
                             f_k = static_cast<int32_T>(f_k + 1)) {
                            a_data[static_cast<int32_T>(i1 + static_cast<int32_T>
                                (f_k * stride))] = a__1_data[f_k];
                        }
                    } else {
                        int32_T f_k;
                        for (f_k = 0; f_k <= static_cast<int32_T>(ns - 1); f_k =
                             static_cast<int32_T>(f_k + 1)) {
                            a__1_data[f_k] = a_data[static_cast<int32_T>(
                                static_cast<int32_T>(f_k * stride) + i1)];
                        }

                        f_k = static_cast<int32_T>(a - ns);
                        for (int32_T g_k{0}; g_k <= f_k; g_k = static_cast<
                                int32_T>(g_k + 1)) {
                            a_data[static_cast<int32_T>(i1 + static_cast<int32_T>
                                (g_k * stride))] = a_data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>(g_k +
                                ns) * stride) + i1)];
                        }

                        for (f_k = 0; f_k <= static_cast<int32_T>(ns - 1); f_k =
                             static_cast<int32_T>(f_k + 1)) {
                            a_data[static_cast<int32_T>(i1 + static_cast<int32_T>
                                (static_cast<int32_T>(static_cast<int32_T>(
                                static_cast<int32_T>(f_k + a) - ns) + 1) *
                                 stride))] = a__1_data[f_k];
                        }
                    }
                }
            }
        }
    }
}

// Function for MATLAB Function: '<S181>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_sind(real_T x_data[], const int32_T
    *x_size)
{
    for (int32_T k{0}; k <= static_cast<int32_T>(*x_size - 1); k =
            static_cast<int32_T>(k + 1)) {
        if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(std::
                isinf(x_data[k])) | static_cast<int32_T>(std::isnan(x_data[k])))))
        {
            x_data[k] = (rtNaN);
        } else {
            real_T absx;
            real_T b_x;
            int8_T n;
            b_x = rt_remd_snf(x_data[k], 360.0);
            absx = std::abs(b_x);
            if (absx > 180.0) {
                if (b_x > 0.0) {
                    b_x -= 360.0;
                } else {
                    b_x += 360.0;
                }

                absx = std::abs(b_x);
            }

            if (absx <= 45.0) {
                b_x *= 0.017453292519943295;
                n = 0;
            } else if (absx <= 135.0) {
                if (b_x > 0.0) {
                    b_x = (b_x - 90.0) * 0.017453292519943295;
                    n = 1;
                } else {
                    b_x = (b_x + 90.0) * 0.017453292519943295;
                    n = -1;
                }
            } else if (b_x > 0.0) {
                b_x = (b_x - 180.0) * 0.017453292519943295;
                n = 2;
            } else {
                b_x = (b_x + 180.0) * 0.017453292519943295;
                n = -2;
            }

            switch (static_cast<int32_T>(n)) {
              case 0:
                x_data[k] = std::sin(b_x);
                break;

              case 1:
                x_data[k] = std::cos(b_x);
                break;

              case -1:
                x_data[k] = -std::cos(b_x);
                break;

              default:
                x_data[k] = -std::sin(b_x);
                break;
            }
        }
    }
}

// Function for MATLAB Function: '<S181>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_cosd(real_T x_data[], const int32_T
    *x_size)
{
    for (int32_T k{0}; k <= static_cast<int32_T>(*x_size - 1); k =
            static_cast<int32_T>(k + 1)) {
        if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(std::
                isinf(x_data[k])) | static_cast<int32_T>(std::isnan(x_data[k])))))
        {
            x_data[k] = (rtNaN);
        } else {
            real_T absx;
            real_T b_x;
            int8_T n;
            b_x = rt_remd_snf(x_data[k], 360.0);
            absx = std::abs(b_x);
            if (absx > 180.0) {
                if (b_x > 0.0) {
                    b_x -= 360.0;
                } else {
                    b_x += 360.0;
                }

                absx = std::abs(b_x);
            }

            if (absx <= 45.0) {
                b_x *= 0.017453292519943295;
                n = 0;
            } else if (absx <= 135.0) {
                if (b_x > 0.0) {
                    b_x = (b_x - 90.0) * 0.017453292519943295;
                    n = 1;
                } else {
                    b_x = (b_x + 90.0) * 0.017453292519943295;
                    n = -1;
                }
            } else if (b_x > 0.0) {
                b_x = (b_x - 180.0) * 0.017453292519943295;
                n = 2;
            } else {
                b_x = (b_x + 180.0) * 0.017453292519943295;
                n = -2;
            }

            switch (static_cast<int32_T>(n)) {
              case 0:
                x_data[k] = std::cos(b_x);
                break;

              case 1:
                x_data[k] = -std::sin(b_x);
                break;

              case -1:
                x_data[k] = std::sin(b_x);
                break;

              default:
                x_data[k] = -std::cos(b_x);
                break;
            }
        }
    }
}

void FlightMissionMode::FlightMissionMode_binary_expand_op_puhaq(real_T
    in1_data[], int32_T *in1_size, const real_T in2_data[], const int32_T
    *in2_size, const real_T in3_data[], const int32_T in3_size[2])
{
    int32_T in2_size_idx_0;
    int32_T loop_ub;
    int32_T stride_0_0;
    int32_T stride_1_0;
    int32_T stride_2_0;
    in2_size_idx_0 = *in1_size == 1 ? in3_size[0] == 1 ? *in2_size : in3_size[0]
        : *in1_size;
    stride_0_0 = (*in2_size != 1);
    stride_1_0 = (in3_size[0] != 1);
    stride_2_0 = (*in1_size != 1);
    loop_ub = *in1_size == 1 ? in3_size[0] == 1 ? *in2_size : in3_size[0] :
        *in1_size;
    for (int32_T i{0}; i <= static_cast<int32_T>(loop_ub - 1); i++) {
        FlightMissionMode_DW.in2_data_cv[i] = (in3_data[static_cast<int32_T>(
            static_cast<int32_T>(i * stride_1_0) + static_cast<int32_T>
            (in3_size[0] << 1))] + in2_data[static_cast<int32_T>(i * stride_0_0)])
            * in1_data[static_cast<int32_T>(i * stride_2_0)];
    }

    *in1_size = in2_size_idx_0;
    for (int32_T i{0}; i <= static_cast<int32_T>(in2_size_idx_0 - 1); i++) {
        in1_data[i] = FlightMissionMode_DW.in2_data_cv[i];
    }
}

void FlightMissionMode::FlightMissionMode_binary_expand_op_puha(real_T in1_data[],
    int32_T in1_size[2], const real_T in2_data[], const int32_T *in2_size, const
    real_T in3_data[], const int32_T *in3_size, const real_T in4_data[], const
    int32_T *in4_size, const real_T in5_data[], const int32_T *in5_size, const
    real_T in6_data[], const int32_T in6_size[2], const real_T in7_data[], const
    int32_T *in7_size)
{
    int32_T in2_size_idx_0;
    int32_T in2_size_idx_0_0;
    int32_T in5_size_idx_0;
    int32_T loop_ub;
    int32_T stride_0_0;
    int32_T stride_1_0;
    int32_T stride_2_0;
    in2_size_idx_0 = *in3_size == 1 ? *in2_size : *in3_size;
    stride_0_0 = (*in2_size != 1);
    stride_1_0 = (*in3_size != 1);
    loop_ub = *in3_size == 1 ? *in2_size : *in3_size;
    for (int32_T i{0}; i <= static_cast<int32_T>(loop_ub - 1); i++) {
        FlightMissionMode_DW.in2_data_c[i] = in2_data[static_cast<int32_T>(i *
            stride_0_0)] * in3_data[static_cast<int32_T>(i * stride_1_0)];
    }

    in2_size_idx_0_0 = *in4_size == 1 ? *in2_size : *in4_size;
    stride_0_0 = (*in2_size != 1);
    stride_1_0 = (*in4_size != 1);
    loop_ub = *in4_size == 1 ? *in2_size : *in4_size;
    for (int32_T i{0}; i <= static_cast<int32_T>(loop_ub - 1); i++) {
        FlightMissionMode_DW.in2_data_b[i] = in2_data[static_cast<int32_T>(i *
            stride_0_0)] * in4_data[static_cast<int32_T>(i * stride_1_0)];
    }

    in5_size_idx_0 = *in7_size == 1 ? in6_size[0] == 1 ? *in5_size : in6_size[0]
        : *in7_size;
    stride_0_0 = (*in5_size != 1);
    stride_1_0 = (in6_size[0] != 1);
    stride_2_0 = (*in7_size != 1);
    loop_ub = *in7_size == 1 ? in6_size[0] == 1 ? *in5_size : in6_size[0] :
        *in7_size;
    for (int32_T i{0}; i <= static_cast<int32_T>(loop_ub - 1); i++) {
        FlightMissionMode_DW.in5_data_p[i] = (in5_data[static_cast<int32_T>(i *
            stride_0_0)] * 0.99330562000985867 + in6_data[static_cast<int32_T>(
            static_cast<int32_T>(i * stride_1_0) + static_cast<int32_T>
            (in6_size[0] << 1))]) * in7_data[static_cast<int32_T>(i * stride_2_0)];
    }

    in1_size[0] = in2_size_idx_0;
    in1_size[1] = 3;
    for (int32_T i{0}; i <= static_cast<int32_T>(in2_size_idx_0 - 1); i++) {
        in1_data[i] = FlightMissionMode_DW.in2_data_c[i];
    }

    for (int32_T i{0}; i <= static_cast<int32_T>(in2_size_idx_0_0 - 1); i++) {
        in1_data[static_cast<int32_T>(i + in1_size[0])] =
            FlightMissionMode_DW.in2_data_b[i];
    }

    for (int32_T i{0}; i <= static_cast<int32_T>(in5_size_idx_0 - 1); i++) {
        in1_data[static_cast<int32_T>(i + static_cast<int32_T>(in1_size[0] << 1))]
            = FlightMissionMode_DW.in5_data_p[i];
    }
}

// Function for MATLAB Function: '<S181>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_lla2ecef(const real_T llaPos_data[],
    const int32_T llaPos_size[2], real_T ecefPos_data[], int32_T ecefPos_size[2])
{
    int32_T b_size;
    int32_T c_size;
    int32_T nx;
    int32_T sinphi_size;
    int32_T z_size;
    nx = llaPos_size[0];
    c_size = llaPos_size[0];
    for (int32_T b_k{0}; b_k <= static_cast<int32_T>(nx - 1); b_k++) {
        FlightMissionMode_DW.c_data[b_k] = llaPos_data[b_k];
    }

    FlightMissionMode_sind(FlightMissionMode_DW.c_data, &c_size);
    sinphi_size = c_size;
    for (int32_T b_k{0}; b_k <= static_cast<int32_T>(c_size - 1); b_k++) {
        FlightMissionMode_DW.sinphi_data_c[b_k] =
            FlightMissionMode_DW.c_data[b_k];
    }

    for (nx = 0; nx <= static_cast<int32_T>(c_size - 1); nx =
            static_cast<int32_T>(nx + 1)) {
        FlightMissionMode_DW.N_data[nx] = FlightMissionMode_DW.sinphi_data_c[nx]
            * FlightMissionMode_DW.sinphi_data_c[nx];
    }

    for (int32_T b_k{0}; b_k <= static_cast<int32_T>(c_size - 1); b_k++) {
        FlightMissionMode_DW.N_data[b_k] = 1.0 - 0.0066943799901413165 *
            FlightMissionMode_DW.N_data[b_k];
    }

    for (int32_T b_k{0}; b_k <= static_cast<int32_T>(c_size - 1); b_k =
            static_cast<int32_T>(b_k + 1)) {
        FlightMissionMode_DW.N_data[b_k] = std::sqrt
            (FlightMissionMode_DW.N_data[b_k]);
    }

    for (int32_T b_k{0}; b_k <= static_cast<int32_T>(c_size - 1); b_k++) {
        FlightMissionMode_DW.N_data[b_k] = 6.378137E+6 /
            FlightMissionMode_DW.N_data[b_k];
    }

    nx = llaPos_size[0];
    c_size = llaPos_size[0];
    for (int32_T b_k{0}; b_k <= static_cast<int32_T>(nx - 1); b_k++) {
        FlightMissionMode_DW.c_data[b_k] = llaPos_data[b_k];
    }

    FlightMissionMode_cosd(FlightMissionMode_DW.c_data, &c_size);
    z_size = c_size;
    for (int32_T b_k{0}; b_k <= static_cast<int32_T>(c_size - 1); b_k++) {
        FlightMissionMode_DW.z_data[b_k] = FlightMissionMode_DW.c_data[b_k];
    }

    if (static_cast<boolean_T>(static_cast<int32_T>(((sinphi_size == 1 ?
            llaPos_size[0] : sinphi_size) == c_size) & (sinphi_size ==
            llaPos_size[0])))) {
        z_size = sinphi_size;
        for (int32_T b_k{0}; b_k <= static_cast<int32_T>(sinphi_size - 1); b_k++)
        {
            FlightMissionMode_DW.z_data[b_k] *= llaPos_data[static_cast<int32_T>
                (static_cast<int32_T>(llaPos_size[0] << 1) + b_k)] +
                FlightMissionMode_DW.N_data[b_k];
        }
    } else {
        FlightMissionMode_binary_expand_op_puhaq(FlightMissionMode_DW.z_data,
            &z_size, FlightMissionMode_DW.N_data, &sinphi_size, llaPos_data,
            llaPos_size);
    }

    nx = llaPos_size[0];
    c_size = llaPos_size[0];
    for (int32_T b_k{0}; b_k <= static_cast<int32_T>(nx - 1); b_k++) {
        FlightMissionMode_DW.c_data[b_k] = llaPos_data[static_cast<int32_T>(b_k
            + llaPos_size[0])];
    }

    FlightMissionMode_cosd(FlightMissionMode_DW.c_data, &c_size);
    b_size = c_size;
    for (int32_T b_k{0}; b_k <= static_cast<int32_T>(c_size - 1); b_k++) {
        FlightMissionMode_DW.b_data_k[b_k] = FlightMissionMode_DW.c_data[b_k];
    }

    nx = llaPos_size[0];
    c_size = llaPos_size[0];
    for (int32_T b_k{0}; b_k <= static_cast<int32_T>(nx - 1); b_k++) {
        FlightMissionMode_DW.c_data[b_k] = llaPos_data[static_cast<int32_T>(b_k
            + llaPos_size[0])];
    }

    FlightMissionMode_sind(FlightMissionMode_DW.c_data, &c_size);
    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
            static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
              static_cast<boolean_T>(static_cast<int32_T>((z_size == b_size) &
                (z_size == c_size)))) & (sinphi_size == llaPos_size[0])))) &
            ((sinphi_size == 1 ? llaPos_size[0] : sinphi_size) == sinphi_size))))
    {
        ecefPos_size[0] = z_size;
        ecefPos_size[1] = 3;
        for (int32_T b_k{0}; b_k <= static_cast<int32_T>(z_size - 1); b_k++) {
            ecefPos_data[b_k] = FlightMissionMode_DW.z_data[b_k] *
                FlightMissionMode_DW.b_data_k[b_k];
        }

        for (int32_T b_k{0}; b_k <= static_cast<int32_T>(z_size - 1); b_k++) {
            ecefPos_data[static_cast<int32_T>(b_k + ecefPos_size[0])] =
                FlightMissionMode_DW.z_data[b_k] *
                FlightMissionMode_DW.c_data[b_k];
        }

        for (int32_T b_k{0}; b_k <= static_cast<int32_T>(sinphi_size - 1); b_k++)
        {
            ecefPos_data[static_cast<int32_T>(b_k + static_cast<int32_T>
                (ecefPos_size[0] << 1))] = (llaPos_data[static_cast<int32_T>(
                static_cast<int32_T>(llaPos_size[0] << 1) + b_k)] +
                FlightMissionMode_DW.N_data[b_k] * 0.99330562000985867) *
                FlightMissionMode_DW.sinphi_data_c[b_k];
        }
    } else {
        FlightMissionMode_binary_expand_op_puha(ecefPos_data, ecefPos_size,
            FlightMissionMode_DW.z_data, &z_size, FlightMissionMode_DW.b_data_k,
            &b_size, FlightMissionMode_DW.c_data, &c_size,
            FlightMissionMode_DW.N_data, &sinphi_size, llaPos_data, llaPos_size,
            FlightMissionMode_DW.sinphi_data_c, &sinphi_size);
    }
}

void FlightMissionMode::FlightMissionMode_minus_l(real_T in1_data[], int32_T
    in1_size[2], const real_T in2_data[], const int32_T in2_size[2])
{
    int32_T in1_size_idx_0;
    int32_T loop_ub;
    int32_T stride_0_0;
    int32_T stride_1_0;
    in1_size_idx_0 = in2_size[0] == 1 ? in1_size[0] : in2_size[0];
    stride_0_0 = (in1_size[0] != 1);
    stride_1_0 = (in2_size[0] != 1);
    loop_ub = in2_size[0] == 1 ? in1_size[0] : in2_size[0];
    for (int32_T i_0{0}; i_0 < 3; i_0++) {
        for (int32_T i{0}; i <= static_cast<int32_T>(loop_ub - 1); i++) {
            FlightMissionMode_DW.in1_data[static_cast<int32_T>(i +
                static_cast<int32_T>(in1_size_idx_0 * i_0))] = in1_data[
                static_cast<int32_T>(static_cast<int32_T>(i * stride_0_0) +
                static_cast<int32_T>(in1_size[0] * i_0))] - in2_data[
                static_cast<int32_T>(static_cast<int32_T>(i * stride_1_0) +
                static_cast<int32_T>(in2_size[0] * i_0))];
        }
    }

    in1_size[0] = in1_size_idx_0;
    in1_size[1] = 3;
    for (int32_T i_0{0}; i_0 < 3; i_0++) {
        for (int32_T i{0}; i <= static_cast<int32_T>(in1_size_idx_0 - 1); i++) {
            in1_data[static_cast<int32_T>(i + static_cast<int32_T>(in1_size[0] *
                i_0))] = FlightMissionMode_DW.in1_data[static_cast<int32_T>(
                static_cast<int32_T>(in1_size_idx_0 * i_0) + i)];
        }
    }
}

void FlightMissionMode::FlightMissionMode_binary_expand_op_puh(real_T in1_data[],
    int32_T *in1_size, const real_T in2_data[], const int32_T *in2_size, const
    real_T in3_data[], const int32_T in3_size[2], const real_T in4_data[], const
    int32_T *in4_size)
{
    int32_T loop_ub;
    int32_T stride_0_0;
    int32_T stride_1_0;
    int32_T stride_2_0;
    int32_T stride_3_0;
    *in1_size = (in3_size[0] == 1 ? *in4_size : in3_size[0]) == 1 ? in3_size[0] ==
        1 ? *in2_size : in3_size[0] : in3_size[0] == 1 ? *in4_size : in3_size[0];
    stride_0_0 = (*in2_size != 1);
    stride_1_0 = (in3_size[0] != 1);
    stride_2_0 = (*in4_size != 1);
    stride_3_0 = (in3_size[0] != 1);
    loop_ub = (in3_size[0] == 1 ? *in4_size : in3_size[0]) == 1 ? in3_size[0] ==
        1 ? *in2_size : in3_size[0] : in3_size[0] == 1 ? *in4_size : in3_size[0];
    for (int32_T i{0}; i <= static_cast<int32_T>(loop_ub - 1); i++) {
        in1_data[i] = in3_data[static_cast<int32_T>(static_cast<int32_T>(i *
            stride_3_0) + in3_size[0])] * in4_data[static_cast<int32_T>(i *
            stride_2_0)] + in2_data[static_cast<int32_T>(i * stride_0_0)] *
            in3_data[static_cast<int32_T>(i * stride_1_0)];
    }
}

void FlightMissionMode::FlightMissionMode_binary_expand_op_pu(real_T in1_data[],
    int32_T in1_size[2], const real_T in2_data[], const int32_T *in2_size, const
    real_T in3_data[], const int32_T in3_size[2], const real_T in4_data[], const
    int32_T *in4_size, const real_T in5_data[], const int32_T *in5_size, const
    real_T in6_data[], const int32_T *in6_size, const real_T in7_data[], const
    int32_T *in7_size)
{
    int32_T in2_size_idx_0;
    int32_T in5_size_idx_0;
    int32_T in7_size_idx_0;
    int32_T loop_ub;
    int32_T stride_0_0;
    int32_T stride_1_0;
    int32_T stride_2_0;
    int32_T stride_3_0;
    in2_size_idx_0 = (in3_size[0] == 1 ? *in4_size : in3_size[0]) == 1 ?
        in3_size[0] == 1 ? *in2_size : in3_size[0] : in3_size[0] == 1 ?
        *in4_size : in3_size[0];
    stride_0_0 = (*in2_size != 1);
    stride_1_0 = (in3_size[0] != 1);
    stride_2_0 = (*in4_size != 1);
    stride_3_0 = (in3_size[0] != 1);
    loop_ub = (in3_size[0] == 1 ? *in4_size : in3_size[0]) == 1 ? in3_size[0] ==
        1 ? *in2_size : in3_size[0] : in3_size[0] == 1 ? *in4_size : in3_size[0];
    for (int32_T i{0}; i <= static_cast<int32_T>(loop_ub - 1); i++) {
        FlightMissionMode_DW.in2_data[i] = in3_data[static_cast<int32_T>(
            static_cast<int32_T>(i * stride_3_0) + in3_size[0])] * in4_data[
            static_cast<int32_T>(i * stride_2_0)] + -in2_data
            [static_cast<int32_T>(i * stride_0_0)] * in3_data
            [static_cast<int32_T>(i * stride_1_0)];
    }

    in5_size_idx_0 = (in3_size[0] == 1 ? *in7_size : in3_size[0]) == 1 ?
        *in6_size == 1 ? *in5_size : *in6_size : in3_size[0] == 1 ? *in7_size :
        in3_size[0];
    stride_0_0 = (*in5_size != 1);
    stride_1_0 = (*in6_size != 1);
    stride_2_0 = (*in7_size != 1);
    stride_3_0 = (in3_size[0] != 1);
    loop_ub = (in3_size[0] == 1 ? *in7_size : in3_size[0]) == 1 ? *in6_size == 1
        ? *in5_size : *in6_size : in3_size[0] == 1 ? *in7_size : in3_size[0];
    for (int32_T i{0}; i <= static_cast<int32_T>(loop_ub - 1); i++) {
        FlightMissionMode_DW.in5_data[i] = in3_data[static_cast<int32_T>(
            static_cast<int32_T>(i * stride_3_0) + static_cast<int32_T>
            (in3_size[0] << 1))] * in7_data[static_cast<int32_T>(i * stride_2_0)]
            + -in5_data[static_cast<int32_T>(i * stride_0_0)] * in6_data[
            static_cast<int32_T>(i * stride_1_0)];
    }

    in7_size_idx_0 = (in3_size[0] == 1 ? *in5_size : in3_size[0]) == 1 ?
        *in6_size == 1 ? *in7_size : *in6_size : in3_size[0] == 1 ? *in5_size :
        in3_size[0];
    stride_0_0 = (*in7_size != 1);
    stride_1_0 = (*in6_size != 1);
    stride_2_0 = (*in5_size != 1);
    stride_3_0 = (in3_size[0] != 1);
    loop_ub = (in3_size[0] == 1 ? *in5_size : in3_size[0]) == 1 ? *in6_size == 1
        ? *in7_size : *in6_size : in3_size[0] == 1 ? *in5_size : in3_size[0];
    for (int32_T i{0}; i <= static_cast<int32_T>(loop_ub - 1); i++) {
        FlightMissionMode_DW.in7_data[i] = in3_data[static_cast<int32_T>(
            static_cast<int32_T>(i * stride_3_0) + static_cast<int32_T>
            (in3_size[0] << 1))] * in5_data[static_cast<int32_T>(i * stride_2_0)]
            + in7_data[static_cast<int32_T>(i * stride_0_0)] * in6_data[
            static_cast<int32_T>(i * stride_1_0)];
    }

    in1_size[0] = in2_size_idx_0;
    in1_size[1] = 3;
    for (int32_T i{0}; i <= static_cast<int32_T>(in2_size_idx_0 - 1); i++) {
        in1_data[i] = FlightMissionMode_DW.in2_data[i];
    }

    for (int32_T i{0}; i <= static_cast<int32_T>(in5_size_idx_0 - 1); i++) {
        in1_data[static_cast<int32_T>(i + in1_size[0])] =
            FlightMissionMode_DW.in5_data[i];
    }

    for (int32_T i{0}; i <= static_cast<int32_T>(in7_size_idx_0 - 1); i++) {
        in1_data[static_cast<int32_T>(i + static_cast<int32_T>(in1_size[0] << 1))]
            = FlightMissionMode_DW.in7_data[i];
    }
}

// Function for MATLAB Function: '<S181>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_lla2ned(const real_T lla_data[], const
    int32_T lla_size[2], const real_T lla0[3], real_T xyzNED_data[], int32_T
    xyzNED_size[2])
{
    int32_T ecefPosWithENUOrigin_size[2];
    int32_T lla0tmp_size[2];
    int32_T llatmp_size[2];
    int32_T b_size;
    int32_T coslambda_size;
    int32_T cosphi_size;
    int32_T ibmat;
    int32_T idx;
    int32_T nrows;
    int32_T sinphi_size;
    if (static_cast<int32_T>(static_cast<int16_T>(lla_size[0])) > 1) {
        nrows = 1;
        idx = 2;
    } else {
        nrows = static_cast<int32_T>(static_cast<int16_T>(lla_size[0]));
        idx = 1;
    }

    if (((nrows != 1) && (lla_size[0] != 1)) || (!(lla_size[0] == 1))) {
    } else {
        idx = 0;
    }

    switch (idx) {
      case 1:
        llatmp_size[0] = static_cast<int32_T>(static_cast<int16_T>(lla_size[0]));
        llatmp_size[1] = 3;
        nrows = lla_size[0];
        lla0tmp_size[0] = 1;
        lla0tmp_size[1] = 3;
        for (ibmat = 1; static_cast<int32_T>(ibmat - 1) <= static_cast<int32_T>
                (nrows - 1); ibmat = static_cast<int32_T>(ibmat + 1)) {
            FlightMissionMode_DW.llatmp_data[static_cast<int32_T>(ibmat - 1)] =
                lla_data[static_cast<int32_T>(ibmat - 1)];
        }

        FlightMissionMode_DW.lla0tmp_data[0] = lla0[0];
        for (ibmat = 1; static_cast<int32_T>(ibmat - 1) <= static_cast<int32_T>
                (nrows - 1); ibmat = static_cast<int32_T>(ibmat + 1)) {
            idx = static_cast<int32_T>(static_cast<int32_T>(nrows + ibmat) - 1);
            FlightMissionMode_DW.llatmp_data[idx] = lla_data[idx];
        }

        FlightMissionMode_DW.lla0tmp_data[1] = lla0[1];
        idx = static_cast<int32_T>(lla_size[0] << 1);
        for (ibmat = 1; static_cast<int32_T>(ibmat - 1) <= static_cast<int32_T>
                (nrows - 1); ibmat = static_cast<int32_T>(ibmat + 1)) {
            FlightMissionMode_DW.llatmp_data[static_cast<int32_T>
                (static_cast<int32_T>(idx + ibmat) - 1)] = lla_data
                [static_cast<int32_T>(static_cast<int32_T>(idx + ibmat) - 1)];
        }

        FlightMissionMode_DW.lla0tmp_data[2] = lla0[2];
        break;

      case 2:
        lla0tmp_size[0] = static_cast<int32_T>(static_cast<int16_T>(lla_size[0]));
        lla0tmp_size[1] = 3;
        nrows = lla_size[0];
        for (ibmat = 0; ibmat <= static_cast<int32_T>(nrows - 1); ibmat =
                static_cast<int32_T>(ibmat + 1)) {
            FlightMissionMode_DW.lla0tmp_data[ibmat] = lla0[0];
        }

        for (ibmat = 0; ibmat <= static_cast<int32_T>(nrows - 1); ibmat =
                static_cast<int32_T>(ibmat + 1)) {
            FlightMissionMode_DW.lla0tmp_data[static_cast<int32_T>(nrows + ibmat)]
                = lla0[1];
        }

        idx = static_cast<int32_T>(lla_size[0] << 1);
        for (ibmat = 0; ibmat <= static_cast<int32_T>(nrows - 1); ibmat =
                static_cast<int32_T>(ibmat + 1)) {
            FlightMissionMode_DW.lla0tmp_data[static_cast<int32_T>(idx + ibmat)]
                = lla0[2];
        }

        llatmp_size[0] = lla_size[0];
        llatmp_size[1] = 3;
        nrows = static_cast<int32_T>(lla_size[0] * 3);
        for (idx = 0; idx <= static_cast<int32_T>(nrows - 1); idx++) {
            FlightMissionMode_DW.llatmp_data[idx] = lla_data[idx];
        }
        break;

      default:
        llatmp_size[0] = lla_size[0];
        llatmp_size[1] = 3;
        nrows = static_cast<int32_T>(lla_size[0] * 3);
        for (idx = 0; idx <= static_cast<int32_T>(nrows - 1); idx++) {
            FlightMissionMode_DW.llatmp_data[idx] = lla_data[idx];
        }

        lla0tmp_size[0] = 1;
        lla0tmp_size[1] = 3;
        FlightMissionMode_DW.lla0tmp_data[0] = lla0[0];
        FlightMissionMode_DW.lla0tmp_data[1] = lla0[1];
        FlightMissionMode_DW.lla0tmp_data[2] = lla0[2];
        break;
    }

    FlightMissionMode_lla2ecef(FlightMissionMode_DW.llatmp_data, llatmp_size,
        FlightMissionMode_DW.ecefPosWithENUOrigin_data,
        ecefPosWithENUOrigin_size);
    nrows = lla0tmp_size[0];
    b_size = lla0tmp_size[0];
    for (idx = 0; idx <= static_cast<int32_T>(nrows - 1); idx++) {
        FlightMissionMode_DW.b_data[idx] = FlightMissionMode_DW.lla0tmp_data[idx];
    }

    FlightMissionMode_cosd(FlightMissionMode_DW.b_data, &b_size);
    cosphi_size = b_size;
    nrows = b_size;
    for (idx = 0; idx <= static_cast<int32_T>(nrows - 1); idx++) {
        FlightMissionMode_DW.cosphi_data[idx] = FlightMissionMode_DW.b_data[idx];
    }

    nrows = lla0tmp_size[0];
    b_size = lla0tmp_size[0];
    for (idx = 0; idx <= static_cast<int32_T>(nrows - 1); idx++) {
        FlightMissionMode_DW.b_data[idx] = FlightMissionMode_DW.lla0tmp_data[idx];
    }

    FlightMissionMode_sind(FlightMissionMode_DW.b_data, &b_size);
    sinphi_size = b_size;
    nrows = b_size;
    for (idx = 0; idx <= static_cast<int32_T>(nrows - 1); idx++) {
        FlightMissionMode_DW.sinphi_data[idx] = FlightMissionMode_DW.b_data[idx];
    }

    nrows = lla0tmp_size[0];
    b_size = lla0tmp_size[0];
    for (idx = 0; idx <= static_cast<int32_T>(nrows - 1); idx++) {
        FlightMissionMode_DW.b_data[idx] = FlightMissionMode_DW.lla0tmp_data[
            static_cast<int32_T>(idx + lla0tmp_size[0])];
    }

    FlightMissionMode_cosd(FlightMissionMode_DW.b_data, &b_size);
    coslambda_size = b_size;
    nrows = b_size;
    for (idx = 0; idx <= static_cast<int32_T>(nrows - 1); idx++) {
        FlightMissionMode_DW.coslambda_data[idx] =
            FlightMissionMode_DW.b_data[idx];
    }

    nrows = lla0tmp_size[0];
    b_size = lla0tmp_size[0];
    for (idx = 0; idx <= static_cast<int32_T>(nrows - 1); idx++) {
        FlightMissionMode_DW.b_data[idx] = FlightMissionMode_DW.lla0tmp_data[
            static_cast<int32_T>(idx + lla0tmp_size[0])];
    }

    FlightMissionMode_sind(FlightMissionMode_DW.b_data, &b_size);
    FlightMissionMode_lla2ecef(FlightMissionMode_DW.lla0tmp_data, lla0tmp_size,
        FlightMissionMode_DW.llatmp_data, llatmp_size);
    if (ecefPosWithENUOrigin_size[0] == llatmp_size[0]) {
        nrows = static_cast<int32_T>(ecefPosWithENUOrigin_size[0] * 3);
        ecefPosWithENUOrigin_size[1] = 3;
        for (ibmat = 0; ibmat <= static_cast<int32_T>(nrows - 1); ibmat++) {
            FlightMissionMode_DW.ecefPosWithENUOrigin_data[ibmat] -=
                FlightMissionMode_DW.llatmp_data[ibmat];
        }
    } else {
        FlightMissionMode_minus_l(FlightMissionMode_DW.ecefPosWithENUOrigin_data,
            ecefPosWithENUOrigin_size, FlightMissionMode_DW.llatmp_data,
            llatmp_size);
    }

    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
            static_cast<boolean_T>(static_cast<int32_T>((coslambda_size ==
              ecefPosWithENUOrigin_size[0]) & (b_size ==
              ecefPosWithENUOrigin_size[0])))) & ((coslambda_size == 1 ?
            ecefPosWithENUOrigin_size[0] : coslambda_size) == (b_size == 1 ?
            ecefPosWithENUOrigin_size[0] : b_size))))) {
        ibmat = coslambda_size;
        for (idx = 0; idx <= static_cast<int32_T>(coslambda_size - 1); idx++) {
            FlightMissionMode_DW.tmp_data[idx] =
                FlightMissionMode_DW.ecefPosWithENUOrigin_data
                [static_cast<int32_T>(idx + ecefPosWithENUOrigin_size[0])] *
                FlightMissionMode_DW.b_data[idx] +
                FlightMissionMode_DW.coslambda_data[idx] *
                FlightMissionMode_DW.ecefPosWithENUOrigin_data[idx];
        }
    } else {
        FlightMissionMode_binary_expand_op_puh(FlightMissionMode_DW.tmp_data,
            &ibmat, FlightMissionMode_DW.coslambda_data, &coslambda_size,
            FlightMissionMode_DW.ecefPosWithENUOrigin_data,
            ecefPosWithENUOrigin_size, FlightMissionMode_DW.b_data, &b_size);
    }

    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
            static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
              static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
                 static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                   (static_cast<boolean_T>(static_cast<int32_T>
                     (static_cast<int32_T>(static_cast<boolean_T>
                       (static_cast<int32_T>(static_cast<int32_T>
                         (static_cast<boolean_T>(static_cast<int32_T>(
            static_cast<int32_T>(static_cast<boolean_T>(static_cast<int32_T>
            ((b_size == ecefPosWithENUOrigin_size[0]) & (coslambda_size ==
            ecefPosWithENUOrigin_size[0])))) & ((b_size == 1 ?
            ecefPosWithENUOrigin_size[0] : b_size) == (coslambda_size == 1 ?
            ecefPosWithENUOrigin_size[0] : coslambda_size))))) & (sinphi_size ==
                          ibmat)))) & (cosphi_size == ecefPosWithENUOrigin_size
                       [0])))) & ((sinphi_size == 1 ? ibmat : sinphi_size) ==
                    (cosphi_size == 1 ? ecefPosWithENUOrigin_size[0] :
                     cosphi_size))))) & (cosphi_size == ibmat)))) & (sinphi_size
              == ecefPosWithENUOrigin_size[0])))) & ((cosphi_size == 1 ? ibmat :
            cosphi_size) == (sinphi_size == 1 ? ecefPosWithENUOrigin_size[0] :
                             sinphi_size))))) {
        llatmp_size[0] = b_size;
        nrows = b_size;
        for (idx = 0; idx <= static_cast<int32_T>(nrows - 1); idx++) {
            FlightMissionMode_DW.llatmp_data[idx] =
                FlightMissionMode_DW.ecefPosWithENUOrigin_data
                [static_cast<int32_T>(idx + ecefPosWithENUOrigin_size[0])] *
                FlightMissionMode_DW.coslambda_data[idx] +
                -FlightMissionMode_DW.b_data[idx] *
                FlightMissionMode_DW.ecefPosWithENUOrigin_data[idx];
        }

        for (idx = 0; idx <= static_cast<int32_T>(sinphi_size - 1); idx++) {
            FlightMissionMode_DW.llatmp_data[static_cast<int32_T>(idx +
                llatmp_size[0])] =
                FlightMissionMode_DW.ecefPosWithENUOrigin_data
                [static_cast<int32_T>(static_cast<int32_T>
                (ecefPosWithENUOrigin_size[0] << 1) + idx)] *
                FlightMissionMode_DW.cosphi_data[idx] +
                -FlightMissionMode_DW.sinphi_data[idx] *
                FlightMissionMode_DW.tmp_data[idx];
        }

        for (idx = 0; idx <= static_cast<int32_T>(cosphi_size - 1); idx++) {
            FlightMissionMode_DW.llatmp_data[static_cast<int32_T>(idx +
                static_cast<int32_T>(llatmp_size[0] << 1))] =
                FlightMissionMode_DW.ecefPosWithENUOrigin_data
                [static_cast<int32_T>(static_cast<int32_T>
                (ecefPosWithENUOrigin_size[0] << 1) + idx)] *
                FlightMissionMode_DW.sinphi_data[idx] +
                FlightMissionMode_DW.cosphi_data[idx] *
                FlightMissionMode_DW.tmp_data[idx];
        }
    } else {
        FlightMissionMode_binary_expand_op_pu(FlightMissionMode_DW.llatmp_data,
            llatmp_size, FlightMissionMode_DW.b_data, &b_size,
            FlightMissionMode_DW.ecefPosWithENUOrigin_data,
            ecefPosWithENUOrigin_size, FlightMissionMode_DW.coslambda_data,
            &coslambda_size, FlightMissionMode_DW.sinphi_data, &sinphi_size,
            FlightMissionMode_DW.tmp_data, &ibmat,
            FlightMissionMode_DW.cosphi_data, &cosphi_size);
    }

    xyzNED_size[0] = static_cast<int32_T>(static_cast<int16_T>(llatmp_size[0]));
    xyzNED_size[1] = 3;
    nrows = static_cast<int32_T>(static_cast<int32_T>(static_cast<int32_T>(
        static_cast<int16_T>(llatmp_size[0])) * 3) - 1);
    for (idx = 0; idx <= nrows; idx++) {
        xyzNED_data[idx] = 0.0;
    }

    nrows = llatmp_size[0];
    for (idx = 0; idx <= static_cast<int32_T>(nrows - 1); idx++) {
        xyzNED_data[idx] = FlightMissionMode_DW.llatmp_data[static_cast<int32_T>
            (idx + llatmp_size[0])];
    }

    nrows = llatmp_size[0];
    for (idx = 0; idx <= static_cast<int32_T>(nrows - 1); idx++) {
        xyzNED_data[static_cast<int32_T>(idx + xyzNED_size[0])] =
            FlightMissionMode_DW.llatmp_data[idx];
    }

    nrows = llatmp_size[0];
    for (idx = 0; idx <= static_cast<int32_T>(nrows - 1); idx++) {
        xyzNED_data[static_cast<int32_T>(idx + static_cast<int32_T>(xyzNED_size
            [0] << 1))] = -FlightMissionMode_DW.llatmp_data[static_cast<int32_T>
            (static_cast<int32_T>(llatmp_size[0] << 1) + idx)];
    }
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_copydigits_d
    (emxArray_char_T_FlightMissionMode_T *s1, int32_T *idx, const
     emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n, boolean_T
     allowpoint)
{
    boolean_T exitg1;
    boolean_T haspoint;
    boolean_T success;
    success = (*k <= n);
    haspoint = false;
    exitg1 = false;
    while ((!exitg1) && (static_cast<boolean_T>(static_cast<int32_T>((*k <= n) &
              static_cast<int32_T>(success))))) {
        char_T tmp;
        tmp = s->data[static_cast<int32_T>(*k - 1)];
        if ((tmp >= '0') && (tmp <= '9')) {
            s1->data[static_cast<int32_T>(*idx - 1)] = tmp;
            *idx = static_cast<int32_T>(*idx + 1);
            *k = static_cast<int32_T>(*k + 1);
        } else if (tmp == '.') {
            success = static_cast<boolean_T>(static_cast<int32_T>
                (static_cast<int32_T>(static_cast<boolean_T>(static_cast<int32_T>
                (static_cast<int32_T>(haspoint) ^ 1))) & static_cast<int32_T>
                 (allowpoint)));
            if (success) {
                s1->data[static_cast<int32_T>(*idx - 1)] = '.';
                *idx = static_cast<int32_T>(*idx + 1);
                haspoint = true;
            }

            *k = static_cast<int32_T>(*k + 1);
        } else if (tmp == ',') {
            *k = static_cast<int32_T>(*k + 1);
        } else {
            exitg1 = true;
        }
    }

    return success;
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_readfloat_i
    (emxArray_char_T_FlightMissionMode_T *s1, int32_T *idx, const
     emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n, boolean_T
     allowimag, boolean_T *isimag, boolean_T *b_finite, real_T *nfv, boolean_T
     *foundsign, boolean_T *success)
{
    static const boolean_T b[128]{ false, false, false, false, false, false,
        false, false, false, true, true, true, true, true, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, true, true, true, true, true, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false };

    emxArray_char_T_FlightMissionMode_T *d;
    int32_T b_idx;
    int32_T b_k;
    int32_T g_k;
    char_T c_idx_0;
    boolean_T a__3;
    boolean_T exitg1;
    boolean_T isneg;
    FlightMissionMode_emxInit_char_T_e(&d, 2);
    *isimag = false;
    *b_finite = true;
    *nfv = 0.0;
    b_idx = *idx;
    b_k = *k;
    isneg = false;
    *foundsign = false;
    exitg1 = false;
    while ((!exitg1) && (b_k <= n)) {
        c_idx_0 = s->data[static_cast<int32_T>(b_k - 1)];
        if (c_idx_0 == '-') {
            isneg = static_cast<boolean_T>(static_cast<int32_T>
                (static_cast<int32_T>(isneg) ^ 1));
            *foundsign = true;
            b_k = static_cast<int32_T>(b_k + 1);
        } else if (c_idx_0 == ',') {
            b_k = static_cast<int32_T>(b_k + 1);
        } else if (c_idx_0 == '+') {
            *foundsign = true;
            b_k = static_cast<int32_T>(b_k + 1);
        } else if (static_cast<boolean_T>(static_cast<int32_T>
                    (static_cast<int32_T>(b[static_cast<int32_T>
                      (static_cast<int32_T>(static_cast<uint8_T>(c_idx_0)) & 127)])
                     ^ 1))) {
            exitg1 = true;
        } else {
            b_k = static_cast<int32_T>(b_k + 1);
        }
    }

    *success = (b_k <= n);
    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
            (*success) & static_cast<int32_T>(isneg)))) {
        if ((*idx >= 2) && (s1->data[static_cast<int32_T>(*idx - 2)] == '-')) {
            s1->data[static_cast<int32_T>(*idx - 2)] = ' ';
        } else {
            s1->data[static_cast<int32_T>(*idx - 1)] = '-';
            b_idx = static_cast<int32_T>(*idx + 1);
        }
    }

    *idx = b_idx;
    *k = b_k;
    if (*success) {
        char_T c_idx_1;
        char_T c_idx_2;
        isneg = false;
        if (b_k <= n) {
            c_idx_0 = s->data[static_cast<int32_T>(b_k - 1)];
            if (c_idx_0 == 'j') {
                isneg = true;
            } else if (c_idx_0 == 'i') {
                if (b_k >= static_cast<int32_T>(n - 1)) {
                    isneg = true;
                } else {
                    g_k = b_k;
                    c_idx_0 = '\x00';
                    while ((g_k <= n) && (s->data[static_cast<int32_T>(g_k - 1)]
                                          == ',')) {
                        g_k = static_cast<int32_T>(g_k + 1);
                    }

                    if (g_k <= n) {
                        c_idx_0 = s->data[static_cast<int32_T>(g_k - 1)];
                    }

                    g_k = static_cast<int32_T>(g_k + 1);
                    c_idx_1 = '\x00';
                    while ((g_k <= n) && (s->data[static_cast<int32_T>(g_k - 1)]
                                          == ',')) {
                        g_k = static_cast<int32_T>(g_k + 1);
                    }

                    if (g_k <= n) {
                        c_idx_1 = s->data[static_cast<int32_T>(g_k - 1)];
                    }

                    g_k = static_cast<int32_T>(g_k + 1);
                    c_idx_2 = '\x00';
                    while ((g_k <= n) && (s->data[static_cast<int32_T>(g_k - 1)]
                                          == ',')) {
                        g_k = static_cast<int32_T>(g_k + 1);
                    }

                    if (g_k <= n) {
                        c_idx_2 = s->data[static_cast<int32_T>(g_k - 1)];
                    }

                    if (((c_idx_0 == 'I') || (c_idx_0 == 'i')) && ((c_idx_1 ==
                            'N') || (c_idx_1 == 'n')) && ((c_idx_2 == 'F') ||
                            (c_idx_2 == 'f'))) {
                    } else if ((c_idx_0 == 'N') || (c_idx_0 == 'n')) {
                        if ((c_idx_1 == 'A') || (c_idx_1 == 'a')) {
                            if ((c_idx_2 != 'N') && (c_idx_2 != 'n')) {
                                isneg = true;
                            }
                        } else {
                            isneg = true;
                        }
                    } else {
                        isneg = true;
                    }
                }
            }
        }

        if (isneg) {
            if (allowimag) {
                *isimag = true;
                *k = static_cast<int32_T>(b_k + 1);
                exitg1 = false;
                while ((!exitg1) && (*k <= n)) {
                    if (b[static_cast<int32_T>(static_cast<int32_T>
                                               (static_cast<uint8_T>(s->data[
                            static_cast<int32_T>(*k - 1)])) & 127)]) {
                        *k = static_cast<int32_T>(*k + 1);
                    } else {
                        c_idx_0 = s->data[static_cast<int32_T>(*k - 1)];
                        if ((c_idx_0 == '\x00') || (c_idx_0 == ',')) {
                            *k = static_cast<int32_T>(*k + 1);
                        } else {
                            exitg1 = true;
                        }
                    }
                }

                if ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == '*'))
                {
                    *k = static_cast<int32_T>(*k + 1);
                    FlightMissionMode_readfloat_i(s1, idx, s, k, n, false,
                        &isneg, b_finite, nfv, &a__3, success);
                } else {
                    s1->data[static_cast<int32_T>(b_idx - 1)] = '1';
                    *idx = static_cast<int32_T>(b_idx + 1);
                }
            } else {
                *success = false;
            }
        } else {
            g_k = b_k;
            c_idx_0 = '\x00';
            while ((g_k <= n) && (s->data[static_cast<int32_T>(g_k - 1)] == ','))
            {
                g_k = static_cast<int32_T>(g_k + 1);
            }

            if (g_k <= n) {
                c_idx_0 = s->data[static_cast<int32_T>(g_k - 1)];
            }

            g_k = static_cast<int32_T>(g_k + 1);
            c_idx_1 = '\x00';
            while ((g_k <= n) && (s->data[static_cast<int32_T>(g_k - 1)] == ','))
            {
                g_k = static_cast<int32_T>(g_k + 1);
            }

            if (g_k <= n) {
                c_idx_1 = s->data[static_cast<int32_T>(g_k - 1)];
            }

            g_k = static_cast<int32_T>(g_k + 1);
            c_idx_2 = '\x00';
            while ((g_k <= n) && (s->data[static_cast<int32_T>(g_k - 1)] == ','))
            {
                g_k = static_cast<int32_T>(g_k + 1);
            }

            if (g_k <= n) {
                c_idx_2 = s->data[static_cast<int32_T>(g_k - 1)];
            }

            g_k = static_cast<int32_T>(g_k + 1);
            if (((c_idx_0 == 'I') || (c_idx_0 == 'i')) && ((c_idx_1 == 'N') ||
                    (c_idx_1 == 'n')) && ((c_idx_2 == 'F') || (c_idx_2 == 'f')))
            {
                *b_finite = false;
                *nfv = (rtInf);
            } else if (((c_idx_0 == 'N') || (c_idx_0 == 'n')) && ((c_idx_1 ==
                         'A') || (c_idx_1 == 'a')) && ((c_idx_2 == 'N') ||
                        (c_idx_2 == 'n'))) {
                *b_finite = false;
                *nfv = (rtNaN);
            } else {
                g_k = b_k;
            }

            *k = g_k;
            if (*b_finite) {
                int32_T loop_ub;
                b_k = static_cast<int32_T>(d->size[0] * d->size[1]);
                d->size[0] = 1;
                d->size[1] = s1->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_g(d, b_k);
                loop_ub = static_cast<int32_T>(s1->size[1] - 1);
                for (b_k = 0; b_k <= loop_ub; b_k++) {
                    d->data[b_k] = s1->data[b_k];
                }

                *success = FlightMissionMode_copydigits_d(d, &b_idx, s, &g_k, n,
                    true);
                b_k = static_cast<int32_T>(s1->size[0] * s1->size[1]);
                s1->size[0] = 1;
                s1->size[1] = d->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_g(s1, b_k);
                loop_ub = d->size[1];
                for (b_k = 0; b_k <= static_cast<int32_T>(loop_ub - 1); b_k++) {
                    s1->data[b_k] = d->data[b_k];
                }

                *idx = b_idx;
                *k = g_k;
                if ((*success) && (g_k <= n)) {
                    c_idx_0 = s->data[static_cast<int32_T>(g_k - 1)];
                    if ((c_idx_0 == 'E') || (c_idx_0 == 'e')) {
                        s1->data[static_cast<int32_T>(b_idx - 1)] = 'e';
                        *idx = static_cast<int32_T>(b_idx + 1);
                        while ((static_cast<int32_T>(g_k + 1) <= n) && (s->
                                data[g_k] == ',')) {
                            g_k = static_cast<int32_T>(g_k + 1);
                        }

                        if (static_cast<int32_T>(g_k + 1) <= n) {
                            if (s->data[g_k] == '-') {
                                s1->data[b_idx] = '-';
                                *idx = static_cast<int32_T>(b_idx + 2);
                                g_k = static_cast<int32_T>(g_k + 1);
                            } else if (s->data[g_k] == '+') {
                                g_k = static_cast<int32_T>(g_k + 1);
                            }
                        }

                        b_k = static_cast<int32_T>(d->size[0] * d->size[1]);
                        d->size[0] = 1;
                        d->size[1] = s1->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_g(d, b_k);
                        loop_ub = static_cast<int32_T>(s1->size[1] - 1);
                        for (b_k = 0; b_k <= loop_ub; b_k++) {
                            d->data[b_k] = s1->data[b_k];
                        }

                        b_idx = static_cast<int32_T>(g_k + 1);
                        isneg = FlightMissionMode_copydigits_d(d, idx, s, &b_idx,
                            n, false);
                        b_k = static_cast<int32_T>(s1->size[0] * s1->size[1]);
                        s1->size[0] = 1;
                        s1->size[1] = d->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_g(s1, b_k);
                        loop_ub = d->size[1];
                        for (b_k = 0; b_k <= static_cast<int32_T>(loop_ub - 1);
                                b_k++) {
                            s1->data[b_k] = d->data[b_k];
                        }

                        *k = b_idx;
                        if (static_cast<boolean_T>(static_cast<int32_T>((b_idx <=
                               static_cast<int32_T>(g_k + 1)) |
                                static_cast<int32_T>(static_cast<boolean_T>(
                                static_cast<int32_T>(static_cast<int32_T>(isneg)
                                 ^ 1)))))) {
                            *success = false;
                        }
                    }
                }
            } else if ((b_idx >= 2) && (s1->data[static_cast<int32_T>(b_idx - 2)]
                        == '-')) {
                *idx = static_cast<int32_T>(b_idx - 1);
                s1->data[static_cast<int32_T>(b_idx - 2)] = ' ';
                *nfv = -*nfv;
            }

            exitg1 = false;
            while ((!exitg1) && (*k <= n)) {
                if (b[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(s->data[
                        static_cast<int32_T>(*k - 1)])) & 127)]) {
                    *k = static_cast<int32_T>(*k + 1);
                } else {
                    c_idx_0 = s->data[static_cast<int32_T>(*k - 1)];
                    if ((c_idx_0 == '\x00') || (c_idx_0 == ',')) {
                        *k = static_cast<int32_T>(*k + 1);
                    } else {
                        exitg1 = true;
                    }
                }
            }

            if ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == '*')) {
                *k = static_cast<int32_T>(*k + 1);
                while ((*k <= n) && (b[static_cast<int32_T>(static_cast<int32_T>
                         (static_cast<uint8_T>(s->data[static_cast<int32_T>(*k -
                            1)])) & 127)] || (s->data[static_cast<int32_T>(*k -
                          1)] == '\x00') || (s->data[static_cast<int32_T>(*k - 1)]
                         == ','))) {
                    *k = static_cast<int32_T>(*k + 1);
                }
            }

            if (*k <= n) {
                c_idx_0 = s->data[static_cast<int32_T>(*k - 1)];
                if ((c_idx_0 == 'i') || (c_idx_0 == 'j')) {
                    *k = static_cast<int32_T>(*k + 1);
                    *isimag = true;
                }
            }
        }

        exitg1 = false;
        while ((!exitg1) && (*k <= n)) {
            c_idx_0 = s->data[static_cast<int32_T>(*k - 1)];
            if (b[static_cast<int32_T>(static_cast<int32_T>(static_cast<uint8_T>
                    (c_idx_0)) & 127)] || (c_idx_0 == '\x00') || (c_idx_0 == ','))
            {
                *k = static_cast<int32_T>(*k + 1);
            } else {
                exitg1 = true;
            }
        }
    }

    FlightMissionMode_emxFree_char_T_o(&d);
}

real_T FlightMissionMode::FlightMissionMode_angdiff(real_T x, real_T y)
{
    real_T delta;
    delta = y - x;
    if (std::abs(delta) > 3.1415926535897931) {
        real_T thetaWrap;
        if (std::isnan(delta + 3.1415926535897931) || std::isinf(delta +
                3.1415926535897931)) {
            thetaWrap = (rtNaN);
        } else if (delta + 3.1415926535897931 == 0.0) {
            thetaWrap = 0.0;
        } else {
            boolean_T rEQ0;
            thetaWrap = std::fmod(delta + 3.1415926535897931, 6.2831853071795862);
            rEQ0 = (thetaWrap == 0.0);
            if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                    (rEQ0) ^ 1))) {
                real_T q;
                q = std::abs((delta + 3.1415926535897931) / 6.2831853071795862);
                rEQ0 = static_cast<boolean_T>(static_cast<int32_T>((std::abs(q -
                    std::floor(q + 0.5)) > 2.2204460492503131E-16 * q) ^ 1));
            }

            if (rEQ0) {
                thetaWrap = 0.0;
            } else if (delta + 3.1415926535897931 < 0.0) {
                thetaWrap += 6.2831853071795862;
            }
        }

        if (static_cast<boolean_T>(static_cast<int32_T>((delta +
                3.1415926535897931 > 0.0) & (thetaWrap == 0.0)))) {
            thetaWrap = 6.2831853071795862;
        }

        delta = thetaWrap - 3.1415926535897931;
    }

    return delta;
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
int8_T FlightMissionMode::FlightMissionMode_filedata_dj(void) const
{
    int32_T k;
    int8_T f;
    boolean_T exitg1;
    f = 0;
    k = 1;
    exitg1 = false;
    while ((!exitg1) && (static_cast<int32_T>(k - 1) < 20)) {
        if (FlightMissionMode_DW.eml_openfiles[static_cast<int32_T>
                (static_cast<int32_T>(static_cast<int8_T>(k)) - 1)] == NULL) {
            f = static_cast<int8_T>(k);
            exitg1 = true;
        } else {
            k = static_cast<int32_T>(k + 1);
        }
    }

    return f;
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
int8_T FlightMissionMode::FlightMissionMode_cfopen_g(const char_T *cfilename,
    const char_T *cpermission)
{
    int8_T fileid;
    int8_T j;
    fileid = -1;
    j = FlightMissionMode_filedata_dj();
    if (static_cast<int32_T>(j) >= 1) {
        FILE* filestar;
        filestar = fopen(cfilename, cpermission);
        if (filestar != NULL) {
            int32_T tmp;
            FlightMissionMode_DW.eml_openfiles[static_cast<int32_T>
                (static_cast<int32_T>(j) - 1)] = filestar;
            tmp = static_cast<int32_T>(static_cast<int32_T>(j) + 2);
            if (static_cast<int32_T>(static_cast<int32_T>(j) + 2) > 127) {
                tmp = 127;
            }

            fileid = static_cast<int8_T>(tmp);
        }
    }

    return fileid;
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
real_T FlightMissionMode::FlightMissionMode_fileManager_e(void)
{
    real_T f;
    int8_T fileid;
    fileid = FlightMissionMode_cfopen_g("config.ini", "rb");
    f = static_cast<real_T>(fileid);
    return f;
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_fread_e(real_T fileID,
    emxArray_char_T_FlightMissionMode_T *A)
{
    FILE* filestar;
    size_t nBytes;
    char_T tbuf[1024];
    int8_T fileid;
    nBytes = sizeof(char_T);
    fileid = static_cast<int8_T>(std::round(fileID));
    if (fileID != static_cast<real_T>(fileid)) {
        fileid = -1;
    }

    if (static_cast<int32_T>(fileid) >= 3) {
        filestar = FlightMissionMode_DW.eml_openfiles[static_cast<int32_T>(
            static_cast<int32_T>(fileid) - 3)];
    } else {
        switch (static_cast<int32_T>(fileid)) {
          case 0:
            filestar = stdin;
            break;

          case 1:
            filestar = stdout;
            break;

          case 2:
            filestar = stderr;
            break;

          default:
            filestar = NULL;
            break;
        }
    }

    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
            static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
              static_cast<boolean_T>(static_cast<int32_T>((fileID != 0.0) ^ 1)))
             | static_cast<int32_T>(static_cast<boolean_T>(static_cast<int32_T>
               ((fileID != 1.0) ^ 1)))))) | static_cast<int32_T>
            (static_cast<boolean_T>(static_cast<int32_T>((fileID != 2.0) ^ 1))))))
    {
        filestar = NULL;
    }

    A->size[0] = 0;
    if (static_cast<boolean_T>(static_cast<int32_T>((filestar == NULL) ^ 1))) {
        int32_T c;
        c = 1;
        while (c > 0) {
            int32_T c_0;
            int32_T i;
            int32_T numRead;
            c = 0;
            numRead = 1;
            while (static_cast<boolean_T>(static_cast<int32_T>((c < 1024) &
                     (numRead > 0)))) {
                size_t numReadSizeT;
                numReadSizeT = fread(&tbuf[c], nBytes, (size_t)(1024 - c),
                                     filestar);
                numRead = (int32_T)numReadSizeT;
                c = static_cast<int32_T>(c + (int32_T)numReadSizeT);
            }

            numRead = A->size[0];
            if (c < 1) {
                c_0 = -1;
            } else {
                c_0 = static_cast<int32_T>(c - 1);
            }

            i = A->size[0];
            A->size[0] = static_cast<int32_T>(static_cast<int32_T>(c_0 + A->
                size[0]) + 1);
            FlightMissionMode_emxEnsureCapacity_char_T_g(A, i);
            if (c < 1) {
                c_0 = -1;
            } else {
                c_0 = static_cast<int32_T>(c - 1);
            }

            for (i = 0; i <= c_0; i++) {
                A->data[static_cast<int32_T>(numRead + i)] = tbuf[i];
            }
        }
    }
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
creal_T FlightMissionMode::FlightMissionMode_str2double_a(const
    emxArray_char_T_FlightMissionMode_T *s)
{
    static const boolean_T c[128]{ false, false, false, false, false, false,
        false, false, false, true, true, true, true, true, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, true, true, true, true, true, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false };

    emxArray_char_T_FlightMissionMode_T *d;
    emxArray_char_T_FlightMissionMode_T *s1;
    creal_T x;
    real_T b_scanned1;
    real_T scanned1;
    real_T scanned2;
    int32_T idx;
    int32_T k;
    boolean_T a__1;
    boolean_T c_success;
    boolean_T foundsign;
    boolean_T isfinite1;
    boolean_T isimag1;
    boolean_T success;
    FlightMissionMode_emxInit_char_T_e(&d, 2);
    x.re = (rtNaN);
    x.im = 0.0;
    if (s->size[1] >= 1) {
        int32_T i;
        int32_T loop_ub;
        int32_T ntoread;
        boolean_T exitg1;
        FlightMissionMode_emxInit_char_T_e(&s1, 2);
        ntoread = 0;
        k = 1;
        exitg1 = false;
        while ((!exitg1) && (k <= s->size[1])) {
            char_T tmp;
            tmp = s->data[static_cast<int32_T>(k - 1)];
            if (c[static_cast<int32_T>(static_cast<int32_T>(static_cast<uint8_T>
                    (tmp)) & 127)] || (tmp == '\x00')) {
                k = static_cast<int32_T>(k + 1);
            } else {
                exitg1 = true;
            }
        }

        i = static_cast<int32_T>(d->size[0] * d->size[1]);
        d->size[0] = 1;
        d->size[1] = static_cast<int32_T>(s->size[1] + 2);
        FlightMissionMode_emxEnsureCapacity_char_T_g(d, i);
        loop_ub = s->size[1];
        for (i = 0; i <= static_cast<int32_T>(loop_ub + 1); i++) {
            d->data[i] = '\x00';
        }

        idx = 1;
        FlightMissionMode_readfloat_i(d, &idx, s, &k, s->size[1], true, &isimag1,
            &isfinite1, &scanned1, &a__1, &success);
        i = static_cast<int32_T>(s1->size[0] * s1->size[1]);
        s1->size[0] = 1;
        s1->size[1] = d->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_g(s1, i);
        loop_ub = static_cast<int32_T>(d->size[1] - 1);
        for (i = 0; i <= loop_ub; i++) {
            s1->data[i] = d->data[i];
        }

        if (isfinite1) {
            ntoread = 1;
        }

        if (success) {
            if (k <= s->size[1]) {
                s1->data[static_cast<int32_T>(idx - 1)] = ' ';
                i = static_cast<int32_T>(d->size[0] * d->size[1]);
                d->size[0] = 1;
                d->size[1] = s1->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_g(d, i);
                loop_ub = static_cast<int32_T>(s1->size[1] - 1);
                for (i = 0; i <= loop_ub; i++) {
                    d->data[i] = s1->data[i];
                }

                idx = static_cast<int32_T>(idx + 1);
                FlightMissionMode_readfloat_i(d, &idx, s, &k, s->size[1], true,
                    &a__1, &success, &scanned2, &foundsign, &c_success);
                i = static_cast<int32_T>(s1->size[0] * s1->size[1]);
                s1->size[0] = 1;
                s1->size[1] = d->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_g(s1, i);
                loop_ub = static_cast<int32_T>(d->size[1] - 1);
                for (i = 0; i <= loop_ub; i++) {
                    s1->data[i] = d->data[i];
                }

                if (success) {
                    ntoread = static_cast<int32_T>(ntoread + 1);
                }

                success = static_cast<boolean_T>(static_cast<int32_T>(
                    static_cast<int32_T>(static_cast<boolean_T>
                    (static_cast<int32_T>(static_cast<int32_T>
                    (static_cast<boolean_T>(static_cast<int32_T>
                    (static_cast<int32_T>(static_cast<boolean_T>
                    (static_cast<int32_T>(static_cast<int32_T>(isimag1) ^
                    static_cast<int32_T>(a__1)))) & static_cast<int32_T>
                     (foundsign)))) & (k > s->size[1])))) & static_cast<int32_T>
                    (c_success)));
            } else {
                scanned2 = 0.0;
            }
        } else {
            scanned2 = 0.0;
        }

        if (success) {
            s1->data[static_cast<int32_T>(idx - 1)] = '\x00';
            switch (ntoread) {
              case 2:
                ntoread = sscanf(&s1->data[0], "%lf %lf", &scanned1, &scanned2);
                if (ntoread != 2) {
                    scanned1 = (rtNaN);
                    scanned2 = (rtNaN);
                }
                break;

              case 1:
                ntoread = sscanf(&s1->data[0], "%lf", &b_scanned1);
                if (isfinite1) {
                    if (ntoread == 1) {
                        scanned1 = b_scanned1;
                    } else {
                        scanned1 = (rtNaN);
                    }
                } else if (ntoread == 1) {
                    scanned2 = b_scanned1;
                } else {
                    scanned2 = (rtNaN);
                }
                break;
            }

            if (isimag1) {
                x.re = scanned2;
                x.im = scanned1;
            } else {
                x.re = scanned1;
                x.im = scanned2;
            }
        }

        FlightMissionMode_emxFree_char_T_o(&s1);
    }

    FlightMissionMode_emxFree_char_T_o(&d);
    return x;
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
int32_T FlightMissionMode::FlightMissionMode_cfclose_p(real_T fid)
{
    FILE* filestar;
    int32_T st;
    int8_T b_fileid;
    int8_T fileid;
    st = -1;
    fileid = static_cast<int8_T>(std::round(fid));
    if (fid != static_cast<real_T>(fileid)) {
        fileid = -1;
    }

    b_fileid = fileid;
    if (static_cast<int32_T>(fileid) < 0) {
        b_fileid = -1;
    }

    if (static_cast<int32_T>(b_fileid) >= 3) {
        filestar = FlightMissionMode_DW.eml_openfiles[static_cast<int32_T>(
            static_cast<int32_T>(b_fileid) - 3)];
    } else {
        switch (static_cast<int32_T>(b_fileid)) {
          case 0:
            filestar = stdin;
            break;

          case 1:
            filestar = stdout;
            break;

          case 2:
            filestar = stderr;
            break;

          default:
            filestar = NULL;
            break;
        }
    }

    if (static_cast<boolean_T>(static_cast<int32_T>((filestar != NULL) & (
            static_cast<int32_T>(fileid) >= 3)))) {
        int32_T cst;
        cst = fclose(filestar);
        if (cst == 0) {
            st = 0;
            FlightMissionMode_DW.eml_openfiles[static_cast<int32_T>
                (static_cast<int32_T>(fileid) - 3)] = NULL;
        }
    }

    return st;
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_strtok_o5(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token, emxArray_char_T_FlightMissionMode_T *remain)
{
    int32_T b;
    int32_T i;
    int32_T itoken;
    int32_T k;
    int32_T n;
    n = x->size[1];
    k = 0;
    while ((static_cast<int32_T>(k + 1) <= n) && (x->data[k] == '\x0a')) {
        k = static_cast<int32_T>(k + 1);
    }

    itoken = static_cast<int32_T>(k + 1);
    while ((static_cast<int32_T>(k + 1) <= n) && (x->data[k] != '\x0a')) {
        k = static_cast<int32_T>(k + 1);
    }

    if (static_cast<int32_T>(k + 1) > x->size[1]) {
        n = 0;
        b = 0;
    } else {
        n = k;
        b = x->size[1];
    }

    i = static_cast<int32_T>(remain->size[0] * remain->size[1]);
    remain->size[0] = 1;
    b = static_cast<int32_T>(b - n);
    remain->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T_g(remain, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        remain->data[i] = x->data[static_cast<int32_T>(n + i)];
    }

    if (itoken > k) {
        itoken = 0;
        k = 0;
    } else {
        itoken = static_cast<int32_T>(itoken - 1);
    }

    i = static_cast<int32_T>(token->size[0] * token->size[1]);
    token->size[0] = 1;
    b = static_cast<int32_T>(k - itoken);
    token->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T_g(token, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        token->data[i] = x->data[static_cast<int32_T>(itoken + i)];
    }
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_strtok_o5f(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token)
{
    int32_T itoken;
    int32_T k;
    int32_T n;
    n = x->size[1];
    k = 1;
    while ((k <= n) && (x->data[static_cast<int32_T>(k - 1)] == ';')) {
        k = static_cast<int32_T>(k + 1);
    }

    itoken = k;
    while ((k <= n) && (x->data[static_cast<int32_T>(k - 1)] != ';')) {
        k = static_cast<int32_T>(k + 1);
    }

    if (itoken > static_cast<int32_T>(k - 1)) {
        n = 0;
        k = 0;
    } else {
        n = static_cast<int32_T>(itoken - 1);
        k = static_cast<int32_T>(k - 1);
    }

    itoken = static_cast<int32_T>(token->size[0] * token->size[1]);
    token->size[0] = 1;
    k = static_cast<int32_T>(k - n);
    token->size[1] = k;
    FlightMissionMode_emxEnsureCapacity_char_T_g(token, itoken);
    for (itoken = 0; itoken <= static_cast<int32_T>(k - 1); itoken++) {
        token->data[itoken] = x->data[static_cast<int32_T>(n + itoken)];
    }
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_strtrim_j(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    y)
{
    static const boolean_T d[128]{ false, false, false, false, false, false,
        false, false, false, true, true, true, true, true, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, true, true, true, true, true, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false };

    int32_T b_j1;
    int32_T i;
    int32_T j2;
    b_j1 = 0;
    while ((static_cast<int32_T>(b_j1 + 1) <= x->size[1]) &&
            (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(d[
               static_cast<int32_T>(static_cast<int32_T>(static_cast<uint8_T>
                 (x->data[b_j1])) & 127)]) & (x->data[b_j1] != '\x00'))))) {
        b_j1 = static_cast<int32_T>(b_j1 + 1);
    }

    j2 = static_cast<int32_T>(x->size[1] - 1);
    while ((static_cast<int32_T>(j2 + 1) > 0) && (static_cast<boolean_T>(
             static_cast<int32_T>(static_cast<int32_T>(d[static_cast<int32_T>(
                static_cast<int32_T>(static_cast<uint8_T>(x->data[j2])) & 127)])
              & (x->data[j2] != '\x00'))))) {
        j2 = static_cast<int32_T>(j2 - 1);
    }

    if (static_cast<int32_T>(b_j1 + 1) > static_cast<int32_T>(j2 + 1)) {
        b_j1 = 0;
        j2 = -1;
    }

    i = static_cast<int32_T>(y->size[0] * y->size[1]);
    y->size[0] = 1;
    j2 = static_cast<int32_T>(j2 - b_j1);
    y->size[1] = static_cast<int32_T>(j2 + 1);
    FlightMissionMode_emxEnsureCapacity_char_T_g(y, i);
    for (i = 0; i <= j2; i++) {
        y->data[i] = x->data[static_cast<int32_T>(b_j1 + i)];
    }
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_n(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[3]{ 'U', 'A', 'V' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_e(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_g(aTmp, i);
        loop_ub = static_cast<int32_T>(a->size[1] - 1);
        for (i = 0; i <= loop_ub; i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 3) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 3) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_o(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_np(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[10]{ 'N', 'o', 'r', 'm', 'A', 'i', 'r', 'S', 'p', 'd'
    };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_e(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_g(aTmp, i);
        loop_ub = static_cast<int32_T>(a->size[1] - 1);
        for (i = 0; i <= loop_ub; i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 10) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 10) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_o(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_contains_k(const
    emxArray_char_T_FlightMissionMode_T *str)
{
    int32_T matchPos;
    matchPos = 0;
    int32_T exitg1;
    do {
        exitg1 = 0;
        if (matchPos <= static_cast<int32_T>(str->size[1] - 1)) {
            if (str->data[matchPos] == '=') {
                exitg1 = 1;
            } else {
                matchPos = static_cast<int32_T>(matchPos + 1);
            }
        } else {
            matchPos = -1;
            exitg1 = 1;
        }
    } while (exitg1 == 0);

    return static_cast<int32_T>(matchPos + 1) > 0;
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_find_token_a(const
    emxArray_char_T_FlightMissionMode_T *x, int32_T *itoken, int32_T *iremain)
{
    int32_T n;
    n = x->size[1];
    *iremain = 1;
    while ((*iremain <= n) && (x->data[static_cast<int32_T>(*iremain - 1)] ==
                               '=')) {
        *iremain = static_cast<int32_T>(*iremain + 1);
    }

    *itoken = *iremain;
    while ((*iremain <= n) && (x->data[static_cast<int32_T>(*iremain - 1)] !=
                               '=')) {
        *iremain = static_cast<int32_T>(*iremain + 1);
    }
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_strtok_o5ft(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token, emxArray_char_T_FlightMissionMode_T *remain)
{
    int32_T b;
    int32_T c;
    int32_T i;
    int32_T iremain;
    int32_T itoken;
    FlightMissionMode_find_token_a(x, &itoken, &iremain);
    if (iremain > x->size[1]) {
        c = 0;
        b = 0;
    } else {
        c = static_cast<int32_T>(iremain - 1);
        b = x->size[1];
    }

    i = static_cast<int32_T>(remain->size[0] * remain->size[1]);
    remain->size[0] = 1;
    b = static_cast<int32_T>(b - c);
    remain->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T_g(remain, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        remain->data[i] = x->data[static_cast<int32_T>(c + i)];
    }

    if (itoken > static_cast<int32_T>(iremain - 1)) {
        itoken = 0;
        iremain = 0;
    } else {
        itoken = static_cast<int32_T>(itoken - 1);
        iremain = static_cast<int32_T>(iremain - 1);
    }

    i = static_cast<int32_T>(token->size[0] * token->size[1]);
    token->size[0] = 1;
    b = static_cast<int32_T>(iremain - itoken);
    token->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T_g(token, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        token->data[i] = x->data[static_cast<int32_T>(itoken + i)];
    }
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_strtok_o5ft5(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token)
{
    int32_T i;
    int32_T iremain;
    int32_T itoken;
    FlightMissionMode_find_token_a(x, &itoken, &iremain);
    if (itoken > static_cast<int32_T>(iremain - 1)) {
        itoken = 0;
        iremain = 0;
    } else {
        itoken = static_cast<int32_T>(itoken - 1);
        iremain = static_cast<int32_T>(iremain - 1);
    }

    i = static_cast<int32_T>(token->size[0] * token->size[1]);
    token->size[0] = 1;
    iremain = static_cast<int32_T>(iremain - itoken);
    token->size[1] = iremain;
    FlightMissionMode_emxEnsureCapacity_char_T_g(token, i);
    for (i = 0; i <= static_cast<int32_T>(iremain - 1); i++) {
        token->data[i] = x->data[static_cast<int32_T>(itoken + i)];
    }
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_npg(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[9]{ 'M', 'a', 'x', 'A', 'i', 'r', 'S', 'p', 'd' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_e(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_g(aTmp, i);
        loop_ub = static_cast<int32_T>(a->size[1] - 1);
        for (i = 0; i <= loop_ub; i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 9) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 9) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_o(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_readINI_m
    (emxArray_char_T_FlightMissionMode_T *ret)
{
    static const char_T h[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T i[15]{ 'C', 'l', 'i', 'm', 'b', 'A', 'n', 'g', 'l', 'e',
        'L', 'i', 'm', 'i', 't' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    emxArray_char_T_FlightMissionMode_T *curKey;
    emxArray_char_T_FlightMissionMode_T *curLine;
    emxArray_char_T_FlightMissionMode_T *curSection;
    emxArray_char_T_FlightMissionMode_T *curVal;
    emxArray_char_T_FlightMissionMode_T *data;
    emxArray_char_T_FlightMissionMode_T *data_0;
    emxArray_char_T_FlightMissionMode_T *j;
    emxArray_char_T_FlightMissionMode_T *tmp;
    int32_T iremain;
    int32_T itoken;
    int8_T fileid;
    ret->size[0] = 1;
    ret->size[1] = 0;
    fileid = FlightMissionMode_cfopen_g("config.ini", "rb");
    if (static_cast<int32_T>(fileid) < 0) {
        printf("INI-file \"%s\" was not found or could not be read.\n",
               "config.ini");
        fflush(stdout);
    } else {
        int32_T itoken_0;
        int32_T loop_ub;
        FlightMissionMode_emxInit_char_T_e(&data, 2);
        FlightMissionMode_emxInit_char_T_e(&j, 1);
        FlightMissionMode_fread_e(static_cast<real_T>(fileid), j);
        itoken_0 = static_cast<int32_T>(data->size[0] * data->size[1]);
        data->size[0] = 1;
        data->size[1] = j->size[0];
        FlightMissionMode_emxEnsureCapacity_char_T_g(data, itoken_0);
        loop_ub = j->size[0];
        for (itoken_0 = 0; itoken_0 <= static_cast<int32_T>(loop_ub - 1);
                itoken_0++) {
            data->data[itoken_0] = j->data[itoken_0];
        }

        FlightMissionMode_emxFree_char_T_o(&j);
        FlightMissionMode_emxInit_char_T_e(&curSection, 2);
        FlightMissionMode_emxInit_char_T_e(&curKey, 2);
        FlightMissionMode_emxInit_char_T_e(&curVal, 2);
        FlightMissionMode_cfclose_p(static_cast<real_T>(fileid));
        curSection->size[0] = 1;
        curSection->size[1] = 0;
        curKey->size[0] = 1;
        curKey->size[1] = 0;
        curVal->size[0] = 1;
        curVal->size[1] = 0;
        FlightMissionMode_emxInit_char_T_e(&curLine, 2);
        FlightMissionMode_emxInit_char_T_e(&aTmp, 2);
        FlightMissionMode_emxInit_char_T_e(&tmp, 2);
        FlightMissionMode_emxInit_char_T_e(&data_0, 2);
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (data->size[1] != 0) {
                boolean_T b_bool;
                itoken_0 = static_cast<int32_T>(data_0->size[0] * data_0->size[1]);
                data_0->size[0] = 1;
                data_0->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_g(data_0, itoken_0);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (itoken_0 = 0; itoken_0 <= loop_ub; itoken_0++) {
                    itoken = itoken_0;
                    data_0->data[itoken_0] = data->data[itoken_0];
                }

                FlightMissionMode_strtok_o5(data_0, curLine, data);
                FlightMissionMode_strtok_o5f(curLine, tmp);
                FlightMissionMode_strtrim_j(tmp, curLine);
                if (curLine->size[1] >= 2) {
                    boolean_T guard1{ false };

                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                iremain = 0;
                                itoken = 0;
                            } else {
                                iremain = 1;
                                itoken = static_cast<int32_T>(curLine->size[1] -
                                    1);
                            }

                            itoken_0 = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(itoken - iremain);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_g
                                (curSection, itoken_0);
                            for (itoken_0 = 0; itoken_0 <= static_cast<int32_T>
                                    (loop_ub - 1); itoken_0++) {
                                curSection->data[itoken_0] = curLine->data[
                                    static_cast<int32_T>(iremain + itoken_0)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains_k(curLine)) {
                            FlightMissionMode_strtok_o5ft(curLine, aTmp, curVal);
                            FlightMissionMode_find_token_a(curVal, &itoken,
                                &iremain);
                            if (itoken > static_cast<int32_T>(iremain - 1)) {
                                itoken = 0;
                                iremain = 0;
                            } else {
                                itoken = static_cast<int32_T>(itoken - 1);
                                iremain = static_cast<int32_T>(iremain - 1);
                            }

                            FlightMissionMode_strtrim_j(aTmp, curKey);
                            itoken_0 = static_cast<int32_T>(curLine->size[0] *
                                curLine->size[1]);
                            curLine->size[0] = 1;
                            loop_ub = static_cast<int32_T>(iremain - itoken);
                            curLine->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_g(curLine,
                                itoken_0);
                            for (itoken_0 = 0; itoken_0 <= static_cast<int32_T>
                                    (loop_ub - 1); itoken_0++) {
                                curLine->data[itoken_0] = curVal->data[
                                    static_cast<int32_T>(itoken + itoken_0)];
                            }

                            FlightMissionMode_strtrim_j(curLine, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp_n(curSection)) {
                    if (curKey->size[1] == 0) {
                        aTmp->size[0] = 1;
                        aTmp->size[1] = 0;
                    } else {
                        itoken_0 = static_cast<int32_T>(aTmp->size[0] *
                            aTmp->size[1]);
                        aTmp->size[0] = 1;
                        aTmp->size[1] = curKey->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_g(aTmp,
                            itoken_0);
                        loop_ub = static_cast<int32_T>(curKey->size[1] - 1);
                        for (itoken_0 = 0; itoken_0 <= loop_ub; itoken_0++) {
                            itoken = itoken_0;
                            aTmp->data[itoken_0] = curKey->data[itoken_0];
                        }
                    }

                    b_bool = false;
                    if (aTmp->size[1] == 15) {
                        iremain = 0;
                        int32_T exitg2;
                        do {
                            exitg2 = 0;
                            if (iremain < 15) {
                                if (h[static_cast<int32_T>(static_cast<int32_T>(
                                        static_cast<uint8_T>(aTmp->data[iremain]))
                                     & 127)] != h[static_cast<int32_T>(i[iremain])])
                                {
                                    exitg2 = 1;
                                } else {
                                    iremain = static_cast<int32_T>(iremain + 1);
                                }
                            } else {
                                b_bool = true;
                                exitg2 = 1;
                            }
                        } while (exitg2 == 0);
                    }

                    if (b_bool) {
                        itoken_0 = static_cast<int32_T>(ret->size[0] * ret->
                            size[1]);
                        ret->size[0] = 1;
                        ret->size[1] = curVal->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_g(ret,
                            itoken_0);
                        loop_ub = static_cast<int32_T>(curVal->size[1] - 1);
                        for (itoken_0 = 0; itoken_0 <= loop_ub; itoken_0++) {
                            ret->data[itoken_0] = curVal->data[itoken_0];
                        }

                        exitg1 = 1;
                    }
                }
            } else {
                exitg1 = 1;
            }
        } while (exitg1 == 0);

        FlightMissionMode_emxFree_char_T_o(&data_0);
        FlightMissionMode_emxFree_char_T_o(&tmp);
        FlightMissionMode_emxFree_char_T_o(&aTmp);
        FlightMissionMode_emxFree_char_T_o(&curLine);
        FlightMissionMode_emxFree_char_T_o(&curVal);
        FlightMissionMode_emxFree_char_T_o(&curKey);
        FlightMissionMode_emxFree_char_T_o(&curSection);
        FlightMissionMode_emxFree_char_T_o(&data);
    }
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_readINI_mk
    (emxArray_char_T_FlightMissionMode_T *ret)
{
    static const char_T h[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T i[14]{ 'D', 'i', 'v', 'e', 'A', 'n', 'g', 'l', 'e', 'L',
        'i', 'm', 'i', 't' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    emxArray_char_T_FlightMissionMode_T *curKey;
    emxArray_char_T_FlightMissionMode_T *curLine;
    emxArray_char_T_FlightMissionMode_T *curSection;
    emxArray_char_T_FlightMissionMode_T *curVal;
    emxArray_char_T_FlightMissionMode_T *data;
    emxArray_char_T_FlightMissionMode_T *data_0;
    emxArray_char_T_FlightMissionMode_T *j;
    emxArray_char_T_FlightMissionMode_T *tmp;
    int32_T iremain;
    int32_T itoken;
    int8_T fileid;
    ret->size[0] = 1;
    ret->size[1] = 0;
    fileid = FlightMissionMode_cfopen_g("config.ini", "rb");
    if (static_cast<int32_T>(fileid) < 0) {
        printf("INI-file \"%s\" was not found or could not be read.\n",
               "config.ini");
        fflush(stdout);
    } else {
        int32_T itoken_0;
        int32_T loop_ub;
        FlightMissionMode_emxInit_char_T_e(&data, 2);
        FlightMissionMode_emxInit_char_T_e(&j, 1);
        FlightMissionMode_fread_e(static_cast<real_T>(fileid), j);
        itoken_0 = static_cast<int32_T>(data->size[0] * data->size[1]);
        data->size[0] = 1;
        data->size[1] = j->size[0];
        FlightMissionMode_emxEnsureCapacity_char_T_g(data, itoken_0);
        loop_ub = j->size[0];
        for (itoken_0 = 0; itoken_0 <= static_cast<int32_T>(loop_ub - 1);
                itoken_0++) {
            data->data[itoken_0] = j->data[itoken_0];
        }

        FlightMissionMode_emxFree_char_T_o(&j);
        FlightMissionMode_emxInit_char_T_e(&curSection, 2);
        FlightMissionMode_emxInit_char_T_e(&curKey, 2);
        FlightMissionMode_emxInit_char_T_e(&curVal, 2);
        FlightMissionMode_cfclose_p(static_cast<real_T>(fileid));
        curSection->size[0] = 1;
        curSection->size[1] = 0;
        curKey->size[0] = 1;
        curKey->size[1] = 0;
        curVal->size[0] = 1;
        curVal->size[1] = 0;
        FlightMissionMode_emxInit_char_T_e(&curLine, 2);
        FlightMissionMode_emxInit_char_T_e(&aTmp, 2);
        FlightMissionMode_emxInit_char_T_e(&tmp, 2);
        FlightMissionMode_emxInit_char_T_e(&data_0, 2);
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (data->size[1] != 0) {
                boolean_T b_bool;
                itoken_0 = static_cast<int32_T>(data_0->size[0] * data_0->size[1]);
                data_0->size[0] = 1;
                data_0->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_g(data_0, itoken_0);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (itoken_0 = 0; itoken_0 <= loop_ub; itoken_0++) {
                    itoken = itoken_0;
                    data_0->data[itoken_0] = data->data[itoken_0];
                }

                FlightMissionMode_strtok_o5(data_0, curLine, data);
                FlightMissionMode_strtok_o5f(curLine, tmp);
                FlightMissionMode_strtrim_j(tmp, curLine);
                if (curLine->size[1] >= 2) {
                    boolean_T guard1{ false };

                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                iremain = 0;
                                itoken = 0;
                            } else {
                                iremain = 1;
                                itoken = static_cast<int32_T>(curLine->size[1] -
                                    1);
                            }

                            itoken_0 = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(itoken - iremain);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_g
                                (curSection, itoken_0);
                            for (itoken_0 = 0; itoken_0 <= static_cast<int32_T>
                                    (loop_ub - 1); itoken_0++) {
                                curSection->data[itoken_0] = curLine->data[
                                    static_cast<int32_T>(iremain + itoken_0)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains_k(curLine)) {
                            FlightMissionMode_strtok_o5ft(curLine, aTmp, curVal);
                            FlightMissionMode_find_token_a(curVal, &itoken,
                                &iremain);
                            if (itoken > static_cast<int32_T>(iremain - 1)) {
                                itoken = 0;
                                iremain = 0;
                            } else {
                                itoken = static_cast<int32_T>(itoken - 1);
                                iremain = static_cast<int32_T>(iremain - 1);
                            }

                            FlightMissionMode_strtrim_j(aTmp, curKey);
                            itoken_0 = static_cast<int32_T>(curLine->size[0] *
                                curLine->size[1]);
                            curLine->size[0] = 1;
                            loop_ub = static_cast<int32_T>(iremain - itoken);
                            curLine->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_g(curLine,
                                itoken_0);
                            for (itoken_0 = 0; itoken_0 <= static_cast<int32_T>
                                    (loop_ub - 1); itoken_0++) {
                                curLine->data[itoken_0] = curVal->data[
                                    static_cast<int32_T>(itoken + itoken_0)];
                            }

                            FlightMissionMode_strtrim_j(curLine, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp_n(curSection)) {
                    if (curKey->size[1] == 0) {
                        aTmp->size[0] = 1;
                        aTmp->size[1] = 0;
                    } else {
                        itoken_0 = static_cast<int32_T>(aTmp->size[0] *
                            aTmp->size[1]);
                        aTmp->size[0] = 1;
                        aTmp->size[1] = curKey->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_g(aTmp,
                            itoken_0);
                        loop_ub = static_cast<int32_T>(curKey->size[1] - 1);
                        for (itoken_0 = 0; itoken_0 <= loop_ub; itoken_0++) {
                            itoken = itoken_0;
                            aTmp->data[itoken_0] = curKey->data[itoken_0];
                        }
                    }

                    b_bool = false;
                    if (aTmp->size[1] == 14) {
                        iremain = 0;
                        int32_T exitg2;
                        do {
                            exitg2 = 0;
                            if (iremain < 14) {
                                if (h[static_cast<int32_T>(static_cast<int32_T>(
                                        static_cast<uint8_T>(aTmp->data[iremain]))
                                     & 127)] != h[static_cast<int32_T>(i[iremain])])
                                {
                                    exitg2 = 1;
                                } else {
                                    iremain = static_cast<int32_T>(iremain + 1);
                                }
                            } else {
                                b_bool = true;
                                exitg2 = 1;
                            }
                        } while (exitg2 == 0);
                    }

                    if (b_bool) {
                        itoken_0 = static_cast<int32_T>(ret->size[0] * ret->
                            size[1]);
                        ret->size[0] = 1;
                        ret->size[1] = curVal->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_g(ret,
                            itoken_0);
                        loop_ub = static_cast<int32_T>(curVal->size[1] - 1);
                        for (itoken_0 = 0; itoken_0 <= loop_ub; itoken_0++) {
                            ret->data[itoken_0] = curVal->data[itoken_0];
                        }

                        exitg1 = 1;
                    }
                }
            } else {
                exitg1 = 1;
            }
        } while (exitg1 == 0);

        FlightMissionMode_emxFree_char_T_o(&data_0);
        FlightMissionMode_emxFree_char_T_o(&tmp);
        FlightMissionMode_emxFree_char_T_o(&aTmp);
        FlightMissionMode_emxFree_char_T_o(&curLine);
        FlightMissionMode_emxFree_char_T_o(&curVal);
        FlightMissionMode_emxFree_char_T_o(&curKey);
        FlightMissionMode_emxFree_char_T_o(&curSection);
        FlightMissionMode_emxFree_char_T_o(&data);
    }
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_npg2(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[9]{ 'M', 'i', 'n', 'A', 'i', 'r', 'S', 'p', 'd' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_e(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_g(aTmp, i);
        loop_ub = static_cast<int32_T>(a->size[1] - 1);
        for (i = 0; i <= loop_ub; i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 9) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 9) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_o(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_npg2o(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[12]{ 'M', 'a', 'x', 'R', 'o', 'l', 'l', 'A', 'n', 'g',
        'l', 'e' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_e(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_g(aTmp, i);
        loop_ub = static_cast<int32_T>(a->size[1] - 1);
        for (i = 0; i <= loop_ub; i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 12) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 12) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_o(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
uavDubinsConnection_FlightMissionMode_T *FlightMissionMode::
    FlightMissionMode_uavDubinsConnection_uavDubinsConnection_o
    (uavDubinsConnection_FlightMissionMode_T *b_this, real_T varargin_2, real_T
     varargin_4, const real_T varargin_6[2])
{
    uavDubinsConnection_FlightMissionMode_T *c_this;
    real_T b_x;
    c_this = b_this;
    b_this->AirSpeed = 10.0;
    b_this->FlightPathAngleLimit[0] = varargin_6[0];
    b_this->FlightPathAngleLimit[1] = varargin_6[1];
    b_this->MaxRollAngle = varargin_4;
    b_x = b_this->MaxRollAngle;
    b_this->MinTurningRadius = b_this->AirSpeed * b_this->AirSpeed / (9.8 * std::
        tan(b_x));
    b_this->AirSpeed = varargin_2;
    b_x = b_this->MaxRollAngle;
    b_this->MinTurningRadius = b_this->AirSpeed * b_this->AirSpeed / (9.8 * std::
        tan(b_x));
    b_x = b_this->MaxRollAngle;
    b_this->MinTurningRadius = b_this->AirSpeed * b_this->AirSpeed / (9.8 * std::
        tan(b_x));
    return c_this;
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
uavDubinsConnection_FlightMissionMode_T *FlightMissionMode::
    FlightMissionMode_DubinsObjSingleton_getConnector_gb(void)
{
    emxArray_char_T_FlightMissionMode_T *b_remainder;
    emxArray_char_T_FlightMissionMode_T *curKey;
    emxArray_char_T_FlightMissionMode_T *curLine;
    emxArray_char_T_FlightMissionMode_T *curSection;
    emxArray_char_T_FlightMissionMode_T *curVal;
    emxArray_char_T_FlightMissionMode_T *data;
    emxArray_char_T_FlightMissionMode_T *data_0;
    emxArray_char_T_FlightMissionMode_T *data_1;
    emxArray_char_T_FlightMissionMode_T *data_2;
    emxArray_char_T_FlightMissionMode_T *data_3;
    emxArray_char_T_FlightMissionMode_T *k;
    emxArray_char_T_FlightMissionMode_T *ret;
    emxArray_char_T_FlightMissionMode_T *tmp_1;
    emxArray_char_T_FlightMissionMode_T *tmp_2;
    emxArray_char_T_FlightMissionMode_T *tmp_3;
    emxArray_char_T_FlightMissionMode_T *tmp_4;
    emxArray_char_T_FlightMissionMode_T *tmp_5;
    emxArray_char_T_FlightMissionMode_T *tmp_6;
    emxArray_char_T_FlightMissionMode_T *tmp_7;
    emxArray_char_T_FlightMissionMode_T *tmp_8;
    uavDubinsConnection_FlightMissionMode_T *outputArg;
    real_T tmp_9[2];
    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
            (FlightMissionMode_DW.SingletonInstance_not_empty) ^ 1))) {
        creal_T tmp;
        creal_T tmp_0;
        real_T ClimbAngleLimit;
        real_T DiveAngleLimit;
        real_T fid;
        int32_T b;
        int32_T b_0;
        int32_T c;
        int32_T loop_ub;
        boolean_T b_bool;
        boolean_T exitg1;
        boolean_T guard1{ false };

        FlightMissionMode_emxInit_char_T_e(&ret, 2);
        FlightMissionMode_DW.SingletonInstance.AirSpeed = 35.0;
        FlightMissionMode_DW.SingletonInstance.MaxRollAngle = 0.3490658503988659;
        FlightMissionMode_DW.SingletonInstance.FlightPathAngleLimit[0] = -0.175;
        FlightMissionMode_DW.SingletonInstance.FlightPathAngleLimit[1] = 0.175;
        ret->size[0] = 1;
        ret->size[1] = 0;
        fid = FlightMissionMode_fileManager_e();
        FlightMissionMode_emxInit_char_T_e(&data, 2);
        FlightMissionMode_emxInit_char_T_e(&curSection, 2);
        FlightMissionMode_emxInit_char_T_e(&curKey, 2);
        FlightMissionMode_emxInit_char_T_e(&curVal, 2);
        FlightMissionMode_emxInit_char_T_e(&curLine, 2);
        FlightMissionMode_emxInit_char_T_e(&b_remainder, 2);
        FlightMissionMode_emxInit_char_T_e(&k, 1);
        if (fid < 0.0) {
            printf("INI-file \"%s\" was not found or could not be read.\n",
                   "config.ini");
            fflush(stdout);
        } else {
            FlightMissionMode_fread_e(fid, k);
            b_0 = static_cast<int32_T>(data->size[0] * data->size[1]);
            data->size[0] = 1;
            data->size[1] = k->size[0];
            FlightMissionMode_emxEnsureCapacity_char_T_g(data, b_0);
            loop_ub = k->size[0];
            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                data->data[b] = k->data[b];
            }

            FlightMissionMode_cfclose_p(fid);
            curSection->size[0] = 1;
            curSection->size[1] = 0;
            curKey->size[0] = 1;
            curKey->size[1] = 0;
            curVal->size[0] = 1;
            curVal->size[1] = 0;
            FlightMissionMode_emxInit_char_T_e(&tmp_7, 2);
            FlightMissionMode_emxInit_char_T_e(&tmp_8, 2);
            FlightMissionMode_emxInit_char_T_e(&data_3, 2);
            exitg1 = false;
            while ((!exitg1) && (data->size[1] != 0)) {
                b_0 = static_cast<int32_T>(data_3->size[0] * data_3->size[1]);
                data_3->size[0] = 1;
                data_3->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_g(data_3, b_0);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (b_0 = 0; b_0 <= loop_ub; b_0++) {
                    data_3->data[b_0] = data->data[b_0];
                }

                FlightMissionMode_strtok_o5(data_3, curLine, data);
                FlightMissionMode_strtok_o5f(curLine, tmp_8);
                FlightMissionMode_strtrim_j(tmp_8, curLine);
                if (curLine->size[1] >= 2) {
                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                c = 0;
                                b = 0;
                            } else {
                                c = 1;
                                b = static_cast<int32_T>(curLine->size[1] - 1);
                            }

                            b_0 = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(b - c);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_g
                                (curSection, b_0);
                            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1);
                                    b++) {
                                curSection->data[b] = curLine->data[static_cast<
                                    int32_T>(c + b)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains_k(curLine)) {
                            FlightMissionMode_strtok_o5ft(curLine, curVal,
                                b_remainder);
                            FlightMissionMode_strtrim_j(curVal, curKey);
                            FlightMissionMode_strtok_o5ft5(b_remainder, tmp_7);
                            FlightMissionMode_strtrim_j(tmp_7, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp_n(curSection) &&
                        FlightMissionMode_strcmp_np(curKey)) {
                    b_0 = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                    ret->size[0] = 1;
                    ret->size[1] = curVal->size[1];
                    FlightMissionMode_emxEnsureCapacity_char_T_g(ret, b_0);
                    loop_ub = static_cast<int32_T>(curVal->size[1] - 1);
                    for (b = 0; b <= loop_ub; b++) {
                        ret->data[b] = curVal->data[b];
                    }

                    exitg1 = true;
                }
            }

            FlightMissionMode_emxFree_char_T_o(&data_3);
            FlightMissionMode_emxFree_char_T_o(&tmp_8);
            FlightMissionMode_emxFree_char_T_o(&tmp_7);
        }

        tmp = FlightMissionMode_str2double_a(ret);
        printf("Set UAV NormAirSpeed:\t\t%f\n", tmp.re);
        fflush(stdout);
        ret->size[0] = 1;
        ret->size[1] = 0;
        fid = FlightMissionMode_fileManager_e();
        if (fid < 0.0) {
            printf("INI-file \"%s\" was not found or could not be read.\n",
                   "config.ini");
            fflush(stdout);
        } else {
            FlightMissionMode_fread_e(fid, k);
            b_0 = static_cast<int32_T>(data->size[0] * data->size[1]);
            data->size[0] = 1;
            data->size[1] = k->size[0];
            FlightMissionMode_emxEnsureCapacity_char_T_g(data, b_0);
            loop_ub = k->size[0];
            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                data->data[b] = k->data[b];
            }

            FlightMissionMode_cfclose_p(fid);
            curSection->size[0] = 1;
            curSection->size[1] = 0;
            curKey->size[0] = 1;
            curKey->size[1] = 0;
            curVal->size[0] = 1;
            curVal->size[1] = 0;
            FlightMissionMode_emxInit_char_T_e(&tmp_5, 2);
            FlightMissionMode_emxInit_char_T_e(&tmp_6, 2);
            FlightMissionMode_emxInit_char_T_e(&data_2, 2);
            exitg1 = false;
            while ((!exitg1) && (data->size[1] != 0)) {
                b_0 = static_cast<int32_T>(data_2->size[0] * data_2->size[1]);
                data_2->size[0] = 1;
                data_2->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_g(data_2, b_0);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (b_0 = 0; b_0 <= loop_ub; b_0++) {
                    data_2->data[b_0] = data->data[b_0];
                }

                FlightMissionMode_strtok_o5(data_2, curLine, data);
                FlightMissionMode_strtok_o5f(curLine, tmp_6);
                FlightMissionMode_strtrim_j(tmp_6, curLine);
                if (curLine->size[1] >= 2) {
                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                c = 0;
                                b = 0;
                            } else {
                                c = 1;
                                b = static_cast<int32_T>(curLine->size[1] - 1);
                            }

                            b_0 = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(b - c);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_g
                                (curSection, b_0);
                            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1);
                                    b++) {
                                curSection->data[b] = curLine->data[static_cast<
                                    int32_T>(c + b)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains_k(curLine)) {
                            FlightMissionMode_strtok_o5ft(curLine, curVal,
                                b_remainder);
                            FlightMissionMode_strtrim_j(curVal, curKey);
                            FlightMissionMode_strtok_o5ft5(b_remainder, tmp_5);
                            FlightMissionMode_strtrim_j(tmp_5, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp_n(curSection) &&
                        FlightMissionMode_strcmp_npg(curKey)) {
                    b_0 = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                    ret->size[0] = 1;
                    ret->size[1] = curVal->size[1];
                    FlightMissionMode_emxEnsureCapacity_char_T_g(ret, b_0);
                    loop_ub = static_cast<int32_T>(curVal->size[1] - 1);
                    for (b = 0; b <= loop_ub; b++) {
                        ret->data[b] = curVal->data[b];
                    }

                    exitg1 = true;
                }
            }

            FlightMissionMode_emxFree_char_T_o(&data_2);
            FlightMissionMode_emxFree_char_T_o(&tmp_6);
            FlightMissionMode_emxFree_char_T_o(&tmp_5);
        }

        tmp_0 = FlightMissionMode_str2double_a(ret);
        printf("Set UAV MaxAirSpeed:\t\t%f\n", tmp_0.re);
        fflush(stdout);
        ret->size[0] = 1;
        ret->size[1] = 0;
        fid = FlightMissionMode_fileManager_e();
        if (fid < 0.0) {
            printf("INI-file \"%s\" was not found or could not be read.\n",
                   "config.ini");
            fflush(stdout);
        } else {
            FlightMissionMode_fread_e(fid, k);
            b_0 = static_cast<int32_T>(data->size[0] * data->size[1]);
            data->size[0] = 1;
            data->size[1] = k->size[0];
            FlightMissionMode_emxEnsureCapacity_char_T_g(data, b_0);
            loop_ub = k->size[0];
            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                data->data[b] = k->data[b];
            }

            FlightMissionMode_cfclose_p(fid);
            curSection->size[0] = 1;
            curSection->size[1] = 0;
            curKey->size[0] = 1;
            curKey->size[1] = 0;
            curVal->size[0] = 1;
            curVal->size[1] = 0;
            FlightMissionMode_emxInit_char_T_e(&tmp_3, 2);
            FlightMissionMode_emxInit_char_T_e(&tmp_4, 2);
            FlightMissionMode_emxInit_char_T_e(&data_1, 2);
            exitg1 = false;
            while ((!exitg1) && (data->size[1] != 0)) {
                b_0 = static_cast<int32_T>(data_1->size[0] * data_1->size[1]);
                data_1->size[0] = 1;
                data_1->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_g(data_1, b_0);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (b_0 = 0; b_0 <= loop_ub; b_0++) {
                    data_1->data[b_0] = data->data[b_0];
                }

                FlightMissionMode_strtok_o5(data_1, curLine, data);
                FlightMissionMode_strtok_o5f(curLine, tmp_4);
                FlightMissionMode_strtrim_j(tmp_4, curLine);
                if (curLine->size[1] >= 2) {
                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                c = 0;
                                b = 0;
                            } else {
                                c = 1;
                                b = static_cast<int32_T>(curLine->size[1] - 1);
                            }

                            b_0 = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(b - c);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_g
                                (curSection, b_0);
                            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1);
                                    b++) {
                                curSection->data[b] = curLine->data[static_cast<
                                    int32_T>(c + b)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains_k(curLine)) {
                            FlightMissionMode_strtok_o5ft(curLine, curVal,
                                b_remainder);
                            FlightMissionMode_strtrim_j(curVal, curKey);
                            FlightMissionMode_strtok_o5ft5(b_remainder, tmp_3);
                            FlightMissionMode_strtrim_j(tmp_3, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp_n(curSection) &&
                        FlightMissionMode_strcmp_npg2(curKey)) {
                    b_0 = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                    ret->size[0] = 1;
                    ret->size[1] = curVal->size[1];
                    FlightMissionMode_emxEnsureCapacity_char_T_g(ret, b_0);
                    loop_ub = static_cast<int32_T>(curVal->size[1] - 1);
                    for (b = 0; b <= loop_ub; b++) {
                        ret->data[b] = curVal->data[b];
                    }

                    exitg1 = true;
                }
            }

            FlightMissionMode_emxFree_char_T_o(&data_1);
            FlightMissionMode_emxFree_char_T_o(&tmp_4);
            FlightMissionMode_emxFree_char_T_o(&tmp_3);
        }

        tmp_0 = FlightMissionMode_str2double_a(ret);
        printf("Set UAV MinAirSpeed:\t\t%f\n", tmp_0.re);
        fflush(stdout);
        ret->size[0] = 1;
        ret->size[1] = 0;
        fid = FlightMissionMode_fileManager_e();
        if (fid < 0.0) {
            printf("INI-file \"%s\" was not found or could not be read.\n",
                   "config.ini");
            fflush(stdout);
        } else {
            FlightMissionMode_fread_e(fid, k);
            b_0 = static_cast<int32_T>(data->size[0] * data->size[1]);
            data->size[0] = 1;
            data->size[1] = k->size[0];
            FlightMissionMode_emxEnsureCapacity_char_T_g(data, b_0);
            loop_ub = k->size[0];
            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                data->data[b] = k->data[b];
            }

            FlightMissionMode_cfclose_p(fid);
            curSection->size[0] = 1;
            curSection->size[1] = 0;
            curKey->size[0] = 1;
            curKey->size[1] = 0;
            curVal->size[0] = 1;
            curVal->size[1] = 0;
            FlightMissionMode_emxInit_char_T_e(&tmp_1, 2);
            FlightMissionMode_emxInit_char_T_e(&tmp_2, 2);
            FlightMissionMode_emxInit_char_T_e(&data_0, 2);
            exitg1 = false;
            while ((!exitg1) && (data->size[1] != 0)) {
                b_0 = static_cast<int32_T>(data_0->size[0] * data_0->size[1]);
                data_0->size[0] = 1;
                data_0->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_g(data_0, b_0);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (b_0 = 0; b_0 <= loop_ub; b_0++) {
                    data_0->data[b_0] = data->data[b_0];
                }

                FlightMissionMode_strtok_o5(data_0, curLine, data);
                FlightMissionMode_strtok_o5f(curLine, tmp_2);
                FlightMissionMode_strtrim_j(tmp_2, curLine);
                if (curLine->size[1] >= 2) {
                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                c = 0;
                                b = 0;
                            } else {
                                c = 1;
                                b = static_cast<int32_T>(curLine->size[1] - 1);
                            }

                            b_0 = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(b - c);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_g
                                (curSection, b_0);
                            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1);
                                    b++) {
                                curSection->data[b] = curLine->data[static_cast<
                                    int32_T>(c + b)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains_k(curLine)) {
                            FlightMissionMode_strtok_o5ft(curLine, curVal,
                                b_remainder);
                            FlightMissionMode_strtrim_j(curVal, curKey);
                            FlightMissionMode_strtok_o5ft5(b_remainder, tmp_1);
                            FlightMissionMode_strtrim_j(tmp_1, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp_n(curSection) &&
                        FlightMissionMode_strcmp_npg2o(curKey)) {
                    b_0 = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                    ret->size[0] = 1;
                    ret->size[1] = curVal->size[1];
                    FlightMissionMode_emxEnsureCapacity_char_T_g(ret, b_0);
                    loop_ub = static_cast<int32_T>(curVal->size[1] - 1);
                    for (b = 0; b <= loop_ub; b++) {
                        ret->data[b] = curVal->data[b];
                    }

                    exitg1 = true;
                }
            }

            FlightMissionMode_emxFree_char_T_o(&data_0);
            FlightMissionMode_emxFree_char_T_o(&tmp_2);
            FlightMissionMode_emxFree_char_T_o(&tmp_1);
        }

        FlightMissionMode_emxFree_char_T_o(&k);
        FlightMissionMode_emxFree_char_T_o(&b_remainder);
        FlightMissionMode_emxFree_char_T_o(&curLine);
        FlightMissionMode_emxFree_char_T_o(&curVal);
        FlightMissionMode_emxFree_char_T_o(&curKey);
        FlightMissionMode_emxFree_char_T_o(&curSection);
        FlightMissionMode_emxFree_char_T_o(&data);
        tmp_0 = FlightMissionMode_str2double_a(ret);
        fid = 0.017453292519943295 * tmp_0.re;
        printf("Set UAV MaxRollAngle:\t\t%f\n", fid);
        fflush(stdout);
        FlightMissionMode_readINI_m(ret);
        tmp_0 = FlightMissionMode_str2double_a(ret);
        ClimbAngleLimit = 0.017453292519943295 * tmp_0.re;
        printf("Set UAV ClimbAngleLimit:\t%f\n", ClimbAngleLimit);
        fflush(stdout);
        FlightMissionMode_readINI_mk(ret);
        tmp_0 = FlightMissionMode_str2double_a(ret);
        DiveAngleLimit = 0.017453292519943295 * tmp_0.re;
        printf("Set UAV DiveAngleLimit:\t\t%f\n", DiveAngleLimit);
        fflush(stdout);
        FlightMissionMode_emxFree_char_T_o(&ret);
        if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(std::
                isnan(tmp.re)) ^ 1))) {
            FlightMissionMode_DW.SingletonInstance.AirSpeed = tmp.re;
        }

        if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(std::
                isnan(fid)) ^ 1))) {
            FlightMissionMode_DW.SingletonInstance.MaxRollAngle = fid;
        }

        if ((static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                (std::isnan(ClimbAngleLimit)) ^ 1))) && (static_cast<boolean_T>(
                static_cast<int32_T>(static_cast<int32_T>(std::isnan
                (DiveAngleLimit)) ^ 1)))) {
            FlightMissionMode_DW.SingletonInstance.FlightPathAngleLimit[0] =
                DiveAngleLimit;
            FlightMissionMode_DW.SingletonInstance.FlightPathAngleLimit[1] =
                ClimbAngleLimit;
        }

        for (b_0 = 0; b_0 < 2; b_0++) {
            tmp_9[b_0] =
                FlightMissionMode_DW.SingletonInstance.FlightPathAngleLimit[b_0];
        }

        FlightMissionMode_uavDubinsConnection_uavDubinsConnection_o
            (&FlightMissionMode_DW.SingletonInstance.Connector,
             FlightMissionMode_DW.SingletonInstance.AirSpeed,
             FlightMissionMode_DW.SingletonInstance.MaxRollAngle, tmp_9);
        FlightMissionMode_DW.SingletonInstance_not_empty = true;
    }

    outputArg = &FlightMissionMode_DW.SingletonInstance.Connector;
    return outputArg;
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_merge_b(int32_T idx_data[], int32_T
    x_data[], int32_T offset, int32_T np, int32_T nq, int32_T iwork_data[],
    int32_T xwork_data[])
{
    if (nq != 0) {
        int32_T iout;
        int32_T n;
        int32_T n_tmp;
        int32_T q;
        n_tmp = static_cast<int32_T>(np + nq);
        for (q = 0; q <= static_cast<int32_T>(n_tmp - 1); q =
                static_cast<int32_T>(q + 1)) {
            iout = static_cast<int32_T>(offset + q);
            iwork_data[q] = idx_data[iout];
            xwork_data[q] = x_data[iout];
        }

        n = 0;
        q = np;
        iout = static_cast<int32_T>(offset - 1);
        int32_T exitg1;
        do {
            exitg1 = 0;
            iout = static_cast<int32_T>(iout + 1);
            if (xwork_data[n] <= xwork_data[q]) {
                idx_data[iout] = iwork_data[n];
                x_data[iout] = xwork_data[n];
                if (static_cast<int32_T>(n + 1) < np) {
                    n = static_cast<int32_T>(n + 1);
                } else {
                    exitg1 = 1;
                }
            } else {
                idx_data[iout] = iwork_data[q];
                x_data[iout] = xwork_data[q];
                if (static_cast<int32_T>(q + 1) < n_tmp) {
                    q = static_cast<int32_T>(q + 1);
                } else {
                    q = static_cast<int32_T>(iout - n);
                    while (static_cast<int32_T>(n + 1) <= np) {
                        iout = static_cast<int32_T>(static_cast<int32_T>(q + n)
                            + 1);
                        idx_data[iout] = iwork_data[n];
                        x_data[iout] = xwork_data[n];
                        n = static_cast<int32_T>(n + 1);
                    }

                    exitg1 = 1;
                }
            }
        } while (exitg1 == 0);
    }
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_sort_c(int32_T x_data[], const int32_T
    *x_size, int32_T idx_data[], int32_T *idx_size)
{
    int32_T d_data[28];
    int32_T e_data[28];
    int32_T f_data[28];
    int32_T g_data[28];
    int32_T vwork_data[28];
    int32_T x4[4];
    int32_T b;
    int32_T c_k;
    int32_T d_size;
    int32_T dim;
    int32_T e_size;
    int32_T f_size;
    int32_T g_size;
    int32_T vstride;
    int32_T vwork_size_idx_0;
    int8_T idx4[4];
    int8_T perm[4];
    dim = 2;
    if (*x_size != 1) {
        dim = 1;
        b = static_cast<int32_T>(*x_size - 1);
    } else {
        b = 0;
    }

    vwork_size_idx_0 = static_cast<int32_T>(b + 1);
    *idx_size = *x_size;
    vstride = 1;
    c_k = 0;
    while (c_k <= static_cast<int32_T>(dim - 2)) {
        vstride = static_cast<int32_T>(vstride * *x_size);
        c_k = 1;
    }

    for (dim = 0; dim <= static_cast<int32_T>(vstride - 1); dim =
            static_cast<int32_T>(dim + 1)) {
        int32_T nQuartets;
        for (nQuartets = 0; nQuartets <= b; nQuartets = static_cast<int32_T>
                (nQuartets + 1)) {
            vwork_data[nQuartets] = x_data[static_cast<int32_T>
                (static_cast<int32_T>(nQuartets * vstride) + dim)];
        }

        e_size = vwork_size_idx_0;
        for (c_k = 0; c_k <= static_cast<int32_T>(vwork_size_idx_0 - 1); c_k++)
        {
            e_data[c_k] = vwork_data[c_k];
        }

        d_size = static_cast<int32_T>(static_cast<int8_T>(vwork_size_idx_0));
        nQuartets = static_cast<int32_T>(static_cast<int8_T>(vwork_size_idx_0));
        for (c_k = 0; c_k <= static_cast<int32_T>(nQuartets - 1); c_k++) {
            d_data[c_k] = 0;
        }

        if (vwork_size_idx_0 != 0) {
            int32_T nLeft;
            int32_T nQuartets_tmp;
            int32_T nTail;
            int32_T tailOffset;
            d_size = static_cast<int32_T>(static_cast<int8_T>(vwork_size_idx_0));
            nQuartets = static_cast<int32_T>(static_cast<int8_T>
                (vwork_size_idx_0));
            for (c_k = 0; c_k <= static_cast<int32_T>(nQuartets - 1); c_k++) {
                d_data[c_k] = 0;
            }

            x4[0] = 0;
            idx4[0] = 0;
            x4[1] = 0;
            idx4[1] = 0;
            x4[2] = 0;
            idx4[2] = 0;
            x4[3] = 0;
            idx4[3] = 0;
            f_size = static_cast<int32_T>(static_cast<int8_T>(vwork_size_idx_0));
            g_size = vwork_size_idx_0;
            nQuartets_tmp = static_cast<int32_T>(vwork_size_idx_0 >> 2);
            for (nLeft = 0; nLeft <= static_cast<int32_T>(nQuartets_tmp - 1);
                    nLeft = static_cast<int32_T>(nLeft + 1)) {
                int32_T i3;
                int32_T i4;
                int32_T tmp;
                tailOffset = static_cast<int32_T>(nLeft << 2);
                idx4[0] = static_cast<int8_T>(static_cast<int32_T>(tailOffset +
                    1));
                idx4[1] = static_cast<int8_T>(static_cast<int32_T>(tailOffset +
                    2));
                idx4[2] = static_cast<int8_T>(static_cast<int32_T>(tailOffset +
                    3));
                idx4[3] = static_cast<int8_T>(static_cast<int32_T>(tailOffset +
                    4));
                x4[0] = e_data[tailOffset];
                x4[1] = e_data[static_cast<int32_T>(tailOffset + 1)];
                x4[2] = e_data[static_cast<int32_T>(tailOffset + 2)];
                x4[3] = e_data[static_cast<int32_T>(tailOffset + 3)];
                if (e_data[tailOffset] <= e_data[static_cast<int32_T>(tailOffset
                     + 1)]) {
                    nTail = 1;
                    nQuartets = 2;
                } else {
                    nTail = 2;
                    nQuartets = 1;
                }

                if (e_data[static_cast<int32_T>(tailOffset + 2)] <= e_data[
                        static_cast<int32_T>(tailOffset + 3)]) {
                    i3 = 3;
                    i4 = 4;
                } else {
                    i3 = 4;
                    i4 = 3;
                }

                c_k = x4[static_cast<int32_T>(nTail - 1)];
                tmp = x4[static_cast<int32_T>(i3 - 1)];
                if (c_k <= tmp) {
                    c_k = x4[static_cast<int32_T>(nQuartets - 1)];
                    if (c_k <= tmp) {
                        perm[0] = static_cast<int8_T>(nTail);
                        perm[1] = static_cast<int8_T>(nQuartets);
                        perm[2] = static_cast<int8_T>(i3);
                        perm[3] = static_cast<int8_T>(i4);
                    } else if (c_k <= x4[static_cast<int32_T>(i4 - 1)]) {
                        perm[0] = static_cast<int8_T>(nTail);
                        perm[1] = static_cast<int8_T>(i3);
                        perm[2] = static_cast<int8_T>(nQuartets);
                        perm[3] = static_cast<int8_T>(i4);
                    } else {
                        perm[0] = static_cast<int8_T>(nTail);
                        perm[1] = static_cast<int8_T>(i3);
                        perm[2] = static_cast<int8_T>(i4);
                        perm[3] = static_cast<int8_T>(nQuartets);
                    }
                } else {
                    tmp = x4[static_cast<int32_T>(i4 - 1)];
                    if (c_k <= tmp) {
                        if (x4[static_cast<int32_T>(nQuartets - 1)] <= tmp) {
                            perm[0] = static_cast<int8_T>(i3);
                            perm[1] = static_cast<int8_T>(nTail);
                            perm[2] = static_cast<int8_T>(nQuartets);
                            perm[3] = static_cast<int8_T>(i4);
                        } else {
                            perm[0] = static_cast<int8_T>(i3);
                            perm[1] = static_cast<int8_T>(nTail);
                            perm[2] = static_cast<int8_T>(i4);
                            perm[3] = static_cast<int8_T>(nQuartets);
                        }
                    } else {
                        perm[0] = static_cast<int8_T>(i3);
                        perm[1] = static_cast<int8_T>(i4);
                        perm[2] = static_cast<int8_T>(nTail);
                        perm[3] = static_cast<int8_T>(nQuartets);
                    }
                }

                d_data[tailOffset] = static_cast<int32_T>(idx4
                    [static_cast<int32_T>(static_cast<int32_T>(perm[0]) - 1)]);
                d_data[static_cast<int32_T>(tailOffset + 1)] =
                    static_cast<int32_T>(idx4[static_cast<int32_T>
                    (static_cast<int32_T>(perm[1]) - 1)]);
                d_data[static_cast<int32_T>(tailOffset + 2)] =
                    static_cast<int32_T>(idx4[static_cast<int32_T>
                    (static_cast<int32_T>(perm[2]) - 1)]);
                d_data[static_cast<int32_T>(tailOffset + 3)] =
                    static_cast<int32_T>(idx4[static_cast<int32_T>
                    (static_cast<int32_T>(perm[3]) - 1)]);
                e_data[tailOffset] = x4[static_cast<int32_T>(static_cast<int32_T>
                    (perm[0]) - 1)];
                e_data[static_cast<int32_T>(tailOffset + 1)] = x4
                    [static_cast<int32_T>(static_cast<int32_T>(perm[1]) - 1)];
                e_data[static_cast<int32_T>(tailOffset + 2)] = x4
                    [static_cast<int32_T>(static_cast<int32_T>(perm[2]) - 1)];
                e_data[static_cast<int32_T>(tailOffset + 3)] = x4
                    [static_cast<int32_T>(static_cast<int32_T>(perm[3]) - 1)];
            }

            nQuartets = static_cast<int32_T>(nQuartets_tmp << 2);
            nLeft = static_cast<int32_T>(vwork_size_idx_0 - nQuartets);
            if (nLeft > 0) {
                for (tailOffset = 0; tailOffset <= static_cast<int32_T>(nLeft -
                        1); tailOffset = static_cast<int32_T>(tailOffset + 1)) {
                    c_k = static_cast<int32_T>(nQuartets + tailOffset);
                    idx4[tailOffset] = static_cast<int8_T>(static_cast<int32_T>
                        (c_k + 1));
                    x4[tailOffset] = e_data[c_k];
                }

                perm[1] = 0;
                perm[2] = 0;
                perm[3] = 0;
                switch (nLeft) {
                  case 1:
                    perm[0] = 1;
                    break;

                  case 2:
                    if (x4[0] <= x4[1]) {
                        perm[0] = 1;
                        perm[1] = 2;
                    } else {
                        perm[0] = 2;
                        perm[1] = 1;
                    }
                    break;

                  default:
                    if (x4[0] <= x4[1]) {
                        if (x4[1] <= x4[2]) {
                            perm[0] = 1;
                            perm[1] = 2;
                            perm[2] = 3;
                        } else if (x4[0] <= x4[2]) {
                            perm[0] = 1;
                            perm[1] = 3;
                            perm[2] = 2;
                        } else {
                            perm[0] = 3;
                            perm[1] = 1;
                            perm[2] = 2;
                        }
                    } else if (x4[0] <= x4[2]) {
                        perm[0] = 2;
                        perm[1] = 1;
                        perm[2] = 3;
                    } else if (x4[1] <= x4[2]) {
                        perm[0] = 2;
                        perm[1] = 3;
                        perm[2] = 1;
                    } else {
                        perm[0] = 3;
                        perm[1] = 2;
                        perm[2] = 1;
                    }
                    break;
                }

                for (tailOffset = 0; tailOffset <= static_cast<int32_T>(nLeft -
                        1); tailOffset = static_cast<int32_T>(tailOffset + 1)) {
                    c_k = static_cast<int32_T>(static_cast<int32_T>
                        (perm[tailOffset]) - 1);
                    nTail = static_cast<int32_T>(nQuartets + tailOffset);
                    d_data[nTail] = static_cast<int32_T>(idx4[c_k]);
                    e_data[nTail] = x4[c_k];
                }
            }

            if (vwork_size_idx_0 > 1) {
                nQuartets = f_size;
                f_size = nQuartets;
                for (c_k = 0; c_k <= static_cast<int32_T>(nQuartets - 1); c_k++)
                {
                    f_data[c_k] = 0;
                }

                nQuartets = g_size;
                g_size = nQuartets;
                for (c_k = 0; c_k <= static_cast<int32_T>(nQuartets - 1); c_k++)
                {
                    g_data[c_k] = 0;
                }

                nLeft = nQuartets_tmp;
                nQuartets = 4;
                while (nLeft > 1) {
                    if (static_cast<uint32_T>(static_cast<uint32_T>(nLeft) & 1U)
                        != 0U) {
                        nLeft = static_cast<int32_T>(nLeft - 1);
                        tailOffset = static_cast<int32_T>(nQuartets * nLeft);
                        nTail = static_cast<int32_T>(vwork_size_idx_0 -
                            tailOffset);
                        if (nTail > nQuartets) {
                            FlightMissionMode_merge_b(d_data, e_data, tailOffset,
                                nQuartets, static_cast<int32_T>(nTail -
                                nQuartets), f_data, g_data);
                        }
                    }

                    tailOffset = static_cast<int32_T>(nQuartets << 1);
                    nLeft = static_cast<int32_T>(nLeft >> 1);
                    for (nTail = 0; nTail <= static_cast<int32_T>(nLeft - 1);
                            nTail = static_cast<int32_T>(nTail + 1)) {
                        FlightMissionMode_merge_b(d_data, e_data,
                            static_cast<int32_T>(nTail * tailOffset), nQuartets,
                            nQuartets, f_data, g_data);
                    }

                    nQuartets = tailOffset;
                }

                if (vwork_size_idx_0 > nQuartets) {
                    FlightMissionMode_merge_b(d_data, e_data, 0, nQuartets,
                        static_cast<int32_T>(vwork_size_idx_0 - nQuartets),
                        f_data, g_data);
                }
            }
        }

        vwork_size_idx_0 = e_size;
        nQuartets = e_size;
        for (c_k = 0; c_k <= static_cast<int32_T>(nQuartets - 1); c_k++) {
            vwork_data[c_k] = e_data[c_k];
        }

        for (nQuartets = 0; nQuartets <= b; nQuartets = static_cast<int32_T>
                (nQuartets + 1)) {
            c_k = static_cast<int32_T>(static_cast<int32_T>(nQuartets * vstride)
                + dim);
            x_data[c_k] = e_data[nQuartets];
            idx_data[c_k] = d_data[nQuartets];
        }
    }
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_do_vectors_m(real_T c_data[], int32_T
    c_size[2], int32_T ia_data[], int32_T *ia_size, int32_T *ib_size)
{
    static const real_T f[28]{ 6.384265086E+9, 6.384265284E+9, 6.384480708E+9,
        6.384480906E+9, 6.384473283E+9, 6.384263997E+9, 2.1067690282E+11,
        2.10676902826E+11, 2.10677124976E+11, 2.10677124982E+11,
        2.10677124751E+11, 2.10676902787E+11, 2.10680747748E+11,
        2.10680754288E+11, 2.10687863274E+11, 2.10687869814E+11,
        2.10687618255E+11, 2.10680711811E+11, 6.384264226E+9, 6.384264232E+9,
        6.384264001E+9, 6.38447332E+9, 6.384473281E+9, 6.384473314E+9,
        6.384265282E+9, 6.384480904E+9, 6.38426509E+9, 6.384480712E+9 };

    static const int8_T e[28]{ 6, 21, 19, 20, 1, 27, 25, 2, 23, 5, 24, 22, 3, 28,
        26, 4, 12, 7, 8, 11, 9, 10, 18, 13, 14, 17, 15, 16 };

    emxArray_int32_T_28_FlightMissionMode_T ia_data_0;
    int32_T iafirst;
    int32_T ialast;
    int32_T nc;
    int32_T nia;
    c_size[0] = 1;
    *ib_size = 0;
    nc = 0;
    nia = -1;
    iafirst = 0;
    ialast = 1;
    while (ialast <= 28) {
        int32_T b_ialast;
        b_ialast = ialast;
        while ((b_ialast < 28) && (f[static_cast<int32_T>(static_cast<int32_T>
                 (e[static_cast<int32_T>(ialast - 1)]) - 1)] == f
                                   [static_cast<int32_T>(static_cast<int32_T>
                 (e[b_ialast]) - 1)])) {
            b_ialast = static_cast<int32_T>(b_ialast + 1);
        }

        nc = static_cast<int32_T>(nc + 1);
        nia = static_cast<int32_T>(nia + 1);
        ia_data[nia] = static_cast<int32_T>(e[iafirst]);
        ialast = static_cast<int32_T>(b_ialast + 1);
        iafirst = b_ialast;
    }

    if (static_cast<int32_T>(nia + 1) < 1) {
        iafirst = -1;
    } else {
        iafirst = nia;
    }

    *ia_size = static_cast<int32_T>(iafirst + 1);
    FlightMissionMode_sort_c(ia_data, ia_size, ia_data_0.data, &ia_data_0.size);
    for (iafirst = 0; iafirst <= nia; iafirst = static_cast<int32_T>(iafirst + 1))
    {
        c_data[iafirst] = f[static_cast<int32_T>(ia_data[iafirst] - 1)];
    }

    if (nc < 1) {
        c_size[1] = 0;
    } else {
        c_size[1] = nc;
    }
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_do_vectors_mj(const real_T b_data[],
    const int32_T *b_size, real_T c_data[], int32_T c_size[2], int32_T ia_data[],
    int32_T *ia_size, int32_T *ib_size)
{
    emxArray_int32_T_28_FlightMissionMode_T ia_data_0;
    real_T bk;
    int32_T bperm_data[28];
    int32_T iwork_data[28];
    int32_T b_p;
    int32_T i;
    int32_T i2;
    int32_T j;
    int32_T kEnd;
    int32_T n;
    int32_T pEnd;
    int32_T qEnd;
    c_size[0] = 1;
    *ib_size = 0;
    i = static_cast<int32_T>(static_cast<int8_T>(*b_size));
    for (n = 0; n <= static_cast<int32_T>(i - 1); n++) {
        bperm_data[n] = 0;
    }

    if (*b_size != 0) {
        for (i = 1; i <= static_cast<int32_T>(static_cast<int32_T>(*b_size + 1)
                - 2); i = static_cast<int32_T>(i + 2)) {
            if (static_cast<boolean_T>(static_cast<int32_T>((b_data[static_cast<
                    int32_T>(i - 1)] <= b_data[i]) | static_cast<int32_T>(std::
                    isnan(b_data[i]))))) {
                bperm_data[static_cast<int32_T>(i - 1)] = i;
                bperm_data[i] = static_cast<int32_T>(i + 1);
            } else {
                bperm_data[static_cast<int32_T>(i - 1)] = static_cast<int32_T>(i
                    + 1);
                bperm_data[i] = i;
            }
        }

        if (static_cast<uint32_T>(static_cast<uint32_T>(*b_size) & 1U) != 0U) {
            bperm_data[static_cast<int32_T>(*b_size - 1)] = *b_size;
        }

        i = 2;
        while (i < static_cast<int32_T>(static_cast<int32_T>(*b_size + 1) - 1))
        {
            i2 = static_cast<int32_T>(i << 1);
            j = 1;
            pEnd = static_cast<int32_T>(i + 1);
            while (pEnd < static_cast<int32_T>(*b_size + 1)) {
                int32_T c_k;
                int32_T q;
                b_p = j;
                q = static_cast<int32_T>(pEnd - 1);
                qEnd = static_cast<int32_T>(j + i2);
                if (qEnd > static_cast<int32_T>(*b_size + 1)) {
                    qEnd = static_cast<int32_T>(*b_size + 1);
                }

                c_k = 0;
                kEnd = static_cast<int32_T>(qEnd - j);
                while (static_cast<int32_T>(c_k + 1) <= kEnd) {
                    bk = b_data[static_cast<int32_T>(bperm_data[q] - 1)];
                    n = bperm_data[static_cast<int32_T>(b_p - 1)];
                    if (static_cast<boolean_T>(static_cast<int32_T>((b_data[
                            static_cast<int32_T>(n - 1)] <= bk) |
                            static_cast<int32_T>(std::isnan(bk))))) {
                        iwork_data[c_k] = n;
                        b_p = static_cast<int32_T>(b_p + 1);
                        if (b_p == pEnd) {
                            while (static_cast<int32_T>(q + 1) < qEnd) {
                                c_k = static_cast<int32_T>(c_k + 1);
                                iwork_data[c_k] = bperm_data[q];
                                q = static_cast<int32_T>(q + 1);
                            }
                        }
                    } else {
                        iwork_data[c_k] = bperm_data[q];
                        q = static_cast<int32_T>(q + 1);
                        if (static_cast<int32_T>(q + 1) == qEnd) {
                            while (b_p < pEnd) {
                                c_k = static_cast<int32_T>(c_k + 1);
                                iwork_data[c_k] = bperm_data[static_cast<int32_T>
                                    (b_p - 1)];
                                b_p = static_cast<int32_T>(b_p + 1);
                            }
                        }
                    }

                    c_k = static_cast<int32_T>(c_k + 1);
                }

                for (pEnd = 0; pEnd <= static_cast<int32_T>(kEnd - 1); pEnd =
                        static_cast<int32_T>(pEnd + 1)) {
                    bperm_data[static_cast<int32_T>(static_cast<int32_T>(j +
                        pEnd) - 1)] = iwork_data[pEnd];
                }

                j = qEnd;
                pEnd = static_cast<int32_T>(qEnd + i);
            }

            i = i2;
        }
    }

    n = 0;
    i = -1;
    i2 = 0;
    j = 1;
    qEnd = 1;
    while ((j <= 28) && (qEnd <= *b_size)) {
        kEnd = j;
        pEnd = j;
        while (static_cast<boolean_T>(static_cast<int32_T>((static_cast<int32_T>
                  (kEnd + 1) == j) & (kEnd < 28)))) {
            kEnd = static_cast<int32_T>(kEnd + 1);
        }

        j = kEnd;
        b_p = qEnd;
        bk = b_data[static_cast<int32_T>(bperm_data[static_cast<int32_T>(qEnd -
            1)] - 1)];
        while ((b_p < *b_size) && (b_data[static_cast<int32_T>(bperm_data[b_p] -
                 1)] == bk)) {
            b_p = static_cast<int32_T>(b_p + 1);
        }

        qEnd = b_p;
        if (static_cast<real_T>(pEnd) == bk) {
            j = static_cast<int32_T>(kEnd + 1);
            i2 = kEnd;
            qEnd = static_cast<int32_T>(b_p + 1);
        } else if (static_cast<boolean_T>(static_cast<int32_T>
                    ((static_cast<real_T>(pEnd) < bk) | static_cast<int32_T>(std::
                      isnan(bk))))) {
            n = static_cast<int32_T>(n + 1);
            i = static_cast<int32_T>(i + 1);
            ia_data[i] = static_cast<int32_T>(i2 + 1);
            j = static_cast<int32_T>(kEnd + 1);
            i2 = kEnd;
        } else {
            qEnd = static_cast<int32_T>(b_p + 1);
        }
    }

    while (j <= 28) {
        qEnd = j;
        while (static_cast<boolean_T>(static_cast<int32_T>((static_cast<int32_T>
                  (qEnd + 1) == j) & (qEnd < 28)))) {
            qEnd = static_cast<int32_T>(qEnd + 1);
        }

        n = static_cast<int32_T>(n + 1);
        i = static_cast<int32_T>(i + 1);
        ia_data[i] = static_cast<int32_T>(i2 + 1);
        j = static_cast<int32_T>(qEnd + 1);
        i2 = qEnd;
    }

    if (static_cast<int32_T>(i + 1) < 1) {
        i2 = -1;
    } else {
        i2 = i;
    }

    *ia_size = static_cast<int32_T>(i2 + 1);
    FlightMissionMode_sort_c(ia_data, ia_size, ia_data_0.data, &ia_data_0.size);
    for (i2 = 0; i2 <= i; i2 = static_cast<int32_T>(i2 + 1)) {
        c_data[i2] = static_cast<real_T>(static_cast<int32_T>(ia_data[i2] - 1))
            + 1.0;
    }

    if (n < 1) {
        c_size[1] = 0;
    } else {
        c_size[1] = n;
    }
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_merge_b3(int32_T idx_data[], real_T
    x_data[], int32_T offset, int32_T np, int32_T nq, int32_T iwork_data[],
    real_T xwork_data[])
{
    if (nq != 0) {
        int32_T iout;
        int32_T n;
        int32_T n_tmp;
        int32_T q;
        n_tmp = static_cast<int32_T>(np + nq);
        for (q = 0; q <= static_cast<int32_T>(n_tmp - 1); q =
                static_cast<int32_T>(q + 1)) {
            iout = static_cast<int32_T>(offset + q);
            iwork_data[q] = idx_data[iout];
            xwork_data[q] = x_data[iout];
        }

        n = 0;
        q = np;
        iout = static_cast<int32_T>(offset - 1);
        int32_T exitg1;
        do {
            exitg1 = 0;
            iout = static_cast<int32_T>(iout + 1);
            if (xwork_data[n] <= xwork_data[q]) {
                idx_data[iout] = iwork_data[n];
                x_data[iout] = xwork_data[n];
                if (static_cast<int32_T>(n + 1) < np) {
                    n = static_cast<int32_T>(n + 1);
                } else {
                    exitg1 = 1;
                }
            } else {
                idx_data[iout] = iwork_data[q];
                x_data[iout] = xwork_data[q];
                if (static_cast<int32_T>(q + 1) < n_tmp) {
                    q = static_cast<int32_T>(q + 1);
                } else {
                    q = static_cast<int32_T>(iout - n);
                    while (static_cast<int32_T>(n + 1) <= np) {
                        iout = static_cast<int32_T>(static_cast<int32_T>(q + n)
                            + 1);
                        idx_data[iout] = iwork_data[n];
                        x_data[iout] = xwork_data[n];
                        n = static_cast<int32_T>(n + 1);
                    }

                    exitg1 = 1;
                }
            }
        } while (exitg1 == 0);
    }
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_sort_c5(real_T x_data[], const int32_T
    *x_size)
{
    real_T e_data[28];
    real_T g_data[28];
    real_T vwork_data[28];
    real_T x4[4];
    int32_T d_data[28];
    int32_T f_data[28];
    int32_T b;
    int32_T d_size;
    int32_T dim;
    int32_T e_size;
    int32_T f_size;
    int32_T g_size;
    int32_T n;
    int32_T vstride;
    int32_T vwork_size_idx_0;
    int8_T idx4[4];
    int8_T perm[4];
    dim = 2;
    if (*x_size != 1) {
        dim = 1;
        b = static_cast<int32_T>(*x_size - 1);
    } else {
        b = 0;
    }

    vwork_size_idx_0 = static_cast<int32_T>(b + 1);
    vstride = 1;
    n = 0;
    while (n <= static_cast<int32_T>(dim - 2)) {
        vstride = static_cast<int32_T>(vstride * *x_size);
        n = 1;
    }

    for (dim = 0; dim <= static_cast<int32_T>(vstride - 1); dim =
            static_cast<int32_T>(dim + 1)) {
        int32_T bLen;
        for (n = 0; n <= b; n = static_cast<int32_T>(n + 1)) {
            vwork_data[n] = x_data[static_cast<int32_T>(static_cast<int32_T>(n *
                vstride) + dim)];
        }

        e_size = vwork_size_idx_0;
        for (bLen = 0; bLen <= static_cast<int32_T>(vwork_size_idx_0 - 1); bLen
                ++) {
            e_data[bLen] = vwork_data[bLen];
        }

        if (vwork_size_idx_0 != 0) {
            int32_T i3;
            int32_T i4;
            int32_T itmp;
            int32_T nTail;
            int32_T wOffset;
            int32_T wOffset_tmp;
            d_size = static_cast<int32_T>(static_cast<int8_T>(vwork_size_idx_0));
            n = static_cast<int32_T>(static_cast<int8_T>(vwork_size_idx_0));
            for (bLen = 0; bLen <= static_cast<int32_T>(n - 1); bLen++) {
                d_data[bLen] = 0;
            }

            x4[0] = 0.0;
            idx4[0] = 0;
            x4[1] = 0.0;
            idx4[1] = 0;
            x4[2] = 0.0;
            idx4[2] = 0;
            x4[3] = 0.0;
            idx4[3] = 0;
            f_size = static_cast<int32_T>(static_cast<int8_T>(vwork_size_idx_0));
            g_size = vwork_size_idx_0;
            n = g_size;
            g_size = n;
            for (bLen = 0; bLen <= static_cast<int32_T>(n - 1); bLen++) {
                g_data[bLen] = 0.0;
            }

            bLen = 1;
            n = 0;
            for (wOffset = 0; wOffset <= static_cast<int32_T>(vwork_size_idx_0 -
                  1); wOffset = static_cast<int32_T>(wOffset + 1)) {
                if (std::isnan(e_data[wOffset])) {
                    i3 = static_cast<int32_T>(vwork_size_idx_0 - bLen);
                    d_data[i3] = static_cast<int32_T>(wOffset + 1);
                    g_data[i3] = e_data[wOffset];
                    bLen = static_cast<int32_T>(bLen + 1);
                } else {
                    n = static_cast<int32_T>(n + 1);
                    idx4[static_cast<int32_T>(n - 1)] = static_cast<int8_T>(
                        static_cast<int32_T>(wOffset + 1));
                    x4[static_cast<int32_T>(n - 1)] = e_data[wOffset];
                    if (n == 4) {
                        real_T tmp;
                        real_T tmp_0;
                        n = static_cast<int32_T>(wOffset - bLen);
                        if (x4[0] <= x4[1]) {
                            nTail = 1;
                            itmp = 2;
                        } else {
                            nTail = 2;
                            itmp = 1;
                        }

                        if (x4[2] <= x4[3]) {
                            i3 = 3;
                            i4 = 4;
                        } else {
                            i3 = 4;
                            i4 = 3;
                        }

                        tmp = x4[static_cast<int32_T>(nTail - 1)];
                        tmp_0 = x4[static_cast<int32_T>(i3 - 1)];
                        if (tmp <= tmp_0) {
                            tmp = x4[static_cast<int32_T>(itmp - 1)];
                            if (tmp <= tmp_0) {
                                perm[0] = static_cast<int8_T>(nTail);
                                perm[1] = static_cast<int8_T>(itmp);
                                perm[2] = static_cast<int8_T>(i3);
                                perm[3] = static_cast<int8_T>(i4);
                            } else if (tmp <= x4[static_cast<int32_T>(i4 - 1)])
                            {
                                perm[0] = static_cast<int8_T>(nTail);
                                perm[1] = static_cast<int8_T>(i3);
                                perm[2] = static_cast<int8_T>(itmp);
                                perm[3] = static_cast<int8_T>(i4);
                            } else {
                                perm[0] = static_cast<int8_T>(nTail);
                                perm[1] = static_cast<int8_T>(i3);
                                perm[2] = static_cast<int8_T>(i4);
                                perm[3] = static_cast<int8_T>(itmp);
                            }
                        } else {
                            tmp_0 = x4[static_cast<int32_T>(i4 - 1)];
                            if (tmp <= tmp_0) {
                                if (x4[static_cast<int32_T>(itmp - 1)] <= tmp_0)
                                {
                                    perm[0] = static_cast<int8_T>(i3);
                                    perm[1] = static_cast<int8_T>(nTail);
                                    perm[2] = static_cast<int8_T>(itmp);
                                    perm[3] = static_cast<int8_T>(i4);
                                } else {
                                    perm[0] = static_cast<int8_T>(i3);
                                    perm[1] = static_cast<int8_T>(nTail);
                                    perm[2] = static_cast<int8_T>(i4);
                                    perm[3] = static_cast<int8_T>(itmp);
                                }
                            } else {
                                perm[0] = static_cast<int8_T>(i3);
                                perm[1] = static_cast<int8_T>(i4);
                                perm[2] = static_cast<int8_T>(nTail);
                                perm[3] = static_cast<int8_T>(itmp);
                            }
                        }

                        d_data[static_cast<int32_T>(n - 2)] = static_cast<
                            int32_T>(idx4[static_cast<int32_T>
                                     (static_cast<int32_T>(perm[0]) - 1)]);
                        d_data[static_cast<int32_T>(n - 1)] =
                            static_cast<int32_T>(idx4[static_cast<int32_T>(
                            static_cast<int32_T>(perm[1]) - 1)]);
                        d_data[n] = static_cast<int32_T>(idx4
                            [static_cast<int32_T>(static_cast<int32_T>(perm[2])
                            - 1)]);
                        d_data[static_cast<int32_T>(n + 1)] =
                            static_cast<int32_T>(idx4[static_cast<int32_T>(
                            static_cast<int32_T>(perm[3]) - 1)]);
                        e_data[static_cast<int32_T>(n - 2)] = x4
                            [static_cast<int32_T>(static_cast<int32_T>(perm[0])
                            - 1)];
                        e_data[static_cast<int32_T>(n - 1)] = x4
                            [static_cast<int32_T>(static_cast<int32_T>(perm[1])
                            - 1)];
                        e_data[n] = x4[static_cast<int32_T>(static_cast<int32_T>
                            (perm[2]) - 1)];
                        e_data[static_cast<int32_T>(n + 1)] = x4
                            [static_cast<int32_T>(static_cast<int32_T>(perm[3])
                            - 1)];
                        n = 0;
                    }
                }
            }

            wOffset_tmp = static_cast<int32_T>(vwork_size_idx_0 - bLen);
            if (n > 0) {
                perm[1] = 0;
                perm[2] = 0;
                perm[3] = 0;
                switch (n) {
                  case 1:
                    perm[0] = 1;
                    break;

                  case 2:
                    if (x4[0] <= x4[1]) {
                        perm[0] = 1;
                        perm[1] = 2;
                    } else {
                        perm[0] = 2;
                        perm[1] = 1;
                    }
                    break;

                  default:
                    if (x4[0] <= x4[1]) {
                        if (x4[1] <= x4[2]) {
                            perm[0] = 1;
                            perm[1] = 2;
                            perm[2] = 3;
                        } else if (x4[0] <= x4[2]) {
                            perm[0] = 1;
                            perm[1] = 3;
                            perm[2] = 2;
                        } else {
                            perm[0] = 3;
                            perm[1] = 1;
                            perm[2] = 2;
                        }
                    } else if (x4[0] <= x4[2]) {
                        perm[0] = 2;
                        perm[1] = 1;
                        perm[2] = 3;
                    } else if (x4[1] <= x4[2]) {
                        perm[0] = 2;
                        perm[1] = 3;
                        perm[2] = 1;
                    } else {
                        perm[0] = 3;
                        perm[1] = 2;
                        perm[2] = 1;
                    }
                    break;
                }

                for (nTail = 0; nTail <= static_cast<int32_T>(n - 1); nTail =
                        static_cast<int32_T>(nTail + 1)) {
                    i3 = static_cast<int32_T>(static_cast<int32_T>(perm[nTail])
                        - 1);
                    itmp = static_cast<int32_T>(static_cast<int32_T>(
                        static_cast<int32_T>(wOffset_tmp - n) + nTail) + 1);
                    d_data[itmp] = static_cast<int32_T>(idx4[i3]);
                    e_data[itmp] = x4[i3];
                }
            }

            n = static_cast<int32_T>(static_cast<int32_T>(static_cast<int32_T>
                (bLen - 1) >> 1) + 1);
            for (nTail = 1; static_cast<int32_T>(nTail - 1) <=
                    static_cast<int32_T>(n - 2); nTail = static_cast<int32_T>
                    (nTail + 1)) {
                i4 = static_cast<int32_T>(wOffset_tmp + nTail);
                itmp = d_data[i4];
                wOffset = static_cast<int32_T>(vwork_size_idx_0 - nTail);
                d_data[i4] = d_data[wOffset];
                d_data[wOffset] = itmp;
                e_data[i4] = g_data[wOffset];
                e_data[wOffset] = g_data[i4];
            }

            if (static_cast<uint32_T>(static_cast<uint32_T>(static_cast<int32_T>
                    (bLen - 1)) & 1U) != 0U) {
                n = static_cast<int32_T>(wOffset_tmp + n);
                e_data[n] = g_data[n];
            }

            if (static_cast<int32_T>(wOffset_tmp + 1) > 1) {
                n = f_size;
                f_size = n;
                for (bLen = 0; bLen <= static_cast<int32_T>(n - 1); bLen++) {
                    f_data[bLen] = 0;
                }

                wOffset = static_cast<int32_T>(static_cast<int32_T>(wOffset_tmp
                    + 1) >> 2);
                bLen = 4;
                while (wOffset > 1) {
                    if (static_cast<uint32_T>(static_cast<uint32_T>(wOffset) &
                                              1U) != 0U) {
                        wOffset = static_cast<int32_T>(wOffset - 1);
                        n = static_cast<int32_T>(bLen * wOffset);
                        nTail = static_cast<int32_T>(static_cast<int32_T>
                            (wOffset_tmp - n) + 1);
                        if (nTail > bLen) {
                            FlightMissionMode_merge_b3(d_data, e_data, n, bLen,
                                static_cast<int32_T>(nTail - bLen), f_data,
                                g_data);
                        }
                    }

                    n = static_cast<int32_T>(bLen << 1);
                    wOffset = static_cast<int32_T>(wOffset >> 1);
                    for (nTail = 0; nTail <= static_cast<int32_T>(wOffset - 1);
                            nTail = static_cast<int32_T>(nTail + 1)) {
                        FlightMissionMode_merge_b3(d_data, e_data,
                            static_cast<int32_T>(nTail * n), bLen, bLen, f_data,
                            g_data);
                    }

                    bLen = n;
                }

                if (static_cast<int32_T>(wOffset_tmp + 1) > bLen) {
                    FlightMissionMode_merge_b3(d_data, e_data, 0, bLen,
                        static_cast<int32_T>(static_cast<int32_T>(wOffset_tmp -
                        bLen) + 1), f_data, g_data);
                }
            }
        }

        vwork_size_idx_0 = e_size;
        n = e_size;
        for (bLen = 0; bLen <= static_cast<int32_T>(n - 1); bLen++) {
            vwork_data[bLen] = e_data[bLen];
        }

        for (n = 0; n <= b; n = static_cast<int32_T>(n + 1)) {
            x_data[static_cast<int32_T>(dim + static_cast<int32_T>(n * vstride))]
                = e_data[n];
        }
    }
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void* FlightMissionMode::
    FlightMissionMode_uavDubinsBuildable_uavDubinsBuildable_e(real_T airSpeed,
    real_T maxRollAngle, const real_T flightPathAngle[2], const real_T
    disabledPathTypes_data[], const int32_T *disabledPathTypes_size)
{
    real_T b_disabledPathTypes_data[28];
    real_T b_flightPathAngle[2];
    int32_T loop_ub;
    b_flightPathAngle[0] = flightPathAngle[0];
    b_flightPathAngle[1] = flightPathAngle[1];
    loop_ub = *disabledPathTypes_size;
    for (int32_T i{0}; i <= static_cast<int32_T>(loop_ub - 1); i++) {
        b_disabledPathTypes_data[i] = disabledPathTypes_data[i];
    }

    return uavDubinsConnectionObj(airSpeed, maxRollAngle, &b_flightPathAngle[0],
        &b_disabledPathTypes_data[0], static_cast<uint32_T>
        (*disabledPathTypes_size));
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_npg2ox(const char_T
    a_data[], const int32_T a_size[2])
{
    static const char_T b[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T c[2]{ 'H', 'L' };

    boolean_T b_bool;
    b_bool = false;
    if (a_size[1] == 2) {
        int32_T kstr;
        kstr = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (kstr < 2) {
                if (b[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(a_data[kstr]))
                                           & 127)] != b[static_cast<int32_T>
                        (c[kstr])]) {
                    exitg1 = 1;
                } else {
                    kstr = static_cast<int32_T>(kstr + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    return b_bool;
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_npg2ox3(const char_T
    a_data[], const int32_T a_size[2])
{
    static const char_T b[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T c[2]{ 'H', 'R' };

    boolean_T b_bool;
    b_bool = false;
    if (a_size[1] == 2) {
        int32_T kstr;
        kstr = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (kstr < 2) {
                if (b[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(a_data[kstr]))
                                           & 127)] != b[static_cast<int32_T>
                        (c[kstr])]) {
                    exitg1 = 1;
                } else {
                    kstr = static_cast<int32_T>(kstr + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    return b_bool;
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::
    FlightMissionMode_uavDubinsPathSegment_uavDubinsPathSegment_gj(const real_T
    varargin_1[4], const real_T varargin_2[4], real_T varargin_3, real_T
    varargin_4, real_T varargin_5, real_T varargin_6, const
    cell_wrap_0_FlightMissionMode_T varargin_7[4], const real_T varargin_8[4],
    uavDubinsPathSegment_FlightMissionMode_T *b_this)
{
    static const char_T d[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K',
        'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',
        'Z', '[', '\\', ']', '^', '_', '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
        'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',
        'V', 'W', 'X', 'Y', 'Z', '{', '|', '}', '~', '\x7f' };

    real_T thetaWrap;
    b_this->MinTurningRadius = varargin_5;
    b_this->StartPose[0] = varargin_1[0];
    b_this->StartPose[1] = varargin_1[1];
    b_this->StartPose[2] = varargin_1[2];
    thetaWrap = mod_d42kHWKw(varargin_1[3]);
    b_this->StartPose[3] = thetaWrap;
    if (static_cast<boolean_T>(static_cast<int32_T>((thetaWrap == 0.0) &
            (varargin_1[3] > 0.0)))) {
        b_this->StartPose[3] = 6.2831853071795862;
    }

    wrapToPi_kQV0kjUY(&b_this->StartPose[3]);
    b_this->GoalPose[0] = varargin_2[0];
    b_this->GoalPose[1] = varargin_2[1];
    b_this->GoalPose[2] = varargin_2[2];
    thetaWrap = mod_d42kHWKw(varargin_2[3]);
    b_this->GoalPose[3] = thetaWrap;
    if (static_cast<boolean_T>(static_cast<int32_T>((thetaWrap == 0.0) &
            (varargin_2[3] > 0.0)))) {
        b_this->GoalPose[3] = 6.2831853071795862;
    }

    wrapToPi_kQV0kjUY(&b_this->GoalPose[3]);
    b_this->AirSpeed = varargin_4;
    b_this->HelixRadius = varargin_6;
    b_this->FlightPathAngle = varargin_3;
    b_this->MotionLengths[0] = varargin_8[0];
    b_this->MotionTypes[0] = varargin_7[0];
    b_this->MotionLengths[1] = varargin_8[1];
    b_this->MotionTypes[1] = varargin_7[1];
    b_this->MotionLengths[2] = varargin_8[2];
    b_this->MotionTypes[2] = varargin_7[2];
    b_this->MotionLengths[3] = varargin_8[3];
    b_this->MotionTypes[3] = varargin_7[3];
    b_this->MotionTypes[0].f1.size[0] = 1;
    b_this->MotionTypes[0].f1.size[1] = varargin_7[0].f1.size[1];
    for (int32_T k{0}; k <= static_cast<int32_T>(varargin_7[0].f1.size[1] - 1);
            k = static_cast<int32_T>(k + 1)) {
        b_this->MotionTypes[0].f1.data[k] = d[static_cast<int32_T>(varargin_7[0]
            .f1.data[k])];
    }

    b_this->MotionTypes[1].f1.size[0] = 1;
    b_this->MotionTypes[1].f1.size[1] = 1;
    b_this->MotionTypes[1].f1.data[0] = d[static_cast<int32_T>
        (static_cast<int32_T>(static_cast<uint8_T>(varargin_7[1].f1.data[0])) &
         127)];
    b_this->MotionTypes[2].f1.size[0] = 1;
    b_this->MotionTypes[2].f1.size[1] = 1;
    b_this->MotionTypes[2].f1.data[0] = d[static_cast<int32_T>
        (static_cast<int32_T>(static_cast<uint8_T>(varargin_7[2].f1.data[0])) &
         127)];
    b_this->MotionTypes[3].f1.size[0] = 1;
    b_this->MotionTypes[3].f1.size[1] = varargin_7[3].f1.size[1];
    for (int32_T k{0}; k <= static_cast<int32_T>(varargin_7[3].f1.size[1] - 1);
            k = static_cast<int32_T>(k + 1)) {
        b_this->MotionTypes[3].f1.data[k] = d[static_cast<int32_T>(varargin_7[3]
            .f1.data[k])];
    }

    if (FlightMissionMode_strcmp_npg2ox(b_this->MotionTypes[0].f1.data,
            b_this->MotionTypes[0].f1.size)) {
        b_this->MotionTypes[0].f1.size[0] = 1;
        b_this->MotionTypes[0].f1.size[1] = 2;
        b_this->MotionTypes[0].f1.data[0] = 'H';
        b_this->MotionTypes[0].f1.data[1] = 'l';
    } else if (FlightMissionMode_strcmp_npg2ox3(b_this->MotionTypes[0].f1.data,
                b_this->MotionTypes[0].f1.size)) {
        b_this->MotionTypes[0].f1.size[0] = 1;
        b_this->MotionTypes[0].f1.size[1] = 2;
        b_this->MotionTypes[0].f1.data[0] = 'H';
        b_this->MotionTypes[0].f1.data[1] = 'r';
    } else if (FlightMissionMode_strcmp_npg2ox3(b_this->MotionTypes[3].f1.data,
                b_this->MotionTypes[3].f1.size)) {
        b_this->MotionTypes[3].f1.size[0] = 1;
        b_this->MotionTypes[3].f1.size[1] = 2;
        b_this->MotionTypes[3].f1.data[0] = 'H';
        b_this->MotionTypes[3].f1.data[1] = 'r';
    } else if (FlightMissionMode_strcmp_npg2ox(b_this->MotionTypes[3].f1.data,
                b_this->MotionTypes[3].f1.size)) {
        b_this->MotionTypes[3].f1.size[0] = 1;
        b_this->MotionTypes[3].f1.size[1] = 2;
        b_this->MotionTypes[3].f1.data[0] = 'H';
        b_this->MotionTypes[3].f1.data[1] = 'l';
    }

    b_this->Length = ((varargin_8[0] + varargin_8[1]) + varargin_8[2]) +
        varargin_8[3];
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_uavDubinsBuiltins_connect_i(const
    uavDubinsConnection_FlightMissionMode_T *obj, const real_T startPose[4],
    const real_T goalPose[4], real_T turningRadius, const real_T dpt_data[],
    const int32_T *dpt_size, uavDubinsPathSegment_FlightMissionMode_T
    *pathSegObjs, real_T *pathCosts)
{
    void* b_obj_UAVDubinsBuildableObj;
    cell_wrap_0_FlightMissionMode_T ac;
    cell_wrap_0_FlightMissionMode_T ad;
    cell_wrap_0_FlightMissionMode_T ae;
    cell_wrap_0_FlightMissionMode_T af;
    cell_wrap_0_FlightMissionMode_T bc;
    cell_wrap_0_FlightMissionMode_T bd;
    cell_wrap_0_FlightMissionMode_T be;
    cell_wrap_0_FlightMissionMode_T bf;
    cell_wrap_0_FlightMissionMode_T cc;
    cell_wrap_0_FlightMissionMode_T cd;
    cell_wrap_0_FlightMissionMode_T ce;
    cell_wrap_0_FlightMissionMode_T cf;
    cell_wrap_0_FlightMissionMode_T dc;
    cell_wrap_0_FlightMissionMode_T dd;
    cell_wrap_0_FlightMissionMode_T de;
    cell_wrap_0_FlightMissionMode_T df;
    cell_wrap_0_FlightMissionMode_T ec;
    cell_wrap_0_FlightMissionMode_T ed;
    cell_wrap_0_FlightMissionMode_T ee;
    cell_wrap_0_FlightMissionMode_T ef;
    cell_wrap_0_FlightMissionMode_T fc;
    cell_wrap_0_FlightMissionMode_T fd;
    cell_wrap_0_FlightMissionMode_T fe;
    cell_wrap_0_FlightMissionMode_T ff;
    cell_wrap_0_FlightMissionMode_T gc;
    cell_wrap_0_FlightMissionMode_T gd;
    cell_wrap_0_FlightMissionMode_T ge;
    cell_wrap_0_FlightMissionMode_T gf;
    cell_wrap_0_FlightMissionMode_T hc;
    cell_wrap_0_FlightMissionMode_T hd;
    cell_wrap_0_FlightMissionMode_T he;
    cell_wrap_0_FlightMissionMode_T hf;
    cell_wrap_0_FlightMissionMode_T ib;
    cell_wrap_0_FlightMissionMode_T ic;
    cell_wrap_0_FlightMissionMode_T id;
    cell_wrap_0_FlightMissionMode_T ie;
    cell_wrap_0_FlightMissionMode_T jb;
    cell_wrap_0_FlightMissionMode_T jc;
    cell_wrap_0_FlightMissionMode_T jd;
    cell_wrap_0_FlightMissionMode_T je;
    cell_wrap_0_FlightMissionMode_T jf;
    cell_wrap_0_FlightMissionMode_T kb;
    cell_wrap_0_FlightMissionMode_T kc;
    cell_wrap_0_FlightMissionMode_T kd;
    cell_wrap_0_FlightMissionMode_T ke;
    cell_wrap_0_FlightMissionMode_T kf;
    cell_wrap_0_FlightMissionMode_T lb;
    cell_wrap_0_FlightMissionMode_T lc;
    cell_wrap_0_FlightMissionMode_T ld;
    cell_wrap_0_FlightMissionMode_T le;
    cell_wrap_0_FlightMissionMode_T lf;
    cell_wrap_0_FlightMissionMode_T mb;
    cell_wrap_0_FlightMissionMode_T mc;
    cell_wrap_0_FlightMissionMode_T md;
    cell_wrap_0_FlightMissionMode_T me;
    cell_wrap_0_FlightMissionMode_T mf;
    cell_wrap_0_FlightMissionMode_T nb;
    cell_wrap_0_FlightMissionMode_T nc;
    cell_wrap_0_FlightMissionMode_T nd;
    cell_wrap_0_FlightMissionMode_T ne;
    cell_wrap_0_FlightMissionMode_T nf;
    cell_wrap_0_FlightMissionMode_T ob;
    cell_wrap_0_FlightMissionMode_T oc;
    cell_wrap_0_FlightMissionMode_T od;
    cell_wrap_0_FlightMissionMode_T oe;
    cell_wrap_0_FlightMissionMode_T of;
    cell_wrap_0_FlightMissionMode_T pb;
    cell_wrap_0_FlightMissionMode_T pc;
    cell_wrap_0_FlightMissionMode_T pd;
    cell_wrap_0_FlightMissionMode_T pe;
    cell_wrap_0_FlightMissionMode_T pf;
    cell_wrap_0_FlightMissionMode_T qb;
    cell_wrap_0_FlightMissionMode_T qc;
    cell_wrap_0_FlightMissionMode_T qd;
    cell_wrap_0_FlightMissionMode_T qe;
    cell_wrap_0_FlightMissionMode_T qf;
    cell_wrap_0_FlightMissionMode_T rb;
    cell_wrap_0_FlightMissionMode_T rc;
    cell_wrap_0_FlightMissionMode_T rd;
    cell_wrap_0_FlightMissionMode_T re;
    cell_wrap_0_FlightMissionMode_T rf;
    cell_wrap_0_FlightMissionMode_T sb;
    cell_wrap_0_FlightMissionMode_T sc;
    cell_wrap_0_FlightMissionMode_T sd;
    cell_wrap_0_FlightMissionMode_T se;
    cell_wrap_0_FlightMissionMode_T sf;
    cell_wrap_0_FlightMissionMode_T tb;
    cell_wrap_0_FlightMissionMode_T tc;
    cell_wrap_0_FlightMissionMode_T td;
    cell_wrap_0_FlightMissionMode_T te;
    cell_wrap_0_FlightMissionMode_T tf;
    cell_wrap_0_FlightMissionMode_T ub;
    cell_wrap_0_FlightMissionMode_T uc;
    cell_wrap_0_FlightMissionMode_T ud;
    cell_wrap_0_FlightMissionMode_T ue;
    cell_wrap_0_FlightMissionMode_T uf;
    cell_wrap_0_FlightMissionMode_T vb;
    cell_wrap_0_FlightMissionMode_T vc;
    cell_wrap_0_FlightMissionMode_T vd;
    cell_wrap_0_FlightMissionMode_T ve;
    cell_wrap_0_FlightMissionMode_T wb;
    cell_wrap_0_FlightMissionMode_T wc;
    cell_wrap_0_FlightMissionMode_T wd;
    cell_wrap_0_FlightMissionMode_T we;
    cell_wrap_0_FlightMissionMode_T xb;
    cell_wrap_0_FlightMissionMode_T xc;
    cell_wrap_0_FlightMissionMode_T xd;
    cell_wrap_0_FlightMissionMode_T xe;
    cell_wrap_0_FlightMissionMode_T yb;
    cell_wrap_0_FlightMissionMode_T yc;
    cell_wrap_0_FlightMissionMode_T yd;
    cell_wrap_0_FlightMissionMode_T ye;
    cell_wrap_22_FlightMissionMode_T motionTypes[28];
    cell_wrap_22_FlightMissionMode_T b;
    real_T g[16];
    real_T ml[16];
    real_T ml1[16];
    real_T s[16];
    real_T b_goalPose[4];
    real_T b_startPose[4];
    real_T ml1_0[4];
    real_T b_a;
    real_T b_fpa;
    real_T h;
    real_T mt;
    real_T mtr;
    int32_T tmp;
    ib.f1.size[0] = 1;
    ib.f1.size[1] = 1;
    ib.f1.data[0] = 'L';
    jb.f1.size[0] = 1;
    jb.f1.size[1] = 1;
    jb.f1.data[0] = 'S';
    kb.f1.size[0] = 1;
    kb.f1.size[1] = 1;
    kb.f1.data[0] = 'L';
    lb.f1.size[0] = 1;
    lb.f1.size[1] = 1;
    lb.f1.data[0] = 'N';
    b.f1[0] = ib;
    b.f1[1] = jb;
    b.f1[2] = kb;
    b.f1[3] = lb;
    mb.f1.size[0] = 1;
    mb.f1.size[1] = 1;
    mb.f1.data[0] = 'L';
    nb.f1.size[0] = 1;
    nb.f1.size[1] = 1;
    nb.f1.data[0] = 'S';
    ob.f1.size[0] = 1;
    ob.f1.size[1] = 1;
    ob.f1.data[0] = 'R';
    pb.f1.size[0] = 1;
    pb.f1.size[1] = 1;
    pb.f1.data[0] = 'N';
    qb.f1.size[0] = 1;
    qb.f1.size[1] = 1;
    qb.f1.data[0] = 'R';
    rb.f1.size[0] = 1;
    rb.f1.size[1] = 1;
    rb.f1.data[0] = 'S';
    sb.f1.size[0] = 1;
    sb.f1.size[1] = 1;
    sb.f1.data[0] = 'L';
    tb.f1.size[0] = 1;
    tb.f1.size[1] = 1;
    tb.f1.data[0] = 'N';
    ub.f1.size[0] = 1;
    ub.f1.size[1] = 1;
    ub.f1.data[0] = 'R';
    vb.f1.size[0] = 1;
    vb.f1.size[1] = 1;
    vb.f1.data[0] = 'S';
    wb.f1.size[0] = 1;
    wb.f1.size[1] = 1;
    wb.f1.data[0] = 'R';
    xb.f1.size[0] = 1;
    xb.f1.size[1] = 1;
    xb.f1.data[0] = 'N';
    yb.f1.size[0] = 1;
    yb.f1.size[1] = 1;
    yb.f1.data[0] = 'R';
    ac.f1.size[0] = 1;
    ac.f1.size[1] = 1;
    ac.f1.data[0] = 'L';
    bc.f1.size[0] = 1;
    bc.f1.size[1] = 1;
    bc.f1.data[0] = 'R';
    cc.f1.size[0] = 1;
    cc.f1.size[1] = 1;
    cc.f1.data[0] = 'N';
    dc.f1.size[0] = 1;
    dc.f1.size[1] = 1;
    dc.f1.data[0] = 'L';
    ec.f1.size[0] = 1;
    ec.f1.size[1] = 1;
    ec.f1.data[0] = 'R';
    fc.f1.size[0] = 1;
    fc.f1.size[1] = 1;
    fc.f1.data[0] = 'L';
    gc.f1.size[0] = 1;
    gc.f1.size[1] = 1;
    gc.f1.data[0] = 'N';
    hc.f1.size[0] = 1;
    hc.f1.size[1] = 2;
    ic.f1.size[0] = 1;
    ic.f1.size[1] = 1;
    ic.f1.data[0] = 'L';
    jc.f1.size[0] = 1;
    jc.f1.size[1] = 1;
    jc.f1.data[0] = 'S';
    kc.f1.size[0] = 1;
    kc.f1.size[1] = 1;
    kc.f1.data[0] = 'L';
    lc.f1.size[0] = 1;
    lc.f1.size[1] = 2;
    mc.f1.size[0] = 1;
    mc.f1.size[1] = 1;
    mc.f1.data[0] = 'L';
    nc.f1.size[0] = 1;
    nc.f1.size[1] = 1;
    nc.f1.data[0] = 'S';
    oc.f1.size[0] = 1;
    oc.f1.size[1] = 1;
    oc.f1.data[0] = 'R';
    pc.f1.size[0] = 1;
    pc.f1.size[1] = 2;
    qc.f1.size[0] = 1;
    qc.f1.size[1] = 1;
    qc.f1.data[0] = 'R';
    rc.f1.size[0] = 1;
    rc.f1.size[1] = 1;
    rc.f1.data[0] = 'S';
    sc.f1.size[0] = 1;
    sc.f1.size[1] = 1;
    sc.f1.data[0] = 'L';
    tc.f1.size[0] = 1;
    tc.f1.size[1] = 2;
    uc.f1.size[0] = 1;
    uc.f1.size[1] = 1;
    uc.f1.data[0] = 'R';
    vc.f1.size[0] = 1;
    vc.f1.size[1] = 1;
    vc.f1.data[0] = 'S';
    wc.f1.size[0] = 1;
    wc.f1.size[1] = 1;
    wc.f1.data[0] = 'R';
    xc.f1.size[0] = 1;
    xc.f1.size[1] = 2;
    yc.f1.size[0] = 1;
    yc.f1.size[1] = 1;
    yc.f1.data[0] = 'R';
    ad.f1.size[0] = 1;
    ad.f1.size[1] = 1;
    ad.f1.data[0] = 'L';
    bd.f1.size[0] = 1;
    bd.f1.size[1] = 1;
    bd.f1.data[0] = 'R';
    cd.f1.size[0] = 1;
    cd.f1.size[1] = 2;
    dd.f1.size[0] = 1;
    dd.f1.size[1] = 1;
    dd.f1.data[0] = 'L';
    ed.f1.size[0] = 1;
    ed.f1.size[1] = 1;
    ed.f1.data[0] = 'R';
    fd.f1.size[0] = 1;
    fd.f1.size[1] = 1;
    fd.f1.data[0] = 'L';
    gd.f1.size[0] = 1;
    gd.f1.size[1] = 1;
    gd.f1.data[0] = 'L';
    hd.f1.size[0] = 1;
    hd.f1.size[1] = 1;
    hd.f1.data[0] = 'S';
    id.f1.size[0] = 1;
    id.f1.size[1] = 1;
    id.f1.data[0] = 'L';
    jd.f1.size[0] = 1;
    jd.f1.size[1] = 2;
    kd.f1.size[0] = 1;
    kd.f1.size[1] = 1;
    kd.f1.data[0] = 'L';
    ld.f1.size[0] = 1;
    ld.f1.size[1] = 1;
    ld.f1.data[0] = 'S';
    md.f1.size[0] = 1;
    md.f1.size[1] = 1;
    md.f1.data[0] = 'R';
    nd.f1.size[0] = 1;
    nd.f1.size[1] = 2;
    od.f1.size[0] = 1;
    od.f1.size[1] = 1;
    od.f1.data[0] = 'R';
    pd.f1.size[0] = 1;
    pd.f1.size[1] = 1;
    pd.f1.data[0] = 'S';
    qd.f1.size[0] = 1;
    qd.f1.size[1] = 1;
    qd.f1.data[0] = 'L';
    rd.f1.size[0] = 1;
    rd.f1.size[1] = 2;
    sd.f1.size[0] = 1;
    sd.f1.size[1] = 1;
    sd.f1.data[0] = 'R';
    td.f1.size[0] = 1;
    td.f1.size[1] = 1;
    td.f1.data[0] = 'S';
    ud.f1.size[0] = 1;
    ud.f1.size[1] = 1;
    ud.f1.data[0] = 'R';
    vd.f1.size[0] = 1;
    vd.f1.size[1] = 2;
    wd.f1.size[0] = 1;
    wd.f1.size[1] = 1;
    wd.f1.data[0] = 'R';
    xd.f1.size[0] = 1;
    xd.f1.size[1] = 1;
    xd.f1.data[0] = 'L';
    yd.f1.size[0] = 1;
    yd.f1.size[1] = 1;
    yd.f1.data[0] = 'R';
    ae.f1.size[0] = 1;
    ae.f1.size[1] = 2;
    be.f1.size[0] = 1;
    be.f1.size[1] = 1;
    be.f1.data[0] = 'L';
    ce.f1.size[0] = 1;
    ce.f1.size[1] = 1;
    ce.f1.data[0] = 'R';
    de.f1.size[0] = 1;
    de.f1.size[1] = 1;
    de.f1.data[0] = 'L';
    ee.f1.size[0] = 1;
    ee.f1.size[1] = 2;
    hc.f1.data[0] = 'H';
    lc.f1.data[0] = 'H';
    pc.f1.data[0] = 'H';
    tc.f1.data[0] = 'H';
    xc.f1.data[0] = 'H';
    cd.f1.data[0] = 'H';
    jd.f1.data[0] = 'H';
    nd.f1.data[0] = 'H';
    rd.f1.data[0] = 'H';
    vd.f1.data[0] = 'H';
    ae.f1.data[0] = 'H';
    ee.f1.data[0] = 'H';
    hc.f1.data[1] = 'l';
    lc.f1.data[1] = 'l';
    pc.f1.data[1] = 'r';
    tc.f1.data[1] = 'r';
    xc.f1.data[1] = 'r';
    cd.f1.data[1] = 'l';
    jd.f1.data[1] = 'l';
    nd.f1.data[1] = 'r';
    rd.f1.data[1] = 'l';
    vd.f1.data[1] = 'r';
    ae.f1.data[1] = 'r';
    ee.f1.data[1] = 'l';
    fe.f1.size[0] = 1;
    fe.f1.size[1] = 1;
    fe.f1.data[0] = 'L';
    ge.f1.size[0] = 1;
    ge.f1.size[1] = 1;
    ge.f1.data[0] = 'R';
    he.f1.size[0] = 1;
    he.f1.size[1] = 1;
    he.f1.data[0] = 'S';
    ie.f1.size[0] = 1;
    ie.f1.size[1] = 1;
    ie.f1.data[0] = 'L';
    je.f1.size[0] = 1;
    je.f1.size[1] = 1;
    je.f1.data[0] = 'L';
    ke.f1.size[0] = 1;
    ke.f1.size[1] = 1;
    ke.f1.data[0] = 'R';
    le.f1.size[0] = 1;
    le.f1.size[1] = 1;
    le.f1.data[0] = 'S';
    me.f1.size[0] = 1;
    me.f1.size[1] = 1;
    me.f1.data[0] = 'R';
    ne.f1.size[0] = 1;
    ne.f1.size[1] = 1;
    ne.f1.data[0] = 'L';
    oe.f1.size[0] = 1;
    oe.f1.size[1] = 1;
    oe.f1.data[0] = 'R';
    pe.f1.size[0] = 1;
    pe.f1.size[1] = 1;
    pe.f1.data[0] = 'L';
    qe.f1.size[0] = 1;
    qe.f1.size[1] = 1;
    qe.f1.data[0] = 'R';
    re.f1.size[0] = 1;
    re.f1.size[1] = 1;
    re.f1.data[0] = 'R';
    se.f1.size[0] = 1;
    se.f1.size[1] = 1;
    se.f1.data[0] = 'L';
    te.f1.size[0] = 1;
    te.f1.size[1] = 1;
    te.f1.data[0] = 'S';
    ue.f1.size[0] = 1;
    ue.f1.size[1] = 1;
    ue.f1.data[0] = 'R';
    ve.f1.size[0] = 1;
    ve.f1.size[1] = 1;
    ve.f1.data[0] = 'R';
    we.f1.size[0] = 1;
    we.f1.size[1] = 1;
    we.f1.data[0] = 'L';
    xe.f1.size[0] = 1;
    xe.f1.size[1] = 1;
    xe.f1.data[0] = 'R';
    ye.f1.size[0] = 1;
    ye.f1.size[1] = 1;
    ye.f1.data[0] = 'L';
    af.f1.size[0] = 1;
    af.f1.size[1] = 1;
    af.f1.data[0] = 'R';
    bf.f1.size[0] = 1;
    bf.f1.size[1] = 1;
    bf.f1.data[0] = 'L';
    cf.f1.size[0] = 1;
    cf.f1.size[1] = 1;
    cf.f1.data[0] = 'S';
    df.f1.size[0] = 1;
    df.f1.size[1] = 1;
    df.f1.data[0] = 'L';
    ef.f1.size[0] = 1;
    ef.f1.size[1] = 1;
    ef.f1.data[0] = 'L';
    ff.f1.size[0] = 1;
    ff.f1.size[1] = 1;
    ff.f1.data[0] = 'S';
    gf.f1.size[0] = 1;
    gf.f1.size[1] = 1;
    gf.f1.data[0] = 'R';
    hf.f1.size[0] = 1;
    hf.f1.size[1] = 1;
    hf.f1.data[0] = 'L';
    jf.f1.size[0] = 1;
    jf.f1.size[1] = 1;
    jf.f1.data[0] = 'R';
    kf.f1.size[0] = 1;
    kf.f1.size[1] = 1;
    kf.f1.data[0] = 'S';
    lf.f1.size[0] = 1;
    lf.f1.size[1] = 1;
    lf.f1.data[0] = 'R';
    mf.f1.size[0] = 1;
    mf.f1.size[1] = 1;
    mf.f1.data[0] = 'L';
    nf.f1.size[0] = 1;
    nf.f1.size[1] = 1;
    nf.f1.data[0] = 'L';
    of.f1.size[0] = 1;
    of.f1.size[1] = 1;
    of.f1.data[0] = 'S';
    pf.f1.size[0] = 1;
    pf.f1.size[1] = 1;
    pf.f1.data[0] = 'L';
    qf.f1.size[0] = 1;
    qf.f1.size[1] = 1;
    qf.f1.data[0] = 'R';
    rf.f1.size[0] = 1;
    rf.f1.size[1] = 1;
    rf.f1.data[0] = 'R';
    sf.f1.size[0] = 1;
    sf.f1.size[1] = 1;
    sf.f1.data[0] = 'S';
    tf.f1.size[0] = 1;
    tf.f1.size[1] = 1;
    tf.f1.data[0] = 'L';
    uf.f1.size[0] = 1;
    uf.f1.size[1] = 1;
    uf.f1.data[0] = 'R';
    motionTypes[0] = b;
    b_obj_UAVDubinsBuildableObj =
        FlightMissionMode_uavDubinsBuildable_uavDubinsBuildable_e(obj->AirSpeed,
        obj->MaxRollAngle, obj->FlightPathAngleLimit, dpt_data, dpt_size);
    b_startPose[0] = startPose[0];
    b_goalPose[0] = goalPose[0];
    b_startPose[1] = startPose[1];
    b_goalPose[1] = goalPose[1];
    b_startPose[2] = startPose[2];
    b_goalPose[2] = goalPose[2];
    b_startPose[3] = startPose[3];
    b_goalPose[3] = goalPose[3];
    uavDubinsDistanceCodegen_real64(b_obj_UAVDubinsBuildableObj, &b_startPose[0],
        1U, &b_goalPose[0], 1U, true, turningRadius, &s[0], &g[0], &b_fpa, &b_a,
        &mtr, &h, &mt, &ml[0]);
    tmp = 0;
    for (int32_T i{0}; i < 4; i++) {
        ml1[tmp] = ml[i];
        ml1[static_cast<int32_T>(tmp + 1)] = ml[static_cast<int32_T>(i + 4)];
        ml1[static_cast<int32_T>(tmp + 2)] = ml[static_cast<int32_T>(i + 8)];
        ml1[static_cast<int32_T>(tmp + 3)] = ml[static_cast<int32_T>(i + 12)];
        tmp = static_cast<int32_T>(tmp + 4);
    }

    if (mt + 1.0 == 2.0) {
        motionTypes[0].f1[0] = mb;
        motionTypes[0].f1[1] = nb;
        motionTypes[0].f1[2] = ob;
        motionTypes[0].f1[3] = pb;
    }

    if (mt + 1.0 == 3.0) {
        motionTypes[0].f1[0] = qb;
        motionTypes[0].f1[1] = rb;
        motionTypes[0].f1[2] = sb;
        motionTypes[0].f1[3] = tb;
    }

    if (mt + 1.0 == 4.0) {
        motionTypes[0].f1[0] = ub;
        motionTypes[0].f1[1] = vb;
        motionTypes[0].f1[2] = wb;
        motionTypes[0].f1[3] = xb;
    }

    if (mt + 1.0 == 5.0) {
        motionTypes[0].f1[0] = yb;
        motionTypes[0].f1[1] = ac;
        motionTypes[0].f1[2] = bc;
        motionTypes[0].f1[3] = cc;
    }

    if (mt + 1.0 == 6.0) {
        motionTypes[0].f1[0] = dc;
        motionTypes[0].f1[1] = ec;
        motionTypes[0].f1[2] = fc;
        motionTypes[0].f1[3] = gc;
    }

    if (mt + 1.0 == 7.0) {
        motionTypes[0].f1[0] = hc;
        motionTypes[0].f1[1] = ic;
        motionTypes[0].f1[2] = jc;
        motionTypes[0].f1[3] = kc;
    }

    if (mt + 1.0 == 8.0) {
        motionTypes[0].f1[0] = lc;
        motionTypes[0].f1[1] = mc;
        motionTypes[0].f1[2] = nc;
        motionTypes[0].f1[3] = oc;
    }

    if (mt + 1.0 == 9.0) {
        motionTypes[0].f1[0] = pc;
        motionTypes[0].f1[1] = qc;
        motionTypes[0].f1[2] = rc;
        motionTypes[0].f1[3] = sc;
    }

    if (mt + 1.0 == 10.0) {
        motionTypes[0].f1[0] = tc;
        motionTypes[0].f1[1] = uc;
        motionTypes[0].f1[2] = vc;
        motionTypes[0].f1[3] = wc;
    }

    if (mt + 1.0 == 11.0) {
        motionTypes[0].f1[0] = xc;
        motionTypes[0].f1[1] = yc;
        motionTypes[0].f1[2] = ad;
        motionTypes[0].f1[3] = bd;
    }

    if (mt + 1.0 == 12.0) {
        motionTypes[0].f1[0] = cd;
        motionTypes[0].f1[1] = dd;
        motionTypes[0].f1[2] = ed;
        motionTypes[0].f1[3] = fd;
    }

    if (mt + 1.0 == 13.0) {
        motionTypes[0].f1[0] = gd;
        motionTypes[0].f1[1] = hd;
        motionTypes[0].f1[2] = id;
        motionTypes[0].f1[3] = jd;
    }

    if (mt + 1.0 == 14.0) {
        motionTypes[0].f1[0] = kd;
        motionTypes[0].f1[1] = ld;
        motionTypes[0].f1[2] = md;
        motionTypes[0].f1[3] = nd;
    }

    if (mt + 1.0 == 15.0) {
        motionTypes[0].f1[0] = od;
        motionTypes[0].f1[1] = pd;
        motionTypes[0].f1[2] = qd;
        motionTypes[0].f1[3] = rd;
    }

    if (mt + 1.0 == 16.0) {
        motionTypes[0].f1[0] = sd;
        motionTypes[0].f1[1] = td;
        motionTypes[0].f1[2] = ud;
        motionTypes[0].f1[3] = vd;
    }

    if (mt + 1.0 == 17.0) {
        motionTypes[0].f1[0] = wd;
        motionTypes[0].f1[1] = xd;
        motionTypes[0].f1[2] = yd;
        motionTypes[0].f1[3] = ae;
    }

    if (mt + 1.0 == 18.0) {
        motionTypes[0].f1[0] = be;
        motionTypes[0].f1[1] = ce;
        motionTypes[0].f1[2] = de;
        motionTypes[0].f1[3] = ee;
    }

    if (mt + 1.0 == 19.0) {
        motionTypes[0].f1[0] = fe;
        motionTypes[0].f1[1] = ge;
        motionTypes[0].f1[2] = he;
        motionTypes[0].f1[3] = ie;
    }

    if (mt + 1.0 == 20.0) {
        motionTypes[0].f1[0] = je;
        motionTypes[0].f1[1] = ke;
        motionTypes[0].f1[2] = le;
        motionTypes[0].f1[3] = me;
    }

    if (mt + 1.0 == 21.0) {
        motionTypes[0].f1[0] = ne;
        motionTypes[0].f1[1] = oe;
        motionTypes[0].f1[2] = pe;
        motionTypes[0].f1[3] = qe;
    }

    if (mt + 1.0 == 22.0) {
        motionTypes[0].f1[0] = re;
        motionTypes[0].f1[1] = se;
        motionTypes[0].f1[2] = te;
        motionTypes[0].f1[3] = ue;
    }

    if (mt + 1.0 == 23.0) {
        motionTypes[0].f1[0] = ve;
        motionTypes[0].f1[1] = we;
        motionTypes[0].f1[2] = xe;
        motionTypes[0].f1[3] = ye;
    }

    if (mt + 1.0 == 24.0) {
        motionTypes[0].f1[0] = af;
        motionTypes[0].f1[1] = bf;
        motionTypes[0].f1[2] = cf;
        motionTypes[0].f1[3] = df;
    }

    if (mt + 1.0 == 25.0) {
        motionTypes[0].f1[0] = ef;
        motionTypes[0].f1[1] = ff;
        motionTypes[0].f1[2] = gf;
        motionTypes[0].f1[3] = hf;
    }

    if (mt + 1.0 == 26.0) {
        motionTypes[0].f1[0] = jf;
        motionTypes[0].f1[1] = kf;
        motionTypes[0].f1[2] = lf;
        motionTypes[0].f1[3] = mf;
    }

    if (mt + 1.0 == 27.0) {
        motionTypes[0].f1[0] = nf;
        motionTypes[0].f1[1] = of;
        motionTypes[0].f1[2] = pf;
        motionTypes[0].f1[3] = qf;
    }

    if (mt + 1.0 == 28.0) {
        motionTypes[0].f1[0] = rf;
        motionTypes[0].f1[1] = sf;
        motionTypes[0].f1[2] = tf;
        motionTypes[0].f1[3] = uf;
    }

    b_startPose[0] = s[0];
    b_goalPose[0] = g[0];
    ml1_0[0] = ml1[0];
    b_startPose[1] = s[1];
    b_goalPose[1] = g[1];
    ml1_0[1] = ml1[4];
    b_startPose[2] = s[2];
    b_goalPose[2] = g[2];
    ml1_0[2] = ml1[8];
    b_startPose[3] = s[3];
    b_goalPose[3] = g[3];
    ml1_0[3] = ml1[12];
    FlightMissionMode_uavDubinsPathSegment_uavDubinsPathSegment_gj(b_startPose,
        b_goalPose, b_fpa, b_a, mtr, h, motionTypes[0].f1, ml1_0, pathSegObjs);
    ml1_0[0] = ml1[0];
    ml1_0[1] = ml1[4];
    ml1_0[2] = ml1[8];
    ml1_0[3] = ml1[12];
    *pathCosts = sum_kSJnGZ04(ml1_0);
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_strcmp_npg2ox3u(const
    cell_wrap_0_FlightMissionMode_T a[4], boolean_T b_bool[4])
{
    b_bool[0] = false;
    if ((a[0].f1.size[1] == 1) && (a[0].f1.data[0] == 'N')) {
        b_bool[0] = true;
    }

    b_bool[1] = false;
    if ((a[1].f1.size[1] == 1) && (a[1].f1.data[0] == 'N')) {
        b_bool[1] = true;
    }

    b_bool[2] = false;
    if ((a[2].f1.size[1] == 1) && (a[2].f1.data[0] == 'N')) {
        b_bool[2] = true;
    }

    b_bool[3] = false;
    if ((a[3].f1.size[1] == 1) && (a[3].f1.data[0] == 'N')) {
        b_bool[3] = true;
    }
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_any_o(const boolean_T x[4])
{
    int32_T k;
    boolean_T exitg1;
    boolean_T y;
    y = false;
    k = 0;
    exitg1 = false;
    while ((!exitg1) && (k < 4)) {
        if (x[k]) {
            y = true;
            exitg1 = true;
        } else {
            k = static_cast<int32_T>(k + 1);
        }
    }

    return y;
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_useConstantDim_d(const real_T
    varargin_2_data[], const int32_T varargin_2_size[2], real_T
    varargout_1_data[], int32_T varargout_1_size[2])
{
    int32_T loop_ub;
    varargout_1_size[0] = 1;
    varargout_1_size[1] = varargin_2_size[1];
    loop_ub = static_cast<int32_T>(varargin_2_size[1] - 1);
    for (int32_T varargout_1_data_tmp{0}; varargout_1_data_tmp <= loop_ub;
            varargout_1_data_tmp++) {
        varargout_1_data[varargout_1_data_tmp] =
            varargin_2_data[varargout_1_data_tmp];
    }

    for (loop_ub = 0; loop_ub <= static_cast<int32_T>(varargin_2_size[1] - 2);
            loop_ub = static_cast<int32_T>(loop_ub + 1)) {
        varargout_1_data[static_cast<int32_T>(loop_ub + 1)] +=
            varargout_1_data[loop_ub];
    }
}

void FlightMissionMode::FlightMissionMode_emxInit_int32_T_k
    (emxArray_int32_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions)
{
    emxArray_int32_T_FlightMissionMode_T *emxArray;
    *pEmxArray = static_cast<emxArray_int32_T_FlightMissionMode_T *>(std::malloc
        (sizeof(emxArray_int32_T_FlightMissionMode_T)));
    emxArray = *pEmxArray;
    emxArray->data = static_cast<int32_T *>(nullptr);
    emxArray->numDimensions = numDimensions;
    emxArray->size = static_cast<int32_T *>(std::malloc(static_cast<uint32_T>
        (sizeof(int32_T) * static_cast<uint32_T>(numDimensions))));
    emxArray->allocatedSize = 0;
    emxArray->canFreeData = true;
    for (int32_T i{0}; i <= static_cast<int32_T>(numDimensions - 1); i++) {
        emxArray->size[i] = 0;
    }
}

void FlightMissionMode::FlightMissionMode_emxEnsureCapacity_int32_T_j
    (emxArray_int32_T_FlightMissionMode_T *emxArray, int32_T oldNumel)
{
    int32_T i;
    int32_T newNumel;
    void *newData;
    if (oldNumel < 0) {
        oldNumel = 0;
    }

    newNumel = 1;
    for (i = 0; i <= static_cast<int32_T>(emxArray->numDimensions - 1); i++) {
        newNumel = static_cast<int32_T>(newNumel * emxArray->size[i]);
    }

    if (newNumel > emxArray->allocatedSize) {
        i = emxArray->allocatedSize;
        if (i < 16) {
            i = 16;
        }

        while (i < newNumel) {
            if (i > 1073741823) {
                i = MAX_int32_T;
            } else {
                i = static_cast<int32_T>(i << 1);
            }
        }

        newData = std::calloc(static_cast<uint32_T>(i), sizeof(int32_T));
        if (emxArray->data != nullptr) {
            std::memcpy(newData, emxArray->data, static_cast<uint32_T>(sizeof
                         (int32_T) * static_cast<uint32_T>(oldNumel)));
            if (emxArray->canFreeData) {
                std::free(emxArray->data);
            }
        }

        emxArray->data = static_cast<int32_T *>(newData);
        emxArray->allocatedSize = i;
        emxArray->canFreeData = true;
    }
}

void FlightMissionMode::FlightMissionMode_emxFree_int32_T_a
    (emxArray_int32_T_FlightMissionMode_T **pEmxArray)
{
    if (*pEmxArray != static_cast<emxArray_int32_T_FlightMissionMode_T *>
            (nullptr)) {
        if (((*pEmxArray)->data != static_cast<int32_T *>(nullptr)) &&
                (*pEmxArray)->canFreeData) {
            std::free((*pEmxArray)->data);
        }

        std::free((*pEmxArray)->size);
        std::free(*pEmxArray);
        *pEmxArray = static_cast<emxArray_int32_T_FlightMissionMode_T *>(nullptr);
    }
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_merge_b30
    (emxArray_int32_T_FlightMissionMode_T *idx,
     emxArray_real_T_FlightMissionMode_T *x, int32_T offset, int32_T np, int32_T
     nq, emxArray_int32_T_FlightMissionMode_T *iwork,
     emxArray_real_T_FlightMissionMode_T *xwork)
{
    if (nq != 0) {
        int32_T iout;
        int32_T n;
        int32_T n_tmp;
        int32_T q;
        n_tmp = static_cast<int32_T>(np + nq);
        for (q = 0; q <= static_cast<int32_T>(n_tmp - 1); q =
                static_cast<int32_T>(q + 1)) {
            iout = static_cast<int32_T>(offset + q);
            iwork->data[q] = idx->data[iout];
            xwork->data[q] = x->data[iout];
        }

        n = 0;
        q = np;
        iout = static_cast<int32_T>(offset - 1);
        int32_T exitg1;
        do {
            exitg1 = 0;
            iout = static_cast<int32_T>(iout + 1);
            if (xwork->data[n] <= xwork->data[q]) {
                idx->data[iout] = iwork->data[n];
                x->data[iout] = xwork->data[n];
                if (static_cast<int32_T>(n + 1) < np) {
                    n = static_cast<int32_T>(n + 1);
                } else {
                    exitg1 = 1;
                }
            } else {
                idx->data[iout] = iwork->data[q];
                x->data[iout] = xwork->data[q];
                if (static_cast<int32_T>(q + 1) < n_tmp) {
                    q = static_cast<int32_T>(q + 1);
                } else {
                    q = static_cast<int32_T>(iout - n);
                    while (static_cast<int32_T>(n + 1) <= np) {
                        n_tmp = static_cast<int32_T>(static_cast<int32_T>(q + n)
                            + 1);
                        idx->data[n_tmp] = iwork->data[n];
                        x->data[n_tmp] = xwork->data[n];
                        n = static_cast<int32_T>(n + 1);
                    }

                    exitg1 = 1;
                }
            }
        } while (exitg1 == 0);
    }
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_merge_block_f
    (emxArray_int32_T_FlightMissionMode_T *idx,
     emxArray_real_T_FlightMissionMode_T *x, int32_T offset, int32_T n, int32_T
     preSortLevel, emxArray_int32_T_FlightMissionMode_T *iwork,
     emxArray_real_T_FlightMissionMode_T *xwork)
{
    int32_T bLen;
    int32_T nPairs;
    nPairs = static_cast<int32_T>(n >> preSortLevel);
    bLen = static_cast<int32_T>(1 << preSortLevel);
    while (nPairs > 1) {
        int32_T nTail;
        int32_T tailOffset;
        if (static_cast<uint32_T>(static_cast<uint32_T>(nPairs) & 1U) != 0U) {
            nPairs = static_cast<int32_T>(nPairs - 1);
            tailOffset = static_cast<int32_T>(bLen * nPairs);
            nTail = static_cast<int32_T>(n - tailOffset);
            if (nTail > bLen) {
                FlightMissionMode_merge_b30(idx, x, static_cast<int32_T>(offset
                    + tailOffset), bLen, static_cast<int32_T>(nTail - bLen),
                    iwork, xwork);
            }
        }

        tailOffset = static_cast<int32_T>(bLen << 1);
        nPairs = static_cast<int32_T>(nPairs >> 1);
        for (nTail = 0; nTail <= static_cast<int32_T>(nPairs - 1); nTail =
                static_cast<int32_T>(nTail + 1)) {
            FlightMissionMode_merge_b30(idx, x, static_cast<int32_T>(offset +
                static_cast<int32_T>(nTail * tailOffset)), bLen, bLen, iwork,
                xwork);
        }

        bLen = tailOffset;
    }

    if (n > bLen) {
        FlightMissionMode_merge_b30(idx, x, offset, bLen, static_cast<int32_T>(n
            - bLen), iwork, xwork);
    }
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_sort_c5e
    (emxArray_real_T_FlightMissionMode_T *x)
{
    emxArray_int32_T_FlightMissionMode_T *c;
    emxArray_int32_T_FlightMissionMode_T *idx;
    emxArray_int32_T_FlightMissionMode_T *iwork;
    emxArray_real_T_FlightMissionMode_T *b_x;
    emxArray_real_T_FlightMissionMode_T *d;
    emxArray_real_T_FlightMissionMode_T *f;
    real_T b_xwork[256];
    real_T x4[4];
    int32_T c_iwork[256];
    int32_T idx4[4];
    int32_T c_iwork_tmp;
    int32_T i1;
    int32_T ib;
    int8_T perm[4];
    FlightMissionMode_emxInit_real_T_h(&b_x, 2);
    FlightMissionMode_emxInit_int32_T_k(&c, 2);
    FlightMissionMode_emxInit_real_T_h(&d, 2);
    FlightMissionMode_emxInit_real_T_h(&f, 1);
    c_iwork_tmp = static_cast<int32_T>(b_x->size[0] * b_x->size[1]);
    b_x->size[0] = 1;
    b_x->size[1] = x->size[1];
    FlightMissionMode_emxEnsureCapacity_real_T_c(b_x, c_iwork_tmp);
    i1 = static_cast<int32_T>(x->size[1] - 1);
    for (ib = 0; ib <= i1; ib++) {
        b_x->data[ib] = x->data[ib];
    }

    if (x->size[1] != 0) {
        int32_T bLen;
        int32_T bLen2;
        int32_T n;
        int32_T nBlocks;
        int32_T nPairs;
        int32_T q;
        int32_T wOffset;
        FlightMissionMode_emxInit_int32_T_k(&idx, 2);
        c_iwork_tmp = static_cast<int32_T>(idx->size[0] * idx->size[1]);
        idx->size[0] = 1;
        idx->size[1] = x->size[1];
        FlightMissionMode_emxEnsureCapacity_int32_T_j(idx, c_iwork_tmp);
        i1 = static_cast<int32_T>(x->size[1] - 1);
        for (ib = 0; ib <= i1; ib++) {
            idx->data[ib] = 0;
        }

        c_iwork_tmp = static_cast<int32_T>(b_x->size[0] * b_x->size[1]);
        b_x->size[0] = 1;
        b_x->size[1] = x->size[1];
        FlightMissionMode_emxEnsureCapacity_real_T_c(b_x, c_iwork_tmp);
        i1 = static_cast<int32_T>(x->size[1] - 1);
        for (ib = 0; ib <= i1; ib++) {
            b_x->data[ib] = x->data[ib];
        }

        n = x->size[1];
        x4[0] = 0.0;
        idx4[0] = 0;
        x4[1] = 0.0;
        idx4[1] = 0;
        x4[2] = 0.0;
        idx4[2] = 0;
        x4[3] = 0.0;
        idx4[3] = 0;
        c_iwork_tmp = f->size[0];
        f->size[0] = x->size[1];
        FlightMissionMode_emxEnsureCapacity_real_T_c(f, c_iwork_tmp);
        nBlocks = f->size[0];
        c_iwork_tmp = f->size[0];
        f->size[0] = nBlocks;
        FlightMissionMode_emxEnsureCapacity_real_T_c(f, c_iwork_tmp);
        for (ib = 0; ib <= static_cast<int32_T>(nBlocks - 1); ib++) {
            f->data[ib] = 0.0;
        }

        nBlocks = 1;
        ib = 0;
        for (wOffset = 0; wOffset <= static_cast<int32_T>(n - 1); wOffset =
                static_cast<int32_T>(wOffset + 1)) {
            if (std::isnan(b_x->data[wOffset])) {
                q = static_cast<int32_T>(n - nBlocks);
                idx->data[q] = static_cast<int32_T>(wOffset + 1);
                f->data[q] = b_x->data[wOffset];
                nBlocks = static_cast<int32_T>(nBlocks + 1);
            } else {
                ib = static_cast<int32_T>(ib + 1);
                idx4[static_cast<int32_T>(ib - 1)] = static_cast<int32_T>
                    (wOffset + 1);
                x4[static_cast<int32_T>(ib - 1)] = b_x->data[wOffset];
                if (ib == 4) {
                    real_T tmp;
                    real_T tmp_0;
                    ib = static_cast<int32_T>(wOffset - nBlocks);
                    if (x4[0] <= x4[1]) {
                        i1 = 1;
                        bLen = 2;
                    } else {
                        i1 = 2;
                        bLen = 1;
                    }

                    if (x4[2] <= x4[3]) {
                        bLen2 = 3;
                        nPairs = 4;
                    } else {
                        bLen2 = 4;
                        nPairs = 3;
                    }

                    tmp = x4[static_cast<int32_T>(i1 - 1)];
                    tmp_0 = x4[static_cast<int32_T>(bLen2 - 1)];
                    if (tmp <= tmp_0) {
                        tmp = x4[static_cast<int32_T>(bLen - 1)];
                        if (tmp <= tmp_0) {
                            perm[0] = static_cast<int8_T>(i1);
                            perm[1] = static_cast<int8_T>(bLen);
                            perm[2] = static_cast<int8_T>(bLen2);
                            perm[3] = static_cast<int8_T>(nPairs);
                        } else if (tmp <= x4[static_cast<int32_T>(nPairs - 1)])
                        {
                            perm[0] = static_cast<int8_T>(i1);
                            perm[1] = static_cast<int8_T>(bLen2);
                            perm[2] = static_cast<int8_T>(bLen);
                            perm[3] = static_cast<int8_T>(nPairs);
                        } else {
                            perm[0] = static_cast<int8_T>(i1);
                            perm[1] = static_cast<int8_T>(bLen2);
                            perm[2] = static_cast<int8_T>(nPairs);
                            perm[3] = static_cast<int8_T>(bLen);
                        }
                    } else {
                        tmp_0 = x4[static_cast<int32_T>(nPairs - 1)];
                        if (tmp <= tmp_0) {
                            if (x4[static_cast<int32_T>(bLen - 1)] <= tmp_0) {
                                perm[0] = static_cast<int8_T>(bLen2);
                                perm[1] = static_cast<int8_T>(i1);
                                perm[2] = static_cast<int8_T>(bLen);
                                perm[3] = static_cast<int8_T>(nPairs);
                            } else {
                                perm[0] = static_cast<int8_T>(bLen2);
                                perm[1] = static_cast<int8_T>(i1);
                                perm[2] = static_cast<int8_T>(nPairs);
                                perm[3] = static_cast<int8_T>(bLen);
                            }
                        } else {
                            perm[0] = static_cast<int8_T>(bLen2);
                            perm[1] = static_cast<int8_T>(nPairs);
                            perm[2] = static_cast<int8_T>(i1);
                            perm[3] = static_cast<int8_T>(bLen);
                        }
                    }

                    idx->data[static_cast<int32_T>(ib - 2)] = idx4[static_cast<
                        int32_T>(static_cast<int32_T>(perm[0]) - 1)];
                    idx->data[static_cast<int32_T>(ib - 1)] = idx4[static_cast<
                        int32_T>(static_cast<int32_T>(perm[1]) - 1)];
                    idx->data[ib] = idx4[static_cast<int32_T>
                        (static_cast<int32_T>(perm[2]) - 1)];
                    idx->data[static_cast<int32_T>(ib + 1)] = idx4[static_cast<
                        int32_T>(static_cast<int32_T>(perm[3]) - 1)];
                    b_x->data[static_cast<int32_T>(ib - 2)] = x4
                        [static_cast<int32_T>(static_cast<int32_T>(perm[0]) - 1)];
                    b_x->data[static_cast<int32_T>(ib - 1)] = x4
                        [static_cast<int32_T>(static_cast<int32_T>(perm[1]) - 1)];
                    b_x->data[ib] = x4[static_cast<int32_T>(static_cast<int32_T>
                        (perm[2]) - 1)];
                    b_x->data[static_cast<int32_T>(ib + 1)] = x4
                        [static_cast<int32_T>(static_cast<int32_T>(perm[3]) - 1)];
                    ib = 0;
                }
            }
        }

        wOffset = static_cast<int32_T>(x->size[1] - nBlocks);
        if (ib > 0) {
            perm[1] = 0;
            perm[2] = 0;
            perm[3] = 0;
            switch (ib) {
              case 1:
                perm[0] = 1;
                break;

              case 2:
                if (x4[0] <= x4[1]) {
                    perm[0] = 1;
                    perm[1] = 2;
                } else {
                    perm[0] = 2;
                    perm[1] = 1;
                }
                break;

              default:
                if (x4[0] <= x4[1]) {
                    if (x4[1] <= x4[2]) {
                        perm[0] = 1;
                        perm[1] = 2;
                        perm[2] = 3;
                    } else if (x4[0] <= x4[2]) {
                        perm[0] = 1;
                        perm[1] = 3;
                        perm[2] = 2;
                    } else {
                        perm[0] = 3;
                        perm[1] = 1;
                        perm[2] = 2;
                    }
                } else if (x4[0] <= x4[2]) {
                    perm[0] = 2;
                    perm[1] = 1;
                    perm[2] = 3;
                } else if (x4[1] <= x4[2]) {
                    perm[0] = 2;
                    perm[1] = 3;
                    perm[2] = 1;
                } else {
                    perm[0] = 3;
                    perm[1] = 2;
                    perm[2] = 1;
                }
                break;
            }

            for (i1 = 0; i1 <= static_cast<int32_T>(ib - 1); i1 =
                    static_cast<int32_T>(i1 + 1)) {
                q = static_cast<int32_T>(static_cast<int32_T>(perm[i1]) - 1);
                c_iwork_tmp = static_cast<int32_T>(static_cast<int32_T>(
                    static_cast<int32_T>(wOffset - ib) + i1) + 1);
                idx->data[c_iwork_tmp] = idx4[q];
                b_x->data[c_iwork_tmp] = x4[q];
            }
        }

        ib = static_cast<int32_T>(static_cast<int32_T>(static_cast<int32_T>
            (nBlocks - 1) >> 1) + 1);
        for (i1 = 1; static_cast<int32_T>(i1 - 1) <= static_cast<int32_T>(ib - 2);
             i1 = static_cast<int32_T>(i1 + 1)) {
            bLen2 = static_cast<int32_T>(wOffset + i1);
            bLen = idx->data[bLen2];
            q = static_cast<int32_T>(n - i1);
            idx->data[bLen2] = idx->data[q];
            idx->data[q] = bLen;
            b_x->data[bLen2] = f->data[q];
            b_x->data[q] = f->data[bLen2];
        }

        if (static_cast<uint32_T>(static_cast<uint32_T>(static_cast<int32_T>
                (nBlocks - 1)) & 1U) != 0U) {
            n = static_cast<int32_T>(wOffset + ib);
            b_x->data[n] = f->data[n];
        }

        FlightMissionMode_emxInit_int32_T_k(&iwork, 1);
        c_iwork_tmp = iwork->size[0];
        iwork->size[0] = x->size[1];
        FlightMissionMode_emxEnsureCapacity_int32_T_j(iwork, c_iwork_tmp);
        i1 = x->size[1];
        for (ib = 0; ib <= static_cast<int32_T>(i1 - 1); ib++) {
            iwork->data[ib] = 0;
        }

        n = static_cast<int32_T>(static_cast<int32_T>(x->size[1] - nBlocks) + 1);
        wOffset = 2;
        if (n > 1) {
            if (x->size[1] >= 256) {
                nBlocks = static_cast<int32_T>(n >> 8);
                if (nBlocks > 0) {
                    for (ib = 0; ib <= static_cast<int32_T>(nBlocks - 1); ib =
                            static_cast<int32_T>(ib + 1)) {
                        i1 = static_cast<int32_T>(static_cast<int32_T>(ib << 8)
                            - 1);
                        for (wOffset = 0; wOffset < 6; wOffset++) {
                            bLen = static_cast<int32_T>(1 << static_cast<int32_T>
                                (wOffset + 2));
                            bLen2 = static_cast<int32_T>(bLen << 1);
                            nPairs = static_cast<int32_T>(256 >>
                                static_cast<int32_T>(wOffset + 3));
                            for (int32_T d_k{0}; d_k <= static_cast<int32_T>
                                    (nPairs - 1); d_k = static_cast<int32_T>(d_k
                                  + 1)) {
                                int32_T blockOffset;
                                int32_T p;
                                blockOffset = static_cast<int32_T>
                                    (static_cast<int32_T>(d_k * bLen2) + i1);
                                for (p = 0; p <= static_cast<int32_T>(bLen2 - 1);
                                     p = static_cast<int32_T>(p + 1)) {
                                    c_iwork_tmp = static_cast<int32_T>(
                                        static_cast<int32_T>(blockOffset + p) +
                                        1);
                                    c_iwork[p] = idx->data[c_iwork_tmp];
                                    b_xwork[p] = b_x->data[c_iwork_tmp];
                                }

                                p = 0;
                                q = bLen;
                                int32_T exitg1;
                                do {
                                    exitg1 = 0;
                                    blockOffset = static_cast<int32_T>
                                        (blockOffset + 1);
                                    if (b_xwork[p] <= b_xwork[q]) {
                                        idx->data[blockOffset] = c_iwork[p];
                                        b_x->data[blockOffset] = b_xwork[p];
                                        if (static_cast<int32_T>(p + 1) < bLen)
                                        {
                                            p = static_cast<int32_T>(p + 1);
                                        } else {
                                            exitg1 = 1;
                                        }
                                    } else {
                                        idx->data[blockOffset] = c_iwork[q];
                                        b_x->data[blockOffset] = b_xwork[q];
                                        if (static_cast<int32_T>(q + 1) < bLen2)
                                        {
                                            q = static_cast<int32_T>(q + 1);
                                        } else {
                                            blockOffset = static_cast<int32_T>
                                                (blockOffset - p);
                                            while (static_cast<int32_T>(p + 1) <=
                                                   bLen) {
                                                c_iwork_tmp =
                                                    static_cast<int32_T>(
                                                    static_cast<int32_T>
                                                    (blockOffset + p) + 1);
                                                idx->data[c_iwork_tmp] =
                                                    c_iwork[p];
                                                b_x->data[c_iwork_tmp] =
                                                    b_xwork[p];
                                                p = static_cast<int32_T>(p + 1);
                                            }

                                            exitg1 = 1;
                                        }
                                    }
                                } while (exitg1 == 0);
                            }
                        }
                    }

                    nBlocks = static_cast<int32_T>(nBlocks << 8);
                    wOffset = static_cast<int32_T>(n - nBlocks);
                    if (wOffset > 0) {
                        c_iwork_tmp = static_cast<int32_T>(c->size[0] * c->size
                            [1]);
                        c->size[0] = 1;
                        c->size[1] = idx->size[1];
                        FlightMissionMode_emxEnsureCapacity_int32_T_j(c,
                            c_iwork_tmp);
                        i1 = static_cast<int32_T>(idx->size[1] - 1);
                        for (ib = 0; ib <= i1; ib++) {
                            c->data[ib] = idx->data[ib];
                        }

                        c_iwork_tmp = static_cast<int32_T>(d->size[0] * d->size
                            [1]);
                        d->size[0] = 1;
                        d->size[1] = b_x->size[1];
                        FlightMissionMode_emxEnsureCapacity_real_T_c(d,
                            c_iwork_tmp);
                        i1 = static_cast<int32_T>(b_x->size[1] - 1);
                        for (ib = 0; ib <= i1; ib++) {
                            d->data[ib] = b_x->data[ib];
                        }

                        c_iwork_tmp = iwork->size[0];
                        iwork->size[0] = x->size[1];
                        FlightMissionMode_emxEnsureCapacity_int32_T_j(iwork,
                            c_iwork_tmp);
                        i1 = x->size[1];
                        for (ib = 0; ib <= static_cast<int32_T>(i1 - 1); ib++) {
                            iwork->data[ib] = 0;
                        }

                        FlightMissionMode_merge_block_f(c, d, nBlocks, wOffset,
                            2, iwork, f);
                        c_iwork_tmp = static_cast<int32_T>(b_x->size[0] *
                            b_x->size[1]);
                        b_x->size[0] = 1;
                        b_x->size[1] = d->size[1];
                        FlightMissionMode_emxEnsureCapacity_real_T_c(b_x,
                            c_iwork_tmp);
                        i1 = static_cast<int32_T>(d->size[1] - 1);
                        for (ib = 0; ib <= i1; ib++) {
                            b_x->data[ib] = d->data[ib];
                        }

                        c_iwork_tmp = static_cast<int32_T>(idx->size[0] *
                            idx->size[1]);
                        idx->size[0] = 1;
                        idx->size[1] = c->size[1];
                        FlightMissionMode_emxEnsureCapacity_int32_T_j(idx,
                            c_iwork_tmp);
                        i1 = static_cast<int32_T>(c->size[1] - 1);
                        for (ib = 0; ib <= i1; ib++) {
                            idx->data[ib] = c->data[ib];
                        }
                    }

                    wOffset = 8;
                }
            }

            c_iwork_tmp = static_cast<int32_T>(c->size[0] * c->size[1]);
            c->size[0] = 1;
            c->size[1] = idx->size[1];
            FlightMissionMode_emxEnsureCapacity_int32_T_j(c, c_iwork_tmp);
            i1 = static_cast<int32_T>(idx->size[1] - 1);
            for (ib = 0; ib <= i1; ib++) {
                c->data[ib] = idx->data[ib];
            }

            c_iwork_tmp = static_cast<int32_T>(d->size[0] * d->size[1]);
            d->size[0] = 1;
            d->size[1] = b_x->size[1];
            FlightMissionMode_emxEnsureCapacity_real_T_c(d, c_iwork_tmp);
            i1 = static_cast<int32_T>(b_x->size[1] - 1);
            for (ib = 0; ib <= i1; ib++) {
                d->data[ib] = b_x->data[ib];
            }

            FlightMissionMode_merge_block_f(c, d, 0, n, wOffset, iwork, f);
            c_iwork_tmp = static_cast<int32_T>(b_x->size[0] * b_x->size[1]);
            b_x->size[0] = 1;
            b_x->size[1] = d->size[1];
            FlightMissionMode_emxEnsureCapacity_real_T_c(b_x, c_iwork_tmp);
            i1 = static_cast<int32_T>(d->size[1] - 1);
            for (ib = 0; ib <= i1; ib++) {
                b_x->data[ib] = d->data[ib];
            }
        }

        FlightMissionMode_emxFree_int32_T_a(&idx);
        FlightMissionMode_emxFree_int32_T_a(&iwork);
    }

    c_iwork_tmp = static_cast<int32_T>(x->size[0] * x->size[1]);
    x->size[0] = 1;
    x->size[1] = b_x->size[1];
    FlightMissionMode_emxEnsureCapacity_real_T_c(x, c_iwork_tmp);
    i1 = b_x->size[1];
    for (ib = 0; ib <= static_cast<int32_T>(i1 - 1); ib++) {
        x->data[ib] = b_x->data[ib];
    }

    FlightMissionMode_emxFree_real_T_n(&b_x);
    FlightMissionMode_emxFree_real_T_n(&f);
    FlightMissionMode_emxFree_real_T_n(&d);
    FlightMissionMode_emxFree_int32_T_a(&c);
}

void FlightMissionMode::FlightMissionMode_emxInit_boolean_T_c
    (emxArray_boolean_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions)
{
    emxArray_boolean_T_FlightMissionMode_T *emxArray;
    *pEmxArray = static_cast<emxArray_boolean_T_FlightMissionMode_T *>(std::
        malloc(sizeof(emxArray_boolean_T_FlightMissionMode_T)));
    emxArray = *pEmxArray;
    emxArray->data = static_cast<boolean_T *>(nullptr);
    emxArray->numDimensions = numDimensions;
    emxArray->size = static_cast<int32_T *>(std::malloc(static_cast<uint32_T>
        (sizeof(int32_T) * static_cast<uint32_T>(numDimensions))));
    emxArray->allocatedSize = 0;
    emxArray->canFreeData = true;
    for (int32_T i{0}; i <= static_cast<int32_T>(numDimensions - 1); i++) {
        emxArray->size[i] = 0;
    }
}

void FlightMissionMode::FlightMissionMode_emxFree_boolean_T_n
    (emxArray_boolean_T_FlightMissionMode_T **pEmxArray)
{
    if (*pEmxArray != static_cast<emxArray_boolean_T_FlightMissionMode_T *>
            (nullptr)) {
        if (((*pEmxArray)->data != static_cast<boolean_T *>(nullptr)) &&
                (*pEmxArray)->canFreeData) {
            std::free((*pEmxArray)->data);
        }

        std::free((*pEmxArray)->size);
        std::free(*pEmxArray);
        *pEmxArray = static_cast<emxArray_boolean_T_FlightMissionMode_T *>
            (nullptr);
    }
}

void FlightMissionMode::FlightMissionMode_emxEnsureCapacity_boolean_T_f
    (emxArray_boolean_T_FlightMissionMode_T *emxArray, int32_T oldNumel)
{
    int32_T i;
    int32_T newNumel;
    void *newData;
    if (oldNumel < 0) {
        oldNumel = 0;
    }

    newNumel = 1;
    for (i = 0; i <= static_cast<int32_T>(emxArray->numDimensions - 1); i++) {
        newNumel = static_cast<int32_T>(newNumel * emxArray->size[i]);
    }

    if (newNumel > emxArray->allocatedSize) {
        i = emxArray->allocatedSize;
        if (i < 16) {
            i = 16;
        }

        while (i < newNumel) {
            if (i > 1073741823) {
                i = MAX_int32_T;
            } else {
                i = static_cast<int32_T>(i << 1);
            }
        }

        newData = std::calloc(static_cast<uint32_T>(i), sizeof(boolean_T));
        if (emxArray->data != nullptr) {
            std::memcpy(newData, emxArray->data, static_cast<uint32_T>(sizeof
                         (boolean_T) * static_cast<uint32_T>(oldNumel)));
            if (emxArray->canFreeData) {
                std::free(emxArray->data);
            }
        }

        emxArray->data = static_cast<boolean_T *>(newData);
        emxArray->allocatedSize = i;
        emxArray->canFreeData = true;
    }
}

void FlightMissionMode::FlightMissionMode_binary_expand_op_p
    (emxArray_boolean_T_FlightMissionMode_T *in1, const
     emxArray_real_T_FlightMissionMode_T *in2, const
     emxArray_real_T_FlightMissionMode_T *in3)
{
    int32_T i;
    int32_T loop_ub;
    int32_T stride_0_0;
    int32_T stride_1_0;
    i = in1->size[0];
    in1->size[0] = in3->size[0] == 1 ? in2->size[0] : in3->size[0];
    FlightMissionMode_emxEnsureCapacity_boolean_T_f(in1, i);
    stride_0_0 = (in2->size[0] != 1);
    stride_1_0 = (in3->size[0] != 1);
    loop_ub = in3->size[0] == 1 ? in2->size[0] : in3->size[0];
    for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
        in1->data[i] = static_cast<boolean_T>(static_cast<int32_T>((in2->data[
            static_cast<int32_T>(i * stride_0_0)] == 0.0) & (in3->data[
            static_cast<int32_T>(i * stride_1_0)] > 0.0)));
    }
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_wrapToPi_o
    (emxArray_real_T_FlightMissionMode_T *theta)
{
    emxArray_boolean_T_FlightMissionMode_T *x;
    emxArray_real_T_FlightMissionMode_T *y;
    int32_T k;
    int32_T loop_ub;
    boolean_T b_y;
    boolean_T exitg1;
    FlightMissionMode_emxInit_real_T_h(&y, 1);
    k = y->size[0];
    y->size[0] = theta->size[0];
    FlightMissionMode_emxEnsureCapacity_real_T_c(y, k);
    for (k = 0; k <= static_cast<int32_T>(theta->size[0] - 1); k = static_cast<
            int32_T>(k + 1)) {
        y->data[k] = std::abs(theta->data[k]);
    }

    FlightMissionMode_emxInit_boolean_T_c(&x, 1);
    k = x->size[0];
    x->size[0] = y->size[0];
    FlightMissionMode_emxEnsureCapacity_boolean_T_f(x, k);
    loop_ub = y->size[0];
    for (k = 0; k <= static_cast<int32_T>(loop_ub - 1); k++) {
        x->data[k] = (y->data[k] > 3.1415926535897931);
    }

    b_y = false;
    k = 1;
    exitg1 = false;
    while ((!exitg1) && (k <= x->size[0])) {
        if (x->data[static_cast<int32_T>(k - 1)]) {
            b_y = true;
            exitg1 = true;
        } else {
            k = static_cast<int32_T>(k + 1);
        }
    }

    if (b_y) {
        k = y->size[0];
        y->size[0] = theta->size[0];
        FlightMissionMode_emxEnsureCapacity_real_T_c(y, k);
        loop_ub = theta->size[0];
        for (k = 0; k <= static_cast<int32_T>(loop_ub - 1); k++) {
            y->data[k] = theta->data[k] + 3.1415926535897931;
        }

        k = theta->size[0];
        theta->size[0] = y->size[0];
        FlightMissionMode_emxEnsureCapacity_real_T_c(theta, k);
        for (k = 0; k <= static_cast<int32_T>(y->size[0] - 1); k = static_cast<
                int32_T>(k + 1)) {
            theta->data[k] = mod_d42kHWKw(y->data[k]);
        }

        if (theta->size[0] == y->size[0]) {
            k = x->size[0];
            x->size[0] = theta->size[0];
            FlightMissionMode_emxEnsureCapacity_boolean_T_f(x, k);
            loop_ub = theta->size[0];
            for (k = 0; k <= static_cast<int32_T>(loop_ub - 1); k++) {
                x->data[k] = static_cast<boolean_T>(static_cast<int32_T>
                    ((theta->data[k] == 0.0) & (y->data[k] > 0.0)));
            }
        } else {
            FlightMissionMode_binary_expand_op_p(x, theta, y);
        }

        for (k = 0; k <= static_cast<int32_T>(x->size[0] - 1); k = static_cast<
                int32_T>(k + 1)) {
            if (x->data[k]) {
                theta->data[k] = 6.2831853071795862;
            }
        }

        loop_ub = theta->size[0];
        for (k = 0; k <= static_cast<int32_T>(loop_ub - 1); k++) {
            theta->data[k] -= 3.1415926535897931;
        }
    }

    FlightMissionMode_emxFree_boolean_T_n(&x);
    FlightMissionMode_emxFree_real_T_n(&y);
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_eml_find_c(const
    emxArray_boolean_T_FlightMissionMode_T *x,
    emxArray_int32_T_FlightMissionMode_T *i)
{
    int32_T idx;
    int32_T ii;
    int32_T nx;
    boolean_T exitg1;
    nx = x->size[1];
    idx = 0;
    ii = static_cast<int32_T>(i->size[0] * i->size[1]);
    i->size[0] = 1;
    i->size[1] = x->size[1];
    FlightMissionMode_emxEnsureCapacity_int32_T_j(i, ii);
    ii = 0;
    exitg1 = false;
    while ((!exitg1) && (ii <= static_cast<int32_T>(nx - 1))) {
        if (x->data[ii]) {
            idx = static_cast<int32_T>(idx + 1);
            i->data[static_cast<int32_T>(idx - 1)] = static_cast<int32_T>(ii + 1);
            if (idx >= nx) {
                exitg1 = true;
            } else {
                ii = static_cast<int32_T>(ii + 1);
            }
        } else {
            ii = static_cast<int32_T>(ii + 1);
        }
    }

    if (x->size[1] == 1) {
        if (idx == 0) {
            i->size[0] = 1;
            i->size[1] = 0;
        }
    } else if (idx < 1) {
        i->size[1] = 0;
    } else {
        ii = static_cast<int32_T>(i->size[0] * i->size[1]);
        i->size[1] = idx;
        FlightMissionMode_emxEnsureCapacity_int32_T_j(i, ii);
    }
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_npg2ox3uz(const char_T
    a_data[], const int32_T a_size[2])
{
    boolean_T b_bool;
    b_bool = false;
    if ((a_size[1] == 1) && (a_data[0] == 'N')) {
        b_bool = true;
    }

    return b_bool;
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_npg2ox3uzp(const char_T
    a_data[], const int32_T a_size[2])
{
    static const char_T b[2]{ 'H', 'l' };

    boolean_T b_bool;
    b_bool = false;
    if (a_size[1] == 2) {
        int32_T kstr;
        kstr = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (kstr < 2) {
                if (a_data[kstr] != b[kstr]) {
                    exitg1 = 1;
                } else {
                    kstr = static_cast<int32_T>(kstr + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    return b_bool;
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_npg2ox3uzpm(const char_T
    a_data[], const int32_T a_size[2])
{
    static const char_T b[2]{ 'H', 'r' };

    boolean_T b_bool;
    b_bool = false;
    if (a_size[1] == 2) {
        int32_T kstr;
        kstr = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (kstr < 2) {
                if (a_data[kstr] != b[kstr]) {
                    exitg1 = 1;
                } else {
                    kstr = static_cast<int32_T>(kstr + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    return b_bool;
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_npg2ox3uzpmy(const char_T
    a_data[], const int32_T a_size[2])
{
    boolean_T b_bool;
    b_bool = false;
    if ((a_size[1] == 1) && (a_data[0] == 'L')) {
        b_bool = true;
    }

    return b_bool;
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_npg2ox3uzpmyq(const char_T
    a_data[], const int32_T a_size[2])
{
    boolean_T b_bool;
    b_bool = false;
    if ((a_size[1] == 1) && (a_data[0] == 'R')) {
        b_bool = true;
    }

    return b_bool;
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
boolean_T FlightMissionMode::FlightMissionMode_strcmp_npg2ox3uzpmyq2(const
    char_T a_data[], const int32_T a_size[2])
{
    boolean_T b_bool;
    b_bool = false;
    if ((a_size[1] == 1) && (a_data[0] == 'S')) {
        b_bool = true;
    }

    return b_bool;
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_mtimes_k(const
    emxArray_real_T_FlightMissionMode_T *A, const real_T B[4],
    emxArray_real_T_FlightMissionMode_T *C)
{
    int32_T i;
    int32_T m;
    m = A->size[0];
    i = static_cast<int32_T>(C->size[0] * C->size[1]);
    C->size[0] = A->size[0];
    C->size[1] = 2;
    FlightMissionMode_emxEnsureCapacity_real_T_c(C, i);
    for (i = 0; i <= static_cast<int32_T>(m - 1); i = static_cast<int32_T>(i + 1))
    {
        C->data[i] = A->data[static_cast<int32_T>(A->size[0] + i)] * B[1] +
            A->data[i] * B[0];
    }

    for (i = 0; i <= static_cast<int32_T>(m - 1); i = static_cast<int32_T>(i + 1))
    {
        C->data[static_cast<int32_T>(m + i)] = A->data[static_cast<int32_T>
            (A->size[0] + i)] * B[3] + A->data[i] * B[2];
    }
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_uavDubinsPathSegment_interpolate_a(
    const real_T b_this_StartPose[4], const real_T b_this_GoalPose[4], real_T
    b_this_FlightPathAngle, real_T b_this_AirSpeed, real_T
    b_this_MinTurningRadius, real_T b_this_HelixRadius, const
    cell_wrap_0_FlightMissionMode_T b_this_MotionTypes[4], const real_T
    b_this_MotionLengths[4], real_T b_this_Length,
    emxArray_real_T_FlightMissionMode_T *samples,
    emxArray_real_T_FlightMissionMode_T *poses)
{
    emxArray_boolean_T_FlightMissionMode_T *tempSamplesIndex;
    emxArray_boolean_T_FlightMissionMode_T *tempSamplesIndex_0;
    emxArray_int32_T_FlightMissionMode_T *ab;
    emxArray_real_T_FlightMissionMode_T *S;
    emxArray_real_T_FlightMissionMode_T *S_0;
    emxArray_real_T_FlightMissionMode_T *bb;
    emxArray_real_T_FlightMissionMode_T *d_x;
    emxArray_real_T_FlightMissionMode_T *ns;
    emxArray_real_T_FlightMissionMode_T *p;
    emxArray_real_T_FlightMissionMode_T *tempSamples;
    emxArray_real_T_FlightMissionMode_T *z;
    real_T state[6];
    real_T TransformMatrix[4];
    real_T tempMotionLength_data[4];
    real_T transLength_data[4];
    int32_T tempMotionLength_size[2];
    int32_T transLength_size[2];
    boolean_T tmp[4];
    FlightMissionMode_emxInit_real_T_h(&bb, 1);
    poses->size[0] = 0;
    poses->size[1] = 6;
    if ((static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(std::
            isnan(b_this_Length)) ^ 1))) && (samples->size[1] != 0)) {
        real_T b_b_tmp;
        real_T intermediateLength;
        real_T startIndex;
        real_T tempStartPose_idx_2;
        int32_T loop_ub;
        int32_T poses_0;
        int32_T tempMotionLength_data_tmp;
        tempStartPose_idx_2 = -b_this_StartPose[2];
        tempMotionLength_data_tmp = static_cast<int32_T>(poses->size[0] *
            poses->size[1]);
        poses->size[0] = samples->size[1];
        poses->size[1] = 6;
        FlightMissionMode_emxEnsureCapacity_real_T_c(poses,
            tempMotionLength_data_tmp);
        loop_ub = static_cast<int32_T>(static_cast<int32_T>(samples->size[1] * 6)
            - 1);
        for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <= loop_ub;
             tempMotionLength_data_tmp++) {
            poses->data[tempMotionLength_data_tmp] = 0.0;
        }

        b_b_tmp = std::cos(std::abs(b_this_FlightPathAngle));
        tempMotionLength_data_tmp = static_cast<int32_T>(samples->size[0] *
            samples->size[1]);
        samples->size[0] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T_c(samples,
            tempMotionLength_data_tmp);
        loop_ub = static_cast<int32_T>(samples->size[1] - 1);
        for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <= loop_ub;
             tempMotionLength_data_tmp++) {
            samples->data[tempMotionLength_data_tmp] *= b_b_tmp;
        }

        TransformMatrix[0] = b_this_MotionLengths[0] * b_b_tmp;
        TransformMatrix[1] = b_this_MotionLengths[1] * b_b_tmp;
        TransformMatrix[2] = b_this_MotionLengths[2] * b_b_tmp;
        tempMotionLength_size[0] = 1;
        tempMotionLength_size[1] = 4;
        tempMotionLength_data[0] = TransformMatrix[0];
        tempMotionLength_data[1] = TransformMatrix[1];
        tempMotionLength_data[2] = TransformMatrix[2];
        tempMotionLength_data[3] = b_this_MotionLengths[3] * b_b_tmp;
        FlightMissionMode_strcmp_npg2ox3u(b_this_MotionTypes, tmp);
        if (FlightMissionMode_any_o(tmp)) {
            tempMotionLength_size[0] = 1;
            tempMotionLength_size[1] = 3;
            tempMotionLength_data[0] = TransformMatrix[0];
            tempMotionLength_data[1] = TransformMatrix[1];
            tempMotionLength_data[2] = TransformMatrix[2];
        }

        FlightMissionMode_useConstantDim_d(tempMotionLength_data,
            tempMotionLength_size, transLength_data, transLength_size);
        FlightMissionMode_sort_c5e(samples);
        intermediateLength = 0.0;
        startIndex = 1.0;
        state[0] = b_this_StartPose[0];
        state[1] = -b_this_StartPose[1];
        state[3] = -b_this_StartPose[3];
        poses_0 = 0;
        FlightMissionMode_emxInit_boolean_T_c(&tempSamplesIndex, 2);
        FlightMissionMode_emxInit_real_T_h(&tempSamples, 1);
        FlightMissionMode_emxInit_real_T_h(&S, 1);
        FlightMissionMode_emxInit_real_T_h(&ns, 2);
        FlightMissionMode_emxInit_real_T_h(&z, 1);
        FlightMissionMode_emxInit_real_T_h(&p, 2);
        FlightMissionMode_emxInit_real_T_h(&d_x, 1);
        FlightMissionMode_emxInit_int32_T_k(&ab, 2);
        FlightMissionMode_emxInit_boolean_T_c(&tempSamplesIndex_0, 2);
        FlightMissionMode_emxInit_real_T_h(&S_0, 2);
        while (poses_0 <= static_cast<int32_T>(tempMotionLength_size[1] - 1)) {
            real_T radius;
            real_T samples_0;
            if (static_cast<int32_T>(poses_0 + 1) == 1) {
                tempMotionLength_data_tmp = static_cast<int32_T>
                    (tempSamplesIndex->size[0] * tempSamplesIndex->size[1]);
                tempSamplesIndex->size[0] = 1;
                tempSamplesIndex->size[1] = samples->size[1];
                FlightMissionMode_emxEnsureCapacity_boolean_T_f(tempSamplesIndex,
                    tempMotionLength_data_tmp);
                loop_ub = static_cast<int32_T>(samples->size[1] - 1);
                radius = (intermediateLength + tempMotionLength_data[0]) +
                    1.0E-6;
                for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <=
                     loop_ub; tempMotionLength_data_tmp++) {
                    samples_0 = samples->data[tempMotionLength_data_tmp];
                    tempSamplesIndex->data[tempMotionLength_data_tmp] =
                        static_cast<boolean_T>(static_cast<int32_T>((samples_0 >=
                        intermediateLength) & (samples_0 <= radius)));
                }
            } else {
                tempMotionLength_data_tmp = static_cast<int32_T>
                    (tempSamplesIndex->size[0] * tempSamplesIndex->size[1]);
                tempSamplesIndex->size[0] = 1;
                tempSamplesIndex->size[1] = samples->size[1];
                FlightMissionMode_emxEnsureCapacity_boolean_T_f(tempSamplesIndex,
                    tempMotionLength_data_tmp);
                loop_ub = static_cast<int32_T>(samples->size[1] - 1);
                radius = (intermediateLength + tempMotionLength_data[poses_0]) +
                    1.0E-6;
                for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <=
                     loop_ub; tempMotionLength_data_tmp++) {
                    samples_0 = samples->data[tempMotionLength_data_tmp];
                    tempSamplesIndex->data[tempMotionLength_data_tmp] =
                        static_cast<boolean_T>(static_cast<int32_T>((samples_0 >
                        intermediateLength) & (samples_0 <= radius)));
                }
            }

            tempMotionLength_data_tmp = static_cast<int32_T>
                (tempSamplesIndex_0->size[0] * tempSamplesIndex_0->size[1]);
            tempSamplesIndex_0->size[0] = 1;
            tempSamplesIndex_0->size[1] = tempSamplesIndex->size[1];
            FlightMissionMode_emxEnsureCapacity_boolean_T_f(tempSamplesIndex_0,
                tempMotionLength_data_tmp);
            loop_ub = tempSamplesIndex->size[1];
            for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <=
                    static_cast<int32_T>(loop_ub - 1); tempMotionLength_data_tmp
                    ++) {
                tempSamplesIndex_0->data[tempMotionLength_data_tmp] =
                    tempSamplesIndex->data[tempMotionLength_data_tmp];
            }

            FlightMissionMode_eml_find_c(tempSamplesIndex_0, ab);
            if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                    (FlightMissionMode_strcmp_npg2ox3uz
                     (b_this_MotionTypes[poses_0].f1.data,
                      b_this_MotionTypes[poses_0].f1.size)) ^ 1))) {
                real_T TransformMatrix_tmp;
                int32_T count;
                int32_T tempMotionLength_data_tmp_0;
                radius = b_this_MinTurningRadius;
                if (FlightMissionMode_strcmp_npg2ox3uzp
                        (b_this_MotionTypes[poses_0].f1.data,
                         b_this_MotionTypes[poses_0].f1.size)) {
                    radius = b_this_HelixRadius;
                } else if (FlightMissionMode_strcmp_npg2ox3uzpm
                           (b_this_MotionTypes[poses_0].f1.data,
                            b_this_MotionTypes[poses_0].f1.size)) {
                    radius = b_this_HelixRadius;
                }

                count = 0;
                tempMotionLength_data_tmp = tempSamples->size[0];
                tempSamples->size[0] = 1;
                FlightMissionMode_emxEnsureCapacity_real_T_c(tempSamples,
                    tempMotionLength_data_tmp);
                tempSamples->data[0] = 0.0;
                if (ab->size[1] != 0) {
                    tempMotionLength_data_tmp = tempSamples->size[0];
                    tempSamples->size[0] = static_cast<int32_T>(ab->size[1] + 1);
                    FlightMissionMode_emxEnsureCapacity_real_T_c(tempSamples,
                        tempMotionLength_data_tmp);
                    loop_ub = ab->size[1];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= loop_ub;
                            tempMotionLength_data_tmp++) {
                        tempSamples->data[tempMotionLength_data_tmp] = 0.0;
                    }

                    count = ab->size[1];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (count - 1); tempMotionLength_data_tmp++) {
                        tempSamples->data[tempMotionLength_data_tmp] =
                            samples->data[static_cast<int32_T>(ab->
                            data[tempMotionLength_data_tmp] - 1)];
                    }

                    count = ab->size[1];
                    loop_ub = static_cast<int32_T>(ab->size[1] - 1);
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= loop_ub;
                            tempMotionLength_data_tmp++) {
                        samples->data[static_cast<int32_T>(ab->
                            data[tempMotionLength_data_tmp] - 1)] = -1.0;
                    }
                }

                tempSamples->data[count] = transLength_data[poses_0];
                tempMotionLength_data_tmp = S->size[0];
                S->size[0] = tempSamples->size[0];
                FlightMissionMode_emxEnsureCapacity_real_T_c(S,
                    tempMotionLength_data_tmp);
                loop_ub = tempSamples->size[0];
                for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <=
                     static_cast<int32_T>(loop_ub - 1);
                        tempMotionLength_data_tmp++) {
                    S->data[tempMotionLength_data_tmp] = (tempSamples->
                        data[tempMotionLength_data_tmp] - intermediateLength) /
                        radius;
                }

                tempMotionLength_data_tmp = static_cast<int32_T>(ns->size[0] *
                    ns->size[1]);
                ns->size[0] = S->size[0];
                ns->size[1] = 6;
                FlightMissionMode_emxEnsureCapacity_real_T_c(ns,
                    tempMotionLength_data_tmp);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(S->size[0] *
                    6) - 1);
                for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <=
                     loop_ub; tempMotionLength_data_tmp++) {
                    ns->data[tempMotionLength_data_tmp] = 0.0;
                }

                tempMotionLength_data_tmp = z->size[0];
                z->size[0] = tempSamples->size[0];
                FlightMissionMode_emxEnsureCapacity_real_T_c(z,
                    tempMotionLength_data_tmp);
                loop_ub = tempSamples->size[0];
                for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <=
                     static_cast<int32_T>(loop_ub - 1);
                        tempMotionLength_data_tmp++) {
                    z->data[tempMotionLength_data_tmp] = tempStartPose_idx_2 +
                        tempSamples->data[tempMotionLength_data_tmp];
                }

                samples_0 = std::sin(state[3]);
                TransformMatrix_tmp = std::cos(state[3]);
                TransformMatrix[0] = TransformMatrix_tmp;
                TransformMatrix[2] = samples_0;
                TransformMatrix[1] = -samples_0;
                TransformMatrix[3] = TransformMatrix_tmp;
                if (b_this_Length != 0.0) {
                    samples_0 = -b_this_GoalPose[2] - tempStartPose_idx_2;
                    TransformMatrix_tmp = b_this_Length * b_b_tmp;
                    tempMotionLength_data_tmp = z->size[0];
                    z->size[0] = tempSamples->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T_c(z,
                        tempMotionLength_data_tmp);
                    loop_ub = tempSamples->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        z->data[tempMotionLength_data_tmp] = tempSamples->
                            data[tempMotionLength_data_tmp] /
                            TransformMatrix_tmp * samples_0 +
                            tempStartPose_idx_2;
                    }
                }

                if (FlightMissionMode_strcmp_npg2ox3uzp
                        (b_this_MotionTypes[poses_0].f1.data,
                         b_this_MotionTypes[poses_0].f1.size) ||
                        FlightMissionMode_strcmp_npg2ox3uzpmy
                        (b_this_MotionTypes[poses_0].f1.data,
                         b_this_MotionTypes[poses_0].f1.size)) {
                    real_T state_0;
                    real_T state_1;
                    tempMotionLength_data_tmp = tempSamples->size[0];
                    tempSamples->size[0] = S->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T_c(tempSamples,
                        tempMotionLength_data_tmp);
                    loop_ub = S->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        tempSamples->data[tempMotionLength_data_tmp] = S->
                            data[tempMotionLength_data_tmp];
                    }

                    for (count = 0; count <= static_cast<int32_T>(S->size[0] - 1);
                         count = static_cast<int32_T>(count + 1)) {
                        tempSamples->data[count] = std::sin(tempSamples->
                            data[count]);
                    }

                    tempMotionLength_data_tmp = d_x->size[0];
                    d_x->size[0] = S->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T_c(d_x,
                        tempMotionLength_data_tmp);
                    loop_ub = S->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        d_x->data[tempMotionLength_data_tmp] = S->
                            data[tempMotionLength_data_tmp];
                    }

                    for (count = 0; count <= static_cast<int32_T>(S->size[0] - 1);
                         count = static_cast<int32_T>(count + 1)) {
                        d_x->data[count] = std::cos(d_x->data[count]);
                    }

                    tempMotionLength_data_tmp = static_cast<int32_T>(S_0->size[0]
                        * S_0->size[1]);
                    S_0->size[0] = tempSamples->size[0];
                    S_0->size[1] = 2;
                    FlightMissionMode_emxEnsureCapacity_real_T_c(S_0,
                        tempMotionLength_data_tmp);
                    loop_ub = tempSamples->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        S_0->data[tempMotionLength_data_tmp] = tempSamples->
                            data[tempMotionLength_data_tmp];
                    }

                    loop_ub = d_x->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        S_0->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + tempSamples->size[0])] = 1.0 - d_x->
                            data[tempMotionLength_data_tmp];
                    }

                    FlightMissionMode_mtimes_k(S_0, TransformMatrix, p);
                    samples_0 = rt_atan2d_snf(b_this_AirSpeed * b_this_AirSpeed,
                        9.8 * radius);
                    TransformMatrix_tmp = state[0];
                    state_0 = state[1];
                    state_1 = state[3];
                    count = S->size[0];
                    tempMotionLength_data_tmp_0 = S->size[0];
                    loop_ub = p->size[0];
                    tempMotionLength_data_tmp = static_cast<int32_T>(ns->size[0]
                        * ns->size[1]);
                    ns->size[0] = p->size[0];
                    ns->size[1] = 6;
                    FlightMissionMode_emxEnsureCapacity_real_T_c(ns,
                        tempMotionLength_data_tmp);
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        ns->data[tempMotionLength_data_tmp] = p->
                            data[tempMotionLength_data_tmp] * radius +
                            TransformMatrix_tmp;
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + ns->size[0])] = p->data[static_cast<int32_T>
                            (tempMotionLength_data_tmp + p->size[0])] * radius +
                            state_0;
                    }

                    loop_ub = z->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] << 1))] = z->
                            data[tempMotionLength_data_tmp];
                    }

                    loop_ub = S->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] * 3))] = state_1
                            + S->data[tempMotionLength_data_tmp];
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (count - 1); tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] << 2))] =
                            b_this_FlightPathAngle;
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (tempMotionLength_data_tmp_0 - 1);
                            tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] * 5))] =
                            -samples_0;
                    }
                } else if (FlightMissionMode_strcmp_npg2ox3uzpm
                           (b_this_MotionTypes[poses_0].f1.data,
                            b_this_MotionTypes[poses_0].f1.size) ||
                           FlightMissionMode_strcmp_npg2ox3uzpmyq
                           (b_this_MotionTypes[poses_0].f1.data,
                            b_this_MotionTypes[poses_0].f1.size)) {
                    real_T state_0;
                    real_T state_1;
                    tempMotionLength_data_tmp = tempSamples->size[0];
                    tempSamples->size[0] = S->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T_c(tempSamples,
                        tempMotionLength_data_tmp);
                    loop_ub = S->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        tempSamples->data[tempMotionLength_data_tmp] = S->
                            data[tempMotionLength_data_tmp];
                    }

                    for (count = 0; count <= static_cast<int32_T>(S->size[0] - 1);
                         count = static_cast<int32_T>(count + 1)) {
                        tempSamples->data[count] = std::sin(tempSamples->
                            data[count]);
                    }

                    tempMotionLength_data_tmp = d_x->size[0];
                    d_x->size[0] = S->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T_c(d_x,
                        tempMotionLength_data_tmp);
                    loop_ub = S->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        d_x->data[tempMotionLength_data_tmp] = S->
                            data[tempMotionLength_data_tmp];
                    }

                    for (count = 0; count <= static_cast<int32_T>(S->size[0] - 1);
                         count = static_cast<int32_T>(count + 1)) {
                        d_x->data[count] = std::cos(d_x->data[count]);
                    }

                    tempMotionLength_data_tmp = static_cast<int32_T>(S_0->size[0]
                        * S_0->size[1]);
                    S_0->size[0] = tempSamples->size[0];
                    S_0->size[1] = 2;
                    FlightMissionMode_emxEnsureCapacity_real_T_c(S_0,
                        tempMotionLength_data_tmp);
                    loop_ub = tempSamples->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        S_0->data[tempMotionLength_data_tmp] = tempSamples->
                            data[tempMotionLength_data_tmp];
                    }

                    loop_ub = d_x->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        S_0->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + tempSamples->size[0])] = d_x->
                            data[tempMotionLength_data_tmp] - 1.0;
                    }

                    FlightMissionMode_mtimes_k(S_0, TransformMatrix, p);
                    samples_0 = rt_atan2d_snf(b_this_AirSpeed * b_this_AirSpeed,
                        9.8 * radius);
                    TransformMatrix_tmp = state[0];
                    state_0 = state[1];
                    state_1 = state[3];
                    count = S->size[0];
                    tempMotionLength_data_tmp_0 = S->size[0];
                    loop_ub = p->size[0];
                    tempMotionLength_data_tmp = static_cast<int32_T>(ns->size[0]
                        * ns->size[1]);
                    ns->size[0] = p->size[0];
                    ns->size[1] = 6;
                    FlightMissionMode_emxEnsureCapacity_real_T_c(ns,
                        tempMotionLength_data_tmp);
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        ns->data[tempMotionLength_data_tmp] = p->
                            data[tempMotionLength_data_tmp] * radius +
                            TransformMatrix_tmp;
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + ns->size[0])] = p->data[static_cast<int32_T>
                            (tempMotionLength_data_tmp + p->size[0])] * radius +
                            state_0;
                    }

                    loop_ub = z->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] << 1))] = z->
                            data[tempMotionLength_data_tmp];
                    }

                    loop_ub = S->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] * 3))] = state_1
                            - S->data[tempMotionLength_data_tmp];
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (count - 1); tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] << 2))] =
                            b_this_FlightPathAngle;
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (tempMotionLength_data_tmp_0 - 1);
                            tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] * 5))] =
                            samples_0;
                    }
                } else if (FlightMissionMode_strcmp_npg2ox3uzpmyq2
                           (b_this_MotionTypes[poses_0].f1.data,
                            b_this_MotionTypes[poses_0].f1.size)) {
                    real_T state_0;
                    int32_T S_idx_0;
                    count = S->size[0];
                    tempMotionLength_data_tmp = static_cast<int32_T>(S_0->size[0]
                        * S_0->size[1]);
                    S_0->size[0] = S->size[0];
                    S_0->size[1] = 2;
                    FlightMissionMode_emxEnsureCapacity_real_T_c(S_0,
                        tempMotionLength_data_tmp);
                    loop_ub = S->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        S_0->data[tempMotionLength_data_tmp] = S->
                            data[tempMotionLength_data_tmp];
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (count - 1); tempMotionLength_data_tmp++) {
                        S_0->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + S->size[0])] = 0.0;
                    }

                    FlightMissionMode_mtimes_k(S_0, TransformMatrix, p);
                    TransformMatrix_tmp = state[0];
                    state_0 = state[1];
                    count = S->size[0];
                    tempMotionLength_data_tmp_0 = S->size[0];
                    S_idx_0 = S->size[0];
                    loop_ub = p->size[0];
                    tempMotionLength_data_tmp = static_cast<int32_T>(ns->size[0]
                        * ns->size[1]);
                    ns->size[0] = p->size[0];
                    ns->size[1] = 6;
                    FlightMissionMode_emxEnsureCapacity_real_T_c(ns,
                        tempMotionLength_data_tmp);
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        ns->data[tempMotionLength_data_tmp] = p->
                            data[tempMotionLength_data_tmp] * radius +
                            TransformMatrix_tmp;
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + ns->size[0])] = p->data[static_cast<int32_T>
                            (tempMotionLength_data_tmp + p->size[0])] * radius +
                            state_0;
                    }

                    loop_ub = z->size[0];
                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (loop_ub - 1); tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] << 1))] = z->
                            data[tempMotionLength_data_tmp];
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (count - 1); tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] * 3))] = state[3];
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (tempMotionLength_data_tmp_0 - 1);
                            tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] << 2))] =
                            b_this_FlightPathAngle;
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= static_cast<int32_T>
                            (S_idx_0 - 1); tempMotionLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(tempMotionLength_data_tmp
                            + static_cast<int32_T>(ns->size[0] * 5))] = 0.0;
                    }
                }

                if (ab->size[1] != 0) {
                    if (startIndex > (startIndex + static_cast<real_T>(ab->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp < 6;
                            tempMotionLength_data_tmp++) {
                        for (tempMotionLength_data_tmp_0 = 0;
                                tempMotionLength_data_tmp_0 <= loop_ub;
                                tempMotionLength_data_tmp_0++) {
                            poses->data[static_cast<int32_T>(static_cast<int32_T>
                                (static_cast<int32_T>(count +
                                tempMotionLength_data_tmp_0) +
                                 static_cast<int32_T>(poses->size[0] *
                                tempMotionLength_data_tmp)) - 1)] = ns->data[
                                static_cast<int32_T>(static_cast<int32_T>
                                (ns->size[0] * tempMotionLength_data_tmp) +
                                tempMotionLength_data_tmp_0)];
                        }
                    }

                    if (startIndex > (startIndex + static_cast<real_T>(ab->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= loop_ub;
                            tempMotionLength_data_tmp++) {
                        poses->data[static_cast<int32_T>(static_cast<int32_T>
                            (count + tempMotionLength_data_tmp) - 1)] = ns->
                            data[tempMotionLength_data_tmp];
                    }

                    if (startIndex > (startIndex + static_cast<real_T>(ab->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= loop_ub;
                            tempMotionLength_data_tmp++) {
                        poses->data[static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>(count +
                            tempMotionLength_data_tmp) + poses->size[0]) - 1)] =
                            -ns->data[static_cast<int32_T>
                            (tempMotionLength_data_tmp + ns->size[0])];
                    }

                    if (startIndex > (startIndex + static_cast<real_T>(ab->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= loop_ub;
                            tempMotionLength_data_tmp++) {
                        poses->data[static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>(count +
                            tempMotionLength_data_tmp) + static_cast<int32_T>
                            (poses->size[0] << 1)) - 1)] = -ns->data[
                            static_cast<int32_T>(static_cast<int32_T>(ns->size[0]
                            << 1) + tempMotionLength_data_tmp)];
                    }

                    if (startIndex > (startIndex + static_cast<real_T>(ab->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (tempMotionLength_data_tmp = 0;
                            tempMotionLength_data_tmp <= loop_ub;
                            tempMotionLength_data_tmp++) {
                        poses->data[static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>(count +
                            tempMotionLength_data_tmp) + static_cast<int32_T>
                            (poses->size[0] * 3)) - 1)] = -ns->data[static_cast<
                            int32_T>(static_cast<int32_T>(ns->size[0] * 3) +
                                     tempMotionLength_data_tmp)];
                    }
                }

                count = ns->size[0];
                for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <
                        6; tempMotionLength_data_tmp++) {
                    state[tempMotionLength_data_tmp] = ns->data
                        [static_cast<int32_T>(static_cast<int32_T>
                        (static_cast<int32_T>(ns->size[0] *
                        tempMotionLength_data_tmp) + count) - 1)];
                }

                startIndex += static_cast<real_T>(ab->size[1]);
            }

            intermediateLength += tempMotionLength_data[poses_0];
            poses_0 = static_cast<int32_T>(poses_0 + 1);
        }

        FlightMissionMode_emxFree_real_T_n(&S_0);
        FlightMissionMode_emxFree_boolean_T_n(&tempSamplesIndex_0);
        FlightMissionMode_emxFree_int32_T_a(&ab);
        FlightMissionMode_emxFree_real_T_n(&d_x);
        FlightMissionMode_emxFree_real_T_n(&p);
        FlightMissionMode_emxFree_real_T_n(&z);
        FlightMissionMode_emxFree_real_T_n(&ns);
        FlightMissionMode_emxFree_real_T_n(&S);
        FlightMissionMode_emxFree_real_T_n(&tempSamples);
        FlightMissionMode_emxFree_boolean_T_n(&tempSamplesIndex);
        loop_ub = poses->size[0];
        tempMotionLength_data_tmp = bb->size[0];
        bb->size[0] = poses->size[0];
        FlightMissionMode_emxEnsureCapacity_real_T_c(bb,
            tempMotionLength_data_tmp);
        for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <=
                static_cast<int32_T>(loop_ub - 1); tempMotionLength_data_tmp++)
        {
            bb->data[tempMotionLength_data_tmp] = poses->data
                [static_cast<int32_T>(static_cast<int32_T>(poses->size[0] * 3) +
                tempMotionLength_data_tmp)];
        }

        FlightMissionMode_wrapToPi_o(bb);
        loop_ub = bb->size[0];
        for (tempMotionLength_data_tmp = 0; tempMotionLength_data_tmp <=
                static_cast<int32_T>(loop_ub - 1); tempMotionLength_data_tmp++)
        {
            poses->data[static_cast<int32_T>(tempMotionLength_data_tmp +
                static_cast<int32_T>(poses->size[0] * 3))] = bb->
                data[tempMotionLength_data_tmp];
        }
    }

    FlightMissionMode_emxFree_real_T_n(&bb);
}

// Function for MATLAB Function: '<S38>/WayPointGenerator'
void FlightMissionMode::FlightMissionMode_genSegWP_m(const real_T start[4],
    const real_T ende[4], real_T numWPs, emxArray_real_T_FlightMissionMode_T
    *segWayPoints)
{
    emxArray_real_T_FlightMissionMode_T *lengths;
    emxArray_real_T_FlightMissionMode_T *poses;
    uavDubinsConnection_FlightMissionMode_T *obj;
    uavDubinsPathSegment_FlightMissionMode_T pathSegObj;
    real_T b_a__1_data[28];
    real_T iia_data_0[28];
    real_T a__1;
    int32_T iia_data[28];
    int32_T b_a__1_size[2];
    int32_T ib_size;
    int32_T iia_size;
    int32_T nm1d2;
    obj = FlightMissionMode_DubinsObjSingleton_getConnector_gb();
    FlightMissionMode_do_vectors_m(b_a__1_data, b_a__1_size, iia_data, &nm1d2,
        &ib_size);
    iia_size = nm1d2;
    for (ib_size = 0; ib_size <= static_cast<int32_T>(nm1d2 - 1); ib_size++) {
        iia_data_0[ib_size] = static_cast<real_T>(iia_data[ib_size]);
    }

    FlightMissionMode_do_vectors_mj(iia_data_0, &iia_size, b_a__1_data,
        b_a__1_size, iia_data, &nm1d2, &ib_size);
    for (ib_size = 0; ib_size <= static_cast<int32_T>(nm1d2 - 1); ib_size++) {
        iia_data_0[ib_size] = static_cast<real_T>(iia_data[ib_size]);
    }

    FlightMissionMode_sort_c5(iia_data_0, &nm1d2);
    for (ib_size = 0; ib_size <= static_cast<int32_T>(nm1d2 - 1); ib_size++) {
        b_a__1_data[ib_size] = iia_data_0[ib_size] - 1.0;
    }

    FlightMissionMode_uavDubinsBuiltins_connect_i(obj, start, ende,
        obj->MinTurningRadius, b_a__1_data, &nm1d2, &pathSegObj, &a__1);
    a__1 = pathSegObj.Length / numWPs;
    FlightMissionMode_emxInit_real_T_h(&lengths, 2);
    if (std::isnan(a__1)) {
        nm1d2 = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        lengths->size[1] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T_c(lengths, nm1d2);
        lengths->data[0] = (rtNaN);
    } else if (std::isnan(pathSegObj.Length)) {
        nm1d2 = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        lengths->size[1] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T_c(lengths, nm1d2);
        lengths->data[0] = (rtNaN);
    } else if (a__1 == 0.0) {
        lengths->size[0] = 1;
        lengths->size[1] = 0;
    } else if ((pathSegObj.Length > 0.0) && (a__1 < 0.0)) {
        lengths->size[0] = 1;
        lengths->size[1] = 0;
    } else if ((pathSegObj.Length < 0.0) && (a__1 > 0.0)) {
        lengths->size[0] = 1;
        lengths->size[1] = 0;
    } else if (std::isinf(pathSegObj.Length) && std::isinf(a__1)) {
        nm1d2 = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        lengths->size[1] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T_c(lengths, nm1d2);
        lengths->data[0] = (rtNaN);
    } else if (std::isinf(a__1)) {
        nm1d2 = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        lengths->size[1] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T_c(lengths, nm1d2);
        lengths->data[0] = 0.0;
    } else if (std::floor(a__1) == a__1) {
        nm1d2 = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        iia_size = static_cast<int32_T>(pathSegObj.Length / a__1);
        lengths->size[1] = static_cast<int32_T>(iia_size + 1);
        FlightMissionMode_emxEnsureCapacity_real_T_c(lengths, nm1d2);
        for (ib_size = 0; ib_size <= iia_size; ib_size++) {
            lengths->data[ib_size] = a__1 * static_cast<real_T>(ib_size);
        }
    } else {
        real_T apnd;
        real_T cdiff;
        real_T ndbl;
        ndbl = std::floor(pathSegObj.Length / a__1 + 0.5);
        apnd = ndbl * a__1;
        if (a__1 > 0.0) {
            cdiff = apnd - pathSegObj.Length;
        } else {
            cdiff = pathSegObj.Length - apnd;
        }

        if (std::abs(cdiff) < 4.4408920985006262E-16 * std::fmax(0.0, std::abs
                (pathSegObj.Length))) {
            ndbl++;
            apnd = pathSegObj.Length;
        } else if (cdiff > 0.0) {
            apnd = (ndbl - 1.0) * a__1;
        } else {
            ndbl++;
        }

        if (ndbl >= 0.0) {
            ib_size = static_cast<int32_T>(static_cast<int32_T>(ndbl) - 1);
        } else {
            ib_size = -1;
        }

        nm1d2 = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        lengths->size[1] = static_cast<int32_T>(ib_size + 1);
        FlightMissionMode_emxEnsureCapacity_real_T_c(lengths, nm1d2);
        if (static_cast<int32_T>(ib_size + 1) > 0) {
            lengths->data[0] = 0.0;
            if (static_cast<int32_T>(ib_size + 1) > 1) {
                lengths->data[ib_size] = apnd;
                nm1d2 = static_cast<int32_T>(ib_size / 2);
                for (iia_size = 1; static_cast<int32_T>(iia_size - 1) <=
                        static_cast<int32_T>(nm1d2 - 2); iia_size = static_cast<
                        int32_T>(iia_size + 1)) {
                    ndbl = static_cast<real_T>(iia_size) * a__1;
                    lengths->data[iia_size] = ndbl;
                    lengths->data[static_cast<int32_T>(ib_size - iia_size)] =
                        apnd - ndbl;
                }

                if (static_cast<int32_T>(nm1d2 << 1) == ib_size) {
                    lengths->data[nm1d2] = apnd / 2.0;
                } else {
                    ndbl = static_cast<real_T>(nm1d2) * a__1;
                    lengths->data[nm1d2] = ndbl;
                    lengths->data[static_cast<int32_T>(nm1d2 + 1)] = apnd - ndbl;
                }
            }
        }
    }

    FlightMissionMode_emxInit_real_T_h(&poses, 2);
    FlightMissionMode_uavDubinsPathSegment_interpolate_a(pathSegObj.StartPose,
        pathSegObj.GoalPose, pathSegObj.FlightPathAngle, pathSegObj.AirSpeed,
        pathSegObj.MinTurningRadius, pathSegObj.HelixRadius,
        pathSegObj.MotionTypes, pathSegObj.MotionLengths, pathSegObj.Length,
        lengths, poses);
    iia_size = poses->size[0];
    nm1d2 = static_cast<int32_T>(segWayPoints->size[0] * segWayPoints->size[1]);
    segWayPoints->size[0] = poses->size[0];
    segWayPoints->size[1] = 3;
    FlightMissionMode_emxEnsureCapacity_real_T_c(segWayPoints, nm1d2);
    FlightMissionMode_emxFree_real_T_n(&lengths);
    for (ib_size = 0; ib_size < 3; ib_size++) {
        for (nm1d2 = 0; nm1d2 <= static_cast<int32_T>(iia_size - 1); nm1d2++) {
            segWayPoints->data[static_cast<int32_T>(nm1d2 + static_cast<int32_T>
                (segWayPoints->size[0] * ib_size))] = poses->data
                [static_cast<int32_T>(static_cast<int32_T>(poses->size[0] *
                ib_size) + nm1d2)];
        }
    }

    FlightMissionMode_emxFree_real_T_n(&poses);
}

// System initialize for referenced model: 'FlightMissionMode'
void FlightMissionMode::init(FixedWingGuidanceBus *rty_GuidanceCmds, real_T
    rty_InitialState[8])
{
    // local block i/o variables
    real_T rtb_TmpSignalConversionAtRotateATRunWayHdgInport1[3];
    real_T rtb_TmpSignalConversionAtRotateATMissionHdgInport1[3];
    real_T rtb_TmpSignalConversionAtRotateUpwardInport1[3];
    real_T rtb_TmpSignalConversionAtRotateATRunWayHdgInport1_l[3];
    real_T rtb_TmpSignalConversionAtRotateATMissionHdgInport1_p[3];
    real_T rtb_TmpSignalConversionAtRotateATMissionHdgInport1_i[3];
    FILE* a;

    // Start for SwitchCase: '<Root>/Switch Case'
    FlightMissionMode_DW.SwitchCase_ActiveSubsystem = -1;

    // SystemInitialize for IfAction SubSystem: '<Root>/Mode1_CirclingNav'
    // Start for MATLABSystem: '<S9>/Orbit Follower'
    FlightMissionMode_DW.objisempty_b = true;
    FlightMissionMode_DW.obj_f.isInitialized = 1;
    FlightMissionMode_DW.obj_f.PrevResetSignal = 0.0;
    FlightMissionMode_DW.obj_f.NumCircles = 0.0;

    // InitializeConditions for MATLABSystem: '<S9>/Orbit Follower'
    FlightMissionMode_DW.obj_f.OrbitRadiusInternal = (rtNaN);
    FlightMissionMode_DW.obj_f.PrevResetSignal *= 0.0;
    FlightMissionMode_DW.obj_f.NumCircles *= 0.0;

    // Start for MATLABSystem: '<S9>/Orbit Follower'
    FlightMissionMode_DW.obj_f.PrevPosition[0] = 0.0;

    // InitializeConditions for MATLABSystem: '<S9>/Orbit Follower'
    FlightMissionMode_DW.obj_f.OrbitCenterInternal[0] = (rtNaN);
    FlightMissionMode_DW.obj_f.PrevPosition[0] *= 0.0;

    // Start for MATLABSystem: '<S9>/Orbit Follower'
    FlightMissionMode_DW.obj_f.PrevPosition[1] = 0.0;

    // InitializeConditions for MATLABSystem: '<S9>/Orbit Follower'
    FlightMissionMode_DW.obj_f.OrbitCenterInternal[1] = (rtNaN);
    FlightMissionMode_DW.obj_f.PrevPosition[1] *= 0.0;

    // Start for MATLABSystem: '<S9>/Orbit Follower'
    FlightMissionMode_DW.obj_f.PrevPosition[2] = 0.0;

    // InitializeConditions for MATLABSystem: '<S9>/Orbit Follower'
    FlightMissionMode_DW.obj_f.OrbitCenterInternal[2] = (rtNaN);
    FlightMissionMode_DW.obj_f.PrevPosition[2] *= 0.0;
    FlightMissionMode_DW.obj_f.StartFlag = true;
    FlightMissionMode_DW.obj_f.SelectTurnDirectionFlag = true;
    FlightMissionMode_DW.obj_f.TurnDirectionInternal = 1.0;
    FlightMissionMode_DW.obj_f.OrbitRadiusFlag = 0U;
    FlightMissionMode_DW.obj_f.LookaheadDistFlag = 0U;

    // End of SystemInitialize for SubSystem: '<Root>/Mode1_CirclingNav'

    // SystemInitialize for IfAction SubSystem: '<Root>/Mode2_HorzScanNav'
    // SystemInitialize for Enabled SubSystem: '<S34>/WayPointGenerator'
    // SystemInitialize for MATLAB Function: '<S38>/WayPointGenerator'
    a = NULL;
    for (int32_T i{0}; i < 20; i++) {
        FlightMissionMode_DW.eml_openfiles[i] = a;
    }

    // End of SystemInitialize for MATLAB Function: '<S38>/WayPointGenerator'
    FlightMissionMode_RotateATMissionHdg_Init(&self_RotateATMissionHdg,
        rtb_TmpSignalConversionAtRotateATMissionHdgInport1_i);

    // End of SystemInitialize for SubSystem: '<S34>/WayPointGenerator'

    // Start for MATLABSystem: '<S34>/Waypoint Follower'
    FlightMissionMode_DW.obj_k.LastWaypointFlag = false;
    FlightMissionMode_DW.obj_k.StartFlag = true;
    FlightMissionMode_DW.obj_k.LookaheadFactor = 1.01;
    FlightMissionMode_DW.objisempty_n = true;
    FlightMissionMode_DW.obj_k.isInitialized = 1;

    // InitializeConditions for MATLABSystem: '<S34>/Waypoint Follower'
    FlightMissionMode_DW.obj_k.WaypointIndex = 1.0;
    for (int32_T i{0}; i < 24576; i++) {
        // InitializeConditions for MATLABSystem: '<S34>/Waypoint Follower'
        FlightMissionMode_DW.obj_k.WaypointsInternal[i] = (rtNaN);
    }

    // End of SystemInitialize for SubSystem: '<Root>/Mode2_HorzScanNav'

    // SystemInitialize for IfAction SubSystem: '<Root>/Mode3_RunWayNav'
    // SystemInitialize for Enabled SubSystem: '<S91>/WayPointGenerator'
    // SystemInitialize for MATLAB Function: '<S96>/StartPointGenerator'
    FlightMissionMode_StartPointGenerator_Init
        (&FlightMissionMode_DW.sf_StartPointGenerator);

    // SystemInitialize for MATLAB Function: '<S96>/WayPointGenerator'
    FlightMissionMode_WayPointGenerator_Init
        (&FlightMissionMode_DW.sf_WayPointGenerator_k);
    FlightMissionMode_RotateATMissionHdg_Init(&self_RotateUpward,
        rtb_TmpSignalConversionAtRotateUpwardInport1);
    FlightMissionMode_RotateATMissionHdg_Init(&self_RotateATRunWayHdg,
        rtb_TmpSignalConversionAtRotateATRunWayHdgInport1_l);
    FlightMissionMode_RotateATMissionHdg_Init(&self_RotateATMissionHdg_m,
        rtb_TmpSignalConversionAtRotateATMissionHdgInport1_p);

    // End of SystemInitialize for SubSystem: '<S91>/WayPointGenerator'

    // SystemInitialize for Atomic SubSystem: '<S91>/SegmentSwitch'
    FlightMissionMode_SegmentSwitch_Init(FlightMissionMode_DW.MergeLookAheadP_j,
        &FlightMissionMode_DW.MergeDesiredCourse_p,
        &FlightMissionMode_DW.RunWayLineMode_k,
        &FlightMissionMode_DW.SegmentSwitch);

    // End of SystemInitialize for SubSystem: '<S91>/SegmentSwitch'
    // End of SystemInitialize for SubSystem: '<Root>/Mode3_RunWayNav'

    // SystemInitialize for IfAction SubSystem: '<Root>/Mode44_ProtLine'
    // SystemInitialize for Enabled SubSystem: '<S133>/WayPointGenerator'
    // SystemInitialize for MATLAB Function: '<S138>/StartPointGenerator'
    FlightMissionMode_StartPointGenerator_Init
        (&FlightMissionMode_DW.sf_StartPointGenerator_k);

    // SystemInitialize for MATLAB Function: '<S138>/WayPointGenerator'
    FlightMissionMode_WayPointGenerator_Init
        (&FlightMissionMode_DW.sf_WayPointGenerator_f);
    FlightMissionMode_RotateATMissionHdg_Init(&self_RotateATRunWayHdg_k,
        rtb_TmpSignalConversionAtRotateATRunWayHdgInport1);
    FlightMissionMode_RotateATMissionHdg_Init(&self_RotateATMissionHdg_k,
        rtb_TmpSignalConversionAtRotateATMissionHdgInport1);

    // End of SystemInitialize for SubSystem: '<S133>/WayPointGenerator'

    // SystemInitialize for Atomic SubSystem: '<S133>/SegmentSwitch'
    FlightMissionMode_SegmentSwitch_Init(FlightMissionMode_DW.MergeLookAheadP,
        &FlightMissionMode_DW.MergeDesiredCourse,
        &FlightMissionMode_DW.RunWayLineMode,
        &FlightMissionMode_DW.SegmentSwitch_p);

    // End of SystemInitialize for SubSystem: '<S133>/SegmentSwitch'
    // End of SystemInitialize for SubSystem: '<Root>/Mode44_ProtLine'

    // SystemInitialize for IfAction SubSystem: '<Root>/Mode55_FrmnWayPoint'
    // Start for SwitchCase: '<S176>/Switch Case'
    FlightMissionMode_DW.SwitchCase_ActiveSubsystem_c = -1;

    // SystemInitialize for Enabled SubSystem: '<S176>/WayPointGenerator'
    // SystemInitialize for MATLAB Function: '<S181>/WayPointGenerator'
    a = NULL;
    for (int32_T i{0}; i < 20; i++) {
        FlightMissionMode_DW.eml_openfiles_n[i] = a;
    }

    // End of SystemInitialize for MATLAB Function: '<S181>/WayPointGenerator'
    // End of SystemInitialize for SubSystem: '<S176>/WayPointGenerator'

    // SystemInitialize for IfAction SubSystem: '<S176>/StartFromClosest'
    // Start for MATLABSystem: '<S179>/Waypoint Follower'
    FlightMissionMode_DW.obj_j.LastWaypointFlag = false;
    FlightMissionMode_DW.obj_j.StartFlag = true;
    FlightMissionMode_DW.obj_j.LookaheadFactor = 1.01;
    FlightMissionMode_DW.obj_j.SearchFlag = true;
    FlightMissionMode_DW.objisempty_e = true;
    FlightMissionMode_DW.obj_j.isInitialized = 1;

    // InitializeConditions for MATLABSystem: '<S179>/Waypoint Follower'
    FlightMissionMode_DW.obj_j.WaypointIndex = 1.0;

    // End of SystemInitialize for SubSystem: '<S176>/StartFromClosest'

    // SystemInitialize for IfAction SubSystem: '<S176>/StartFromFirst'
    // Start for MATLABSystem: '<S180>/Waypoint Follower'
    FlightMissionMode_DW.obj.LastWaypointFlag = false;
    FlightMissionMode_DW.obj.StartFlag = true;
    FlightMissionMode_DW.obj.LookaheadFactor = 1.01;
    FlightMissionMode_DW.objisempty = true;
    FlightMissionMode_DW.obj.isInitialized = 1;

    // InitializeConditions for MATLABSystem: '<S180>/Waypoint Follower'
    FlightMissionMode_DW.obj.WaypointIndex = 1.0;

    // SystemInitialize for IfAction SubSystem: '<S176>/StartFromClosest'
    for (int32_T i{0}; i < 24576; i++) {
        // InitializeConditions for MATLABSystem: '<S179>/Waypoint Follower'
        FlightMissionMode_DW.obj_j.WaypointsInternal[i] = (rtNaN);

        // InitializeConditions for MATLABSystem: '<S180>/Waypoint Follower' incorporates:
        //   MATLABSystem: '<S179>/Waypoint Follower'

        FlightMissionMode_DW.obj.WaypointsInternal[i] = (rtNaN);
    }

    // End of SystemInitialize for SubSystem: '<S176>/StartFromClosest'
    // End of SystemInitialize for SubSystem: '<S176>/StartFromFirst'
    // End of SystemInitialize for SubSystem: '<Root>/Mode55_FrmnWayPoint'
    std::memset(rty_GuidanceCmds, 0, sizeof(FixedWingGuidanceBus));

    // SystemInitialize for Merge: '<Root>/MergeInitialState'
    std::memset(&rty_InitialState[0], 0, static_cast<uint32_T>(sizeof(real_T) <<
                 3U));
}

// Disable for referenced model: 'FlightMissionMode'
void FlightMissionMode::disable(void)
{
    // Disable for SwitchCase: '<Root>/Switch Case'
    switch (FlightMissionMode_DW.SwitchCase_ActiveSubsystem) {
      case 0:
      case 5:
        break;

      case 1:
        // Disable for Enabled SubSystem: '<S34>/WayPointGenerator'
        FlightMissionMode_DW.WayPointGenerator_MODE_h = false;

        // End of Disable for SubSystem: '<S34>/WayPointGenerator'
        break;

      case 2:
        // Disable for Enabled SubSystem: '<S91>/WayPointGenerator'
        FlightMissionMode_DW.WayPointGenerator_MODE_k = false;

        // End of Disable for SubSystem: '<S91>/WayPointGenerator'

        // Disable for Atomic SubSystem: '<S91>/SegmentSwitch'
        FlightMissionMode_SegmentSwitch_Disable
            (&FlightMissionMode_DW.SegmentSwitch);

        // End of Disable for SubSystem: '<S91>/SegmentSwitch'
        break;

      case 3:
        // Disable for Enabled SubSystem: '<S133>/WayPointGenerator'
        FlightMissionMode_DW.WayPointGenerator_MODE_m = false;

        // End of Disable for SubSystem: '<S133>/WayPointGenerator'

        // Disable for Atomic SubSystem: '<S133>/SegmentSwitch'
        FlightMissionMode_SegmentSwitch_Disable
            (&FlightMissionMode_DW.SegmentSwitch_p);

        // End of Disable for SubSystem: '<S133>/SegmentSwitch'
        break;

      case 4:
        // Disable for Enabled SubSystem: '<S176>/WayPointGenerator'
        FlightMissionMode_DW.WayPointGenerator_MODE = false;

        // End of Disable for SubSystem: '<S176>/WayPointGenerator'

        // Disable for SwitchCase: '<S176>/Switch Case'
        FlightMissionMode_DW.SwitchCase_ActiveSubsystem_c = -1;
        break;
    }

    FlightMissionMode_DW.SwitchCase_ActiveSubsystem = -1;

    // End of Disable for SwitchCase: '<Root>/Switch Case'
}

// Output and update for referenced model: 'FlightMissionMode'
void FlightMissionMode::step(const boolean_T *rtu_startFlight, const
    MissionModes *rtu_mode, const Location *rtu_PrevLocation, const Location
    *rtu_Location, const Parameters *rtu_Parameters, const int32_T *rtu_Reset,
    const int32_T *rtu_FormationIDX, const int32_T *rtu_MissionUAV, const real_T
    rtu_Pose[4], real_T *rty_thisTaskStatus, FixedWingGuidanceBus
    *rty_GuidanceCmds, real_T rty_InitialState[8])
{
    // local block i/o variables
    real_T rtb_TmpSignalConversionAtRotateATRunWayHdgInport1[3];
    real_T rtb_TmpSignalConversionAtRotateATMissionHdgInport1[3];
    real_T rtb_nedWayPoint_CoreSubsysCanOut[384];
    real_T rtb_RotateRunway[384];
    real_T rtb_RotateIndivWayPoint[384];
    real_T rtb_TmpSignalConversionAtRotateUpwardInport1[3];
    real_T rtb_TmpSignalConversionAtRotateATRunWayHdgInport1_l[3];
    real_T rtb_TmpSignalConversionAtRotateATMissionHdgInport1_p[3];
    real_T rtb_ImpSel_InsertedFor_RawRunWay_at_outport_0_k[384];
    real_T rtb_nedWayPoint_CoreSubsysCanOut_b[384];
    real_T rtb_MatrixMultiply[384];
    real_T rtb_y[384];
    real_T rtb_TmpSignalConversionAtRotateATMissionHdgInport1_i[3];
    real_T rtb_y_o[384];
    static const int16_T j[12]{ 1000, 0, -1000, 0, 0, 1000, 0, -1000, -1000,
        -1000, -1000, -1000 };

    static const char_T i_0[14]{ 'F', 'l', 'i', 'g', 'h', 't', 'P', 'a', 't',
        'h', '/', 'L', 'L', 'A' };

    static const boolean_T m[128]{ false, false, false, false, false, false,
        false, false, false, true, true, true, true, true, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, true, true, true, true, true, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    emxArray_char_T_FlightMissionMode_T *r;
    emxArray_char_T_FlightMissionMode_T *s1;
    emxArray_char_T_FlightMissionMode_T *tline;
    emxArray_real_T_FlightMissionMode_T *CheckPoints;
    emxArray_real_T_FlightMissionMode_T *b_waypointsIn;
    emxArray_real_T_FlightMissionMode_T *dummyWayPoint;
    emxArray_real_T_FlightMissionMode_T *dummyWayPoint_0;
    emxArray_real_T_FlightMissionMode_T *segWayPoints;
    emxArray_real_T_FlightMissionMode_T *waypoints;
    real_T rtb_MatrixConcatenate[9];
    real_T tmp[9];
    real_T startPose[5];
    real_T CheckPoints_0[4];
    real_T CheckPoints_1[4];
    real_T rtb_ReshapeRowVecStartpose_d[3];
    real_T rtb_TmpSignalConversionAtOrbitFollowerInport2[3];
    real_T turnVector[3];
    real_T u[3];
    real_T distToCenter_tmp[2];
    real_T rtu_Pose_0[2];
    real_T rtb_CastToDouble_l;
    real_T rtb_Cos_j;
    real_T rtb_Sum1_k_idx_1;
    real_T rtb_Sum_id;
    int32_T NED_WP_size[2];
    int32_T i_size[2];
    int32_T o_size[2];
    int32_T obj_Value_size[2];
    int32_T q_size[2];
    int32_T b_exponent;
    int32_T b_exponent_0;
    int32_T i2;
    int32_T nrowx;
    int32_T ntilerows;
    char_T i_data[37];
    char_T obj_Value_data[37];
    int8_T rtAction;
    int8_T rtPrevAction;
    uint8_T rtb_MergeStatus;
    uint8_T status;
    boolean_T c_success;
    boolean_T foundsign;
    boolean_T rtb_Compare_em;
    boolean_T rtb_Compare_lx;
    boolean_T rtb_Compare_ni;
    boolean_T success;
    FlightMissionMode_emxInit_char_T_e(&r, 2);

    // Chart: '<Root>/PreemptableMissionModeSelector'
    // Gateway: PreemptableMissionModeSelector
    // During: PreemptableMissionModeSelector
    if (static_cast<uint32_T>
            (FlightMissionMode_DW.is_active_c2_FlightMissionMode) == 0U) {
        // Entry: PreemptableMissionModeSelector
        FlightMissionMode_DW.is_active_c2_FlightMissionMode = 1U;

        // Entry Internal: PreemptableMissionModeSelector
        // Transition: '<S7>:152'
        FlightMissionMode_DW.is_c2_FlightMissionMode =
            FlightMissionMode_IN_WaitToStart;
        FlightMissionMode_DW.FlightMission = MissionModes::WaitToStart;

        // Entry 'WaitToStart': '<S7>:151'
    } else if (FlightMissionMode_DW.is_c2_FlightMissionMode ==
               FlightMissionMode_IN_FlightMission) {
        // During 'FlightMission': '<S7>:275'
        if (*rtu_Reset != 0) {
            // Transition: '<S7>:241'
            // Transition: '<S7>:255'
            if (static_cast<boolean_T>(static_cast<int32_T>((*rtu_mode ==
                    MissionModes::CircNav) | (*rtu_mode == MissionModes::
                    CircDispNav)))) {
                // Transition: '<S7>:264'
                // Transition: '<S7>:253'
                // Exit Internal 'FlightMission': '<S7>:275'
                FlightMissionMode_DW.is_c2_FlightMissionMode =
                    FlightMissionMode_IN_FlightMission;
                FlightMissionMode_DW.FlightMission = MissionModes::CircNav;

                // Transition: '<S7>:267'
            } else if (static_cast<boolean_T>(static_cast<int32_T>((*rtu_mode ==
                          MissionModes::HorzScanNav) | (*rtu_mode ==
                          MissionModes::CustomFrmnNav)))) {
                // Transition: '<S7>:245'
                // Transition: '<S7>:246'
                // Exit Internal 'FlightMission': '<S7>:275'
                FlightMissionMode_DW.is_c2_FlightMissionMode =
                    FlightMissionMode_IN_FlightMission;
                FlightMissionMode_DW.FlightMission = MissionModes::HorzScanNav;

                // Transition: '<S7>:258'
            } else if (static_cast<boolean_T>(static_cast<int32_T>((*rtu_mode ==
                          MissionModes::RunWayNav) | (*rtu_mode == MissionModes::
                          FrmnRunWay)))) {
                // Transition: '<S7>:256'
                // Transition: '<S7>:244'
                // Exit Internal 'FlightMission': '<S7>:275'
                FlightMissionMode_DW.is_c2_FlightMissionMode =
                    FlightMissionMode_IN_FlightMission;
                FlightMissionMode_DW.FlightMission = MissionModes::RunWayNav;
            } else {
                // Transition: '<S7>:257'
                switch (*rtu_mode) {
                  case MissionModes::ProtLine:
                    // Transition: '<S7>:247'
                    // Transition: '<S7>:248'
                    // Exit Internal 'FlightMission': '<S7>:275'
                    FlightMissionMode_DW.is_c2_FlightMissionMode =
                        FlightMissionMode_IN_FlightMission;
                    FlightMissionMode_DW.FlightMission = MissionModes::ProtLine;
                    break;

                  case MissionModes::FrmnWayPoint:
                    // Transition: '<S7>:260'
                    // Transition: '<S7>:294'
                    // Transition: '<S7>:291'
                    // Exit Internal 'FlightMission': '<S7>:275'
                    FlightMissionMode_DW.is_c2_FlightMissionMode =
                        FlightMissionMode_IN_FlightMission;
                    FlightMissionMode_DW.FlightMission = MissionModes::
                        FrmnWayPoint;
                    break;
                }
            }
        }

        // During 'WaitToStart': '<S7>:151'
    } else if (*rtu_startFlight) {
        // Transition: '<S7>:287'
        // Transition: '<S7>:255'
        if (static_cast<boolean_T>(static_cast<int32_T>((*rtu_mode ==
                MissionModes::CircNav) | (*rtu_mode == MissionModes::CircDispNav))))
        {
            // Transition: '<S7>:264'
            // Transition: '<S7>:253'
            FlightMissionMode_DW.is_c2_FlightMissionMode =
                FlightMissionMode_IN_FlightMission;
            FlightMissionMode_DW.FlightMission = MissionModes::CircNav;

            // Transition: '<S7>:267'
        } else if (static_cast<boolean_T>(static_cast<int32_T>((*rtu_mode ==
                      MissionModes::HorzScanNav) | (*rtu_mode == MissionModes::
                      CustomFrmnNav)))) {
            // Transition: '<S7>:245'
            // Transition: '<S7>:246'
            FlightMissionMode_DW.is_c2_FlightMissionMode =
                FlightMissionMode_IN_FlightMission;
            FlightMissionMode_DW.FlightMission = MissionModes::HorzScanNav;

            // Transition: '<S7>:258'
        } else if (static_cast<boolean_T>(static_cast<int32_T>((*rtu_mode ==
                      MissionModes::RunWayNav) | (*rtu_mode == MissionModes::
                      FrmnRunWay)))) {
            // Transition: '<S7>:256'
            // Transition: '<S7>:244'
            FlightMissionMode_DW.is_c2_FlightMissionMode =
                FlightMissionMode_IN_FlightMission;
            FlightMissionMode_DW.FlightMission = MissionModes::RunWayNav;
        } else {
            // Transition: '<S7>:257'
            switch (*rtu_mode) {
              case MissionModes::ProtLine:
                // Transition: '<S7>:247'
                // Transition: '<S7>:248'
                FlightMissionMode_DW.is_c2_FlightMissionMode =
                    FlightMissionMode_IN_FlightMission;
                FlightMissionMode_DW.FlightMission = MissionModes::ProtLine;
                break;

              case MissionModes::FrmnWayPoint:
                // Transition: '<S7>:260'
                // Transition: '<S7>:294'
                // Transition: '<S7>:291'
                FlightMissionMode_DW.is_c2_FlightMissionMode =
                    FlightMissionMode_IN_FlightMission;
                FlightMissionMode_DW.FlightMission = MissionModes::FrmnWayPoint;
                break;
            }
        }
    }

    // End of Chart: '<Root>/PreemptableMissionModeSelector'

    // SwitchCase: '<Root>/Switch Case'
    rtPrevAction = FlightMissionMode_DW.SwitchCase_ActiveSubsystem;
    switch (FlightMissionMode_DW.FlightMission) {
      case MissionModes::CircNav:
        rtAction = 0;
        break;

      case MissionModes::HorzScanNav:
        rtAction = 1;
        break;

      case MissionModes::RunWayNav:
        rtAction = 2;
        break;

      case MissionModes::ProtLine:
        rtAction = 3;
        break;

      case MissionModes::FrmnWayPoint:
        rtAction = 4;
        break;

      default:
        rtAction = 5;
        break;
    }

    FlightMissionMode_DW.SwitchCase_ActiveSubsystem = rtAction;
    if (static_cast<int32_T>(rtPrevAction) != static_cast<int32_T>(rtAction)) {
        switch (rtPrevAction) {
          case 0:
          case 5:
            break;

          case 1:
            // Disable for Enabled SubSystem: '<S34>/WayPointGenerator'
            FlightMissionMode_DW.WayPointGenerator_MODE_h = false;

            // End of Disable for SubSystem: '<S34>/WayPointGenerator'
            break;

          case 2:
            // Disable for Enabled SubSystem: '<S91>/WayPointGenerator'
            FlightMissionMode_DW.WayPointGenerator_MODE_k = false;

            // End of Disable for SubSystem: '<S91>/WayPointGenerator'

            // Disable for Atomic SubSystem: '<S91>/SegmentSwitch'
            FlightMissionMode_SegmentSwitch_Disable
                (&FlightMissionMode_DW.SegmentSwitch);

            // End of Disable for SubSystem: '<S91>/SegmentSwitch'
            break;

          case 3:
            // Disable for Enabled SubSystem: '<S133>/WayPointGenerator'
            FlightMissionMode_DW.WayPointGenerator_MODE_m = false;

            // End of Disable for SubSystem: '<S133>/WayPointGenerator'

            // Disable for Atomic SubSystem: '<S133>/SegmentSwitch'
            FlightMissionMode_SegmentSwitch_Disable
                (&FlightMissionMode_DW.SegmentSwitch_p);

            // End of Disable for SubSystem: '<S133>/SegmentSwitch'
            break;

          case 4:
            // Disable for Enabled SubSystem: '<S176>/WayPointGenerator'
            FlightMissionMode_DW.WayPointGenerator_MODE = false;

            // End of Disable for SubSystem: '<S176>/WayPointGenerator'

            // Disable for SwitchCase: '<S176>/Switch Case'
            FlightMissionMode_DW.SwitchCase_ActiveSubsystem_c = -1;
            break;
        }
    }

    FlightMissionMode_emxInit_real_T_h(&dummyWayPoint, 2);
    FlightMissionMode_emxInit_real_T_h(&waypoints, 2);
    FlightMissionMode_emxInit_real_T_h(&b_waypointsIn, 2);

    // SwitchCase: '<Root>/Switch Case' incorporates:
    //   MATLAB Function: '<S181>/WayPointGenerator'
    //   MATLAB Function: '<S38>/WayPointGenerator'
    //   MATLABSystem: '<S34>/Waypoint Follower'

    switch (rtAction) {
      case 0:
        {
            real_T a_0;
            real_T rtb_Abs1_n;
            real_T rtb_AltitudeGCS_dj;
            real_T rtb_Down2Up_c;
            real_T rtb_LatitudeGCS_gv;
            real_T rtb_Sum1_k_idx_0;
            real_T rtb_Sum_k5;
            real_T rtb_Switch_lo;
            int32_T i;
            int32_T rtb_Bias_f;
            if (static_cast<int32_T>(rtAction) != static_cast<int32_T>
                    (rtPrevAction)) {
                // SystemReset for IfAction SubSystem: '<Root>/Mode1_CirclingNav' incorporates:
                //   ActionPort: '<S1>/Action Port'

                // SystemReset for SwitchCase: '<Root>/Switch Case' incorporates:
                //   MATLABSystem: '<S9>/Orbit Follower'

                FlightMissionMode_DW.obj_f.OrbitRadiusInternal = (rtNaN);
                FlightMissionMode_DW.obj_f.PrevResetSignal *= 0.0;
                FlightMissionMode_DW.obj_f.NumCircles *= 0.0;
                FlightMissionMode_DW.obj_f.OrbitCenterInternal[0] = (rtNaN);
                FlightMissionMode_DW.obj_f.PrevPosition[0] *= 0.0;
                FlightMissionMode_DW.obj_f.OrbitCenterInternal[1] = (rtNaN);
                FlightMissionMode_DW.obj_f.PrevPosition[1] *= 0.0;
                FlightMissionMode_DW.obj_f.OrbitCenterInternal[2] = (rtNaN);
                FlightMissionMode_DW.obj_f.PrevPosition[2] *= 0.0;
                FlightMissionMode_DW.obj_f.StartFlag = true;
                FlightMissionMode_DW.obj_f.SelectTurnDirectionFlag = true;
                FlightMissionMode_DW.obj_f.TurnDirectionInternal = 1.0;
                FlightMissionMode_DW.obj_f.OrbitRadiusFlag = 0U;
                FlightMissionMode_DW.obj_f.LookaheadDistFlag = 0U;

                // End of SystemReset for SubSystem: '<Root>/Mode1_CirclingNav'
            }

            // Outputs for IfAction SubSystem: '<Root>/Mode1_CirclingNav' incorporates:
            //   ActionPort: '<S1>/Action Port'

            // DataStoreRead: '<S9>/AltitudeGCS'
            rtw_pthread_mutex_lock(AltitudeGCS_m0);
            rtb_AltitudeGCS_dj = AltitudeGCS;
            rtw_pthread_mutex_unlock(AltitudeGCS_m0);

            // Bias: '<S9>/Bias'
            rtb_Bias_f = *rtu_MissionUAV;

            // DataTypeConversion: '<S9>/CastToDouble'
            rtb_LatitudeGCS_gv = static_cast<real_T>(*rtu_FormationIDX);

            // Product: '<S9>/Divide' incorporates:
            //   Constant: '<S9>/two_pi'

            rtb_Sum_id = 6.2831853071795862 / static_cast<real_T>
                (*rtu_MissionUAV);

            // Product: '<S9>/Map2Radian' incorporates:
            //   Bias: '<S9>/Bias'
            //   Gain: '<S9>/HalveMissionUAV'
            //   Sum: '<S9>/Minus'

            rtb_Sum_id *= rtb_LatitudeGCS_gv - static_cast<real_T>
                (static_cast<int32_T>(rtb_Bias_f + 1)) * 0.5;

            // Trigonometry: '<S9>/Cos'
            rtb_Cos_j = std::cos(rtb_Sum_id);

            // DataStoreRead: '<S9>/LatitudeGCS'
            rtw_pthread_mutex_lock(LatitudeGCS_m0);
            rtb_LatitudeGCS_gv = LatitudeGCS;
            rtw_pthread_mutex_unlock(LatitudeGCS_m0);

            // DataStoreRead: '<S9>/LongitudeGCS'
            rtw_pthread_mutex_lock(LongitudeGCS_m0);
            rtb_Abs1_n = LongitudeGCS;
            rtw_pthread_mutex_unlock(LongitudeGCS_m0);

            // Sum: '<S10>/Sum1' incorporates:
            //   Sum: '<S12>/Sum'

            rtb_Sum1_k_idx_0 = rtu_Location->Lat - rtb_LatitudeGCS_gv;
            rtb_Sum1_k_idx_1 = rtu_Location->Lon - rtb_Abs1_n;

            // Switch: '<S18>/Switch' incorporates:
            //   Abs: '<S18>/Abs'
            //   Bias: '<S18>/Bias'
            //   Bias: '<S18>/Bias1'
            //   Constant: '<S18>/Constant2'
            //   Constant: '<S19>/Constant'
            //   Math: '<S18>/Math Function1'
            //   RelationalOperator: '<S19>/Compare'

            if (std::abs(rtb_Sum1_k_idx_0) > 180.0) {
                rtb_Switch_lo = rt_modd_snf(rtb_Sum1_k_idx_0 + 180.0, 360.0) +
                    -180.0;
            } else {
                rtb_Switch_lo = rtb_Sum1_k_idx_0;
            }

            // End of Switch: '<S18>/Switch'

            // Abs: '<S15>/Abs1'
            rtb_Abs1_n = std::abs(rtb_Switch_lo);

            // Switch: '<S15>/Switch' incorporates:
            //   Bias: '<S15>/Bias'
            //   Bias: '<S15>/Bias1'
            //   Constant: '<S11>/Constant'
            //   Constant: '<S11>/Constant1'
            //   Constant: '<S17>/Constant'
            //   Gain: '<S15>/Gain'
            //   Product: '<S15>/Divide1'
            //   RelationalOperator: '<S17>/Compare'
            //   Switch: '<S11>/Switch1'

            if (rtb_Abs1_n > 90.0) {
                // Signum: '<S15>/Sign1'
                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>(std::isnan
                        (rtb_Switch_lo)) ^ 1))) {
                    if (rtb_Switch_lo < 0.0) {
                        rtb_Switch_lo = -1.0;
                    } else {
                        rtb_Switch_lo = static_cast<real_T>(rtb_Switch_lo > 0.0);
                    }
                }

                // End of Signum: '<S15>/Sign1'
                rtb_Switch_lo *= -(rtb_Abs1_n + -90.0) + 90.0;
                i = 180;
            } else {
                i = 0;
            }

            // End of Switch: '<S15>/Switch'

            // Sum: '<S11>/Sum'
            rtb_Sum_k5 = static_cast<real_T>(i) + rtb_Sum1_k_idx_1;

            // Switch: '<S16>/Switch' incorporates:
            //   Abs: '<S16>/Abs'
            //   Bias: '<S16>/Bias'
            //   Bias: '<S16>/Bias1'
            //   Constant: '<S16>/Constant2'
            //   Constant: '<S20>/Constant'
            //   Math: '<S16>/Math Function1'
            //   RelationalOperator: '<S20>/Compare'

            if (std::abs(rtb_Sum_k5) > 180.0) {
                rtb_Sum_k5 = rt_modd_snf(rtb_Sum_k5 + 180.0, 360.0) + -180.0;
            }

            // End of Switch: '<S16>/Switch'

            // UnitConversion: '<S14>/Unit Conversion'
            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            rtb_Sum1_k_idx_0 = 0.017453292519943295 * rtb_Switch_lo;
            rtb_Sum1_k_idx_1 = 0.017453292519943295 * rtb_Sum_k5;

            // UnitConversion: '<S29>/Unit Conversion'
            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            rtb_LatitudeGCS_gv *= 0.017453292519943295;

            // Trigonometry: '<S30>/Trigonometric Function1'
            rtb_Sum_k5 = std::sin(rtb_LatitudeGCS_gv);

            // Sum: '<S30>/Sum1' incorporates:
            //   Constant: '<S30>/Constant'
            //   Product: '<S30>/Product1'

            rtb_Sum_k5 = 1.0 - 0.0066943799901413295 * rtb_Sum_k5 * rtb_Sum_k5;

            // Product: '<S28>/Product1' incorporates:
            //   Constant: '<S28>/Constant1'
            //   Sqrt: '<S28>/sqrt'

            rtb_Switch_lo = 6.378137E+6 / std::sqrt(rtb_Sum_k5);

            // Product: '<S13>/dNorth' incorporates:
            //   Constant: '<S28>/Constant2'
            //   Product: '<S28>/Product3'
            //   Trigonometry: '<S28>/Trigonometric Function1'

            rtb_Sum_k5 = rtb_Sum1_k_idx_0 / rt_atan2d_snf(1.0, rtb_Switch_lo *
                0.99330562000985867 / rtb_Sum_k5);

            // Product: '<S13>/dEast' incorporates:
            //   Constant: '<S28>/Constant3'
            //   Product: '<S28>/Product4'
            //   Trigonometry: '<S28>/Trigonometric Function'
            //   Trigonometry: '<S28>/Trigonometric Function2'

            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            rtb_Switch_lo = 1.0 / rt_atan2d_snf(1.0, rtb_Switch_lo * std::cos
                (rtb_LatitudeGCS_gv)) * rtb_Sum1_k_idx_1;

            // Sum: '<S13>/Sum2' incorporates:
            //   Product: '<S13>/x*cos'
            //   Product: '<S13>/y*sin'

            rtb_LatitudeGCS_gv = rtb_Switch_lo * 0.0 + rtb_Sum_k5;

            // Sum: '<S13>/Sum3' incorporates:
            //   Product: '<S13>/x*sin'
            //   Product: '<S13>/y*cos'

            rtb_Abs1_n = rtb_Switch_lo - rtb_Sum_k5 * 0.0;

            // Sum: '<S10>/Sum' incorporates:
            //   Gain: '<S9>/inverse'

            rtb_Down2Up_c = rtu_Location->Alt + -rtb_AltitudeGCS_dj;

            // SignalConversion generated from: '<S9>/Orbit Follower' incorporates:
            //   UnaryMinus: '<S10>/Ze2height'

            rtb_TmpSignalConversionAtOrbitFollowerInport2[0] =
                rtb_LatitudeGCS_gv;
            rtb_TmpSignalConversionAtOrbitFollowerInport2[1] = rtb_Abs1_n;
            rtb_TmpSignalConversionAtOrbitFollowerInport2[2] = -rtb_Down2Up_c;

            // MATLABSystem: '<S9>/Orbit Follower' incorporates:
            //   DataTypeConversion: '<S9>/Param1'
            //   DataTypeConversion: '<S9>/Param2'
            //   SignalConversion generated from: '<S9>/Orbit Follower'
            //   UnaryMinus: '<S10>/Ze2height'

            rtb_AltitudeGCS_dj = static_cast<real_T>(rtu_Parameters->Param1);
            FlightMissionMode_DW.obj_f.OrbitRadiusFlag = 0U;
            if (rtu_Parameters->Param1 <= 220.0F) {
                rtb_AltitudeGCS_dj = 220.0;
                FlightMissionMode_DW.obj_f.OrbitRadiusFlag = 1U;
            }

            FlightMissionMode_DW.obj_f.LookaheadDistFlag = 0U;
            FlightMissionMode_DW.obj_f.LookaheadDistFlag = 1U;
            rtb_CastToDouble_l = rtu_Pose[0] - rtb_LatitudeGCS_gv;
            rtu_Pose_0[0] = rtb_CastToDouble_l;
            rtu_Pose_0[1] = rtu_Pose[1] - rtb_Abs1_n;
            if (FlightMissionMode_norm_p(rtu_Pose_0) < 2.47032822920623E-323) {
                u[2] = -rtb_Down2Up_c;
                a_0 = rtu_Pose[3];
                *rty_thisTaskStatus = FlightMissionMode_DW.obj_f.NumCircles;
            } else {
                boolean_T exitg1;
                boolean_T guard1{ false };

                rtb_Compare_em = false;
                rtb_Compare_ni = true;
                rtb_Bias_f = 0;
                exitg1 = false;
                while ((!exitg1) && (rtb_Bias_f < 3)) {
                    if ((FlightMissionMode_DW.obj_f.OrbitCenterInternal[rtb_Bias_f]
                         == rtb_TmpSignalConversionAtOrbitFollowerInport2[rtb_Bias_f])
                        || (std::isnan
                            (FlightMissionMode_DW.obj_f.OrbitCenterInternal[rtb_Bias_f])
                            && std::isnan
                            (rtb_TmpSignalConversionAtOrbitFollowerInport2[rtb_Bias_f])))
                    {
                        rtb_Bias_f = static_cast<int32_T>(rtb_Bias_f + 1);
                    } else {
                        rtb_Compare_ni = false;
                        exitg1 = true;
                    }
                }

                if (rtb_Compare_ni) {
                    rtb_Compare_em = true;
                }

                if ((static_cast<boolean_T>(static_cast<int32_T>(static_cast<
                        int32_T>(rtb_Compare_em) ^ 1))) ||
                        (!((FlightMissionMode_DW.obj_f.OrbitRadiusInternal ==
                            rtb_AltitudeGCS_dj) || (std::isnan
                        (FlightMissionMode_DW.obj_f.OrbitRadiusInternal) && std::
                        isnan(rtb_AltitudeGCS_dj))))) {
                    FlightMissionMode_DW.obj_f.NumCircles = 0.0;
                    FlightMissionMode_DW.obj_f.OrbitCenterInternal[0] =
                        rtb_LatitudeGCS_gv;
                    FlightMissionMode_DW.obj_f.OrbitCenterInternal[1] =
                        rtb_Abs1_n;
                    FlightMissionMode_DW.obj_f.OrbitCenterInternal[2] =
                        -rtb_Down2Up_c;
                    FlightMissionMode_DW.obj_f.OrbitRadiusInternal =
                        rtb_AltitudeGCS_dj;
                    FlightMissionMode_DW.obj_f.SelectTurnDirectionFlag = true;
                }

                if (rtb_AltitudeGCS_dj <= 35.0) {
                    FlightMissionMode_DW.obj_f.LookaheadDistance = 0.9 *
                        rtb_AltitudeGCS_dj;
                } else {
                    FlightMissionMode_DW.obj_f.LookaheadDistance = 35.0;
                }

                distToCenter_tmp[0] = rtb_CastToDouble_l;
                rtb_Sum1_k_idx_0 = rtu_Pose[1] - rtb_Abs1_n;
                distToCenter_tmp[1] = rtb_Sum1_k_idx_0;
                rtb_Switch_lo = std::sqrt(rtb_Sum1_k_idx_0 * rtb_Sum1_k_idx_0 +
                    rtb_CastToDouble_l * rtb_CastToDouble_l);
                rtb_Sum_k5 = rtb_AltitudeGCS_dj +
                    FlightMissionMode_DW.obj_f.LookaheadDistance;
                rtb_Sum1_k_idx_1 = std::abs(rtb_Sum_k5);
                rtb_Compare_em = static_cast<boolean_T>(static_cast<int32_T>(
                    static_cast<int32_T>(std::isinf(rtb_Sum1_k_idx_1)) ^ 1));
                rtb_Compare_ni = static_cast<boolean_T>(static_cast<int32_T>(
                    static_cast<int32_T>(std::isnan(rtb_Sum1_k_idx_1)) ^ 1));
                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>(rtb_Compare_em)
                      & static_cast<int32_T>(rtb_Compare_ni)))) {
                    if (rtb_Sum1_k_idx_1 <= 2.2250738585072014E-308) {
                        a_0 = 4.94065645841247E-324;
                    } else {
                        frexp(rtb_Sum1_k_idx_1, &b_exponent_0);
                        a_0 = std::ldexp(1.0, static_cast<int32_T>(b_exponent_0
                                          - 53));
                    }
                } else {
                    a_0 = (rtNaN);
                }

                guard1 = false;
                if (rtb_Switch_lo >= rtb_Sum_k5 - 5.0 * a_0) {
                    guard1 = true;
                } else {
                    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<
                            int32_T>(rtb_Compare_em) & static_cast<int32_T>
                            (rtb_Compare_ni)))) {
                        if (rtb_Sum1_k_idx_1 <= 2.2250738585072014E-308) {
                            a_0 = 4.94065645841247E-324;
                        } else {
                            frexp(rtb_Sum1_k_idx_1, &nrowx);
                            a_0 = std::ldexp(1.0, static_cast<int32_T>(nrowx -
                                              53));
                        }
                    } else {
                        a_0 = (rtNaN);
                    }

                    if (rtb_Switch_lo <= (rtb_AltitudeGCS_dj -
                                          FlightMissionMode_DW.obj_f.LookaheadDistance)
                        + 5.0 * a_0) {
                        guard1 = true;
                    } else {
                        real_T a_tmp;
                        real_T rtb_Sum1_k_tmp;
                        real_T rtb_Sum_n_tmp;
                        real_T yout_idx_0;
                        if (FlightMissionMode_DW.obj_f.StartFlag) {
                            FlightMissionMode_DW.obj_f.PrevPosition[0] =
                                rtu_Pose[0];
                            FlightMissionMode_DW.obj_f.PrevPosition[1] =
                                rtu_Pose[1];
                            FlightMissionMode_DW.obj_f.PrevPosition[2] =
                                rtu_Pose[2];
                            FlightMissionMode_DW.obj_f.StartFlag = false;
                        }

                        rtu_Pose_0[0] = rtb_CastToDouble_l;
                        rtb_Sum1_k_tmp = rtu_Pose[1] - rtb_Abs1_n;
                        rtu_Pose_0[1] = rtb_Sum1_k_tmp;
                        rtb_Switch_lo = FlightMissionMode_norm_p(rtu_Pose_0);
                        a_tmp = FlightMissionMode_DW.obj_f.LookaheadDistance *
                            FlightMissionMode_DW.obj_f.LookaheadDistance;
                        a_0 = ((a_tmp - rtb_AltitudeGCS_dj * rtb_AltitudeGCS_dj)
                               + rtb_Switch_lo * rtb_Switch_lo) / (2.0 *
                            rtb_Switch_lo);
                        rtb_Sum1_k_idx_1 = rtb_LatitudeGCS_gv - rtu_Pose[0];
                        rtb_AltitudeGCS_dj = rtb_Sum1_k_idx_1 * a_0 /
                            rtb_Switch_lo + rtu_Pose[0];
                        rtb_Sum_n_tmp = rtb_Abs1_n - rtu_Pose[1];
                        rtb_Sum_k5 = rtb_Sum_n_tmp * a_0 / rtb_Switch_lo +
                            rtu_Pose[1];
                        a_0 = std::sqrt(a_tmp - a_0 * a_0);
                        rtb_Sum1_k_idx_0 = rtb_Sum_n_tmp * a_0 / rtb_Switch_lo;
                        distToCenter_tmp[0] = rtb_AltitudeGCS_dj -
                            rtb_Sum1_k_idx_0;
                        distToCenter_tmp[1] = rtb_Sum1_k_idx_0 +
                            rtb_AltitudeGCS_dj;
                        a_0 = rtb_Sum1_k_idx_1 * a_0 / rtb_Switch_lo;
                        yout_idx_0 = a_0 + rtb_Sum_k5;
                        rtb_Switch_lo = rtb_Sum_k5 - a_0;
                        if ((rtu_Parameters->Param2 == 0.0F) &&
                                (static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>
                                (FlightMissionMode_DW.obj_f.SelectTurnDirectionFlag)
                               ^ 1)))) {
                            rtb_AltitudeGCS_dj =
                                FlightMissionMode_DW.obj_f.TurnDirectionInternal;
                        } else {
                            rtb_AltitudeGCS_dj = static_cast<real_T>
                                (rtu_Parameters->Param2);
                        }

                        turnVector[0] = FlightMissionMode_DW.obj_f.PrevPosition
                            [0] - rtb_LatitudeGCS_gv;
                        turnVector[1] = FlightMissionMode_DW.obj_f.PrevPosition
                            [1] - rtb_Abs1_n;
                        u[0] = turnVector[0];
                        u[1] = turnVector[1];
                        u[2] = 0.0;
                        rtb_ReshapeRowVecStartpose_d[0] = rtb_CastToDouble_l;
                        rtb_ReshapeRowVecStartpose_d[1] = rtb_Sum1_k_tmp;
                        rtb_ReshapeRowVecStartpose_d[2] = 0.0;
                        if (rtb_AltitudeGCS_dj < 0.0) {
                            u[0] = rtb_CastToDouble_l;
                            rtb_ReshapeRowVecStartpose_d[0] = turnVector[0];
                            u[1] = rtb_Sum1_k_tmp;
                            rtb_ReshapeRowVecStartpose_d[1] = turnVector[1];
                            u[2] = 0.0;
                            rtb_ReshapeRowVecStartpose_d[2] = 0.0;
                        }

                        a_0 = FlightMissionMode_norm_pv(u);
                        rtb_CastToDouble_l = FlightMissionMode_norm_pv
                            (rtb_ReshapeRowVecStartpose_d);
                        rtb_Sum_k5 = u[0] / a_0;
                        rtb_Sum1_k_tmp = rtb_ReshapeRowVecStartpose_d[0] /
                            rtb_CastToDouble_l;
                        a_tmp = u[1] / a_0;
                        rtb_Sum1_k_idx_0 = rtb_ReshapeRowVecStartpose_d[1] /
                            rtb_CastToDouble_l;
                        FlightMissionMode_DW.obj_f.PrevPosition[0] = rtu_Pose[0];
                        FlightMissionMode_DW.obj_f.PrevPosition[1] = rtu_Pose[1];
                        FlightMissionMode_DW.obj_f.PrevPosition[2] = rtu_Pose[2];
                        FlightMissionMode_DW.obj_f.NumCircles += rt_atan2d_snf
                            (rtb_Sum_k5 * rtb_Sum1_k_idx_0 - rtb_Sum1_k_tmp *
                             a_tmp, (rtb_Sum_k5 * rtb_Sum1_k_tmp + a_tmp *
                                     rtb_Sum1_k_idx_0) + 0.0 / a_0 * (0.0 /
                              rtb_CastToDouble_l)) / 2.0 / 3.1415926535897931;
                        *rty_thisTaskStatus =
                            FlightMissionMode_DW.obj_f.NumCircles;
                        if (static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(std::isnan
                                (rtb_AltitudeGCS_dj)) ^ 1))) {
                            if (rtb_AltitudeGCS_dj < 0.0) {
                                rtb_AltitudeGCS_dj = -1.0;
                            } else {
                                rtb_AltitudeGCS_dj = static_cast<real_T>
                                    (rtb_AltitudeGCS_dj > 0.0);
                            }
                        }

                        switch (static_cast<int32_T>(rtb_AltitudeGCS_dj)) {
                          case 1:
                            if ((distToCenter_tmp[0] - rtu_Pose[0]) *
                                    rtb_Sum_n_tmp - (yout_idx_0 - rtu_Pose[1]) *
                                rtb_Sum1_k_idx_1 > 0.0) {
                                rtb_Sum_k5 = distToCenter_tmp[0];
                                rtb_Switch_lo = yout_idx_0;
                            } else {
                                rtb_Sum_k5 = distToCenter_tmp[1];
                            }
                            break;

                          case -1:
                            if ((distToCenter_tmp[0] - rtu_Pose[0]) *
                                    rtb_Sum_n_tmp - (yout_idx_0 - rtu_Pose[1]) *
                                rtb_Sum1_k_idx_1 < 0.0) {
                                rtb_Sum_k5 = distToCenter_tmp[0];
                                rtb_Switch_lo = yout_idx_0;
                            } else {
                                rtb_Sum_k5 = distToCenter_tmp[1];
                            }
                            break;

                          default:
                            if (std::abs(FlightMissionMode_angdiff(rt_atan2d_snf
                                    (yout_idx_0 - rtu_Pose[1], distToCenter_tmp
                                     [0] - rtu_Pose[0]), rtu_Pose[3])) < std::
                                    abs(FlightMissionMode_angdiff(rt_atan2d_snf
                                    (rtb_Switch_lo - rtu_Pose[1],
                                     distToCenter_tmp[1] - rtu_Pose[0]),
                                    rtu_Pose[3]))) {
                                rtb_Sum_k5 = distToCenter_tmp[0];
                                rtb_Switch_lo = yout_idx_0;
                            } else {
                                rtb_Sum_k5 = distToCenter_tmp[1];
                            }

                            if ((rtb_Sum_k5 - rtu_Pose[0]) * rtb_Sum_n_tmp -
                                    (rtb_Switch_lo - rtu_Pose[1]) *
                                    rtb_Sum1_k_idx_1 > 0.0) {
                                FlightMissionMode_DW.obj_f.TurnDirectionInternal
                                    = 1.0;
                            } else {
                                FlightMissionMode_DW.obj_f.TurnDirectionInternal
                                    = -1.0;
                            }

                            FlightMissionMode_DW.obj_f.SelectTurnDirectionFlag =
                                false;
                            break;
                        }
                    }
                }

                if (guard1) {
                    a_0 = FlightMissionMode_norm_p(distToCenter_tmp);
                    rtb_Sum_k5 = rtb_CastToDouble_l / a_0 * rtb_AltitudeGCS_dj +
                        rtb_LatitudeGCS_gv;
                    rtb_Switch_lo = rtb_Sum1_k_idx_0 / a_0 * rtb_AltitudeGCS_dj
                        + rtb_Abs1_n;
                    *rty_thisTaskStatus = FlightMissionMode_DW.obj_f.NumCircles;
                }

                u[2] = -rtb_Down2Up_c;
                a_0 = rt_atan2d_snf(rtb_Switch_lo - rtu_Pose[1], rtb_Sum_k5 -
                                    rtu_Pose[0]);
            }

            // BusCreator: '<S9>/GuidanceCMDBusCreator' incorporates:
            //   DataTypeConversion: '<S9>/Param3'
            //   Gain: '<S9>/Down2Height'
            //   MATLABSystem: '<S9>/Orbit Follower'

            rty_GuidanceCmds->Height = -u[2];
            rty_GuidanceCmds->AirSpeed = static_cast<real_T>
                (rtu_Parameters->Param4);
            rty_GuidanceCmds->HeadingAngle = a_0;

            // Reshape: '<S9>/Reshape' incorporates:
            //   Constant: '<S9>/InitialFlightPathAngle'
            //   Constant: '<S9>/InitialRollAngle'
            //   Constant: '<S9>/InitialRollAngleRate'
            //   Constant: '<S9>/halfPi'
            //   DataTypeConversion: '<S9>/Param1'
            //   DataTypeConversion: '<S9>/Param2'
            //   DataTypeConversion: '<S9>/Param3'
            //   Product: '<S9>/EastDis'
            //   Product: '<S9>/NorthDis'
            //   Product: '<S9>/Product'
            //   Sum: '<S9>/Sum'
            //   Sum: '<S9>/SumInitEast'
            //   Sum: '<S9>/SumInitNorth'
            //   Trigonometry: '<S9>/Sin'
            //   UnaryMinus: '<S10>/Ze2height'

            rty_InitialState[0] = rtb_Cos_j * static_cast<real_T>
                (rtu_Parameters->Param1) + rtb_LatitudeGCS_gv;
            rty_InitialState[1] = static_cast<real_T>(rtu_Parameters->Param1) *
                std::sin(rtb_Sum_id) + rtb_Abs1_n;
            rty_InitialState[2] = rtb_Down2Up_c;
            rty_InitialState[3] = static_cast<real_T>(rtu_Parameters->Param4);
            rty_InitialState[4] = static_cast<real_T>(rtu_Parameters->Param2) *
                1.5707963267948966 + rtb_Sum_id;
            rty_InitialState[5] = 0.0;
            rty_InitialState[6] = 0.0;
            rty_InitialState[7] = 0.0;

            // End of Outputs for SubSystem: '<Root>/Mode1_CirclingNav'
        }
        break;

      case 1:
        {
            real_T a_0;
            real_T rtb_Abs1_n;
            real_T rtb_AltitudeGCS_dj;
            real_T rtb_Down2Up_c;
            real_T rtb_LatitudeGCS_gv;
            real_T rtb_Sum1_k_idx_0;
            real_T rtb_Sum_k5;
            real_T rtb_Switch_lo;
            int32_T i;
            int32_T ibcol;
            int32_T nrows;
            int32_T rtb_Bias_f;
            boolean_T exitg1;
            if (static_cast<int32_T>(rtAction) != static_cast<int32_T>
                    (rtPrevAction)) {
                // SystemReset for IfAction SubSystem: '<Root>/Mode2_HorzScanNav' incorporates:
                //   ActionPort: '<S3>/Action Port'

                // SystemReset for SwitchCase: '<Root>/Switch Case' incorporates:
                //   MATLABSystem: '<S34>/Waypoint Follower'

                FlightMissionMode_DW.obj_k.WaypointIndex = 1.0;
                for (i = 0; i < 24576; i++) {
                    FlightMissionMode_DW.obj_k.WaypointsInternal[i] = (rtNaN);
                }

                // End of SystemReset for SubSystem: '<Root>/Mode2_HorzScanNav'
            }

            // Outputs for IfAction SubSystem: '<Root>/Mode2_HorzScanNav' incorporates:
            //   ActionPort: '<S3>/Action Port'

            // DataStoreRead: '<S34>/AltitudeGCS'
            rtw_pthread_mutex_lock(AltitudeGCS_m0);
            rtb_Abs1_n = AltitudeGCS;
            rtw_pthread_mutex_unlock(AltitudeGCS_m0);

            // Sum: '<S36>/Sum' incorporates:
            //   Gain: '<S34>/inverse'

            rtb_Abs1_n = rtu_Location->Alt + -rtb_Abs1_n;

            // DataTypeConversion: '<S34>/CastToDouble'
            rtb_Switch_lo = static_cast<real_T>(*rtu_FormationIDX);

            // Sum: '<S34>/Minus' incorporates:
            //   Constant: '<S34>/One2ZeroIdx'

            rtb_Switch_lo--;

            // Gain: '<S34>/Gain' incorporates:
            //   Constant: '<S34>/Three'
            //   Math: '<S34>/ModRunWayLayer'

            rtb_Sum_id = 15.0 * rt_modd_snf(rtb_Switch_lo, 3.0);

            // Sum: '<S34>/BiasMissionAlt' incorporates:
            //   UnaryMinus: '<S36>/Ze2height'

            rtb_Cos_j = -rtb_Abs1_n - rtb_Sum_id;

            // DataStoreRead: '<S37>/PrevAltitudeGCS'
            rtw_pthread_mutex_lock(AltitudeGCS_m0);
            rtb_Abs1_n = AltitudeGCS;
            rtw_pthread_mutex_unlock(AltitudeGCS_m0);

            // Sum: '<S64>/Sum' incorporates:
            //   Gain: '<S37>/PrevInverse'

            rtb_Abs1_n = rtu_PrevLocation->Alt + -rtb_Abs1_n;

            // Sum: '<S34>/BiasPrevAlt' incorporates:
            //   UnaryMinus: '<S64>/Ze2height'

            rtb_Sum_id = -rtb_Abs1_n - rtb_Sum_id;

            // RelationalOperator: '<S62>/Compare' incorporates:
            //   Constant: '<S62>/Constant'

            rtb_Compare_lx = (rtu_PrevLocation->Lat == 0.0);

            // RelationalOperator: '<S63>/Compare' incorporates:
            //   Constant: '<S63>/Constant'

            rtb_Compare_ni = (rtu_PrevLocation->Lon == 0.0);

            // RelationalOperator: '<S61>/Compare' incorporates:
            //   Constant: '<S61>/Constant'

            rtb_Compare_em = (rtu_PrevLocation->Alt == 0.0);

            // Logic: '<S37>/AND'
            rtb_Compare_lx = static_cast<boolean_T>(static_cast<int32_T>(
                static_cast<int32_T>(static_cast<boolean_T>(static_cast<int32_T>
                (static_cast<int32_T>(rtb_Compare_lx) & static_cast<int32_T>
                 (rtb_Compare_ni)))) & static_cast<int32_T>(rtb_Compare_em)));

            // DataStoreRead: '<S37>/PrevLatitudeGCS'
            rtw_pthread_mutex_lock(LatitudeGCS_m0);
            rtb_LatitudeGCS_gv = LatitudeGCS;
            rtw_pthread_mutex_unlock(LatitudeGCS_m0);

            // DataStoreRead: '<S37>/PrevLongitudeGCS'
            rtw_pthread_mutex_lock(LongitudeGCS_m0);
            rtb_Abs1_n = LongitudeGCS;
            rtw_pthread_mutex_unlock(LongitudeGCS_m0);

            // Sum: '<S64>/Sum1' incorporates:
            //   Sum: '<S66>/Sum'

            rtb_Sum1_k_idx_0 = rtu_PrevLocation->Lat - rtb_LatitudeGCS_gv;
            rtb_Sum1_k_idx_1 = rtu_PrevLocation->Lon - rtb_Abs1_n;

            // Switch: '<S72>/Switch' incorporates:
            //   Abs: '<S72>/Abs'
            //   Bias: '<S72>/Bias'
            //   Bias: '<S72>/Bias1'
            //   Constant: '<S72>/Constant2'
            //   Constant: '<S73>/Constant'
            //   Math: '<S72>/Math Function1'
            //   RelationalOperator: '<S73>/Compare'

            if (std::abs(rtb_Sum1_k_idx_0) > 180.0) {
                rtb_AltitudeGCS_dj = rt_modd_snf(rtb_Sum1_k_idx_0 + 180.0, 360.0)
                    + -180.0;
            } else {
                rtb_AltitudeGCS_dj = rtb_Sum1_k_idx_0;
            }

            // End of Switch: '<S72>/Switch'

            // Abs: '<S69>/Abs1'
            rtb_Abs1_n = std::abs(rtb_AltitudeGCS_dj);

            // Switch: '<S69>/Switch' incorporates:
            //   Bias: '<S69>/Bias'
            //   Bias: '<S69>/Bias1'
            //   Constant: '<S65>/Constant'
            //   Constant: '<S65>/Constant1'
            //   Constant: '<S71>/Constant'
            //   Gain: '<S69>/Gain'
            //   Product: '<S69>/Divide1'
            //   RelationalOperator: '<S71>/Compare'
            //   Switch: '<S65>/Switch1'

            if (rtb_Abs1_n > 90.0) {
                // Signum: '<S69>/Sign1'
                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>(std::isnan
                        (rtb_AltitudeGCS_dj)) ^ 1))) {
                    if (rtb_AltitudeGCS_dj < 0.0) {
                        rtb_AltitudeGCS_dj = -1.0;
                    } else {
                        rtb_AltitudeGCS_dj = static_cast<real_T>
                            (rtb_AltitudeGCS_dj > 0.0);
                    }
                }

                // End of Signum: '<S69>/Sign1'
                rtb_AltitudeGCS_dj *= -(rtb_Abs1_n + -90.0) + 90.0;
                i = 180;
            } else {
                i = 0;
            }

            // End of Switch: '<S69>/Switch'

            // Sum: '<S65>/Sum'
            a_0 = static_cast<real_T>(i) + rtb_Sum1_k_idx_1;

            // Switch: '<S70>/Switch' incorporates:
            //   Abs: '<S70>/Abs'
            //   Bias: '<S70>/Bias'
            //   Bias: '<S70>/Bias1'
            //   Constant: '<S70>/Constant2'
            //   Constant: '<S74>/Constant'
            //   Math: '<S70>/Math Function1'
            //   RelationalOperator: '<S74>/Compare'

            if (std::abs(a_0) > 180.0) {
                a_0 = rt_modd_snf(a_0 + 180.0, 360.0) + -180.0;
            }

            // End of Switch: '<S70>/Switch'

            // UnitConversion: '<S68>/Unit Conversion'
            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            rtb_Sum1_k_idx_0 = 0.017453292519943295 * rtb_AltitudeGCS_dj;
            rtb_Sum1_k_idx_1 = 0.017453292519943295 * a_0;

            // UnitConversion: '<S83>/Unit Conversion'
            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            rtb_LatitudeGCS_gv *= 0.017453292519943295;

            // Trigonometry: '<S84>/Trigonometric Function1'
            a_0 = std::sin(rtb_LatitudeGCS_gv);

            // Sum: '<S84>/Sum1' incorporates:
            //   Constant: '<S84>/Constant'
            //   Product: '<S84>/Product1'

            a_0 = 1.0 - 0.0066943799901413295 * a_0 * a_0;

            // Product: '<S82>/Product1' incorporates:
            //   Constant: '<S82>/Constant1'
            //   Sqrt: '<S82>/sqrt'

            rtb_AltitudeGCS_dj = 6.378137E+6 / std::sqrt(a_0);

            // Product: '<S67>/dNorth' incorporates:
            //   Constant: '<S82>/Constant2'
            //   Product: '<S82>/Product3'
            //   Trigonometry: '<S82>/Trigonometric Function1'

            a_0 = rtb_Sum1_k_idx_0 / rt_atan2d_snf(1.0, rtb_AltitudeGCS_dj *
                0.99330562000985867 / a_0);

            // Product: '<S67>/dEast' incorporates:
            //   Constant: '<S82>/Constant3'
            //   Product: '<S82>/Product4'
            //   Trigonometry: '<S82>/Trigonometric Function'
            //   Trigonometry: '<S82>/Trigonometric Function2'

            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            rtb_AltitudeGCS_dj = 1.0 / rt_atan2d_snf(1.0, rtb_AltitudeGCS_dj *
                std::cos(rtb_LatitudeGCS_gv)) * rtb_Sum1_k_idx_1;

            // Sum: '<S67>/Sum2' incorporates:
            //   Product: '<S67>/x*cos'
            //   Product: '<S67>/y*sin'

            rtb_LatitudeGCS_gv = rtb_AltitudeGCS_dj * 0.0 + a_0;

            // Sum: '<S67>/Sum3' incorporates:
            //   Product: '<S67>/x*sin'
            //   Product: '<S67>/y*cos'

            rtb_Down2Up_c = rtb_AltitudeGCS_dj - a_0 * 0.0;

            // DataStoreRead: '<S34>/LatitudeGCS'
            rtw_pthread_mutex_lock(LatitudeGCS_m0);
            rtb_Sum_k5 = LatitudeGCS;
            rtw_pthread_mutex_unlock(LatitudeGCS_m0);

            // DataStoreRead: '<S34>/LongitudeGCS'
            rtw_pthread_mutex_lock(LongitudeGCS_m0);
            rtb_Abs1_n = LongitudeGCS;
            rtw_pthread_mutex_unlock(LongitudeGCS_m0);

            // Sum: '<S36>/Sum1' incorporates:
            //   Sum: '<S40>/Sum'

            rtb_Sum1_k_idx_0 = rtu_Location->Lat - rtb_Sum_k5;
            rtb_Sum1_k_idx_1 = rtu_Location->Lon - rtb_Abs1_n;

            // Switch: '<S46>/Switch' incorporates:
            //   Abs: '<S46>/Abs'
            //   Bias: '<S46>/Bias'
            //   Bias: '<S46>/Bias1'
            //   Constant: '<S46>/Constant2'
            //   Constant: '<S47>/Constant'
            //   Math: '<S46>/Math Function1'
            //   RelationalOperator: '<S47>/Compare'

            if (std::abs(rtb_Sum1_k_idx_0) > 180.0) {
                a_0 = rt_modd_snf(rtb_Sum1_k_idx_0 + 180.0, 360.0) + -180.0;
            } else {
                a_0 = rtb_Sum1_k_idx_0;
            }

            // End of Switch: '<S46>/Switch'

            // Abs: '<S43>/Abs1'
            rtb_Abs1_n = std::abs(a_0);

            // Switch: '<S43>/Switch' incorporates:
            //   Bias: '<S43>/Bias'
            //   Bias: '<S43>/Bias1'
            //   Constant: '<S39>/Constant'
            //   Constant: '<S39>/Constant1'
            //   Constant: '<S45>/Constant'
            //   Gain: '<S43>/Gain'
            //   Product: '<S43>/Divide1'
            //   RelationalOperator: '<S45>/Compare'
            //   Switch: '<S39>/Switch1'

            if (rtb_Abs1_n > 90.0) {
                // Signum: '<S43>/Sign1'
                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>(std::isnan(a_0))
                      ^ 1))) {
                    if (a_0 < 0.0) {
                        a_0 = -1.0;
                    } else {
                        a_0 = static_cast<real_T>(a_0 > 0.0);
                    }
                }

                // End of Signum: '<S43>/Sign1'
                a_0 *= -(rtb_Abs1_n + -90.0) + 90.0;
                i = 180;
            } else {
                i = 0;
            }

            // End of Switch: '<S43>/Switch'

            // Sum: '<S39>/Sum'
            rtb_AltitudeGCS_dj = static_cast<real_T>(i) + rtb_Sum1_k_idx_1;

            // Switch: '<S44>/Switch' incorporates:
            //   Abs: '<S44>/Abs'
            //   Bias: '<S44>/Bias'
            //   Bias: '<S44>/Bias1'
            //   Constant: '<S44>/Constant2'
            //   Constant: '<S48>/Constant'
            //   Math: '<S44>/Math Function1'
            //   RelationalOperator: '<S48>/Compare'

            if (std::abs(rtb_AltitudeGCS_dj) > 180.0) {
                rtb_AltitudeGCS_dj = rt_modd_snf(rtb_AltitudeGCS_dj + 180.0,
                    360.0) + -180.0;
            }

            // End of Switch: '<S44>/Switch'

            // UnitConversion: '<S42>/Unit Conversion'
            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            rtb_Sum1_k_idx_0 = 0.017453292519943295 * a_0;
            rtb_Sum1_k_idx_1 = 0.017453292519943295 * rtb_AltitudeGCS_dj;

            // UnitConversion: '<S57>/Unit Conversion'
            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            rtb_Sum_k5 *= 0.017453292519943295;

            // Trigonometry: '<S58>/Trigonometric Function1'
            a_0 = std::sin(rtb_Sum_k5);

            // Sum: '<S58>/Sum1' incorporates:
            //   Constant: '<S58>/Constant'
            //   Product: '<S58>/Product1'

            a_0 = 1.0 - 0.0066943799901413295 * a_0 * a_0;

            // Product: '<S56>/Product1' incorporates:
            //   Constant: '<S56>/Constant1'
            //   Sqrt: '<S56>/sqrt'

            rtb_AltitudeGCS_dj = 6.378137E+6 / std::sqrt(a_0);

            // Product: '<S41>/dNorth' incorporates:
            //   Constant: '<S56>/Constant2'
            //   Product: '<S56>/Product3'
            //   Trigonometry: '<S56>/Trigonometric Function1'

            a_0 = rtb_Sum1_k_idx_0 / rt_atan2d_snf(1.0, rtb_AltitudeGCS_dj *
                0.99330562000985867 / a_0);

            // Product: '<S41>/dEast' incorporates:
            //   Constant: '<S56>/Constant3'
            //   Product: '<S56>/Product4'
            //   Trigonometry: '<S56>/Trigonometric Function'
            //   Trigonometry: '<S56>/Trigonometric Function2'

            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            rtb_Sum_k5 = 1.0 / rt_atan2d_snf(1.0, rtb_AltitudeGCS_dj * std::cos
                (rtb_Sum_k5)) * rtb_Sum1_k_idx_1;

            // Sum: '<S41>/Sum2' incorporates:
            //   Product: '<S41>/x*cos'
            //   Product: '<S41>/y*sin'

            rtb_AltitudeGCS_dj = rtb_Sum_k5 * 0.0 + a_0;

            // Sum: '<S41>/Sum3' incorporates:
            //   Product: '<S41>/x*sin'
            //   Product: '<S41>/y*cos'

            rtb_Abs1_n = rtb_Sum_k5 - a_0 * 0.0;

            // Saturate: '<S34>/Saturation' incorporates:
            //   DataTypeConversion: '<S34>/Param3'

            if (rtu_Parameters->Param3 <= 1.0F) {
                a_0 = 1.0;
            } else {
                a_0 = static_cast<real_T>(rtu_Parameters->Param3);
            }

            // End of Saturate: '<S34>/Saturation'

            // Switch: '<S34>/Switch' incorporates:
            //   Bias: '<S34>/Bias'
            //   Constant: '<S34>/Zero'

            if (rtb_Compare_lx) {
                rtb_Sum1_k_idx_1 = 0.0;
            } else {
                // DataTypeConversion: '<S34>/Cast To Double Mission UAV'
                rtb_Sum_k5 = static_cast<real_T>(*rtu_MissionUAV);
                rtb_Sum1_k_idx_1 = rtb_Sum_k5 + -1.0;
            }

            // End of Switch: '<S34>/Switch'

            // Product: '<S34>/Map2Radian' incorporates:
            //   Gain: '<S34>/Half'
            //   Sum: '<S34>/MinusNumUAV'

            rtb_Switch_lo = (rtb_Switch_lo - 0.5 * rtb_Sum1_k_idx_1) * a_0;

            // Gain: '<S35>/Gain1'
            rtb_Sum_k5 = 0.017453292519943295 * rtu_Location->degHDG;

            // Outputs for Enabled SubSystem: '<S34>/WayPointGenerator' incorporates:
            //   EnablePort: '<S38>/Enable'

            if (*rtu_Reset > 0) {
                int32_T loop_ub;
                if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<
                        int32_T>(FlightMissionMode_DW.WayPointGenerator_MODE_h) ^
                      1))) {
                    FILE* a;

                    // SystemReset for MATLAB Function: '<S38>/WayPointGenerator' 
                    FlightMissionMode_DW.SingletonInstance_not_empty = false;
                    a = NULL;
                    for (i = 0; i < 20; i++) {
                        FlightMissionMode_DW.eml_openfiles[i] = a;
                    }

                    // End of SystemReset for MATLAB Function: '<S38>/WayPointGenerator' 
                    FlightMissionMode_DW.WayPointGenerator_MODE_h = true;
                }

                // DataTypeConversion: '<S38>/Cast To Double'
                rtb_CastToDouble_l = static_cast<real_T>(*rtu_MissionUAV);

                // Reshape: '<S38>/ReshapeRowVec'
                rtb_TmpSignalConversionAtOrbitFollowerInport2[0] =
                    rtb_AltitudeGCS_dj;
                rtb_TmpSignalConversionAtOrbitFollowerInport2[1] = rtb_Abs1_n;
                rtb_TmpSignalConversionAtOrbitFollowerInport2[2] = rtb_Cos_j;

                // Switch: '<S38>/Switch' incorporates:
                //   Bias: '<S38>/Bias'
                //   Constant: '<S38>/Zero'

                if (rtb_Compare_lx) {
                    rtb_Sum1_k_idx_0 = 0.0;
                } else {
                    rtb_Sum1_k_idx_0 = rtb_CastToDouble_l + -1.0;
                }

                // End of Switch: '<S38>/Switch'
                FlightMissionMode_emxInit_real_T_h(&CheckPoints, 2);

                // Product: '<S38>/ReverseBias' incorporates:
                //   Gain: '<S38>/Half'

                rtb_Sum1_k_idx_1 = 0.5 * rtb_Sum1_k_idx_0 * a_0;

                // SignalConversion generated from: '<S38>/RotateATMissionHdg' incorporates:
                //   Constant: '<S38>/Zero'

                rtb_TmpSignalConversionAtRotateATMissionHdgInport1_i[0] =
                    rtb_Sum_k5;
                rtb_TmpSignalConversionAtRotateATMissionHdgInport1_i[1] = 0.0;
                rtb_TmpSignalConversionAtRotateATMissionHdgInport1_i[2] = 0.0;
                FlightMissionMode_RotateATMissionHdg(&self_RotateATMissionHdg,
                    rtb_TmpSignalConversionAtRotateATMissionHdgInport1_i);

                // Reshape: '<S34>/Reshape2Row' incorporates:
                //   Sum: '<S34>/RelPrevPos'

                rtb_ReshapeRowVecStartpose_d[0] = rtb_Down2Up_c - rtb_Abs1_n;
                rtb_ReshapeRowVecStartpose_d[1] = rtb_LatitudeGCS_gv -
                    rtb_AltitudeGCS_dj;
                rtb_ReshapeRowVecStartpose_d[2] = rtb_Sum_id - rtb_Cos_j;

                // Product: '<S38>/RotateRelPrevPos' incorporates:
                //   MATLABSystem: '<S38>/RotateATMissionHdg'

                rt_mrdivide_U1d1x3_U2d3x3_Yd1x3_snf(rtb_ReshapeRowVecStartpose_d,
                    self_RotateATMissionHdg.dwork.RotateATMissionHdg, u);

                // MATLAB Function: '<S38>/WayPointGenerator' incorporates:
                //   DataTypeConversion: '<S34>/Param2'
                //   Product: '<S38>/ProductScanWidth'

                // MATLAB Function 'Mode2_HorzScanNav/Mode2_Variant/Mode2/WayPointGenerator/WayPointGenerator': '<S87>:1' 
                // '<S87>:1:28'
                // '<S87>:1:4'
                a_0 = std::ceil(static_cast<real_T>(rtu_Parameters->Param2) /
                                (a_0 * rtb_CastToDouble_l));

                // '<S87>:1:5'
                rtb_CastToDouble_l = static_cast<real_T>(rtu_Parameters->Param2)
                    / a_0;

                // '<S87>:1:8'
                i = static_cast<int32_T>(CheckPoints->size[0] *
                    CheckPoints->size[1]);

                // MATLAB Function: '<S38>/WayPointGenerator'
                rtb_Bias_f = static_cast<int32_T>(a_0 * 2.0);
                CheckPoints->size[0] = rtb_Bias_f;
                CheckPoints->size[1] = 4;
                FlightMissionMode_emxEnsureCapacity_real_T_c(CheckPoints, i);

                // MATLAB Function: '<S38>/WayPointGenerator' incorporates:
                //   DataTypeConversion: '<S34>/Param1'

                ibcol = static_cast<int32_T>(static_cast<int32_T>(rtb_Bias_f <<
                    2) - 1);
                for (i = 0; i <= ibcol; i++) {
                    CheckPoints->data[i] = 0.0;
                }

                // '<S87>:1:9'
                for (rtb_Bias_f = 0; rtb_Bias_f <= static_cast<int32_T>(
                        static_cast<int32_T>(a_0) - 1); rtb_Bias_f =
                        static_cast<int32_T>(rtb_Bias_f + 1)) {
                    // '<S87>:1:9'
                    if (rt_remd_snf(static_cast<real_T>(rtb_Bias_f) + 1.0, 2.0) ==
                        1.0) {
                        // '<S87>:1:10'
                        // '<S87>:1:11'
                        i = static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>(rtb_Bias_f + 1) << 1) - 2);
                        CheckPoints->data[i] = ((static_cast<real_T>(rtb_Bias_f)
                            + 1.0) - 1.0) * rtb_CastToDouble_l;
                        CheckPoints->data[static_cast<int32_T>(i +
                            CheckPoints->size[0])] = 0.0;
                        CheckPoints->data[static_cast<int32_T>(i +
                            static_cast<int32_T>(CheckPoints->size[0] << 1))] =
                            0.0;
                        CheckPoints->data[static_cast<int32_T>(i +
                            static_cast<int32_T>(CheckPoints->size[0] * 3))] =
                            1.5707963267948966;

                        // '<S87>:1:13'
                        i = static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>(rtb_Bias_f + 1) << 1) - 1);
                        CheckPoints->data[i] = ((static_cast<real_T>(rtb_Bias_f)
                            + 1.0) - 1.0) * rtb_CastToDouble_l;
                        CheckPoints->data[static_cast<int32_T>(i +
                            CheckPoints->size[0])] = static_cast<real_T>
                            (rtu_Parameters->Param1);
                        CheckPoints->data[static_cast<int32_T>(i +
                            static_cast<int32_T>(CheckPoints->size[0] << 1))] =
                            0.0;
                        CheckPoints->data[static_cast<int32_T>(i +
                            static_cast<int32_T>(CheckPoints->size[0] * 3))] =
                            1.5707963267948966;
                    } else {
                        // '<S87>:1:16'
                        i = static_cast<int32_T>(static_cast<int32_T>(rtb_Bias_f
                            + 1) << 1);
                        CheckPoints->data[static_cast<int32_T>(i - 2)] = ((
                            static_cast<real_T>(rtb_Bias_f) + 1.0) - 1.0) *
                            rtb_CastToDouble_l;
                        CheckPoints->data[static_cast<int32_T>
                            (static_cast<int32_T>(i + CheckPoints->size[0]) - 2)]
                            = static_cast<real_T>(rtu_Parameters->Param1);
                        CheckPoints->data[static_cast<int32_T>(static_cast<
                            int32_T>(i + static_cast<int32_T>(CheckPoints->size
                            [0] << 1)) - 2)] = 0.0;
                        CheckPoints->data[static_cast<int32_T>
                            (static_cast<int32_T>(i + static_cast<int32_T>
                              (CheckPoints->size[0] * 3)) - 2)] =
                            -1.5707963267948966;

                        // '<S87>:1:18'
                        CheckPoints->data[static_cast<int32_T>(i - 1)] = ((
                            static_cast<real_T>(rtb_Bias_f) + 1.0) - 1.0) *
                            rtb_CastToDouble_l;
                        CheckPoints->data[static_cast<int32_T>
                            (static_cast<int32_T>(i + CheckPoints->size[0]) - 1)]
                            = 0.0;
                        CheckPoints->data[static_cast<int32_T>
                            (static_cast<int32_T>(i + static_cast<int32_T>
                              (CheckPoints->size[0] << 1)) - 1)] = 0.0;
                        CheckPoints->data[static_cast<int32_T>
                            (static_cast<int32_T>(i + static_cast<int32_T>
                              (CheckPoints->size[0] * 3)) - 1)] =
                            -1.5707963267948966;
                    }
                }

                // '<S87>:1:24'
                i = static_cast<int32_T>(dummyWayPoint->size[0] *
                    dummyWayPoint->size[1]);

                // MATLAB Function: '<S38>/WayPointGenerator'
                dummyWayPoint->size[0] = 1;
                dummyWayPoint->size[1] = 3;
                FlightMissionMode_emxEnsureCapacity_real_T_c(dummyWayPoint, i);

                // MATLAB Function: '<S38>/WayPointGenerator'
                dummyWayPoint->data[0] = 0.0;
                dummyWayPoint->data[1] = 0.0;
                dummyWayPoint->data[2] = 0.0;

                // '<S87>:1:27'
                rtb_Bias_f = 0;
                FlightMissionMode_emxInit_real_T_h(&segWayPoints, 2);
                FlightMissionMode_emxInit_real_T_h(&dummyWayPoint_0, 2);

                // MATLAB Function: '<S38>/WayPointGenerator'
                while (rtb_Bias_f <= static_cast<int32_T>(CheckPoints->size[0] -
                        2)) {
                    // '<S87>:1:27'
                    // '<S87>:1:28'
                    CheckPoints_0[0] = CheckPoints->data[rtb_Bias_f];
                    CheckPoints_1[0] = CheckPoints->data[static_cast<int32_T>
                        (rtb_Bias_f + 1)];
                    CheckPoints_0[1] = CheckPoints->data[static_cast<int32_T>
                        (rtb_Bias_f + CheckPoints->size[0])];
                    CheckPoints_1[1] = CheckPoints->data[static_cast<int32_T>(
                        static_cast<int32_T>(rtb_Bias_f + CheckPoints->size[0])
                        + 1)];
                    CheckPoints_0[2] = CheckPoints->data[static_cast<int32_T>(
                        static_cast<int32_T>(CheckPoints->size[0] << 1) +
                        rtb_Bias_f)];
                    CheckPoints_1[2] = CheckPoints->data[static_cast<int32_T>(
                        static_cast<int32_T>(static_cast<int32_T>
                        (CheckPoints->size[0] << 1) + rtb_Bias_f) + 1)];
                    CheckPoints_0[3] = CheckPoints->data[static_cast<int32_T>(
                        static_cast<int32_T>(CheckPoints->size[0] * 3) +
                        rtb_Bias_f)];
                    CheckPoints_1[3] = CheckPoints->data[static_cast<int32_T>(
                        static_cast<int32_T>(static_cast<int32_T>
                        (CheckPoints->size[0] * 3) + rtb_Bias_f) + 1)];
                    FlightMissionMode_genSegWP_m(CheckPoints_0, CheckPoints_1,
                        100.0, segWayPoints);
                    i = static_cast<int32_T>(dummyWayPoint_0->size[0] *
                        dummyWayPoint_0->size[1]);
                    dummyWayPoint_0->size[0] = static_cast<int32_T>
                        (dummyWayPoint->size[0] + segWayPoints->size[0]);
                    dummyWayPoint_0->size[1] = 3;
                    FlightMissionMode_emxEnsureCapacity_real_T_c(dummyWayPoint_0,
                        i);
                    ibcol = dummyWayPoint->size[0];
                    for (i = 0; i < 3; i++) {
                        for (i2 = 0; i2 <= static_cast<int32_T>(ibcol - 1); i2++)
                        {
                            dummyWayPoint_0->data[static_cast<int32_T>(i2 +
                                static_cast<int32_T>(dummyWayPoint_0->size[0] *
                                i))] = dummyWayPoint->data[static_cast<int32_T>(
                                static_cast<int32_T>(dummyWayPoint->size[0] * i)
                                + i2)];
                        }
                    }

                    ibcol = segWayPoints->size[0];
                    for (i = 0; i < 3; i++) {
                        for (i2 = 0; i2 <= static_cast<int32_T>(ibcol - 1); i2++)
                        {
                            dummyWayPoint_0->data[static_cast<int32_T>(
                                static_cast<int32_T>(i2 + dummyWayPoint->size[0])
                                + static_cast<int32_T>(dummyWayPoint_0->size[0] *
                                i))] = segWayPoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(segWayPoints->size[0] * i)
                                + i2)];
                        }
                    }

                    i = static_cast<int32_T>(dummyWayPoint->size[0] *
                        dummyWayPoint->size[1]);
                    dummyWayPoint->size[0] = dummyWayPoint_0->size[0];
                    dummyWayPoint->size[1] = 3;
                    FlightMissionMode_emxEnsureCapacity_real_T_c(dummyWayPoint,
                        i);
                    ibcol = static_cast<int32_T>(dummyWayPoint_0->size[0] * 3);
                    for (i = 0; i <= static_cast<int32_T>(ibcol - 1); i++) {
                        dummyWayPoint->data[i] = dummyWayPoint_0->data[i];
                    }

                    rtb_Bias_f = static_cast<int32_T>(rtb_Bias_f + 1);
                }

                // '<S87>:1:33'
                CheckPoints_0[0] = CheckPoints->data[static_cast<int32_T>
                    (CheckPoints->size[0] - 1)];
                CheckPoints_1[0] = CheckPoints->data[0];
                CheckPoints_0[1] = CheckPoints->data[static_cast<int32_T>(
                    static_cast<int32_T>(CheckPoints->size[0] +
                    CheckPoints->size[0]) - 1)];
                CheckPoints_1[1] = CheckPoints->data[CheckPoints->size[0]];
                CheckPoints_0[2] = CheckPoints->data[static_cast<int32_T>(
                    static_cast<int32_T>(static_cast<int32_T>(CheckPoints->size
                    [0] << 1) + CheckPoints->size[0]) - 1)];
                CheckPoints_1[2] = CheckPoints->data[static_cast<int32_T>
                    (CheckPoints->size[0] << 1)];
                CheckPoints_0[3] = CheckPoints->data[static_cast<int32_T>(
                    static_cast<int32_T>(static_cast<int32_T>(CheckPoints->size
                    [0] * 3) + CheckPoints->size[0]) - 1)];
                CheckPoints_1[3] = CheckPoints->data[static_cast<int32_T>
                    (CheckPoints->size[0] * 3)];
                FlightMissionMode_genSegWP_m(CheckPoints_0, CheckPoints_1, 100.0,
                    segWayPoints);

                // '<S87>:1:34'
                i = static_cast<int32_T>(dummyWayPoint_0->size[0] *
                    dummyWayPoint_0->size[1]);

                // MATLAB Function: '<S38>/WayPointGenerator'
                dummyWayPoint_0->size[0] = static_cast<int32_T>
                    (dummyWayPoint->size[0] + segWayPoints->size[0]);
                dummyWayPoint_0->size[1] = 3;
                FlightMissionMode_emxEnsureCapacity_real_T_c(dummyWayPoint_0, i);

                // MATLAB Function: '<S38>/WayPointGenerator'
                ibcol = dummyWayPoint->size[0];
                loop_ub = segWayPoints->size[0];
                for (i = 0; i < 3; i++) {
                    for (i2 = 0; i2 <= static_cast<int32_T>(ibcol - 1); i2++) {
                        dummyWayPoint_0->data[static_cast<int32_T>(i2 +
                            static_cast<int32_T>(dummyWayPoint_0->size[0] * i))]
                            = dummyWayPoint->data[static_cast<int32_T>(
                            static_cast<int32_T>(dummyWayPoint->size[0] * i) +
                            i2)];
                    }

                    for (i2 = 0; i2 <= static_cast<int32_T>(loop_ub - 1); i2++)
                    {
                        dummyWayPoint_0->data[static_cast<int32_T>
                            (static_cast<int32_T>(i2 + dummyWayPoint->size[0]) +
                             static_cast<int32_T>(dummyWayPoint_0->size[0] * i))]
                            = segWayPoints->data[static_cast<int32_T>(
                            static_cast<int32_T>(segWayPoints->size[0] * i) + i2)];
                    }
                }

                i = static_cast<int32_T>(dummyWayPoint->size[0] *
                    dummyWayPoint->size[1]);

                // MATLAB Function: '<S38>/WayPointGenerator'
                dummyWayPoint->size[0] = dummyWayPoint_0->size[0];
                dummyWayPoint->size[1] = 3;
                FlightMissionMode_emxEnsureCapacity_real_T_c(dummyWayPoint, i);

                // MATLAB Function: '<S38>/WayPointGenerator'
                ibcol = static_cast<int32_T>(dummyWayPoint_0->size[0] * 3);
                for (i = 0; i <= static_cast<int32_T>(ibcol - 1); i++) {
                    dummyWayPoint->data[i] = dummyWayPoint_0->data[i];
                }

                // '<S87>:1:37'
                nrowx = static_cast<int32_T>(dummyWayPoint->size[0] - 2);
                nrows = static_cast<int32_T>(dummyWayPoint->size[0] - 1);
                for (i2 = 0; i2 <= nrowx; i2 = static_cast<int32_T>(i2 + 1)) {
                    dummyWayPoint->data[i2] = dummyWayPoint->data
                        [static_cast<int32_T>(i2 + 1)];
                }

                for (i2 = 0; i2 <= nrowx; i2 = static_cast<int32_T>(i2 + 1)) {
                    dummyWayPoint->data[static_cast<int32_T>(i2 +
                        dummyWayPoint->size[0])] = dummyWayPoint->data[
                        static_cast<int32_T>(static_cast<int32_T>(i2 +
                        dummyWayPoint->size[0]) + 1)];
                }

                for (i2 = 0; i2 <= nrowx; i2 = static_cast<int32_T>(i2 + 1)) {
                    dummyWayPoint->data[static_cast<int32_T>(i2 +
                        static_cast<int32_T>(dummyWayPoint->size[0] << 1))] =
                        dummyWayPoint->data[static_cast<int32_T>
                        (static_cast<int32_T>(static_cast<int32_T>
                          (dummyWayPoint->size[0] << 1) + i2) + 1)];
                }

                if (nrows < 1) {
                    ibcol = -1;
                } else {
                    ibcol = nrowx;
                }

                i = static_cast<int32_T>(segWayPoints->size[0] *
                    segWayPoints->size[1]);

                // MATLAB Function: '<S38>/WayPointGenerator'
                segWayPoints->size[0] = static_cast<int32_T>(ibcol + 1);
                segWayPoints->size[1] = 3;
                FlightMissionMode_emxEnsureCapacity_real_T_c(segWayPoints, i);

                // MATLAB Function: '<S38>/WayPointGenerator'
                for (i = 0; i < 3; i++) {
                    for (i2 = 0; i2 <= ibcol; i2++) {
                        segWayPoints->data[static_cast<int32_T>(i2 +
                            static_cast<int32_T>(segWayPoints->size[0] * i))] =
                            dummyWayPoint->data[static_cast<int32_T>(
                            static_cast<int32_T>(dummyWayPoint->size[0] * i) +
                            i2)];
                    }
                }

                // '<S87>:1:38'
                if (nrows < 1) {
                    i = -1;
                    nrowx = -1;
                } else {
                    i = nrowx;
                }

                a_0 = std::ceil(10240.0 / static_cast<real_T>
                                (static_cast<int32_T>(i + 1)));
                i = static_cast<int32_T>(dummyWayPoint->size[0] *
                    dummyWayPoint->size[1]);

                // MATLAB Function: '<S38>/WayPointGenerator'
                dummyWayPoint->size[0] = static_cast<int32_T>
                    (static_cast<int32_T>(nrowx + 1) * static_cast<int32_T>(a_0));
                dummyWayPoint->size[1] = 3;
                FlightMissionMode_emxEnsureCapacity_real_T_c(dummyWayPoint, i);

                // MATLAB Function: '<S38>/WayPointGenerator' incorporates:
                //   Product: '<S38>/RotateRelPrevPos'

                nrows = segWayPoints->size[0];
                for (nrowx = 0; nrowx <= static_cast<int32_T>
                        (static_cast<int32_T>(a_0) - 1); nrowx =
                        static_cast<int32_T>(nrowx + 1)) {
                    ibcol = static_cast<int32_T>(static_cast<int32_T>(nrowx *
                        nrows) + -1);
                    for (i2 = 1; static_cast<int32_T>(i2 - 1) <=
                            static_cast<int32_T>(nrows - 1); i2 =
                            static_cast<int32_T>(i2 + 1)) {
                        dummyWayPoint->data[static_cast<int32_T>(ibcol + i2)] =
                            segWayPoints->data[static_cast<int32_T>(i2 - 1)];
                    }
                }

                i = static_cast<int32_T>(static_cast<int32_T>(segWayPoints->
                    size[0] * static_cast<int32_T>(a_0)) - 1);
                for (nrowx = 0; nrowx <= static_cast<int32_T>
                        (static_cast<int32_T>(a_0) - 1); nrowx =
                        static_cast<int32_T>(nrowx + 1)) {
                    ibcol = static_cast<int32_T>(static_cast<int32_T>(nrowx *
                        nrows) + i);
                    for (i2 = 1; static_cast<int32_T>(i2 - 1) <=
                            static_cast<int32_T>(nrows - 1); i2 =
                            static_cast<int32_T>(i2 + 1)) {
                        dummyWayPoint->data[static_cast<int32_T>(ibcol + i2)] =
                            segWayPoints->data[static_cast<int32_T>(static_cast<
                            int32_T>(nrows + i2) - 1)];
                    }
                }

                rtb_Bias_f = static_cast<int32_T>(segWayPoints->size[0] << 1);
                i = static_cast<int32_T>(static_cast<int32_T>
                    (static_cast<int32_T>(segWayPoints->size[0] *
                    static_cast<int32_T>(a_0)) << 1) - 1);
                for (nrowx = 0; nrowx <= static_cast<int32_T>
                        (static_cast<int32_T>(a_0) - 1); nrowx =
                        static_cast<int32_T>(nrowx + 1)) {
                    ibcol = static_cast<int32_T>(static_cast<int32_T>(nrowx *
                        nrows) + i);
                    for (i2 = 1; static_cast<int32_T>(i2 - 1) <=
                            static_cast<int32_T>(nrows - 1); i2 =
                            static_cast<int32_T>(i2 + 1)) {
                        dummyWayPoint->data[static_cast<int32_T>(ibcol + i2)] =
                            segWayPoints->data[static_cast<int32_T>(static_cast<
                            int32_T>(rtb_Bias_f + i2) - 1)];
                    }
                }

                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>(rtb_Compare_lx)
                      ^ 1))) {
                    // '<S87>:1:40'
                    rtb_Compare_em = false;
                    rtb_Bias_f = 0;
                    exitg1 = false;
                    while ((!exitg1) && (rtb_Bias_f < 3)) {
                        if (static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<boolean_T>(
                                static_cast<int32_T>((u[rtb_Bias_f] == 0.0) ^ 1)))
                              & static_cast<int32_T>(static_cast<boolean_T>(
                                static_cast<int32_T>(static_cast<int32_T>(std::
                                  isnan(u[rtb_Bias_f])) ^ 1)))))) {
                            rtb_Compare_em = true;
                            exitg1 = true;
                        } else {
                            rtb_Bias_f = static_cast<int32_T>(rtb_Bias_f + 1);
                        }
                    }

                    if (rtb_Compare_em) {
                        // '<S87>:1:40'
                        // '<S87>:1:42'
                        CheckPoints_1[0] = u[0] + -rtb_Sum1_k_idx_1;
                        CheckPoints_1[1] = u[1];
                        CheckPoints_1[2] = u[2];
                        CheckPoints_1[3] = 1.5707963267948966;
                        CheckPoints_0[0] = CheckPoints->data[0];
                        CheckPoints_0[1] = CheckPoints->data[CheckPoints->size[0]];
                        CheckPoints_0[2] = CheckPoints->data[static_cast<int32_T>
                            (CheckPoints->size[0] << 1)];
                        CheckPoints_0[3] = CheckPoints->data[static_cast<int32_T>
                            (CheckPoints->size[0] * 3)];
                        FlightMissionMode_genSegWP_m(CheckPoints_1,
                            CheckPoints_0, 100.0, segWayPoints);

                        // '<S87>:1:44'
                        i = static_cast<int32_T>(dummyWayPoint_0->size[0] *
                            dummyWayPoint_0->size[1]);
                        dummyWayPoint_0->size[0] = static_cast<int32_T>
                            (segWayPoints->size[0] + dummyWayPoint->size[0]);
                        dummyWayPoint_0->size[1] = 3;
                        FlightMissionMode_emxEnsureCapacity_real_T_c
                            (dummyWayPoint_0, i);
                        ibcol = segWayPoints->size[0];
                        loop_ub = dummyWayPoint->size[0];
                        for (i = 0; i < 3; i++) {
                            for (i2 = 0; i2 <= static_cast<int32_T>(ibcol - 1);
                                    i2++) {
                                dummyWayPoint_0->data[static_cast<int32_T>(i2 +
                                    static_cast<int32_T>(dummyWayPoint_0->size[0]
                                    * i))] = segWayPoints->data
                                    [static_cast<int32_T>(static_cast<int32_T>
                                    (segWayPoints->size[0] * i) + i2)];
                            }

                            for (i2 = 0; i2 <= static_cast<int32_T>(loop_ub - 1);
                                 i2++) {
                                dummyWayPoint_0->data[static_cast<int32_T>(
                                    static_cast<int32_T>(i2 + segWayPoints->
                                    size[0]) + static_cast<int32_T>
                                    (dummyWayPoint_0->size[0] * i))] =
                                    dummyWayPoint->data[static_cast<int32_T>(
                                    static_cast<int32_T>(dummyWayPoint->size[0] *
                                    i) + i2)];
                            }
                        }

                        i = static_cast<int32_T>(dummyWayPoint->size[0] *
                            dummyWayPoint->size[1]);
                        dummyWayPoint->size[0] = dummyWayPoint_0->size[0];
                        dummyWayPoint->size[1] = 3;
                        FlightMissionMode_emxEnsureCapacity_real_T_c
                            (dummyWayPoint, i);
                        ibcol = static_cast<int32_T>(dummyWayPoint_0->size[0] *
                            3);
                        for (i = 0; i <= static_cast<int32_T>(ibcol - 1); i++) {
                            dummyWayPoint->data[i] = dummyWayPoint_0->data[i];
                        }
                    }
                }

                FlightMissionMode_emxFree_real_T_n(&dummyWayPoint_0);
                FlightMissionMode_emxFree_real_T_n(&segWayPoints);
                FlightMissionMode_emxFree_real_T_n(&CheckPoints);

                // MATLAB Function: '<S38>/WayPointGenerator'
                // '<S87>:1:48'
                i = 0;
                for (i2 = 0; i2 < 3; i2++) {
                    for (nrowx = 0; nrowx < 8192; nrowx++) {
                        FlightMissionMode_DW.WayPoint_p[static_cast<int32_T>
                            (nrowx + i)] = dummyWayPoint->data
                            [static_cast<int32_T>(static_cast<int32_T>
                            (dummyWayPoint->size[0] * i2) + nrowx)];
                    }

                    i = static_cast<int32_T>(i + 8192);
                }

                // Sum: '<S38>/Sum'
                a_0 = rtb_Sum1_k_idx_1 + rtb_Switch_lo;

                // MATLAB Function: '<S38>/biasWayPoint'
                // MATLAB Function 'biasWayPoint': '<S89>:1'
                // '<S89>:1:4'
                for (i = 0; i < 8192; i++) {
                    FlightMissionMode_DW.WayPoint_p_m[i] =
                        FlightMissionMode_DW.WayPoint_p[i] + a_0;
                    FlightMissionMode_DW.WayPoint_p_m[static_cast<int32_T>(i +
                        8192)] = FlightMissionMode_DW.WayPoint_p
                        [static_cast<int32_T>(i + 8192)];
                    FlightMissionMode_DW.WayPoint_p_m[static_cast<int32_T>(i +
                        16384)] = FlightMissionMode_DW.WayPoint_p
                        [static_cast<int32_T>(i + 16384)];
                }

                // End of MATLAB Function: '<S38>/biasWayPoint'

                // Product: '<S38>/RotateIndivWayPoint' incorporates:
                //   MATLABSystem: '<S38>/RotateATMissionHdg'

                i = 0;
                i2 = 0;
                for (nrowx = 0; nrowx < 3; nrowx++) {
                    for (rtb_Bias_f = 0; rtb_Bias_f < 8192; rtb_Bias_f++) {
                        nrows = static_cast<int32_T>(rtb_Bias_f + i);
                        FlightMissionMode_DW.RotateIndivWayPoint_g[nrows] = 0.0;
                        FlightMissionMode_DW.RotateIndivWayPoint_g[nrows] +=
                            self_RotateATMissionHdg.dwork.RotateATMissionHdg[i2]
                            * FlightMissionMode_DW.WayPoint_p_m[rtb_Bias_f];
                        FlightMissionMode_DW.RotateIndivWayPoint_g[nrows] +=
                            self_RotateATMissionHdg.dwork.RotateATMissionHdg[
                            static_cast<int32_T>(i2 + 1)] *
                            FlightMissionMode_DW.WayPoint_p_m
                            [static_cast<int32_T>(rtb_Bias_f + 8192)];
                        FlightMissionMode_DW.RotateIndivWayPoint_g[nrows] +=
                            self_RotateATMissionHdg.dwork.RotateATMissionHdg[
                            static_cast<int32_T>(i2 + 2)] *
                            FlightMissionMode_DW.WayPoint_p_m
                            [static_cast<int32_T>(rtb_Bias_f + 16384)];
                    }

                    i = static_cast<int32_T>(i + 8192);
                    i2 = static_cast<int32_T>(i2 + 3);
                }

                // End of Product: '<S38>/RotateIndivWayPoint'

                // MATLAB Function: '<S38>/biasNED' incorporates:
                //   Product: '<S38>/RotateIndivWayPoint'
                //   Reshape: '<S38>/ReshapeRowVec'

                // MATLAB Function 'biasNED': '<S88>:1'
                // '<S88>:1:4'
                for (rtb_Bias_f = 0; rtb_Bias_f < 3; rtb_Bias_f++) {
                    i = static_cast<int32_T>(rtb_Bias_f << 13);
                    for (nrowx = 0; nrowx < 8192; nrowx++) {
                        FlightMissionMode_DW.WayPoint_p[static_cast<int32_T>(i +
                            nrowx)] =
                            rtb_TmpSignalConversionAtOrbitFollowerInport2[rtb_Bias_f];
                    }
                }

                for (i = 0; i < 8192; i++) {
                    FlightMissionMode_DW.nedWayPoint_o[i] =
                        FlightMissionMode_DW.RotateIndivWayPoint_g
                        [static_cast<int32_T>(i + 8192)] +
                        FlightMissionMode_DW.WayPoint_p[i];
                    FlightMissionMode_DW.nedWayPoint_o[static_cast<int32_T>(i +
                        8192)] = FlightMissionMode_DW.WayPoint_p
                        [static_cast<int32_T>(i + 8192)] +
                        FlightMissionMode_DW.RotateIndivWayPoint_g[i];
                    FlightMissionMode_DW.nedWayPoint_o[static_cast<int32_T>(i +
                        16384)] = FlightMissionMode_DW.RotateIndivWayPoint_g[
                        static_cast<int32_T>(i + 16384)] +
                        FlightMissionMode_DW.WayPoint_p[static_cast<int32_T>(i +
                        16384)];
                }

                // End of MATLAB Function: '<S38>/biasNED'
            } else {
                FlightMissionMode_DW.WayPointGenerator_MODE_h = false;
            }

            // End of Outputs for SubSystem: '<S34>/WayPointGenerator'

            // MATLABSystem: '<S34>/Waypoint Follower' incorporates:
            //   MATLAB Function: '<S38>/WayPointGenerator'

            FlightMissionMode_DW.obj_k.LookaheadDistFlag = 0U;
            FlightMissionMode_DW.obj_k.InitialPose[0] = 0.0;
            FlightMissionMode_DW.obj_k.InitialPose[1] = 0.0;
            FlightMissionMode_DW.obj_k.InitialPose[2] = 0.0;
            FlightMissionMode_DW.obj_k.InitialPose[3] = 0.0;
            for (i = 0; i < 24576; i++) {
                FlightMissionMode_DW.RotateIndivWayPoint_g[i] = (rtNaN);
            }

            i = 0;
            for (i2 = 0; i2 < 3; i2++) {
                std::memcpy(&FlightMissionMode_DW.RotateIndivWayPoint_g[i],
                            &FlightMissionMode_DW.nedWayPoint_o[i],
                            static_cast<uint32_T>(sizeof(real_T) << 13U));
                i = static_cast<int32_T>(i + 8192);
            }

            rtb_Compare_em = false;
            rtb_Compare_ni = true;
            rtb_Bias_f = 0;
            exitg1 = false;
            while ((!exitg1) && (rtb_Bias_f < 24576)) {
                if ((FlightMissionMode_DW.obj_k.WaypointsInternal[rtb_Bias_f] ==
                     FlightMissionMode_DW.RotateIndivWayPoint_g[rtb_Bias_f]) ||
                        (std::isnan
                         (FlightMissionMode_DW.obj_k.WaypointsInternal[rtb_Bias_f])
                         && std::isnan
                         (FlightMissionMode_DW.RotateIndivWayPoint_g[rtb_Bias_f])))
                {
                    rtb_Bias_f = static_cast<int32_T>(rtb_Bias_f + 1);
                } else {
                    rtb_Compare_ni = false;
                    exitg1 = true;
                }
            }

            if (rtb_Compare_ni) {
                rtb_Compare_em = true;
            }

            if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                    (rtb_Compare_em) ^ 1))) {
                std::memcpy(&FlightMissionMode_DW.obj_k.WaypointsInternal[0],
                            &FlightMissionMode_DW.RotateIndivWayPoint_g[0],
                            static_cast<uint32_T>(24576U * sizeof(real_T)));
                FlightMissionMode_DW.obj_k.WaypointIndex = 1.0;
            }

            i = 0;
            for (i2 = 0; i2 < 3; i2++) {
                std::memcpy(&FlightMissionMode_DW.WayPoint_p[i],
                            &FlightMissionMode_DW.nedWayPoint_o
                            [static_cast<int32_T>(i + 1)], static_cast<uint32_T>
                            (8191U * sizeof(real_T)));
                i = static_cast<int32_T>(i + 8192);
            }

            FlightMissionMode_DW.WayPoint_p[8191] = (rtNaN);
            FlightMissionMode_DW.WayPoint_p[16383] = (rtNaN);
            FlightMissionMode_DW.WayPoint_p[24575] = (rtNaN);
            for (i = 0; i < 24576; i++) {
                FlightMissionMode_DW.x[i] =
                    (FlightMissionMode_DW.nedWayPoint_o[i] !=
                     FlightMissionMode_DW.WayPoint_p[i]);
            }

            nrows = 0;
            i2 = 16384;
            for (i = 0; i < 8192; i++) {
                FlightMissionMode_DW.b[i] = false;
                nrows = static_cast<int32_T>(nrows + 1);
                i2 = static_cast<int32_T>(i2 + 1);
                ntilerows = nrows;
                exitg1 = false;
                while ((!exitg1) && (ntilerows <= i2)) {
                    if (FlightMissionMode_DW.x[static_cast<int32_T>(ntilerows -
                            1)]) {
                        FlightMissionMode_DW.b[i] = true;
                        exitg1 = true;
                    } else {
                        ntilerows = static_cast<int32_T>(ntilerows + 8192);
                    }
                }
            }

            nrows = 0;
            for (rtb_Bias_f = 0; rtb_Bias_f < 8192; rtb_Bias_f++) {
                if (FlightMissionMode_DW.b[rtb_Bias_f]) {
                    nrows = static_cast<int32_T>(nrows + 1);
                }
            }

            nrowx = nrows;
            nrows = 0;
            for (rtb_Bias_f = 0; rtb_Bias_f < 8192; rtb_Bias_f++) {
                if (FlightMissionMode_DW.b[rtb_Bias_f]) {
                    FlightMissionMode_DW.c_data_f[nrows] = static_cast<int16_T>(
                        static_cast<int32_T>(rtb_Bias_f + 1));
                    nrows = static_cast<int32_T>(nrows + 1);
                }
            }

            i = static_cast<int32_T>(b_waypointsIn->size[0] *
                b_waypointsIn->size[1]);

            // MATLABSystem: '<S34>/Waypoint Follower'
            b_waypointsIn->size[0] = nrowx;
            b_waypointsIn->size[1] = 3;
            FlightMissionMode_emxEnsureCapacity_real_T_c(b_waypointsIn, i);

            // MATLABSystem: '<S34>/Waypoint Follower'
            for (i = 0; i < 3; i++) {
                for (i2 = 0; i2 <= static_cast<int32_T>(nrowx - 1); i2++) {
                    b_waypointsIn->data[static_cast<int32_T>(i2 +
                        static_cast<int32_T>(b_waypointsIn->size[0] * i))] =
                        FlightMissionMode_DW.nedWayPoint_o[static_cast<int32_T>(
                        static_cast<int32_T>(static_cast<int32_T>(i << 13) +
                        static_cast<int32_T>(FlightMissionMode_DW.c_data_f[i2]))
                        - 1)];
                }
            }

            FlightMissionMode_DW.obj_k.NumWaypoints = static_cast<real_T>(nrowx);
            FlightMissionMode_DW.obj_k.LookaheadDistance = 200.0;
            if (nrowx == 0) {
                turnVector[2] = rtu_Pose[2];
                a_0 = rtu_Pose[3];
                status = 1U;
            } else {
                boolean_T guard1;
                guard1 = false;
                if (nrowx == 1) {
                    if (FlightMissionMode_DW.obj_k.StartFlag) {
                        FlightMissionMode_DW.obj_k.InitialPose[0] = rtu_Pose[0];
                        FlightMissionMode_DW.obj_k.InitialPose[1] = rtu_Pose[1];
                        FlightMissionMode_DW.obj_k.InitialPose[2] = rtu_Pose[2];
                        FlightMissionMode_DW.obj_k.InitialPose[3] = rtu_Pose[3];
                    }

                    rtb_TmpSignalConversionAtOrbitFollowerInport2[0] =
                        b_waypointsIn->data[0] - rtu_Pose[0];
                    rtb_TmpSignalConversionAtOrbitFollowerInport2[1] =
                        b_waypointsIn->data[1] - rtu_Pose[1];
                    rtb_TmpSignalConversionAtOrbitFollowerInport2[2] =
                        b_waypointsIn->data[2] - rtu_Pose[2];
                    if (FlightMissionMode_norm_pv
                            (rtb_TmpSignalConversionAtOrbitFollowerInport2) <
                            1.4901161193847656E-8) {
                        turnVector[2] = rtu_Pose[2];
                        a_0 = rtu_Pose[3];
                        status = 1U;
                        FlightMissionMode_DW.obj_k.StartFlag = false;
                    } else {
                        FlightMissionMode_DW.obj_k.StartFlag = false;
                        FlightMissionMode_DW.obj_k.NumWaypoints = 2.0;
                        i = static_cast<int32_T>(waypoints->size[0] *
                            waypoints->size[1]);
                        waypoints->size[0] = static_cast<int32_T>
                            (b_waypointsIn->size[0] + 1);
                        waypoints->size[1] = 3;
                        FlightMissionMode_emxEnsureCapacity_real_T_c(waypoints,
                            i);
                        ibcol = b_waypointsIn->size[0];
                        for (i = 0; i < 3; i++) {
                            waypoints->data[static_cast<int32_T>(waypoints->
                                size[0] * i)] =
                                FlightMissionMode_DW.obj_k.InitialPose[i];
                            for (i2 = 0; i2 <= static_cast<int32_T>(ibcol - 1);
                                    i2++) {
                                waypoints->data[static_cast<int32_T>(
                                    static_cast<int32_T>(i2 +
                                    static_cast<int32_T>(waypoints->size[0] * i))
                                    + 1)] = b_waypointsIn->data
                                    [static_cast<int32_T>(static_cast<int32_T>
                                    (b_waypointsIn->size[0] * i) + i2)];
                            }
                        }

                        guard1 = true;
                    }
                } else {
                    i = static_cast<int32_T>(waypoints->size[0] *
                        waypoints->size[1]);
                    waypoints->size[0] = b_waypointsIn->size[0];
                    waypoints->size[1] = 3;
                    FlightMissionMode_emxEnsureCapacity_real_T_c(waypoints, i);
                    ibcol = static_cast<int32_T>(b_waypointsIn->size[0] * 3);
                    for (i = 0; i <= static_cast<int32_T>(ibcol - 1); i++) {
                        waypoints->data[i] = b_waypointsIn->data[i];
                    }

                    guard1 = true;
                }

                if (guard1) {
                    real_T a_tmp;
                    real_T rtb_Sum1_k_tmp;
                    real_T rtb_Sum_n_tmp;
                    real_T yout_idx_0;
                    boolean_T guard2{ false };

                    rtb_Compare_em = false;
                    if (FlightMissionMode_DW.obj_k.WaypointIndex ==
                            FlightMissionMode_DW.obj_k.NumWaypoints) {
                        rtb_Compare_em = true;
                    }

                    if (rtb_Compare_em) {
                        FlightMissionMode_DW.obj_k.LastWaypointFlag = true;
                        FlightMissionMode_DW.obj_k.WaypointIndex--;
                    }

                    u[0] = rtu_Pose[0] - waypoints->data[static_cast<int32_T>(
                        static_cast<int32_T>
                        (FlightMissionMode_DW.obj_k.WaypointIndex + 1.0) - 1)];
                    u[1] = rtu_Pose[1] - waypoints->data[static_cast<int32_T>(
                        static_cast<int32_T>(static_cast<int32_T>
                        (FlightMissionMode_DW.obj_k.WaypointIndex + 1.0) +
                        waypoints->size[0]) - 1)];
                    u[2] = rtu_Pose[2] - waypoints->data[static_cast<int32_T>(
                        static_cast<int32_T>(static_cast<int32_T>
                        (FlightMissionMode_DW.obj_k.WaypointIndex + 1.0) +
                        static_cast<int32_T>(waypoints->size[0] << 1)) - 1)];
                    guard2 = false;
                    if (FlightMissionMode_norm_pv(u) <= 100.0) {
                        guard2 = true;
                    } else {
                        a_0 = waypoints->data[static_cast<int32_T>(static_cast<
                            int32_T>(FlightMissionMode_DW.obj_k.WaypointIndex +
                                     1.0) - 1)];
                        rtb_TmpSignalConversionAtOrbitFollowerInport2[0] =
                            rtu_Pose[0] - a_0;
                        turnVector[0] = a_0 - waypoints->data
                            [static_cast<int32_T>(static_cast<int32_T>
                            (FlightMissionMode_DW.obj_k.WaypointIndex) - 1)];
                        a_0 = waypoints->data[static_cast<int32_T>
                            (static_cast<int32_T>(static_cast<int32_T>
                              (FlightMissionMode_DW.obj_k.WaypointIndex + 1.0) +
                              waypoints->size[0]) - 1)];
                        rtb_TmpSignalConversionAtOrbitFollowerInport2[1] =
                            rtu_Pose[1] - a_0;
                        turnVector[1] = a_0 - waypoints->data
                            [static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>
                            (FlightMissionMode_DW.obj_k.WaypointIndex) +
                            waypoints->size[0]) - 1)];
                        rtb_TmpSignalConversionAtOrbitFollowerInport2[2] =
                            rtu_Pose[2] - waypoints->data[static_cast<int32_T>(
                            static_cast<int32_T>(static_cast<int32_T>
                            (FlightMissionMode_DW.obj_k.WaypointIndex + 1.0) +
                            static_cast<int32_T>(waypoints->size[0] << 1)) - 1)];
                        turnVector[2] = waypoints->data[static_cast<int32_T>(
                            static_cast<int32_T>(static_cast<int32_T>
                            (FlightMissionMode_DW.obj_k.WaypointIndex + 1.0) +
                            static_cast<int32_T>(waypoints->size[0] << 1)) - 1)]
                            - waypoints->data[static_cast<int32_T>
                            (static_cast<int32_T>(static_cast<int32_T>
                              (waypoints->size[0] << 1) + static_cast<int32_T>
                              (FlightMissionMode_DW.obj_k.WaypointIndex)) - 1)];
                        a_0 = FlightMissionMode_norm_pv(turnVector);
                        rtb_CastToDouble_l = FlightMissionMode_norm_pv
                            (rtb_TmpSignalConversionAtOrbitFollowerInport2);
                        rtb_Sum1_k_idx_0 = waypoints->data[static_cast<int32_T>(
                            static_cast<int32_T>
                            (FlightMissionMode_DW.obj_k.WaypointIndex) - 1)];
                        rtb_Sum1_k_idx_1 = waypoints->data[static_cast<int32_T>(
                            static_cast<int32_T>
                            (FlightMissionMode_DW.obj_k.WaypointIndex + 1.0) - 1)];
                        rtb_Sum_n_tmp = waypoints->data[static_cast<int32_T>(
                            static_cast<int32_T>(static_cast<int32_T>
                            (FlightMissionMode_DW.obj_k.WaypointIndex) +
                            waypoints->size[0]) - 1)];
                        a_tmp = waypoints->data[static_cast<int32_T>(
                            static_cast<int32_T>(static_cast<int32_T>
                            (FlightMissionMode_DW.obj_k.WaypointIndex + 1.0) +
                            waypoints->size[0]) - 1)];
                        yout_idx_0 = waypoints->data[static_cast<int32_T>(
                            static_cast<int32_T>(static_cast<int32_T>
                            (waypoints->size[0] << 1) + static_cast<int32_T>
                            (FlightMissionMode_DW.obj_k.WaypointIndex)) - 1)];
                        rtb_Sum1_k_tmp = waypoints->data[static_cast<int32_T>(
                            static_cast<int32_T>(static_cast<int32_T>
                            (FlightMissionMode_DW.obj_k.WaypointIndex + 1.0) +
                            static_cast<int32_T>(waypoints->size[0] << 1)) - 1)];
                        a_0 = ((rtb_Sum1_k_idx_1 - rtb_Sum1_k_idx_0) / a_0 *
                               (rtb_TmpSignalConversionAtOrbitFollowerInport2[0]
                                / rtb_CastToDouble_l) + (a_tmp - rtb_Sum_n_tmp) /
                               a_0 *
                               (rtb_TmpSignalConversionAtOrbitFollowerInport2[1]
                                / rtb_CastToDouble_l)) + (rtb_Sum1_k_tmp -
                            yout_idx_0) / a_0 *
                            (rtb_TmpSignalConversionAtOrbitFollowerInport2[2] /
                             rtb_CastToDouble_l);
                        if (static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(std::isnan(a_0)) ^ 1))) {
                            if (a_0 < 0.0) {
                                a_0 = -1.0;
                            } else {
                                a_0 = static_cast<real_T>(a_0 > 0.0);
                            }
                        }

                        if (a_0 >= 0.0) {
                            guard2 = true;
                        } else {
                            rtb_TmpSignalConversionAtOrbitFollowerInport2[0] =
                                rtb_Sum1_k_idx_0;
                            turnVector[0] = rtb_Sum1_k_idx_1;
                            rtb_TmpSignalConversionAtOrbitFollowerInport2[1] =
                                rtb_Sum_n_tmp;
                            turnVector[1] = a_tmp;
                            rtb_TmpSignalConversionAtOrbitFollowerInport2[2] =
                                yout_idx_0;
                            turnVector[2] = rtb_Sum1_k_tmp;
                        }
                    }

                    if (guard2) {
                        FlightMissionMode_DW.obj_k.WaypointIndex++;
                        rtb_Compare_em = false;
                        if (FlightMissionMode_DW.obj_k.WaypointIndex ==
                                FlightMissionMode_DW.obj_k.NumWaypoints) {
                            rtb_Compare_em = true;
                        }

                        if (rtb_Compare_em) {
                            FlightMissionMode_DW.obj_k.LastWaypointFlag = true;
                            FlightMissionMode_DW.obj_k.WaypointIndex--;
                        }

                        rtb_TmpSignalConversionAtOrbitFollowerInport2[0] =
                            waypoints->data[static_cast<int32_T>
                            (static_cast<int32_T>
                             (FlightMissionMode_DW.obj_k.WaypointIndex) - 1)];
                        turnVector[0] = waypoints->data[static_cast<int32_T>(
                            static_cast<int32_T>
                            (FlightMissionMode_DW.obj_k.WaypointIndex + 1.0) - 1)];
                        rtb_TmpSignalConversionAtOrbitFollowerInport2[1] =
                            waypoints->data[static_cast<int32_T>
                            (static_cast<int32_T>(static_cast<int32_T>
                              (FlightMissionMode_DW.obj_k.WaypointIndex) +
                              waypoints->size[0]) - 1)];
                        turnVector[1] = waypoints->data[static_cast<int32_T>(
                            static_cast<int32_T>(static_cast<int32_T>
                            (FlightMissionMode_DW.obj_k.WaypointIndex + 1.0) +
                            waypoints->size[0]) - 1)];
                        rtb_TmpSignalConversionAtOrbitFollowerInport2[2] =
                            waypoints->data[static_cast<int32_T>
                            (static_cast<int32_T>(static_cast<int32_T>
                              (waypoints->size[0] << 1) + static_cast<int32_T>
                              (FlightMissionMode_DW.obj_k.WaypointIndex)) - 1)];
                        turnVector[2] = waypoints->data[static_cast<int32_T>(
                            static_cast<int32_T>(static_cast<int32_T>
                            (FlightMissionMode_DW.obj_k.WaypointIndex + 1.0) +
                            static_cast<int32_T>(waypoints->size[0] << 1)) - 1)];
                    }

                    rtb_Sum1_k_idx_0 = turnVector[0] -
                        rtb_TmpSignalConversionAtOrbitFollowerInport2[0];
                    rtb_CastToDouble_l = rtu_Pose[0] -
                        rtb_TmpSignalConversionAtOrbitFollowerInport2[0];
                    rtb_Sum_n_tmp = turnVector[1] -
                        rtb_TmpSignalConversionAtOrbitFollowerInport2[1];
                    rtb_Sum1_k_idx_1 = rtu_Pose[1] -
                        rtb_TmpSignalConversionAtOrbitFollowerInport2[1];
                    yout_idx_0 = turnVector[2] -
                        rtb_TmpSignalConversionAtOrbitFollowerInport2[2];
                    a_tmp = rtu_Pose[2] -
                        rtb_TmpSignalConversionAtOrbitFollowerInport2[2];
                    a_0 = ((rtb_Sum1_k_idx_1 * rtb_Sum_n_tmp +
                            rtb_CastToDouble_l * rtb_Sum1_k_idx_0) + a_tmp *
                           yout_idx_0) / ((rtb_Sum_n_tmp * rtb_Sum_n_tmp +
                                           rtb_Sum1_k_idx_0 * rtb_Sum1_k_idx_0)
                                          + yout_idx_0 * yout_idx_0);
                    if (a_0 < 0.0) {
                        u[0] = rtb_CastToDouble_l;
                        u[1] = rtb_Sum1_k_idx_1;
                        u[2] = a_tmp;
                        rtb_CastToDouble_l = FlightMissionMode_norm_pv(u);
                    } else if (a_0 > 1.0) {
                        u[0] = rtu_Pose[0] - turnVector[0];
                        u[1] = rtu_Pose[1] - turnVector[1];
                        u[2] = rtu_Pose[2] - turnVector[2];
                        rtb_CastToDouble_l = FlightMissionMode_norm_pv(u);
                    } else {
                        u[0] = rtu_Pose[0] - (a_0 * rtb_Sum1_k_idx_0 +
                                              rtb_TmpSignalConversionAtOrbitFollowerInport2
                                              [0]);
                        u[1] = rtu_Pose[1] - (a_0 * rtb_Sum_n_tmp +
                                              rtb_TmpSignalConversionAtOrbitFollowerInport2
                                              [1]);
                        u[2] = rtu_Pose[2] - (a_0 * yout_idx_0 +
                                              rtb_TmpSignalConversionAtOrbitFollowerInport2
                                              [2]);
                        rtb_CastToDouble_l = FlightMissionMode_norm_pv(u);
                    }

                    if (FlightMissionMode_DW.obj_k.LastWaypointFlag) {
                        a_0 = (((rtu_Pose[0] -
                                 rtb_TmpSignalConversionAtOrbitFollowerInport2[0])
                                * (turnVector[0] -
                                   rtb_TmpSignalConversionAtOrbitFollowerInport2[
                                   0]) + (rtu_Pose[1] -
                                          rtb_TmpSignalConversionAtOrbitFollowerInport2
                                          [1]) * (turnVector[1] -
                                 rtb_TmpSignalConversionAtOrbitFollowerInport2[1]))
                               + (rtu_Pose[2] -
                                  rtb_TmpSignalConversionAtOrbitFollowerInport2
                                  [2]) * (turnVector[2] -
                                          rtb_TmpSignalConversionAtOrbitFollowerInport2
                                          [2])) / (((turnVector[0] -
                            rtb_TmpSignalConversionAtOrbitFollowerInport2[0]) *
                            (turnVector[0] -
                             rtb_TmpSignalConversionAtOrbitFollowerInport2[0]) +
                            (turnVector[1] -
                             rtb_TmpSignalConversionAtOrbitFollowerInport2[1]) *
                            (turnVector[1] -
                             rtb_TmpSignalConversionAtOrbitFollowerInport2[1]))
                            + (turnVector[2] -
                               rtb_TmpSignalConversionAtOrbitFollowerInport2[2])
                            * (turnVector[2] -
                               rtb_TmpSignalConversionAtOrbitFollowerInport2[2]));
                        u[0] = rtu_Pose[0] - (a_0 * rtb_Sum1_k_idx_0 +
                                              rtb_TmpSignalConversionAtOrbitFollowerInport2
                                              [0]);
                        u[1] = rtu_Pose[1] - (a_0 * rtb_Sum_n_tmp +
                                              rtb_TmpSignalConversionAtOrbitFollowerInport2
                                              [1]);
                        u[2] = rtu_Pose[2] - (a_0 * yout_idx_0 +
                                              rtb_TmpSignalConversionAtOrbitFollowerInport2
                                              [2]);
                        rtb_CastToDouble_l = FlightMissionMode_norm_pv(u);
                    }

                    rtb_Sum1_k_idx_1 = std::abs(rtb_CastToDouble_l);
                    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<
                            int32_T>(static_cast<boolean_T>(static_cast<int32_T>
                            (static_cast<int32_T>(std::isinf(rtb_Sum1_k_idx_1)) ^
                             1))) & static_cast<int32_T>(static_cast<boolean_T>(
                            static_cast<int32_T>(static_cast<int32_T>(std::isnan
                              (rtb_Sum1_k_idx_1)) ^ 1)))))) {
                        if (rtb_Sum1_k_idx_1 <= 2.2250738585072014E-308) {
                            a_0 = 4.94065645841247E-324;
                            rtb_Sum1_k_idx_1 = 4.94065645841247E-324;
                        } else {
                            frexp(rtb_Sum1_k_idx_1, &b_exponent);
                            a_0 = std::ldexp(1.0, static_cast<int32_T>
                                             (b_exponent - 53));
                            frexp(rtb_Sum1_k_idx_1, &b_exponent_0);
                            rtb_Sum1_k_idx_1 = std::ldexp(1.0, static_cast<
                                int32_T>(b_exponent_0 - 53));
                        }
                    } else {
                        a_0 = (rtNaN);
                        rtb_Sum1_k_idx_1 = (rtNaN);
                    }

                    if (FlightMissionMode_DW.obj_k.LookaheadDistance <= std::
                            fmax(std::sqrt(a_0), 5.0 * rtb_Sum1_k_idx_1) +
                            rtb_CastToDouble_l) {
                        FlightMissionMode_DW.obj_k.LookaheadDistance =
                            FlightMissionMode_DW.obj_k.LookaheadFactor *
                            rtb_CastToDouble_l;
                    }

                    a_tmp = rtb_TmpSignalConversionAtOrbitFollowerInport2[0] -
                        rtu_Pose[0];
                    rtb_CastToDouble_l =
                        rtb_TmpSignalConversionAtOrbitFollowerInport2[1] -
                        rtu_Pose[1];
                    a_0 = ((turnVector[0] -
                            rtb_TmpSignalConversionAtOrbitFollowerInport2[0]) *
                           (turnVector[0] -
                            rtb_TmpSignalConversionAtOrbitFollowerInport2[0]) +
                           (turnVector[1] -
                            rtb_TmpSignalConversionAtOrbitFollowerInport2[1]) *
                           (turnVector[1] -
                            rtb_TmpSignalConversionAtOrbitFollowerInport2[1])) +
                        (turnVector[2] -
                         rtb_TmpSignalConversionAtOrbitFollowerInport2[2]) *
                        (turnVector[2] -
                         rtb_TmpSignalConversionAtOrbitFollowerInport2[2]);
                    rtb_Sum1_k_tmp =
                        rtb_TmpSignalConversionAtOrbitFollowerInport2[2] -
                        rtu_Pose[2];
                    rtb_Sum1_k_idx_1 = ((rtb_Sum1_k_idx_0 * a_tmp +
                                         rtb_Sum_n_tmp * rtb_CastToDouble_l) +
                                        yout_idx_0 * rtb_Sum1_k_tmp) * 2.0;
                    rtb_CastToDouble_l = std::sqrt(rtb_Sum1_k_idx_1 *
                        rtb_Sum1_k_idx_1 - (((a_tmp * a_tmp + rtb_CastToDouble_l
                        * rtb_CastToDouble_l) + rtb_Sum1_k_tmp * rtb_Sum1_k_tmp)
                                            - FlightMissionMode_DW.obj_k.LookaheadDistance
                                            * FlightMissionMode_DW.obj_k.LookaheadDistance)
                        * (4.0 * a_0));
                    a_0 = std::fmax((-rtb_Sum1_k_idx_1 + rtb_CastToDouble_l) /
                                    2.0 / a_0, (-rtb_Sum1_k_idx_1 -
                                     rtb_CastToDouble_l) / 2.0 / a_0);
                    turnVector[2] = (1.0 - a_0) *
                        rtb_TmpSignalConversionAtOrbitFollowerInport2[2] + a_0 *
                        turnVector[2];
                    a_0 = rt_atan2d_snf(((1.0 - a_0) *
                                         rtb_TmpSignalConversionAtOrbitFollowerInport2
                                         [1] + a_0 * turnVector[1]) - rtu_Pose[1],
                                        ((1.0 - a_0) *
                                         rtb_TmpSignalConversionAtOrbitFollowerInport2
                                         [0] + a_0 * turnVector[0]) - rtu_Pose[0]);
                    status = 0U;
                    rtb_Compare_em = false;
                    if (FlightMissionMode_DW.obj_k.LastWaypointFlag) {
                        rtb_Compare_em = true;
                    }

                    if (rtb_Compare_em) {
                        status = 1U;
                    }

                    FlightMissionMode_DW.obj_k.LastWaypointFlag = false;
                }
            }

            // DataTypeConversion: '<S34>/Cast To Double' incorporates:
            //   MATLABSystem: '<S34>/Waypoint Follower'

            *rty_thisTaskStatus = static_cast<real_T>(status);

            // BusCreator: '<S34>/GuidanceCMDBusCreator' incorporates:
            //   DataTypeConversion: '<S34>/Param4'
            //   Gain: '<S34>/Down2Height'
            //   MATLABSystem: '<S34>/Waypoint Follower'

            rty_GuidanceCmds->Height = -turnVector[2];
            rty_GuidanceCmds->AirSpeed = static_cast<real_T>
                (rtu_Parameters->Param4);
            rty_GuidanceCmds->HeadingAngle = a_0;

            // Switch: '<S34>/SwitchNorth' incorporates:
            //   Switch: '<S34>/SwitchEast'

            if (rtb_Compare_lx) {
                rtb_LatitudeGCS_gv = rtb_AltitudeGCS_dj;
                rtb_Down2Up_c = rtb_Abs1_n;
            }

            // End of Switch: '<S34>/SwitchNorth'

            // Reshape: '<S34>/Reshape' incorporates:
            //   Bias: '<S34>/Rotate90deg'
            //   Product: '<S34>/ProductEast'
            //   Product: '<S34>/ProductNorth'
            //   Sum: '<S34>/SumInitEast'
            //   Sum: '<S34>/SumInitNorth'
            //   Trigonometry: '<S34>/Cos'
            //   Trigonometry: '<S34>/Sin'

            rty_InitialState[0] = std::cos(rtb_Sum_k5 + 1.5707963267948966) *
                rtb_Switch_lo + rtb_LatitudeGCS_gv;
            rty_InitialState[1] = std::sin(rtb_Sum_k5 + 1.5707963267948966) *
                rtb_Switch_lo + rtb_Down2Up_c;

            // Switch: '<S34>/SwitchAlt'
            if (rtb_Compare_lx) {
                // Reshape: '<S34>/Reshape' incorporates:
                //   Gain: '<S34>/Down2Up'

                rty_InitialState[2] = -rtb_Cos_j;
            } else {
                // Reshape: '<S34>/Reshape' incorporates:
                //   Gain: '<S34>/Down2Up'

                rty_InitialState[2] = -rtb_Sum_id;
            }

            // End of Switch: '<S34>/SwitchAlt'

            // Reshape: '<S34>/Reshape' incorporates:
            //   Constant: '<S34>/InitialFlightPathAngle'
            //   Constant: '<S34>/InitialRollAngle'
            //   Constant: '<S34>/InitialRollAngleRate'
            //   DataTypeConversion: '<S34>/Param4'

            rty_InitialState[3] = static_cast<real_T>(rtu_Parameters->Param4);
            rty_InitialState[4] = rtb_Sum_k5;
            rty_InitialState[5] = 0.0;
            rty_InitialState[6] = 0.0;
            rty_InitialState[7] = 0.0;

            // End of Outputs for SubSystem: '<Root>/Mode2_HorzScanNav'
        }
        break;

      case 2:
        {
            real_T rtb_Abs1_n;
            real_T rtb_AltitudeGCS_dj;
            real_T rtb_Down2Up_c;
            real_T rtb_Sum1_k_idx_0;
            int32_T i;
            if (static_cast<int32_T>(rtAction) != static_cast<int32_T>
                    (rtPrevAction)) {
                // InitializeConditions for IfAction SubSystem: '<Root>/Mode3_RunWayNav' incorporates:
                //   ActionPort: '<S4>/Action Port'

                // InitializeConditions for SwitchCase: '<Root>/Switch Case' incorporates:
                //   Delay: '<S91>/Delay'

                std::memset(&FlightMissionMode_DW.Delay_DSTATE[0], 0,
                            static_cast<uint32_T>(200U * sizeof(real_T)));

                // End of InitializeConditions for SubSystem: '<Root>/Mode3_RunWayNav' 

                // SystemReset for IfAction SubSystem: '<Root>/Mode3_RunWayNav' incorporates:
                //   ActionPort: '<S4>/Action Port'

                // SystemReset for Atomic SubSystem: '<S91>/SegmentSwitch'
                // SystemReset for SwitchCase: '<Root>/Switch Case'
                FlightMissionMode_SegmentSwitch_Reset
                    (&FlightMissionMode_DW.RunWayLineMode_k,
                     &FlightMissionMode_DW.SegmentSwitch);

                // End of SystemReset for SubSystem: '<S91>/SegmentSwitch'
                // End of SystemReset for SubSystem: '<Root>/Mode3_RunWayNav'
            }

            // Outputs for IfAction SubSystem: '<Root>/Mode3_RunWayNav' incorporates:
            //   ActionPort: '<S4>/Action Port'

            // DataStoreRead: '<S91>/AltitudeGCS'
            rtw_pthread_mutex_lock(AltitudeGCS_m0);
            rtb_Down2Up_c = AltitudeGCS;
            rtw_pthread_mutex_unlock(AltitudeGCS_m0);

            // DataStoreRead: '<S91>/LatitudeGCS'
            rtw_pthread_mutex_lock(LatitudeGCS_m0);
            rtb_AltitudeGCS_dj = LatitudeGCS;
            rtw_pthread_mutex_unlock(LatitudeGCS_m0);

            // DataStoreRead: '<S91>/LongitudeGCS'
            rtw_pthread_mutex_lock(LongitudeGCS_m0);
            rtb_Abs1_n = LongitudeGCS;
            rtw_pthread_mutex_unlock(LongitudeGCS_m0);

            // Sum: '<S94>/Sum1' incorporates:
            //   Sum: '<S98>/Sum'

            rtb_Sum1_k_idx_0 = rtu_Location->Lat - rtb_AltitudeGCS_dj;
            rtb_Sum1_k_idx_1 = rtu_Location->Lon - rtb_Abs1_n;

            // Switch: '<S104>/Switch' incorporates:
            //   Abs: '<S104>/Abs'
            //   Bias: '<S104>/Bias'
            //   Bias: '<S104>/Bias1'
            //   Constant: '<S104>/Constant2'
            //   Constant: '<S105>/Constant'
            //   Math: '<S104>/Math Function1'
            //   RelationalOperator: '<S105>/Compare'

            if (std::abs(rtb_Sum1_k_idx_0) > 180.0) {
                rtb_Sum_id = rt_modd_snf(rtb_Sum1_k_idx_0 + 180.0, 360.0) +
                    -180.0;
            } else {
                rtb_Sum_id = rtb_Sum1_k_idx_0;
            }

            // End of Switch: '<S104>/Switch'

            // Abs: '<S101>/Abs1'
            rtb_Abs1_n = std::abs(rtb_Sum_id);

            // Switch: '<S101>/Switch' incorporates:
            //   Bias: '<S101>/Bias'
            //   Bias: '<S101>/Bias1'
            //   Constant: '<S103>/Constant'
            //   Constant: '<S97>/Constant'
            //   Constant: '<S97>/Constant1'
            //   Gain: '<S101>/Gain'
            //   Product: '<S101>/Divide1'
            //   RelationalOperator: '<S103>/Compare'
            //   Switch: '<S97>/Switch1'

            if (rtb_Abs1_n > 90.0) {
                // Signum: '<S101>/Sign1'
                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>(std::isnan
                        (rtb_Sum_id)) ^ 1))) {
                    if (rtb_Sum_id < 0.0) {
                        rtb_Sum_id = -1.0;
                    } else {
                        rtb_Sum_id = static_cast<real_T>(rtb_Sum_id > 0.0);
                    }
                }

                // End of Signum: '<S101>/Sign1'
                rtb_Sum_id *= -(rtb_Abs1_n + -90.0) + 90.0;
                i = 180;
            } else {
                i = 0;
            }

            // End of Switch: '<S101>/Switch'

            // Sum: '<S97>/Sum'
            rtb_Cos_j = static_cast<real_T>(i) + rtb_Sum1_k_idx_1;

            // Switch: '<S102>/Switch' incorporates:
            //   Abs: '<S102>/Abs'
            //   Bias: '<S102>/Bias'
            //   Bias: '<S102>/Bias1'
            //   Constant: '<S102>/Constant2'
            //   Constant: '<S106>/Constant'
            //   Math: '<S102>/Math Function1'
            //   RelationalOperator: '<S106>/Compare'

            if (std::abs(rtb_Cos_j) > 180.0) {
                rtb_Cos_j = rt_modd_snf(rtb_Cos_j + 180.0, 360.0) + -180.0;
            }

            // End of Switch: '<S102>/Switch'

            // UnitConversion: '<S100>/Unit Conversion'
            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            rtb_Sum1_k_idx_0 = 0.017453292519943295 * rtb_Sum_id;
            rtb_Sum1_k_idx_1 = 0.017453292519943295 * rtb_Cos_j;

            // UnitConversion: '<S115>/Unit Conversion'
            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            rtb_AltitudeGCS_dj *= 0.017453292519943295;

            // Trigonometry: '<S116>/Trigonometric Function1'
            rtb_Cos_j = std::sin(rtb_AltitudeGCS_dj);

            // Sum: '<S116>/Sum1' incorporates:
            //   Constant: '<S116>/Constant'
            //   Product: '<S116>/Product1'

            rtb_Cos_j = 1.0 - 0.0066943799901413295 * rtb_Cos_j * rtb_Cos_j;

            // Product: '<S114>/Product1' incorporates:
            //   Constant: '<S114>/Constant1'
            //   Sqrt: '<S114>/sqrt'

            rtb_Sum_id = 6.378137E+6 / std::sqrt(rtb_Cos_j);

            // Product: '<S99>/dNorth' incorporates:
            //   Constant: '<S114>/Constant2'
            //   Product: '<S114>/Product3'
            //   Trigonometry: '<S114>/Trigonometric Function1'

            rtb_Cos_j = rtb_Sum1_k_idx_0 / rt_atan2d_snf(1.0, rtb_Sum_id *
                0.99330562000985867 / rtb_Cos_j);

            // Product: '<S99>/dEast' incorporates:
            //   Constant: '<S114>/Constant3'
            //   Product: '<S114>/Product4'
            //   Trigonometry: '<S114>/Trigonometric Function'
            //   Trigonometry: '<S114>/Trigonometric Function2'

            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            rtb_Sum_id = 1.0 / rt_atan2d_snf(1.0, rtb_Sum_id * std::cos
                (rtb_AltitudeGCS_dj)) * rtb_Sum1_k_idx_1;

            // Sum: '<S94>/Sum' incorporates:
            //   Gain: '<S91>/inverse'

            rtb_Down2Up_c = rtu_Location->Alt + -rtb_Down2Up_c;

            // Gain: '<S93>/Gain1'
            rtb_AltitudeGCS_dj = 0.017453292519943295 * rtu_Location->degHDG;

            // Outputs for Enabled SubSystem: '<S91>/WayPointGenerator' incorporates:
            //   EnablePort: '<S96>/Enable'

            if (*rtu_Reset > 0) {
                real_T rtb_LatitudeGCS_gv;
                real_T rtb_Sum_k5;
                real_T rtb_Switch_lo;
                int32_T rtb_Bias_f;
                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>
                                            (FlightMissionMode_DW.WayPointGenerator_MODE_k)
                      ^ 1))) {
                    // SystemReset for MATLAB Function: '<S96>/StartPointGenerator' 
                    FlightMissionMode_StartPointGenerator_Reset
                        (&FlightMissionMode_DW.sf_StartPointGenerator);

                    // SystemReset for MATLAB Function: '<S96>/WayPointGenerator' 
                    FlightMissionMode_WayPointGenerator_Reset
                        (&FlightMissionMode_DW.sf_WayPointGenerator_k);
                    FlightMissionMode_DW.WayPointGenerator_MODE_k = true;
                }

                // DataTypeConversion: '<S96>/DoubleMissionUAV'
                rtb_Switch_lo = static_cast<real_T>(*rtu_MissionUAV);

                // DataTypeConversion: '<S96>/Cast To Double'
                rtb_Sum_k5 = static_cast<real_T>(*rtu_FormationIDX);

                // MATLAB Function: '<S96>/StartPointGenerator' incorporates:
                //   Concatenate: '<S96>/Matrix Concatenate WayPoint'
                //   DataTypeConversion: '<S91>/Param3'

                FlightMissionMode_StartPointGenerator(static_cast<real_T>
                    (rtu_Parameters->Param3), rtb_Switch_lo, rtb_Sum_k5,
                    &FlightMissionMode_DW.MatrixConcatenateWayPoint_g[1536],
                    FlightMissionMode_DW.startPose_c,
                    &FlightMissionMode_DW.sf_StartPointGenerator);

                // Gain: '<S96>/InterLayerDis' incorporates:
                //   Constant: '<S96>/Three'
                //   DataTypeConversion: '<S91>/Param5'
                //   Math: '<S96>/ModRunWayLayer'

                rtb_Switch_lo = 0.0 * rt_modd_snf(static_cast<real_T>
                    (rtu_Parameters->Param5), 3.0);

                // Product: '<S96>/IndivRunwayRotAng' incorporates:
                //   DataTypeConversion: '<S91>/Param2'
                //   DataTypeConversion: '<S91>/Param5'
                //   Gain: '<S125>/Gain1'
                //   Gain: '<S96>/Gain'

                rtb_Sum_k5 = 0.5 * static_cast<real_T>(rtu_Parameters->Param2) *
                    0.017453292519943295 * static_cast<real_T>
                    (rtu_Parameters->Param5);

                // MATLAB Function: '<S96>/WayPointGenerator' incorporates:
                //   Concatenate: '<S96>/Matrix Concatenate WayPoint'
                //   DataTypeConversion: '<S91>/Param3'

                FlightMissionMode_WayPointGenerator(static_cast<real_T>
                    (rtu_Parameters->Param3),
                    &FlightMissionMode_DW.MatrixConcatenateWayPoint_g[0],
                    &FlightMissionMode_DW.MatrixConcatenateWayPoint_g[384],
                    &FlightMissionMode_DW.MatrixConcatenateWayPoint_g[768],
                    &FlightMissionMode_DW.MatrixConcatenateWayPoint_g[1152],
                    &FlightMissionMode_DW.sf_WayPointGenerator_k);

                // SignalConversion generated from: '<S96>/RotateUpward' incorporates:
                //   Constant: '<S96>/Constant'
                //   Constant: '<S96>/Zero'

                rtb_TmpSignalConversionAtRotateUpwardInport1[0] = 0.0;
                rtb_TmpSignalConversionAtRotateUpwardInport1[1] = -0.0;
                rtb_TmpSignalConversionAtRotateUpwardInport1[2] = 0.0;
                FlightMissionMode_RotateATMissionHdg(&self_RotateUpward,
                    rtb_TmpSignalConversionAtRotateUpwardInport1);

                // SignalConversion generated from: '<S96>/RotateATRunWayHdg' incorporates:
                //   Constant: '<S96>/Zero'

                rtb_TmpSignalConversionAtRotateATRunWayHdgInport1_l[0] =
                    rtb_Sum_k5;
                rtb_TmpSignalConversionAtRotateATRunWayHdgInport1_l[1] = 0.0;
                rtb_TmpSignalConversionAtRotateATRunWayHdgInport1_l[2] = 0.0;
                FlightMissionMode_RotateATMissionHdg(&self_RotateATRunWayHdg,
                    rtb_TmpSignalConversionAtRotateATRunWayHdgInport1_l);

                // SignalConversion generated from: '<S96>/RotateATMissionHdg' incorporates:
                //   Constant: '<S96>/Zero'

                rtb_TmpSignalConversionAtRotateATMissionHdgInport1_p[0] =
                    rtb_AltitudeGCS_dj;
                rtb_TmpSignalConversionAtRotateATMissionHdgInport1_p[1] = 0.0;
                rtb_TmpSignalConversionAtRotateATMissionHdgInport1_p[2] = 0.0;
                FlightMissionMode_RotateATMissionHdg(&self_RotateATMissionHdg_m,
                    rtb_TmpSignalConversionAtRotateATMissionHdgInport1_p);

                // Product: '<S96>/MatrixProduct' incorporates:
                //   MATLABSystem: '<S96>/RotateATMissionHdg'
                //   MATLABSystem: '<S96>/RotateATRunWayHdg'
                //   MATLABSystem: '<S96>/RotateUpward'
                //   Product: '<S127>/MatrixMultiply'

                i = 0;
                for (i2 = 0; i2 < 3; i2++) {
                    for (nrowx = 0; nrowx < 3; nrowx++) {
                        rtb_Bias_f = static_cast<int32_T>(nrowx + i);
                        tmp[rtb_Bias_f] = 0.0;
                        tmp[rtb_Bias_f] +=
                            self_RotateATMissionHdg_m.dwork.RotateATMissionHdg[i]
                            * self_RotateATRunWayHdg.dwork.RotateATMissionHdg[nrowx];
                        tmp[rtb_Bias_f] +=
                            self_RotateATMissionHdg_m.dwork.RotateATMissionHdg[
                            static_cast<int32_T>(i + 1)] *
                            self_RotateATRunWayHdg.dwork.RotateATMissionHdg[
                            static_cast<int32_T>(nrowx + 3)];
                        tmp[rtb_Bias_f] +=
                            self_RotateATMissionHdg_m.dwork.RotateATMissionHdg[
                            static_cast<int32_T>(i + 2)] *
                            self_RotateATRunWayHdg.dwork.RotateATMissionHdg[
                            static_cast<int32_T>(nrowx + 6)];
                    }

                    i = static_cast<int32_T>(i + 3);
                }

                // Outputs for Iterator SubSystem: '<S96>/TransformWayPoint' incorporates:
                //   ForEach: '<S127>/For Each'

                i = 0;
                for (i2 = 0; i2 < 3; i2++) {
                    for (nrowx = 0; nrowx < 3; nrowx++) {
                        b_exponent = static_cast<int32_T>(nrowx + i);
                        rtb_MatrixConcatenate[b_exponent] = 0.0;
                        rtb_MatrixConcatenate[b_exponent] += tmp[i] *
                            self_RotateUpward.dwork.RotateATMissionHdg[nrowx];
                        rtb_MatrixConcatenate[b_exponent] += tmp
                            [static_cast<int32_T>(i + 1)] *
                            self_RotateUpward.dwork.RotateATMissionHdg[
                            static_cast<int32_T>(nrowx + 3)];
                        rtb_MatrixConcatenate[b_exponent] += tmp
                            [static_cast<int32_T>(i + 2)] *
                            self_RotateUpward.dwork.RotateATMissionHdg[
                            static_cast<int32_T>(nrowx + 6)];
                    }

                    i = static_cast<int32_T>(i + 3);
                }

                // End of Outputs for SubSystem: '<S96>/TransformWayPoint'

                // Sum: '<S96>/BiasStartPose1' incorporates:
                //   DataTypeConversion: '<S91>/Param1'

                rtb_LatitudeGCS_gv = FlightMissionMode_DW.startPose_c[0];
                rtb_Abs1_n = FlightMissionMode_DW.startPose_c[1] - static_cast<
                    real_T>(rtu_Parameters->Param1);
                rtb_Sum1_k_idx_0 = FlightMissionMode_DW.startPose_c[2] -
                    rtb_Switch_lo;

                // Product: '<S96>/MatrixProduct'
                i = 0;
                for (i2 = 0; i2 < 3; i2++) {
                    rtb_TmpSignalConversionAtOrbitFollowerInport2[i2] = 0.0;
                    rtb_TmpSignalConversionAtOrbitFollowerInport2[i2] +=
                        rtb_MatrixConcatenate[i] * rtb_LatitudeGCS_gv;
                    rtb_TmpSignalConversionAtOrbitFollowerInport2[i2] +=
                        rtb_MatrixConcatenate[static_cast<int32_T>(i + 1)] *
                        rtb_Abs1_n;
                    rtb_TmpSignalConversionAtOrbitFollowerInport2[i2] +=
                        rtb_MatrixConcatenate[static_cast<int32_T>(i + 2)] *
                        rtb_Sum1_k_idx_0;
                    i = static_cast<int32_T>(i + 3);
                }

                // Reshape: '<S96>/Reshape' incorporates:
                //   Constant: '<S96>/Zero'
                //   DataTypeConversion: '<S91>/Param1'

                u[0] = 0.0;
                u[1] = static_cast<real_T>(rtu_Parameters->Param1);
                u[2] = rtb_Switch_lo;

                // Reshape: '<S96>/ReshapeRowVecStartpose' incorporates:
                //   Product: '<S99>/x*cos'
                //   Product: '<S99>/x*sin'
                //   Product: '<S99>/y*cos'
                //   Product: '<S99>/y*sin'
                //   Sum: '<S99>/Sum2'
                //   Sum: '<S99>/Sum3'
                //   UnaryMinus: '<S94>/Ze2height'

                rtb_ReshapeRowVecStartpose_d[0] = rtb_Sum_id * 0.0 + rtb_Cos_j;
                rtb_ReshapeRowVecStartpose_d[1] = rtb_Sum_id - rtb_Cos_j * 0.0;
                rtb_ReshapeRowVecStartpose_d[2] = -rtb_Down2Up_c;

                // Sum: '<S96>/Sum' incorporates:
                //   Bias: '<S96>/Bias'
                //   Gain: '<S96>/Invert'

                FlightMissionMode_DW.Sum_i = (rtb_AltitudeGCS_dj + rtb_Sum_k5) +
                    -(FlightMissionMode_DW.startPose_c[3] + -1.5707963267948966);

                // Outputs for Iterator SubSystem: '<S96>/TransformWayPoint' incorporates:
                //   ForEach: '<S127>/For Each'

                for (int32_T ibcol{0}; ibcol < 5; ibcol++) {
                    for (i = 0; i < 3; i++) {
                        // ForEachSliceSelector generated from: '<S127>/RawRunWay' incorporates:
                        //   Concatenate: '<S96>/Matrix Concatenate WayPoint'

                        std::memcpy
                            (&rtb_ImpSel_InsertedFor_RawRunWay_at_outport_0_k[
                             static_cast<int32_T>(i << 7)],
                             &FlightMissionMode_DW.MatrixConcatenateWayPoint_g[
                             static_cast<int32_T>(static_cast<int32_T>(ibcol *
                               384) + static_cast<int32_T>(i << 7))],
                             static_cast<uint32_T>(sizeof(real_T) << 7U));
                    }

                    // MATLAB Function: '<S127>/minus'
                    FlightMissionMode_minus
                        (rtb_ImpSel_InsertedFor_RawRunWay_at_outport_0_k, u,
                         rtb_y);
                    for (i = 0; i < 128; i++) {
                        // Product: '<S127>/MatrixMultiply'
                        i2 = 0;
                        nrowx = 0;
                        for (rtb_Bias_f = 0; rtb_Bias_f < 3; rtb_Bias_f++) {
                            b_exponent = static_cast<int32_T>(i2 + i);
                            rtb_MatrixMultiply[b_exponent] = 0.0;
                            rtb_MatrixMultiply[b_exponent] +=
                                rtb_MatrixConcatenate[nrowx] * rtb_y[i];
                            rtb_MatrixMultiply[b_exponent] +=
                                rtb_MatrixConcatenate[static_cast<int32_T>(nrowx
                                + 1)] * rtb_y[static_cast<int32_T>(i + 128)];
                            rtb_MatrixMultiply[b_exponent] +=
                                rtb_MatrixConcatenate[static_cast<int32_T>(nrowx
                                + 2)] * rtb_y[static_cast<int32_T>(i + 256)];
                            i2 = static_cast<int32_T>(i2 + 128);
                            nrowx = static_cast<int32_T>(nrowx + 3);
                        }

                        // End of Product: '<S127>/MatrixMultiply'
                    }

                    // MATLAB Function: '<S127>/biasNED'
                    FlightMissionMode_biasNED(rtb_ReshapeRowVecStartpose_d,
                        rtb_MatrixMultiply, rtb_nedWayPoint_CoreSubsysCanOut_b);

                    // ForEachSliceAssignment generated from: '<S127>/nedWayPoint' 
                    for (i = 0; i < 3; i++) {
                        std::memcpy
                            (&FlightMissionMode_DW.ImpAsg_InsertedFor_nedWayPoint_at_inport_0_c
                             [static_cast<int32_T>(static_cast<int32_T>(ibcol *
                               384) + static_cast<int32_T>(i << 7))],
                             &rtb_nedWayPoint_CoreSubsysCanOut_b
                             [static_cast<int32_T>(i << 7)],
                             static_cast<uint32_T>(sizeof(real_T) << 7U));
                    }
                }

                // End of Outputs for SubSystem: '<S96>/TransformWayPoint'

                // MATLAB Function: '<S96>/biasNEDstartpose'
                FlightMissionMode_biasNEDstartpose(rtb_ReshapeRowVecStartpose_d,
                    rtb_TmpSignalConversionAtOrbitFollowerInport2,
                    FlightMissionMode_DW.nedWayPoint_m);
            } else {
                FlightMissionMode_DW.WayPointGenerator_MODE_k = false;
            }

            // End of Outputs for SubSystem: '<S91>/WayPointGenerator'

            // Outputs for Atomic SubSystem: '<S91>/SegmentSwitch'
            FlightMissionMode_SegmentSwitch(rtu_Reset, rtu_Pose,
                FlightMissionMode_DW.ImpAsg_InsertedFor_nedWayPoint_at_inport_0_c,
                FlightMissionMode_DW.MergeLookAheadP_j,
                &FlightMissionMode_DW.MergeDesiredCourse_p,
                &FlightMissionMode_DW.RunWayLineMode_k, 200.0,
                &FlightMissionMode_DW.SegmentSwitch);

            // End of Outputs for SubSystem: '<S91>/SegmentSwitch'

            // BusCreator: '<S91>/GuidanceCMDBusCreator1' incorporates:
            //   DataTypeConversion: '<S91>/Param4'
            //   Gain: '<S91>/Down2Height1'

            rty_GuidanceCmds->Height = -FlightMissionMode_DW.MergeLookAheadP_j[2];
            rty_GuidanceCmds->AirSpeed = static_cast<real_T>
                (rtu_Parameters->Param4);
            rty_GuidanceCmds->HeadingAngle =
                FlightMissionMode_DW.MergeDesiredCourse_p;

            // Reshape: '<S91>/Reshape' incorporates:
            //   Constant: '<S91>/InitialFlightPathAngle'
            //   Constant: '<S91>/InitialRollAngleRate'
            //   DataTypeConversion: '<S91>/Param4'
            //   Gain: '<S91>/Down2Up'

            rty_InitialState[0] = FlightMissionMode_DW.nedWayPoint_m[0];
            rty_InitialState[1] = FlightMissionMode_DW.nedWayPoint_m[1];
            rty_InitialState[2] = -FlightMissionMode_DW.nedWayPoint_m[2];
            rty_InitialState[3] = static_cast<real_T>(rtu_Parameters->Param4);
            rty_InitialState[4] = FlightMissionMode_DW.Sum_i;
            rty_InitialState[5] = 0.0;
            rty_InitialState[6] = FlightMissionMode_DW.startPose_c[4];
            rty_InitialState[7] = 0.0;

            // Switch: '<S91>/Switch' incorporates:
            //   Constant: '<S92>/Constant'
            //   DataTypeConversion: '<S91>/Cast To Double'
            //   Delay: '<S91>/Delay'
            //   RelationalOperator: '<S92>/Compare'

            if (static_cast<int32_T>(FlightMissionMode_DW.RunWayLineMode_k) == 2)
            {
                *rty_thisTaskStatus = static_cast<real_T>
                    (FlightMissionMode_DW.RunWayLineMode_k);
            } else {
                *rty_thisTaskStatus = FlightMissionMode_DW.Delay_DSTATE[0];
            }

            // End of Switch: '<S91>/Switch'

            // Update for Delay: '<S91>/Delay' incorporates:
            //   DataTypeConversion: '<S91>/Cast To Double'

            for (b_exponent = 0; b_exponent < 199; b_exponent++) {
                FlightMissionMode_DW.Delay_DSTATE[b_exponent] =
                    FlightMissionMode_DW.Delay_DSTATE[static_cast<int_T>
                    (b_exponent + 1)];
            }

            FlightMissionMode_DW.Delay_DSTATE[199] = static_cast<real_T>
                (FlightMissionMode_DW.RunWayLineMode_k);

            // End of Update for Delay: '<S91>/Delay'
            // End of Outputs for SubSystem: '<Root>/Mode3_RunWayNav'
        }
        break;

      case 3:
        {
            real_T a_0;
            real_T rtb_Abs1_n;
            real_T rtb_AltitudeGCS_dj;
            real_T rtb_Down2Up_c;
            real_T rtb_Sum1_k_idx_0;
            real_T rtb_Switch_lo;
            int32_T i;
            if (static_cast<int32_T>(rtAction) != static_cast<int32_T>
                    (rtPrevAction)) {
                // SystemReset for IfAction SubSystem: '<Root>/Mode44_ProtLine' incorporates:
                //   ActionPort: '<S5>/Action Port'

                // SystemReset for Atomic SubSystem: '<S133>/SegmentSwitch'
                // SystemReset for SwitchCase: '<Root>/Switch Case'
                FlightMissionMode_SegmentSwitch_Reset
                    (&FlightMissionMode_DW.RunWayLineMode,
                     &FlightMissionMode_DW.SegmentSwitch_p);

                // End of SystemReset for SubSystem: '<S133>/SegmentSwitch'
                // End of SystemReset for SubSystem: '<Root>/Mode44_ProtLine'
            }

            // Outputs for IfAction SubSystem: '<Root>/Mode44_ProtLine' incorporates:
            //   ActionPort: '<S5>/Action Port'

            // DataStoreRead: '<S133>/AltitudeGCS'
            rtw_pthread_mutex_lock(AltitudeGCS_m0);
            rtb_Down2Up_c = AltitudeGCS;
            rtw_pthread_mutex_unlock(AltitudeGCS_m0);

            // DataStoreRead: '<S133>/LatitudeGCS'
            rtw_pthread_mutex_lock(LatitudeGCS_m0);
            rtb_AltitudeGCS_dj = LatitudeGCS;
            rtw_pthread_mutex_unlock(LatitudeGCS_m0);

            // DataStoreRead: '<S133>/LongitudeGCS'
            rtw_pthread_mutex_lock(LongitudeGCS_m0);
            rtb_Abs1_n = LongitudeGCS;
            rtw_pthread_mutex_unlock(LongitudeGCS_m0);

            // Sum: '<S135>/Sum1' incorporates:
            //   Sum: '<S140>/Sum'

            rtb_Sum1_k_idx_0 = rtu_Location->Lat - rtb_AltitudeGCS_dj;
            rtb_Sum1_k_idx_1 = rtu_Location->Lon - rtb_Abs1_n;

            // Switch: '<S146>/Switch' incorporates:
            //   Abs: '<S146>/Abs'
            //   Bias: '<S146>/Bias'
            //   Bias: '<S146>/Bias1'
            //   Constant: '<S146>/Constant2'
            //   Constant: '<S147>/Constant'
            //   Math: '<S146>/Math Function1'
            //   RelationalOperator: '<S147>/Compare'

            if (std::abs(rtb_Sum1_k_idx_0) > 180.0) {
                rtb_Sum_id = rt_modd_snf(rtb_Sum1_k_idx_0 + 180.0, 360.0) +
                    -180.0;
            } else {
                rtb_Sum_id = rtb_Sum1_k_idx_0;
            }

            // End of Switch: '<S146>/Switch'

            // Abs: '<S143>/Abs1'
            rtb_Abs1_n = std::abs(rtb_Sum_id);

            // Switch: '<S143>/Switch' incorporates:
            //   Bias: '<S143>/Bias'
            //   Bias: '<S143>/Bias1'
            //   Constant: '<S139>/Constant'
            //   Constant: '<S139>/Constant1'
            //   Constant: '<S145>/Constant'
            //   Gain: '<S143>/Gain'
            //   Product: '<S143>/Divide1'
            //   RelationalOperator: '<S145>/Compare'
            //   Switch: '<S139>/Switch1'

            if (rtb_Abs1_n > 90.0) {
                // Signum: '<S143>/Sign1'
                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>(std::isnan
                        (rtb_Sum_id)) ^ 1))) {
                    if (rtb_Sum_id < 0.0) {
                        rtb_Sum_id = -1.0;
                    } else {
                        rtb_Sum_id = static_cast<real_T>(rtb_Sum_id > 0.0);
                    }
                }

                // End of Signum: '<S143>/Sign1'
                rtb_Sum_id *= -(rtb_Abs1_n + -90.0) + 90.0;
                i = 180;
            } else {
                i = 0;
            }

            // End of Switch: '<S143>/Switch'

            // Sum: '<S139>/Sum'
            rtb_Cos_j = static_cast<real_T>(i) + rtb_Sum1_k_idx_1;

            // Switch: '<S144>/Switch' incorporates:
            //   Abs: '<S144>/Abs'
            //   Bias: '<S144>/Bias'
            //   Bias: '<S144>/Bias1'
            //   Constant: '<S144>/Constant2'
            //   Constant: '<S148>/Constant'
            //   Math: '<S144>/Math Function1'
            //   RelationalOperator: '<S148>/Compare'

            if (std::abs(rtb_Cos_j) > 180.0) {
                rtb_Cos_j = rt_modd_snf(rtb_Cos_j + 180.0, 360.0) + -180.0;
            }

            // End of Switch: '<S144>/Switch'

            // UnitConversion: '<S142>/Unit Conversion'
            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            rtb_Sum1_k_idx_0 = 0.017453292519943295 * rtb_Sum_id;
            rtb_Sum1_k_idx_1 = 0.017453292519943295 * rtb_Cos_j;

            // UnitConversion: '<S157>/Unit Conversion'
            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            rtb_AltitudeGCS_dj *= 0.017453292519943295;

            // Trigonometry: '<S158>/Trigonometric Function1'
            rtb_Cos_j = std::sin(rtb_AltitudeGCS_dj);

            // Sum: '<S158>/Sum1' incorporates:
            //   Constant: '<S158>/Constant'
            //   Product: '<S158>/Product1'

            rtb_Cos_j = 1.0 - 0.0066943799901413295 * rtb_Cos_j * rtb_Cos_j;

            // Product: '<S156>/Product1' incorporates:
            //   Constant: '<S156>/Constant1'
            //   Sqrt: '<S156>/sqrt'

            rtb_Sum_id = 6.378137E+6 / std::sqrt(rtb_Cos_j);

            // Product: '<S141>/dNorth' incorporates:
            //   Constant: '<S156>/Constant2'
            //   Product: '<S156>/Product3'
            //   Trigonometry: '<S156>/Trigonometric Function1'

            rtb_Cos_j = rtb_Sum1_k_idx_0 / rt_atan2d_snf(1.0, rtb_Sum_id *
                0.99330562000985867 / rtb_Cos_j);

            // Product: '<S141>/dEast' incorporates:
            //   Constant: '<S156>/Constant3'
            //   Product: '<S156>/Product4'
            //   Trigonometry: '<S156>/Trigonometric Function'
            //   Trigonometry: '<S156>/Trigonometric Function2'

            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            rtb_Sum_id = 1.0 / rt_atan2d_snf(1.0, rtb_Sum_id * std::cos
                (rtb_AltitudeGCS_dj)) * rtb_Sum1_k_idx_1;

            // Sum: '<S135>/Sum' incorporates:
            //   Gain: '<S133>/inverse'

            rtb_Down2Up_c = rtu_Location->Alt + -rtb_Down2Up_c;

            // Gain: '<S134>/Gain1'
            rtb_AltitudeGCS_dj = 0.017453292519943295 * rtu_Location->degHDG;

            // Outputs for Atomic SubSystem: '<S133>/OneSidePercentage'
            // Gain: '<S136>/Gain' incorporates:
            //   DataTypeConversion: '<S133>/Param3'

            rtb_Switch_lo = 0.5 * static_cast<real_T>(rtu_Parameters->Param3);

            // Outputs for Enabled SubSystem: '<S133>/WayPointGenerator' incorporates:
            //   EnablePort: '<S138>/Enable'

            // Gain: '<S161>/Gain1' incorporates:
            //   DataTypeConversion: '<S133>/Param2'
            //   Gain: '<S168>/Gain1'

            a_0 = 0.017453292519943295 * static_cast<real_T>
                (rtu_Parameters->Param2);

            // End of Outputs for SubSystem: '<S133>/WayPointGenerator'

            // Switch: '<S136>/Switch' incorporates:
            //   Constant: '<S136>/Constant'
            //   Constant: '<S136>/Half'
            //   Constant: '<S136>/One'
            //   DataTypeConversion: '<S133>/Param1'
            //   Gain: '<S161>/Gain1'
            //   Math: '<S136>/Square'
            //   Product: '<S136>/Product'
            //   RelationalOperator: '<S136>/Relational Operator'
            //   Sqrt: '<S136>/Sqrt'
            //   Sum: '<S136>/Minus'
            //   Trigonometry: '<S136>/Cos'

            if (std::sqrt(rtb_Switch_lo * rtb_Switch_lo * 2.0 * (1.0 - std::cos
                    (a_0))) < static_cast<real_T>(rtu_Parameters->Param1)) {
                rtb_Sum1_k_idx_1 = 0.5;
            } else {
                rtb_Sum1_k_idx_1 = 1.0;
            }

            // End of Switch: '<S136>/Switch'
            // End of Outputs for SubSystem: '<S133>/OneSidePercentage'

            // Outputs for Enabled SubSystem: '<S133>/WayPointGenerator' incorporates:
            //   EnablePort: '<S138>/Enable'

            if (*rtu_Reset > 0) {
                real_T rtb_LatitudeGCS_gv;
                real_T rtb_Sum_k5;
                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>
                                            (FlightMissionMode_DW.WayPointGenerator_MODE_m)
                      ^ 1))) {
                    // SystemReset for MATLAB Function: '<S138>/StartPointGenerator' 
                    FlightMissionMode_StartPointGenerator_Reset
                        (&FlightMissionMode_DW.sf_StartPointGenerator_k);

                    // SystemReset for MATLAB Function: '<S138>/WayPointGenerator' 
                    FlightMissionMode_WayPointGenerator_Reset
                        (&FlightMissionMode_DW.sf_WayPointGenerator_f);
                    FlightMissionMode_DW.WayPointGenerator_MODE_m = true;
                }

                // DataTypeConversion: '<S138>/DoubleFormationIDX'
                rtb_Switch_lo = static_cast<real_T>(*rtu_FormationIDX);

                // DataTypeConversion: '<S138>/DoubleMissionUAV'
                rtb_Sum_k5 = static_cast<real_T>(*rtu_MissionUAV);

                // MATLAB Function: '<S138>/StartPointGenerator' incorporates:
                //   Abs: '<S138>/Abs'
                //   Concatenate: '<S138>/Matrix Concatenate WayPoint'
                //   DataTypeConversion: '<S133>/Param3'
                //   Product: '<S138>/ProductOneSideUAV'

                FlightMissionMode_StartPointGenerator(static_cast<real_T>
                    (rtu_Parameters->Param3), rtb_Sum_k5 * rtb_Sum1_k_idx_1, std::
                    abs(rtb_Switch_lo),
                    &FlightMissionMode_DW.MatrixConcatenateWayPoint[1536],
                    startPose, &FlightMissionMode_DW.sf_StartPointGenerator_k);

                // Signum: '<S138>/Sign'
                if (rtb_Switch_lo < 0.0) {
                    rtb_Switch_lo = -1.0;
                } else {
                    rtb_Switch_lo = static_cast<real_T>(rtb_Switch_lo > 0.0);
                }

                // End of Signum: '<S138>/Sign'

                // Product: '<S138>/ProductFlipStartPose' incorporates:
                //   Gain: '<S138>/RevFlip'

                FlightMissionMode_DW.ProductFlipStartPose[0] = startPose[0] *
                    -rtb_Switch_lo;
                FlightMissionMode_DW.ProductFlipStartPose[1] = startPose[1];
                FlightMissionMode_DW.ProductFlipStartPose[2] = startPose[2];
                FlightMissionMode_DW.ProductFlipStartPose[3] = startPose[3];
                FlightMissionMode_DW.ProductFlipStartPose[4] = startPose[4];

                // Product: '<S138>/ProductRotAng' incorporates:
                //   Product: '<S138>/ProductFlipRotAng'

                a_0 = a_0 * rtb_Switch_lo * rtb_Sum1_k_idx_1;

                // SignalConversion generated from: '<S138>/RotateATRunWayHdg' incorporates:
                //   Constant: '<S138>/Zero'

                rtb_TmpSignalConversionAtRotateATRunWayHdgInport1[0] = a_0;
                rtb_TmpSignalConversionAtRotateATRunWayHdgInport1[1] = 0.0;
                rtb_TmpSignalConversionAtRotateATRunWayHdgInport1[2] = 0.0;
                FlightMissionMode_RotateATMissionHdg(&self_RotateATRunWayHdg_k,
                    rtb_TmpSignalConversionAtRotateATRunWayHdgInport1);

                // Product: '<S138>/ProductFlipXbias' incorporates:
                //   DataTypeConversion: '<S133>/Param1'
                //   Product: '<S138>/ProductSepDis'

                rtb_Sum1_k_idx_1 = rtb_Sum1_k_idx_1 * static_cast<real_T>
                    (rtu_Parameters->Param1) * rtb_Switch_lo;

                // SignalConversion generated from: '<S138>/Matrix Concatenate' incorporates:
                //   Constant: '<S138>/Zeros'
                //   Gain: '<S138>/RevFlip'

                rtb_MatrixConcatenate[0] = -rtb_Switch_lo;
                rtb_MatrixConcatenate[1] = 0.0;
                rtb_MatrixConcatenate[2] = 0.0;

                // SignalConversion generated from: '<S138>/Matrix Concatenate' incorporates:
                //   Constant: '<S138>/One'
                //   Constant: '<S138>/Zeros'

                rtb_MatrixConcatenate[3] = 0.0;
                rtb_MatrixConcatenate[4] = 1.0;
                rtb_MatrixConcatenate[5] = 0.0;

                // SignalConversion generated from: '<S138>/Matrix Concatenate' incorporates:
                //   Constant: '<S138>/One'
                //   Constant: '<S138>/Zeros'

                rtb_MatrixConcatenate[6] = 0.0;
                rtb_MatrixConcatenate[7] = 0.0;
                rtb_MatrixConcatenate[8] = 1.0;

                // MATLAB Function: '<S138>/WayPointGenerator' incorporates:
                //   Concatenate: '<S138>/Matrix Concatenate WayPoint'
                //   DataTypeConversion: '<S133>/Param3'

                FlightMissionMode_WayPointGenerator(static_cast<real_T>
                    (rtu_Parameters->Param3),
                    &FlightMissionMode_DW.MatrixConcatenateWayPoint[0],
                    &FlightMissionMode_DW.MatrixConcatenateWayPoint[384],
                    &FlightMissionMode_DW.MatrixConcatenateWayPoint[768],
                    &FlightMissionMode_DW.MatrixConcatenateWayPoint[1152],
                    &FlightMissionMode_DW.sf_WayPointGenerator_f);

                // Reshape: '<S138>/Reshape' incorporates:
                //   Constant: '<S138>/Zero'

                rtb_TmpSignalConversionAtOrbitFollowerInport2[0] =
                    rtb_Sum1_k_idx_1;
                rtb_TmpSignalConversionAtOrbitFollowerInport2[1] = 0.0;
                rtb_TmpSignalConversionAtOrbitFollowerInport2[2] = 0.0;

                // Reshape: '<S138>/ReshapeRowVec' incorporates:
                //   Product: '<S141>/x*cos'
                //   Product: '<S141>/x*sin'
                //   Product: '<S141>/y*cos'
                //   Product: '<S141>/y*sin'
                //   Reshape: '<S138>/ReshapeRowVecStartpose'
                //   Sum: '<S141>/Sum2'
                //   Sum: '<S141>/Sum3'
                //   UnaryMinus: '<S135>/Ze2height'

                u[0] = rtb_Sum_id * 0.0 + rtb_Cos_j;
                u[1] = rtb_Sum_id - rtb_Cos_j * 0.0;
                u[2] = -rtb_Down2Up_c;

                // SignalConversion generated from: '<S138>/RotateATMissionHdg' incorporates:
                //   Constant: '<S138>/Zero'

                rtb_TmpSignalConversionAtRotateATMissionHdgInport1[0] =
                    rtb_AltitudeGCS_dj;
                rtb_TmpSignalConversionAtRotateATMissionHdgInport1[1] = 0.0;
                rtb_TmpSignalConversionAtRotateATMissionHdgInport1[2] = 0.0;
                FlightMissionMode_RotateATMissionHdg(&self_RotateATMissionHdg_k,
                    rtb_TmpSignalConversionAtRotateATMissionHdgInport1);

                // Product: '<S138>/RotateRunwayStartpose' incorporates:
                //   MATLABSystem: '<S138>/RotateATRunWayHdg'

                i = 0;
                for (i2 = 0; i2 < 3; i2++) {
                    turnVector[i2] = 0.0;
                    turnVector[i2] +=
                        self_RotateATRunWayHdg_k.dwork.RotateATMissionHdg[i] *
                        FlightMissionMode_DW.ProductFlipStartPose[0];
                    turnVector[i2] +=
                        self_RotateATRunWayHdg_k.dwork.RotateATMissionHdg[
                        static_cast<int32_T>(i + 1)] *
                        FlightMissionMode_DW.ProductFlipStartPose[1];
                    turnVector[i2] +=
                        self_RotateATRunWayHdg_k.dwork.RotateATMissionHdg[
                        static_cast<int32_T>(i + 2)] *
                        FlightMissionMode_DW.ProductFlipStartPose[2];
                    i = static_cast<int32_T>(i + 3);
                }

                // End of Product: '<S138>/RotateRunwayStartpose'

                // Sum: '<S138>/BiasStartPose'
                rtb_LatitudeGCS_gv = turnVector[0] - rtb_Sum1_k_idx_1;
                rtb_Abs1_n = turnVector[1];
                rtb_Sum1_k_idx_0 = turnVector[2];

                // Product: '<S138>/RotateIndivWayPointStartpose' incorporates:
                //   MATLABSystem: '<S138>/RotateATMissionHdg'

                i = 0;
                for (i2 = 0; i2 < 3; i2++) {
                    rtb_ReshapeRowVecStartpose_d[i2] = 0.0;
                    rtb_ReshapeRowVecStartpose_d[i2] +=
                        self_RotateATMissionHdg_k.dwork.RotateATMissionHdg[i] *
                        rtb_LatitudeGCS_gv;
                    rtb_ReshapeRowVecStartpose_d[i2] +=
                        self_RotateATMissionHdg_k.dwork.RotateATMissionHdg[
                        static_cast<int32_T>(i + 1)] * rtb_Abs1_n;
                    rtb_ReshapeRowVecStartpose_d[i2] +=
                        self_RotateATMissionHdg_k.dwork.RotateATMissionHdg[
                        static_cast<int32_T>(i + 2)] * rtb_Sum1_k_idx_0;
                    i = static_cast<int32_T>(i + 3);
                }

                // End of Product: '<S138>/RotateIndivWayPointStartpose'

                // Sum: '<S138>/Sum' incorporates:
                //   Bias: '<S138>/Bias'
                //   Product: '<S138>/ProductFlipStartHeading'

                FlightMissionMode_DW.Sum =
                    (FlightMissionMode_DW.ProductFlipStartPose[3] +
                     -1.5707963267948966) * rtb_Switch_lo + (rtb_AltitudeGCS_dj
                    + a_0);

                // Outputs for Iterator SubSystem: '<S138>/TransformWayPoint' incorporates:
                //   ForEach: '<S170>/For Each'

                for (int32_T ibcol{0}; ibcol < 5; ibcol++) {
                    // Product: '<S170>/ProductFlipRunWay' incorporates:
                    //   Concatenate: '<S138>/Matrix Concatenate'
                    //   Concatenate: '<S138>/Matrix Concatenate WayPoint'
                    //   ForEachSliceSelector generated from: '<S170>/RawRunWay'

                    for (i = 0; i < 128; i++) {
                        for (i2 = 0; i2 < 3; i2++) {
                            b_exponent = static_cast<int32_T>
                                (static_cast<int32_T>(i2 << 7) + i);
                            rtb_y_o[b_exponent] = 0.0;

                            // ForEachSliceSelector generated from: '<S170>/RawRunWay' 
                            b_exponent_0 = static_cast<int32_T>
                                (static_cast<int32_T>(384 * ibcol) + i);
                            rtb_y_o[b_exponent] += rtb_MatrixConcatenate[
                                static_cast<int32_T>(3 * i2)] *
                                FlightMissionMode_DW.MatrixConcatenateWayPoint[b_exponent_0];
                            rtb_y_o[b_exponent] += rtb_MatrixConcatenate[
                                static_cast<int32_T>(static_cast<int32_T>(3 * i2)
                                + 1)] *
                                FlightMissionMode_DW.MatrixConcatenateWayPoint[
                                static_cast<int32_T>(b_exponent_0 + 128)];
                            rtb_y_o[b_exponent] += rtb_MatrixConcatenate[
                                static_cast<int32_T>(static_cast<int32_T>(3 * i2)
                                + 2)] *
                                FlightMissionMode_DW.MatrixConcatenateWayPoint[
                                static_cast<int32_T>(b_exponent_0 + 256)];
                        }
                    }

                    // End of Product: '<S170>/ProductFlipRunWay'
                    for (i = 0; i < 128; i++) {
                        // Product: '<S170>/RotateRunway' incorporates:
                        //   MATLABSystem: '<S138>/RotateATRunWayHdg'

                        i2 = 0;
                        nrowx = 0;
                        for (int32_T rtb_Bias_f{0}; rtb_Bias_f < 3; rtb_Bias_f++)
                        {
                            b_exponent = static_cast<int32_T>(i2 + i);
                            rtb_RotateRunway[b_exponent] = 0.0;
                            rtb_RotateRunway[b_exponent] +=
                                self_RotateATRunWayHdg_k.dwork.RotateATMissionHdg
                                [nrowx] * rtb_y_o[i];
                            rtb_RotateRunway[b_exponent] +=
                                self_RotateATRunWayHdg_k.dwork.RotateATMissionHdg
                                [static_cast<int32_T>(nrowx + 1)] * rtb_y_o[
                                static_cast<int32_T>(i + 128)];
                            rtb_RotateRunway[b_exponent] +=
                                self_RotateATRunWayHdg_k.dwork.RotateATMissionHdg
                                [static_cast<int32_T>(nrowx + 2)] * rtb_y_o[
                                static_cast<int32_T>(i + 256)];
                            i2 = static_cast<int32_T>(i2 + 128);
                            nrowx = static_cast<int32_T>(nrowx + 3);
                        }

                        // End of Product: '<S170>/RotateRunway'
                    }

                    // MATLAB Function: '<S170>/minus'
                    FlightMissionMode_minus(rtb_RotateRunway,
                                            rtb_TmpSignalConversionAtOrbitFollowerInport2,
                                            rtb_y_o);
                    for (i = 0; i < 128; i++) {
                        // Product: '<S170>/RotateIndivWayPoint' incorporates:
                        //   MATLABSystem: '<S138>/RotateATMissionHdg'

                        i2 = 0;
                        nrowx = 0;
                        for (int32_T rtb_Bias_f{0}; rtb_Bias_f < 3; rtb_Bias_f++)
                        {
                            b_exponent = static_cast<int32_T>(i2 + i);
                            rtb_RotateIndivWayPoint[b_exponent] = 0.0;
                            rtb_RotateIndivWayPoint[b_exponent] +=
                                self_RotateATMissionHdg_k.dwork.RotateATMissionHdg
                                [nrowx] * rtb_y_o[i];
                            rtb_RotateIndivWayPoint[b_exponent] +=
                                self_RotateATMissionHdg_k.dwork.RotateATMissionHdg
                                [static_cast<int32_T>(nrowx + 1)] * rtb_y_o[
                                static_cast<int32_T>(i + 128)];
                            rtb_RotateIndivWayPoint[b_exponent] +=
                                self_RotateATMissionHdg_k.dwork.RotateATMissionHdg
                                [static_cast<int32_T>(nrowx + 2)] * rtb_y_o[
                                static_cast<int32_T>(i + 256)];
                            i2 = static_cast<int32_T>(i2 + 128);
                            nrowx = static_cast<int32_T>(nrowx + 3);
                        }

                        // End of Product: '<S170>/RotateIndivWayPoint'
                    }

                    // MATLAB Function: '<S170>/biasNED' incorporates:
                    //   Reshape: '<S138>/ReshapeRowVec'

                    FlightMissionMode_biasNED(u, rtb_RotateIndivWayPoint,
                        rtb_nedWayPoint_CoreSubsysCanOut);

                    // ForEachSliceAssignment generated from: '<S170>/nedWayPoint' 
                    for (i = 0; i < 3; i++) {
                        std::memcpy
                            (&FlightMissionMode_DW.ImpAsg_InsertedFor_nedWayPoint_at_inport_0
                             [static_cast<int32_T>(static_cast<int32_T>(ibcol *
                               384) + static_cast<int32_T>(i << 7))],
                             &rtb_nedWayPoint_CoreSubsysCanOut
                             [static_cast<int32_T>(i << 7)],
                             static_cast<uint32_T>(sizeof(real_T) << 7U));
                    }
                }

                // End of Outputs for SubSystem: '<S138>/TransformWayPoint'

                // MATLAB Function: '<S138>/biasNEDstartpose1'
                FlightMissionMode_biasNEDstartpose(u,
                    rtb_ReshapeRowVecStartpose_d,
                    FlightMissionMode_DW.nedWayPoint);
            } else {
                FlightMissionMode_DW.WayPointGenerator_MODE_m = false;
            }

            // End of Outputs for SubSystem: '<S133>/WayPointGenerator'

            // Outputs for Atomic SubSystem: '<S133>/SegmentSwitch'
            FlightMissionMode_SegmentSwitch(rtu_Reset, rtu_Pose,
                FlightMissionMode_DW.ImpAsg_InsertedFor_nedWayPoint_at_inport_0,
                FlightMissionMode_DW.MergeLookAheadP,
                &FlightMissionMode_DW.MergeDesiredCourse,
                &FlightMissionMode_DW.RunWayLineMode, 200.0,
                &FlightMissionMode_DW.SegmentSwitch_p);

            // End of Outputs for SubSystem: '<S133>/SegmentSwitch'

            // DataTypeConversion: '<S133>/Cast To Double'
            *rty_thisTaskStatus = static_cast<real_T>
                (FlightMissionMode_DW.RunWayLineMode);

            // BusCreator: '<S133>/GuidanceCMDBusCreator' incorporates:
            //   DataTypeConversion: '<S133>/Param4'
            //   Gain: '<S133>/Down2Height'

            rty_GuidanceCmds->Height = -FlightMissionMode_DW.MergeLookAheadP[2];
            rty_GuidanceCmds->AirSpeed = static_cast<real_T>
                (rtu_Parameters->Param4);
            rty_GuidanceCmds->HeadingAngle =
                FlightMissionMode_DW.MergeDesiredCourse;

            // Reshape: '<S133>/Reshape' incorporates:
            //   Constant: '<S133>/InitialFlightPathAngle'
            //   Constant: '<S133>/InitialRollAngleRate'
            //   DataTypeConversion: '<S133>/Param4'
            //   Gain: '<S133>/Down2Up'

            rty_InitialState[0] = FlightMissionMode_DW.nedWayPoint[0];
            rty_InitialState[1] = FlightMissionMode_DW.nedWayPoint[1];
            rty_InitialState[2] = -FlightMissionMode_DW.nedWayPoint[2];
            rty_InitialState[3] = static_cast<real_T>(rtu_Parameters->Param4);
            rty_InitialState[4] = FlightMissionMode_DW.Sum;
            rty_InitialState[5] = 0.0;
            rty_InitialState[6] = FlightMissionMode_DW.ProductFlipStartPose[4];
            rty_InitialState[7] = 0.0;

            // End of Outputs for SubSystem: '<Root>/Mode44_ProtLine'
        }
        break;

      case 4:
        {
            real_T a_0;
            real_T rtb_Abs1_n;
            real_T rtb_AltitudeGCS_dj;
            real_T rtb_Down2Up_c;
            real_T rtb_LatitudeGCS_gv;
            real_T rtb_Sum1_k_idx_0;
            real_T rtb_Sum_k5;
            real_T rtb_Switch_lo;
            int32_T i;
            int32_T ibcol;
            int32_T nrows;
            int32_T rtb_Bias_f;
            boolean_T exitg1;

            // Outputs for IfAction SubSystem: '<Root>/Mode55_FrmnWayPoint' incorporates:
            //   ActionPort: '<S6>/Action Port'

            // DataStoreRead: '<S176>/AltitudeGCS'
            rtw_pthread_mutex_lock(AltitudeGCS_m0);
            rtb_Abs1_n = AltitudeGCS;
            rtw_pthread_mutex_unlock(AltitudeGCS_m0);

            // DataTypeConversion: '<S176>/Param1'
            rtb_Sum_id = static_cast<real_T>(rtu_Parameters->Param1);

            // DataTypeConversion: '<S176>/Param2'
            rtb_LatitudeGCS_gv = static_cast<real_T>(rtu_Parameters->Param2);

            // DataTypeConversion: '<S176>/Param3'
            rtb_Sum_k5 = static_cast<real_T>(rtu_Parameters->Param3);

            // Outputs for Enabled SubSystem: '<S176>/WayPointGenerator' incorporates:
            //   EnablePort: '<S181>/Enable'

            if (*rtu_Reset > 0) {
                FILE* a;
                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>
                                            (FlightMissionMode_DW.WayPointGenerator_MODE)
                      ^ 1))) {
                    // SystemReset for MATLAB Function: '<S181>/WayPointGenerator' 
                    a = NULL;
                    for (i = 0; i < 20; i++) {
                        FlightMissionMode_DW.eml_openfiles_n[i] = a;
                    }

                    // End of SystemReset for MATLAB Function: '<S181>/WayPointGenerator' 
                    FlightMissionMode_DW.WayPointGenerator_MODE = true;
                }

                // DataStoreRead: '<S181>/AltitudeGCS'
                rtw_pthread_mutex_lock(AltitudeGCS_m0);
                rtb_Down2Up_c = AltitudeGCS;
                rtw_pthread_mutex_unlock(AltitudeGCS_m0);

                // DataStoreRead: '<S181>/LatitudeGCS'
                rtw_pthread_mutex_lock(LatitudeGCS_m0);
                rtb_AltitudeGCS_dj = LatitudeGCS;
                rtw_pthread_mutex_unlock(LatitudeGCS_m0);

                // DataStoreRead: '<S181>/LongitudeGCS'
                rtw_pthread_mutex_lock(LongitudeGCS_m0);
                rtb_Switch_lo = LongitudeGCS;
                rtw_pthread_mutex_unlock(LongitudeGCS_m0);

                // MATLAB Function: '<S181>/WayPointGenerator' incorporates:
                //   Reshape: '<S181>/Reshape'

                // MATLAB Function 'Mode55_FrmnWayPoint/Mode55_Variant/Mode55/WayPointGenerator/WayPointGenerator': '<S204>:1' 
                // '<S204>:1:3'
                FlightMissionMode_string_string(rtb_Sum_k5, obj_Value_data,
                    obj_Value_size);
                i_size[0] = 1;
                i_size[1] = static_cast<int32_T>(obj_Value_size[1] + 14);
                for (i = 0; i < 14; i++) {
                    i_data[i] = i_0[i];
                }

                ibcol = obj_Value_size[1];
                for (i = 0; i <= static_cast<int32_T>(ibcol - 1); i++) {
                    i_data[static_cast<int32_T>(i + 14)] = obj_Value_data[i];
                }

                rtPrevAction = FlightMissionMode_cfopen_f(i_data, i_size, "rb");
                if (static_cast<int32_T>(rtPrevAction) != -1) {
                    // '<S204>:1:5'
                    // '<S204>:1:6'
                    FlightMissionMode_cfclose_m(static_cast<real_T>(rtPrevAction));

                    // '<S204>:1:7'
                    FlightMissionMode_string_string(rtb_Sum_k5, obj_Value_data,
                        obj_Value_size);
                    i_size[0] = 1;
                    i_size[1] = static_cast<int32_T>(obj_Value_size[1] + 14);
                    for (i = 0; i < 14; i++) {
                        i_data[i] = i_0[i];
                    }

                    ibcol = obj_Value_size[1];
                    for (i = 0; i <= static_cast<int32_T>(ibcol - 1); i++) {
                        i_data[static_cast<int32_T>(i + 14)] = obj_Value_data[i];
                    }

                    rtPrevAction = FlightMissionMode_cfopen_f(i_data, i_size,
                        "rb");
                    std::memset(&FlightMissionMode_DW.MAT[0], 0,
                                static_cast<uint32_T>(sizeof(real_T) << 12U));
                    FlightMissionMode_emxInit_char_T_e(&tline, 2);
                    FlightMissionMode_fgetl(static_cast<real_T>(rtPrevAction),
                                            tline);
                    rtb_Sum_k5 = 0.0;
                    a = NULL;
                    FlightMissionMode_emxInit_char_T_e(&aTmp, 2);
                    FlightMissionMode_emxInit_char_T_e(&s1, 2);
                    int32_T exitg2;
                    do {
                        FILE* filestar;
                        exitg2 = 0;
                        if (tline->size[1] != 0) {
                            rtb_Sum_k5++;
                            a_0 = 0.0;
                            int32_T exitg3;
                            do {
                                exitg3 = 0;
                                if (tline->size[1] == 0) {
                                    aTmp->size[1] = 0;
                                } else {
                                    i = static_cast<int32_T>(aTmp->size[0] *
                                        aTmp->size[1]);
                                    aTmp->size[0] = 1;
                                    aTmp->size[1] = tline->size[1];
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (aTmp, i);
                                    ibcol = static_cast<int32_T>(tline->size[1]
                                        - 1);
                                    for (i = 0; i <= ibcol; i++) {
                                        aTmp->data[i] = tline->data[i];
                                    }
                                }

                                if (aTmp->size[1] == 0) {
                                    exitg3 = 1;
                                } else {
                                    a_0++;
                                    i = static_cast<int32_T>(aTmp->size[0] *
                                        aTmp->size[1]);
                                    aTmp->size[0] = 1;
                                    aTmp->size[1] = tline->size[1];
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (aTmp, i);
                                    ibcol = static_cast<int32_T>(tline->size[1]
                                        - 1);
                                    for (i = 0; i <= ibcol; i++) {
                                        aTmp->data[i] = tline->data[i];
                                    }

                                    nrows = tline->size[1];
                                    rtb_Bias_f = 0;
                                    while ((static_cast<int32_T>(rtb_Bias_f + 1)
                                            <= nrows) && (tline->data[rtb_Bias_f]
                                                          == ',')) {
                                        rtb_Bias_f = static_cast<int32_T>
                                            (rtb_Bias_f + 1);
                                    }

                                    nrowx = static_cast<int32_T>(rtb_Bias_f + 1);
                                    while ((static_cast<int32_T>(rtb_Bias_f + 1)
                                            <= nrows) && (tline->data[rtb_Bias_f]
                                                          != ',')) {
                                        rtb_Bias_f = static_cast<int32_T>
                                            (rtb_Bias_f + 1);
                                    }

                                    if (static_cast<int32_T>(rtb_Bias_f + 1) >
                                            tline->size[1]) {
                                        nrows = 0;
                                        i2 = 0;
                                    } else {
                                        nrows = rtb_Bias_f;
                                        i2 = tline->size[1];
                                    }

                                    i2 = static_cast<int32_T>(i2 - nrows);
                                    for (i = 0; i <= static_cast<int32_T>(i2 - 1);
                                         i++) {
                                        tline->data[i] = tline->data[
                                            static_cast<int32_T>(nrows + i)];
                                    }

                                    i = static_cast<int32_T>(tline->size[0] *
                                        tline->size[1]);
                                    tline->size[0] = 1;
                                    tline->size[1] = i2;
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (tline, i);
                                    if (nrowx > rtb_Bias_f) {
                                        nrowx = -1;
                                        rtb_Bias_f = -1;
                                    } else {
                                        nrowx = static_cast<int32_T>(nrowx - 2);
                                        rtb_Bias_f = static_cast<int32_T>
                                            (rtb_Bias_f - 1);
                                    }

                                    FlightMissionMode_DW.MAT[static_cast<int32_T>
                                        (static_cast<int32_T>
                                         (static_cast<int32_T>(rtb_Sum_k5) +
                                          static_cast<int32_T>
                                          (static_cast<int32_T>
                                           (static_cast<int32_T>(a_0) - 1) << 10))
                                         - 1)] = (rtNaN);
                                    ibcol = static_cast<int32_T>(rtb_Bias_f -
                                        nrowx);
                                    if (ibcol >= 1) {
                                        int32_T loop_ub;
                                        nrows = 0;
                                        ntilerows = 1;
                                        exitg1 = false;
                                        while ((!exitg1) && (ntilerows <= ibcol))
                                        {
                                            char_T tmp_0;
                                            tmp_0 = aTmp->data
                                                [static_cast<int32_T>(nrowx +
                                                ntilerows)];
                                            if (m[static_cast<int32_T>(
                                                    static_cast<int32_T>(
                                                    static_cast<uint8_T>(tmp_0))
                                                 & 127)] || (tmp_0 == '\x00')) {
                                                ntilerows = static_cast<int32_T>
                                                    (ntilerows + 1);
                                            } else {
                                                exitg1 = true;
                                            }
                                        }

                                        i = static_cast<int32_T>(r->size[0] *
                                            r->size[1]);
                                        r->size[0] = 1;
                                        r->size[1] = static_cast<int32_T>(ibcol
                                            + 2);
                                        FlightMissionMode_emxEnsureCapacity_char_T_g
                                            (r, i);
                                        for (i = 0; i <= static_cast<int32_T>
                                                (ibcol + 1); i++) {
                                            r->data[i] = '\x00';
                                        }

                                        i2 = 1;
                                        i = static_cast<int32_T>(s1->size[0] *
                                            s1->size[1]);
                                        s1->size[0] = 1;
                                        s1->size[1] = ibcol;
                                        FlightMissionMode_emxEnsureCapacity_char_T_g
                                            (s1, i);
                                        for (i = 0; i <= static_cast<int32_T>
                                                (ibcol - 1); i++) {
                                            s1->data[i] = aTmp->data[
                                                static_cast<int32_T>(
                                                static_cast<int32_T>(nrowx + i)
                                                + 1)];
                                        }

                                        FlightMissionMode_readfloat_i(r, &i2, s1,
                                            &ntilerows, static_cast<int32_T>
                                            (rtb_Bias_f - nrowx), true,
                                            &rtb_Compare_lx, &rtb_Compare_em,
                                            &rtb_Sum1_k_idx_1, &rtb_Compare_ni,
                                            &success);
                                        i = static_cast<int32_T>(s1->size[0] *
                                            s1->size[1]);
                                        s1->size[0] = 1;
                                        s1->size[1] = r->size[1];
                                        FlightMissionMode_emxEnsureCapacity_char_T_g
                                            (s1, i);
                                        loop_ub = static_cast<int32_T>(r->size[1]
                                            - 1);
                                        for (i = 0; i <= loop_ub; i++) {
                                            s1->data[i] = r->data[i];
                                        }

                                        if (rtb_Compare_em) {
                                            nrows = 1;
                                        }

                                        if (static_cast<boolean_T>
                                                (static_cast<int32_T>((ntilerows
                                               <= ibcol) & static_cast<int32_T>
                                                (success)))) {
                                            s1->data[static_cast<int32_T>(i2 - 1)]
                                                = ' ';
                                            i = static_cast<int32_T>(r->size[0] *
                                                r->size[1]);
                                            r->size[0] = 1;
                                            r->size[1] = s1->size[1];
                                            FlightMissionMode_emxEnsureCapacity_char_T_g
                                                (r, i);
                                            loop_ub = static_cast<int32_T>
                                                (s1->size[1] - 1);
                                            for (i = 0; i <= loop_ub; i++) {
                                                r->data[i] = s1->data[i];
                                            }

                                            i2 = static_cast<int32_T>(i2 + 1);
                                            i = static_cast<int32_T>(s1->size[0]
                                                * s1->size[1]);
                                            s1->size[0] = 1;
                                            s1->size[1] = ibcol;
                                            FlightMissionMode_emxEnsureCapacity_char_T_g
                                                (s1, i);
                                            for (i = 0; i <= static_cast<int32_T>
                                                    (ibcol - 1); i++) {
                                                s1->data[i] = aTmp->data[
                                                    static_cast<int32_T>(
                                                    static_cast<int32_T>(nrowx +
                                                    i) + 1)];
                                            }

                                            FlightMissionMode_readfloat_i(r, &i2,
                                                s1, &ntilerows,
                                                static_cast<int32_T>(rtb_Bias_f
                                                - nrowx), true, &rtb_Compare_ni,
                                                &success, &rtb_CastToDouble_l,
                                                &foundsign, &c_success);
                                            i = static_cast<int32_T>(s1->size[0]
                                                * s1->size[1]);
                                            s1->size[0] = 1;
                                            s1->size[1] = r->size[1];
                                            FlightMissionMode_emxEnsureCapacity_char_T_g
                                                (s1, i);
                                            loop_ub = static_cast<int32_T>
                                                (r->size[1] - 1);
                                            for (i = 0; i <= loop_ub; i++) {
                                                s1->data[i] = r->data[i];
                                            }

                                            if (success) {
                                                nrows = static_cast<int32_T>
                                                    (nrows + 1);
                                            }

                                            success = static_cast<boolean_T>(
                                                static_cast<int32_T>(
                                                static_cast<int32_T>(
                                                static_cast<boolean_T>(
                                                static_cast<int32_T>(
                                                static_cast<int32_T>(
                                                static_cast<boolean_T>(
                                                static_cast<int32_T>((ntilerows >
                                                ibcol) & static_cast<int32_T>
                                                (c_success)))) &
                                                static_cast<int32_T>(
                                                static_cast<boolean_T>(
                                                static_cast<int32_T>(
                                                static_cast<int32_T>
                                                (rtb_Compare_lx) ^
                                                static_cast<int32_T>
                                                (rtb_Compare_ni))))))) &
                                                static_cast<int32_T>(foundsign)));
                                        } else {
                                            rtb_CastToDouble_l = 0.0;
                                        }

                                        if (success) {
                                            s1->data[static_cast<int32_T>(i2 - 1)]
                                                = '\x00';
                                            switch (nrows) {
                                              case 2:
                                                rtb_Bias_f = sscanf(&s1->data[0],
                                                                    "%lf %lf",
                                                                    &rtb_Sum1_k_idx_1,
                                                                    &rtb_CastToDouble_l);
                                                if (rtb_Bias_f != 2) {
                                                    rtb_Sum1_k_idx_1 = (rtNaN);
                                                    rtb_CastToDouble_l = (rtNaN);
                                                }
                                                break;

                                              case 1:
                                                rtb_Bias_f = sscanf(&s1->data[0],
                                                                    "%lf",
                                                                    &rtb_Cos_j);
                                                if (rtb_Compare_em) {
                                                    if (rtb_Bias_f == 1) {
                                                        rtb_Sum1_k_idx_1 =
                                                            rtb_Cos_j;
                                                    } else {
                                                        rtb_Sum1_k_idx_1 =
                                                            (rtNaN);
                                                    }
                                                } else if (rtb_Bias_f == 1) {
                                                    rtb_CastToDouble_l =
                                                        rtb_Cos_j;
                                                } else {
                                                    rtb_CastToDouble_l = (rtNaN);
                                                }
                                                break;
                                            }

                                            if (rtb_Compare_lx) {
                                                FlightMissionMode_DW.MAT[
                                                    static_cast<int32_T>(
                                                    static_cast<int32_T>(
                                                    static_cast<int32_T>
                                                    (rtb_Sum_k5) +
                                                    static_cast<int32_T>(
                                                    static_cast<int32_T>(
                                                    static_cast<int32_T>(a_0) -
                                                    1) << 10)) - 1)] =
                                                    rtb_CastToDouble_l;
                                            } else {
                                                FlightMissionMode_DW.MAT[
                                                    static_cast<int32_T>(
                                                    static_cast<int32_T>(
                                                    static_cast<int32_T>
                                                    (rtb_Sum_k5) +
                                                    static_cast<int32_T>(
                                                    static_cast<int32_T>(
                                                    static_cast<int32_T>(a_0) -
                                                    1) << 10)) - 1)] =
                                                    rtb_Sum1_k_idx_1;
                                            }
                                        }
                                    }
                                }
                            } while (exitg3 == 0);
                        }

                        filestar = FlightMissionMode_fileManager_l
                            (static_cast<real_T>(rtPrevAction));
                        if (filestar == a) {
                            rtb_Bias_f = 0;
                        } else {
                            int st;
                            st = feof(filestar);
                            rtb_Bias_f = ((int32_T)st != 0);
                        }

                        if (rtb_Bias_f != 0) {
                            exitg2 = 1;
                        } else {
                            FlightMissionMode_fgetl(static_cast<real_T>
                                                    (rtPrevAction), tline);
                        }
                    } while (exitg2 == 0);

                    FlightMissionMode_emxFree_char_T_o(&s1);
                    FlightMissionMode_emxFree_char_T_o(&aTmp);
                    FlightMissionMode_emxFree_char_T_o(&tline);
                    if (rtb_Sum_k5 < 1.0) {
                        rtb_Bias_f = -1;
                    } else {
                        rtb_Bias_f = static_cast<int32_T>(static_cast<int32_T>
                            (rtb_Sum_k5) - 1);
                    }

                    FlightMissionMode_cfclose_m(static_cast<real_T>(rtPrevAction));

                    // '<S204>:1:8'
                    // '<S204>:1:9'
                    // '<S204>:1:10'
                    q_size[0] = static_cast<int32_T>(rtb_Bias_f + 1);
                    q_size[1] = 3;
                    i = 0;
                    for (i2 = 0; i2 < 3; i2++) {
                        for (nrowx = 0; nrowx <= rtb_Bias_f; nrowx++) {
                            FlightMissionMode_DW.q_data[static_cast<int32_T>
                                (nrowx + static_cast<int32_T>(q_size[0] * i2))] =
                                FlightMissionMode_DW.MAT[static_cast<int32_T>
                                (nrowx + i)];
                        }

                        i = static_cast<int32_T>(i + 1024);
                    }

                    FlightMissionMode_circshift(FlightMissionMode_DW.q_data,
                        q_size, rtb_LatitudeGCS_gv);
                    o_size[0] = q_size[0];
                    o_size[1] = 3;
                    ibcol = static_cast<int32_T>(q_size[0] * 3);
                    for (i = 0; i <= static_cast<int32_T>(ibcol - 1); i++) {
                        FlightMissionMode_DW.o_data[i] =
                            FlightMissionMode_DW.q_data[i];
                    }

                    rtb_TmpSignalConversionAtOrbitFollowerInport2[0] =
                        rtb_AltitudeGCS_dj;
                    rtb_TmpSignalConversionAtOrbitFollowerInport2[1] =
                        rtb_Switch_lo;
                    rtb_TmpSignalConversionAtOrbitFollowerInport2[2] =
                        rtb_Down2Up_c;
                    FlightMissionMode_lla2ned(FlightMissionMode_DW.o_data,
                        o_size, rtb_TmpSignalConversionAtOrbitFollowerInport2,
                        FlightMissionMode_DW.NED_WP_data, NED_WP_size);
                } else {
                    // '<S204>:1:12'
                    NED_WP_size[0] = 4;
                    for (i = 0; i < 12; i++) {
                        FlightMissionMode_DW.NED_WP_data[i] = static_cast<real_T>
                            (j[i]);
                    }

                    // '<S204>:1:16'
                    printf("Path waypoint doesn\'t exist!\n");
                    fflush(stdout);
                }

                // '<S204>:1:20'
                a_0 = std::ceil(8192.0 / static_cast<real_T>(NED_WP_size[0]));
                i = static_cast<int32_T>(dummyWayPoint->size[0] *
                    dummyWayPoint->size[1]);

                // MATLAB Function: '<S181>/WayPointGenerator'
                dummyWayPoint->size[0] = static_cast<int32_T>(NED_WP_size[0] *
                    static_cast<int32_T>(a_0));
                dummyWayPoint->size[1] = 3;
                FlightMissionMode_emxEnsureCapacity_real_T_c(dummyWayPoint, i);

                // MATLAB Function: '<S181>/WayPointGenerator'
                nrows = NED_WP_size[0];
                for (nrowx = 0; nrowx <= static_cast<int32_T>
                        (static_cast<int32_T>(a_0) - 1); nrowx =
                        static_cast<int32_T>(nrowx + 1)) {
                    ibcol = static_cast<int32_T>(static_cast<int32_T>(nrowx *
                        nrows) + -1);
                    for (i2 = 1; static_cast<int32_T>(i2 - 1) <=
                            static_cast<int32_T>(nrows - 1); i2 =
                            static_cast<int32_T>(i2 + 1)) {
                        dummyWayPoint->data[static_cast<int32_T>(ibcol + i2)] =
                            FlightMissionMode_DW.NED_WP_data[static_cast<int32_T>
                            (i2 - 1)];
                    }
                }

                i = static_cast<int32_T>(static_cast<int32_T>(NED_WP_size[0] *
                    static_cast<int32_T>(a_0)) - 1);
                for (nrowx = 0; nrowx <= static_cast<int32_T>
                        (static_cast<int32_T>(a_0) - 1); nrowx =
                        static_cast<int32_T>(nrowx + 1)) {
                    ibcol = static_cast<int32_T>(static_cast<int32_T>(nrowx *
                        nrows) + i);
                    for (i2 = 1; static_cast<int32_T>(i2 - 1) <=
                            static_cast<int32_T>(nrows - 1); i2 =
                            static_cast<int32_T>(i2 + 1)) {
                        dummyWayPoint->data[static_cast<int32_T>(ibcol + i2)] =
                            FlightMissionMode_DW.NED_WP_data[static_cast<int32_T>
                            (static_cast<int32_T>(nrows + i2) - 1)];
                    }
                }

                rtb_Bias_f = static_cast<int32_T>(NED_WP_size[0] << 1);
                i = static_cast<int32_T>(static_cast<int32_T>
                    (static_cast<int32_T>(NED_WP_size[0] * static_cast<int32_T>
                    (a_0)) << 1) - 1);
                for (nrowx = 0; nrowx <= static_cast<int32_T>
                        (static_cast<int32_T>(a_0) - 1); nrowx =
                        static_cast<int32_T>(nrowx + 1)) {
                    ibcol = static_cast<int32_T>(static_cast<int32_T>(nrowx *
                        nrows) + i);
                    for (i2 = 1; static_cast<int32_T>(i2 - 1) <=
                            static_cast<int32_T>(nrows - 1); i2 =
                            static_cast<int32_T>(i2 + 1)) {
                        dummyWayPoint->data[static_cast<int32_T>(ibcol + i2)] =
                            FlightMissionMode_DW.NED_WP_data[static_cast<int32_T>
                            (static_cast<int32_T>(rtb_Bias_f + i2) - 1)];
                    }
                }

                // '<S204>:1:23'
                i = 0;
                for (i2 = 0; i2 < 3; i2++) {
                    for (nrowx = 0; nrowx < 8192; nrowx++) {
                        FlightMissionMode_DW.WayPoint[static_cast<int32_T>(nrowx
                            + i)] = dummyWayPoint->data[static_cast<int32_T>(
                            static_cast<int32_T>(dummyWayPoint->size[0] * i2) +
                            nrowx)];
                    }

                    i = static_cast<int32_T>(i + 8192);
                }
            } else {
                FlightMissionMode_DW.WayPointGenerator_MODE = false;
            }

            // End of Outputs for SubSystem: '<S176>/WayPointGenerator'

            // SwitchCase: '<S176>/Switch Case' incorporates:
            //   MATLAB Function: '<S181>/WayPointGenerator'
            //   MATLABSystem: '<S180>/Waypoint Follower'

            rtPrevAction = FlightMissionMode_DW.SwitchCase_ActiveSubsystem_c;
            a_0 = std::trunc(rtb_Sum_id);
            if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                    (std::isnan(a_0)) | static_cast<int32_T>(std::isinf(a_0)))))
            {
                a_0 = 0.0;
            } else {
                a_0 = std::fmod(a_0, 4.294967296E+9);
            }

            if ((a_0 < 0.0 ? static_cast<int32_T>(-static_cast<int32_T>(
                    static_cast<uint32_T>(-a_0))) : static_cast<int32_T>(
                    static_cast<uint32_T>(a_0))) == 99) {
                rtAction = 0;
            } else {
                rtAction = 1;
            }

            FlightMissionMode_DW.SwitchCase_ActiveSubsystem_c = rtAction;
            if (static_cast<int32_T>(rtAction) == 0) {
                if (static_cast<int32_T>(rtPrevAction) != 0) {
                    // SystemReset for IfAction SubSystem: '<S176>/StartFromClosest' incorporates:
                    //   ActionPort: '<S179>/Action Port'

                    // SystemReset for SwitchCase: '<S176>/Switch Case' incorporates:
                    //   MATLABSystem: '<S179>/Waypoint Follower'

                    FlightMissionMode_DW.obj_j.WaypointIndex = 1.0;
                    for (i = 0; i < 24576; i++) {
                        FlightMissionMode_DW.obj_j.WaypointsInternal[i] = (rtNaN);
                    }

                    // End of SystemReset for SubSystem: '<S176>/StartFromClosest' 
                }

                // Outputs for IfAction SubSystem: '<S176>/StartFromClosest' incorporates:
                //   ActionPort: '<S179>/Action Port'

                // SignalConversion generated from: '<S179>/Waypoint Follower' incorporates:
                //   Constant: '<S179>/LookAheadDis'
                //   MATLABSystem: '<S179>/Waypoint Follower'
                //   Merge: '<S176>/MergeLAP'

                FlightMissionMode_WaypointFollower_stepImpl
                    (&FlightMissionMode_DW.obj_j, rtu_Pose,
                     FlightMissionMode_DW.WayPoint, 200.0, turnVector,
                     &rtb_Cos_j, &rtb_Sum_id, &status, &rtb_MergeStatus);

                // End of Outputs for SubSystem: '<S176>/StartFromClosest'
            } else {
                if (static_cast<int32_T>(rtPrevAction) != 1) {
                    // SystemReset for IfAction SubSystem: '<S176>/StartFromFirst' incorporates:
                    //   ActionPort: '<S180>/Action Port'

                    // SystemReset for SwitchCase: '<S176>/Switch Case' incorporates:
                    //   MATLABSystem: '<S180>/Waypoint Follower'

                    FlightMissionMode_DW.obj.WaypointIndex = 1.0;
                    for (i = 0; i < 24576; i++) {
                        FlightMissionMode_DW.obj.WaypointsInternal[i] = (rtNaN);
                    }

                    // End of SystemReset for SubSystem: '<S176>/StartFromFirst' 
                }

                // Outputs for IfAction SubSystem: '<S176>/StartFromFirst' incorporates:
                //   ActionPort: '<S180>/Action Port'

                // MATLABSystem: '<S180>/Waypoint Follower'
                FlightMissionMode_DW.obj.LookaheadDistFlag = 0U;
                FlightMissionMode_DW.obj.InitialPose[0] = 0.0;
                FlightMissionMode_DW.obj.InitialPose[1] = 0.0;
                FlightMissionMode_DW.obj.InitialPose[2] = 0.0;
                FlightMissionMode_DW.obj.InitialPose[3] = 0.0;
                for (i = 0; i < 24576; i++) {
                    FlightMissionMode_DW.RotateIndivWayPoint_g[i] = (rtNaN);
                }

                i = 0;
                for (i2 = 0; i2 < 3; i2++) {
                    std::memcpy(&FlightMissionMode_DW.RotateIndivWayPoint_g[i],
                                &FlightMissionMode_DW.WayPoint[i],
                                static_cast<uint32_T>(sizeof(real_T) << 13U));
                    i = static_cast<int32_T>(i + 8192);
                }

                rtb_Compare_em = false;
                rtb_Compare_ni = true;
                rtb_Bias_f = 0;
                exitg1 = false;
                while ((!exitg1) && (rtb_Bias_f < 24576)) {
                    if ((FlightMissionMode_DW.obj.WaypointsInternal[rtb_Bias_f] ==
                         FlightMissionMode_DW.RotateIndivWayPoint_g[rtb_Bias_f])
                        || (std::isnan
                            (FlightMissionMode_DW.obj.WaypointsInternal[rtb_Bias_f])
                            && std::isnan
                            (FlightMissionMode_DW.RotateIndivWayPoint_g[rtb_Bias_f])))
                    {
                        rtb_Bias_f = static_cast<int32_T>(rtb_Bias_f + 1);
                    } else {
                        rtb_Compare_ni = false;
                        exitg1 = true;
                    }
                }

                if (rtb_Compare_ni) {
                    rtb_Compare_em = true;
                }

                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>(rtb_Compare_em)
                      ^ 1))) {
                    std::memcpy(&FlightMissionMode_DW.obj.WaypointsInternal[0],
                                &FlightMissionMode_DW.RotateIndivWayPoint_g[0],
                                static_cast<uint32_T>(24576U * sizeof(real_T)));
                    FlightMissionMode_DW.obj.WaypointIndex = 1.0;
                }

                i = 0;
                for (i2 = 0; i2 < 3; i2++) {
                    std::memcpy(&FlightMissionMode_DW.WayPoint_p[i],
                                &FlightMissionMode_DW.WayPoint
                                [static_cast<int32_T>(i + 1)],
                                static_cast<uint32_T>(8191U * sizeof(real_T)));
                    i = static_cast<int32_T>(i + 8192);
                }

                FlightMissionMode_DW.WayPoint_p[8191] = (rtNaN);
                FlightMissionMode_DW.WayPoint_p[16383] = (rtNaN);
                FlightMissionMode_DW.WayPoint_p[24575] = (rtNaN);
                for (i = 0; i < 24576; i++) {
                    FlightMissionMode_DW.x[i] = (FlightMissionMode_DW.WayPoint[i]
                        != FlightMissionMode_DW.WayPoint_p[i]);
                }

                nrows = 0;
                i2 = 16384;
                for (i = 0; i < 8192; i++) {
                    FlightMissionMode_DW.b[i] = false;
                    nrows = static_cast<int32_T>(nrows + 1);
                    i2 = static_cast<int32_T>(i2 + 1);
                    ntilerows = nrows;
                    exitg1 = false;
                    while ((!exitg1) && (ntilerows <= i2)) {
                        if (FlightMissionMode_DW.x[static_cast<int32_T>
                                (ntilerows - 1)]) {
                            FlightMissionMode_DW.b[i] = true;
                            exitg1 = true;
                        } else {
                            ntilerows = static_cast<int32_T>(ntilerows + 8192);
                        }
                    }
                }

                nrows = 0;
                for (rtb_Bias_f = 0; rtb_Bias_f < 8192; rtb_Bias_f++) {
                    if (FlightMissionMode_DW.b[rtb_Bias_f]) {
                        nrows = static_cast<int32_T>(nrows + 1);
                    }
                }

                nrowx = nrows;
                nrows = 0;
                for (rtb_Bias_f = 0; rtb_Bias_f < 8192; rtb_Bias_f++) {
                    if (FlightMissionMode_DW.b[rtb_Bias_f]) {
                        FlightMissionMode_DW.c_data_f[nrows] =
                            static_cast<int16_T>(static_cast<int32_T>(rtb_Bias_f
                            + 1));
                        nrows = static_cast<int32_T>(nrows + 1);
                    }
                }

                i = static_cast<int32_T>(b_waypointsIn->size[0] *
                    b_waypointsIn->size[1]);

                // MATLABSystem: '<S180>/Waypoint Follower'
                b_waypointsIn->size[0] = nrowx;
                b_waypointsIn->size[1] = 3;
                FlightMissionMode_emxEnsureCapacity_real_T_c(b_waypointsIn, i);

                // MATLABSystem: '<S180>/Waypoint Follower'
                for (i = 0; i < 3; i++) {
                    for (i2 = 0; i2 <= static_cast<int32_T>(nrowx - 1); i2++) {
                        b_waypointsIn->data[static_cast<int32_T>(i2 +
                            static_cast<int32_T>(b_waypointsIn->size[0] * i))] =
                            FlightMissionMode_DW.WayPoint[static_cast<int32_T>(
                            static_cast<int32_T>(static_cast<int32_T>(i << 13) +
                            static_cast<int32_T>
                            (FlightMissionMode_DW.c_data_f[i2])) - 1)];
                    }
                }

                FlightMissionMode_DW.obj.NumWaypoints = static_cast<real_T>
                    (nrowx);
                FlightMissionMode_DW.obj.LookaheadDistance = 200.0;
                if (nrowx == 0) {
                    // SignalConversion generated from: '<S180>/Waypoint Follower' incorporates:
                    //   Merge: '<S176>/MergeLAP'

                    turnVector[2] = rtu_Pose[2];

                    // SignalConversion generated from: '<S180>/Waypoint Follower' 
                    rtb_Cos_j = rtu_Pose[3];

                    // SignalConversion generated from: '<S180>/Waypoint Follower' 
                    rtb_MergeStatus = 1U;
                } else {
                    boolean_T guard1;
                    guard1 = false;
                    if (nrowx == 1) {
                        if (FlightMissionMode_DW.obj.StartFlag) {
                            FlightMissionMode_DW.obj.InitialPose[0] = rtu_Pose[0];
                            FlightMissionMode_DW.obj.InitialPose[1] = rtu_Pose[1];
                            FlightMissionMode_DW.obj.InitialPose[2] = rtu_Pose[2];
                            FlightMissionMode_DW.obj.InitialPose[3] = rtu_Pose[3];
                        }

                        rtb_TmpSignalConversionAtOrbitFollowerInport2[0] =
                            b_waypointsIn->data[0] - rtu_Pose[0];
                        rtb_TmpSignalConversionAtOrbitFollowerInport2[1] =
                            b_waypointsIn->data[1] - rtu_Pose[1];
                        rtb_TmpSignalConversionAtOrbitFollowerInport2[2] =
                            b_waypointsIn->data[2] - rtu_Pose[2];
                        if (FlightMissionMode_norm_pv
                                (rtb_TmpSignalConversionAtOrbitFollowerInport2) <
                            1.4901161193847656E-8) {
                            // SignalConversion generated from: '<S180>/Waypoint Follower' incorporates:
                            //   Merge: '<S176>/MergeLAP'

                            turnVector[2] = rtu_Pose[2];

                            // SignalConversion generated from: '<S180>/Waypoint Follower' 
                            rtb_Cos_j = rtu_Pose[3];

                            // SignalConversion generated from: '<S180>/Waypoint Follower' 
                            rtb_MergeStatus = 1U;
                            FlightMissionMode_DW.obj.StartFlag = false;
                        } else {
                            FlightMissionMode_DW.obj.StartFlag = false;
                            FlightMissionMode_DW.obj.NumWaypoints = 2.0;
                            i = static_cast<int32_T>(waypoints->size[0] *
                                waypoints->size[1]);
                            waypoints->size[0] = static_cast<int32_T>
                                (b_waypointsIn->size[0] + 1);
                            waypoints->size[1] = 3;
                            FlightMissionMode_emxEnsureCapacity_real_T_c
                                (waypoints, i);
                            ibcol = b_waypointsIn->size[0];
                            for (i = 0; i < 3; i++) {
                                waypoints->data[static_cast<int32_T>
                                    (waypoints->size[0] * i)] =
                                    FlightMissionMode_DW.obj.InitialPose[i];
                                for (i2 = 0; i2 <= static_cast<int32_T>(ibcol -
                                        1); i2++) {
                                    waypoints->data[static_cast<int32_T>(
                                        static_cast<int32_T>(i2 +
                                        static_cast<int32_T>(waypoints->size[0] *
                                        i)) + 1)] = b_waypointsIn->data[
                                        static_cast<int32_T>(static_cast<int32_T>
                                        (b_waypointsIn->size[0] * i) + i2)];
                                }
                            }

                            guard1 = true;
                        }
                    } else {
                        i = static_cast<int32_T>(waypoints->size[0] *
                            waypoints->size[1]);
                        waypoints->size[0] = b_waypointsIn->size[0];
                        waypoints->size[1] = 3;
                        FlightMissionMode_emxEnsureCapacity_real_T_c(waypoints,
                            i);
                        ibcol = static_cast<int32_T>(b_waypointsIn->size[0] * 3);
                        for (i = 0; i <= static_cast<int32_T>(ibcol - 1); i++) {
                            waypoints->data[i] = b_waypointsIn->data[i];
                        }

                        guard1 = true;
                    }

                    if (guard1) {
                        real_T a_tmp;
                        real_T rtb_Sum1_k_tmp;
                        real_T rtb_Sum_n_tmp;
                        real_T yout_idx_0;
                        boolean_T guard2;
                        rtb_Compare_em = false;
                        if (FlightMissionMode_DW.obj.WaypointIndex ==
                                FlightMissionMode_DW.obj.NumWaypoints) {
                            rtb_Compare_em = true;
                        }

                        if (rtb_Compare_em) {
                            FlightMissionMode_DW.obj.LastWaypointFlag = true;
                            FlightMissionMode_DW.obj.WaypointIndex--;
                        }

                        u[0] = rtu_Pose[0] - waypoints->data[static_cast<int32_T>
                            (static_cast<int32_T>
                             (FlightMissionMode_DW.obj.WaypointIndex + 1.0) - 1)];
                        u[1] = rtu_Pose[1] - waypoints->data[static_cast<int32_T>
                            (static_cast<int32_T>(static_cast<int32_T>
                              (FlightMissionMode_DW.obj.WaypointIndex + 1.0) +
                              waypoints->size[0]) - 1)];
                        u[2] = rtu_Pose[2] - waypoints->data[static_cast<int32_T>
                            (static_cast<int32_T>(static_cast<int32_T>
                              (FlightMissionMode_DW.obj.WaypointIndex + 1.0) +
                              static_cast<int32_T>(waypoints->size[0] << 1)) - 1)];
                        guard2 = false;
                        if (FlightMissionMode_norm_pv(u) <= 30.0) {
                            guard2 = true;
                        } else {
                            a_0 = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>
                                (FlightMissionMode_DW.obj.WaypointIndex + 1.0) -
                                1)];
                            rtb_TmpSignalConversionAtOrbitFollowerInport2[0] =
                                rtu_Pose[0] - a_0;
                            turnVector[0] = a_0 - waypoints->data
                                [static_cast<int32_T>(static_cast<int32_T>
                                (FlightMissionMode_DW.obj.WaypointIndex) - 1)];
                            a_0 = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>
                                (FlightMissionMode_DW.obj.WaypointIndex + 1.0) +
                                waypoints->size[0]) - 1)];
                            rtb_TmpSignalConversionAtOrbitFollowerInport2[1] =
                                rtu_Pose[1] - a_0;
                            turnVector[1] = a_0 - waypoints->data
                                [static_cast<int32_T>(static_cast<int32_T>(
                                static_cast<int32_T>
                                (FlightMissionMode_DW.obj.WaypointIndex) +
                                waypoints->size[0]) - 1)];
                            rtb_TmpSignalConversionAtOrbitFollowerInport2[2] =
                                rtu_Pose[2] - waypoints->data
                                [static_cast<int32_T>(static_cast<int32_T>(
                                static_cast<int32_T>
                                (FlightMissionMode_DW.obj.WaypointIndex + 1.0) +
                                static_cast<int32_T>(waypoints->size[0] << 1)) -
                                1)];
                            turnVector[2] = waypoints->data[static_cast<int32_T>
                                (static_cast<int32_T>(static_cast<int32_T>
                                  (FlightMissionMode_DW.obj.WaypointIndex + 1.0)
                                  + static_cast<int32_T>(waypoints->size[0] << 1))
                                 - 1)] - waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>
                                (waypoints->size[0] << 1) + static_cast<int32_T>
                                (FlightMissionMode_DW.obj.WaypointIndex)) - 1)];
                            a_0 = FlightMissionMode_norm_pv(turnVector);
                            rtb_CastToDouble_l = FlightMissionMode_norm_pv
                                (rtb_TmpSignalConversionAtOrbitFollowerInport2);
                            rtb_Sum1_k_idx_0 = waypoints->data
                                [static_cast<int32_T>(static_cast<int32_T>
                                (FlightMissionMode_DW.obj.WaypointIndex) - 1)];
                            rtb_Sum1_k_idx_1 = waypoints->data
                                [static_cast<int32_T>(static_cast<int32_T>
                                (FlightMissionMode_DW.obj.WaypointIndex + 1.0) -
                                1)];
                            rtb_Sum_n_tmp = waypoints->data[static_cast<int32_T>
                                (static_cast<int32_T>(static_cast<int32_T>
                                  (FlightMissionMode_DW.obj.WaypointIndex) +
                                  waypoints->size[0]) - 1)];
                            a_tmp = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>
                                (FlightMissionMode_DW.obj.WaypointIndex + 1.0) +
                                waypoints->size[0]) - 1)];
                            yout_idx_0 = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>
                                (waypoints->size[0] << 1) + static_cast<int32_T>
                                (FlightMissionMode_DW.obj.WaypointIndex)) - 1)];
                            rtb_Sum1_k_tmp = waypoints->data[static_cast<int32_T>
                                (static_cast<int32_T>(static_cast<int32_T>
                                  (FlightMissionMode_DW.obj.WaypointIndex + 1.0)
                                  + static_cast<int32_T>(waypoints->size[0] << 1))
                                 - 1)];
                            a_0 = ((rtb_Sum1_k_idx_1 - rtb_Sum1_k_idx_0) / a_0 *
                                   (rtb_TmpSignalConversionAtOrbitFollowerInport2
                                    [0] / rtb_CastToDouble_l) + (a_tmp -
                                    rtb_Sum_n_tmp) / a_0 *
                                   (rtb_TmpSignalConversionAtOrbitFollowerInport2
                                    [1] / rtb_CastToDouble_l)) + (rtb_Sum1_k_tmp
                                - yout_idx_0) / a_0 *
                                (rtb_TmpSignalConversionAtOrbitFollowerInport2[2]
                                 / rtb_CastToDouble_l);
                            if (static_cast<boolean_T>(static_cast<int32_T>(
                                    static_cast<int32_T>(std::isnan(a_0)) ^ 1)))
                            {
                                if (a_0 < 0.0) {
                                    a_0 = -1.0;
                                } else {
                                    a_0 = static_cast<real_T>(a_0 > 0.0);
                                }
                            }

                            if (a_0 >= 0.0) {
                                guard2 = true;
                            } else {
                                rtb_TmpSignalConversionAtOrbitFollowerInport2[0]
                                    = rtb_Sum1_k_idx_0;
                                turnVector[0] = rtb_Sum1_k_idx_1;
                                rtb_TmpSignalConversionAtOrbitFollowerInport2[1]
                                    = rtb_Sum_n_tmp;
                                turnVector[1] = a_tmp;
                                rtb_TmpSignalConversionAtOrbitFollowerInport2[2]
                                    = yout_idx_0;
                                turnVector[2] = rtb_Sum1_k_tmp;
                            }
                        }

                        if (guard2) {
                            FlightMissionMode_DW.obj.WaypointIndex++;
                            rtb_Compare_em = false;
                            if (FlightMissionMode_DW.obj.WaypointIndex ==
                                    FlightMissionMode_DW.obj.NumWaypoints) {
                                rtb_Compare_em = true;
                            }

                            if (rtb_Compare_em) {
                                FlightMissionMode_DW.obj.LastWaypointFlag = true;
                                FlightMissionMode_DW.obj.WaypointIndex--;
                            }

                            rtb_TmpSignalConversionAtOrbitFollowerInport2[0] =
                                waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>
                                (FlightMissionMode_DW.obj.WaypointIndex) - 1)];
                            turnVector[0] = waypoints->data[static_cast<int32_T>
                                (static_cast<int32_T>
                                 (FlightMissionMode_DW.obj.WaypointIndex + 1.0)
                                 - 1)];
                            rtb_TmpSignalConversionAtOrbitFollowerInport2[1] =
                                waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>
                                (FlightMissionMode_DW.obj.WaypointIndex) +
                                waypoints->size[0]) - 1)];
                            turnVector[1] = waypoints->data[static_cast<int32_T>
                                (static_cast<int32_T>(static_cast<int32_T>
                                  (FlightMissionMode_DW.obj.WaypointIndex + 1.0)
                                  + waypoints->size[0]) - 1)];
                            rtb_TmpSignalConversionAtOrbitFollowerInport2[2] =
                                waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>
                                (waypoints->size[0] << 1) + static_cast<int32_T>
                                (FlightMissionMode_DW.obj.WaypointIndex)) - 1)];
                            turnVector[2] = waypoints->data[static_cast<int32_T>
                                (static_cast<int32_T>(static_cast<int32_T>
                                  (FlightMissionMode_DW.obj.WaypointIndex + 1.0)
                                  + static_cast<int32_T>(waypoints->size[0] << 1))
                                 - 1)];
                        }

                        rtb_LatitudeGCS_gv = turnVector[0] -
                            rtb_TmpSignalConversionAtOrbitFollowerInport2[0];
                        rtb_Sum_id = rtu_Pose[0] -
                            rtb_TmpSignalConversionAtOrbitFollowerInport2[0];
                        rtb_Sum_n_tmp = turnVector[1] -
                            rtb_TmpSignalConversionAtOrbitFollowerInport2[1];
                        rtb_Sum1_k_idx_1 = rtu_Pose[1] -
                            rtb_TmpSignalConversionAtOrbitFollowerInport2[1];
                        yout_idx_0 = turnVector[2] -
                            rtb_TmpSignalConversionAtOrbitFollowerInport2[2];
                        a_tmp = rtu_Pose[2] -
                            rtb_TmpSignalConversionAtOrbitFollowerInport2[2];
                        a_0 = ((rtb_Sum1_k_idx_1 * rtb_Sum_n_tmp + rtb_Sum_id *
                                rtb_LatitudeGCS_gv) + a_tmp * yout_idx_0) /
                            ((rtb_Sum_n_tmp * rtb_Sum_n_tmp + rtb_LatitudeGCS_gv
                              * rtb_LatitudeGCS_gv) + yout_idx_0 * yout_idx_0);
                        if (a_0 < 0.0) {
                            u[0] = rtb_Sum_id;
                            u[1] = rtb_Sum1_k_idx_1;
                            u[2] = a_tmp;
                            rtb_CastToDouble_l = FlightMissionMode_norm_pv(u);
                        } else if (a_0 > 1.0) {
                            u[0] = rtu_Pose[0] - turnVector[0];
                            u[1] = rtu_Pose[1] - turnVector[1];
                            u[2] = rtu_Pose[2] - turnVector[2];
                            rtb_CastToDouble_l = FlightMissionMode_norm_pv(u);
                        } else {
                            u[0] = rtu_Pose[0] - (a_0 * rtb_LatitudeGCS_gv +
                                                  rtb_TmpSignalConversionAtOrbitFollowerInport2
                                                  [0]);
                            u[1] = rtu_Pose[1] - (a_0 * rtb_Sum_n_tmp +
                                                  rtb_TmpSignalConversionAtOrbitFollowerInport2
                                                  [1]);
                            u[2] = rtu_Pose[2] - (a_0 * yout_idx_0 +
                                                  rtb_TmpSignalConversionAtOrbitFollowerInport2
                                                  [2]);
                            rtb_CastToDouble_l = FlightMissionMode_norm_pv(u);
                        }

                        if (FlightMissionMode_DW.obj.LastWaypointFlag) {
                            a_0 = (((rtu_Pose[1] -
                                     rtb_TmpSignalConversionAtOrbitFollowerInport2
                                     [1]) * (turnVector[1] -
                                             rtb_TmpSignalConversionAtOrbitFollowerInport2
                                             [1]) + rtb_Sum_id *
                                    rtb_LatitudeGCS_gv) + (rtu_Pose[2] -
                                    rtb_TmpSignalConversionAtOrbitFollowerInport2
                                    [2]) * (turnVector[2] -
                                            rtb_TmpSignalConversionAtOrbitFollowerInport2
                                            [2])) / (((turnVector[0] -
                                rtb_TmpSignalConversionAtOrbitFollowerInport2[0])
                                * (turnVector[0] -
                                   rtb_TmpSignalConversionAtOrbitFollowerInport2[
                                   0]) + (turnVector[1] -
                                          rtb_TmpSignalConversionAtOrbitFollowerInport2
                                          [1]) * (turnVector[1] -
                                                  rtb_TmpSignalConversionAtOrbitFollowerInport2
                                                  [1])) + (turnVector[2] -
                                rtb_TmpSignalConversionAtOrbitFollowerInport2[2])
                                * (turnVector[2] -
                                   rtb_TmpSignalConversionAtOrbitFollowerInport2[
                                   2]));
                            u[0] = rtu_Pose[0] - (a_0 * rtb_LatitudeGCS_gv +
                                                  rtb_TmpSignalConversionAtOrbitFollowerInport2
                                                  [0]);
                            u[1] = rtu_Pose[1] - (a_0 * rtb_Sum_n_tmp +
                                                  rtb_TmpSignalConversionAtOrbitFollowerInport2
                                                  [1]);
                            u[2] = rtu_Pose[2] - (a_0 * yout_idx_0 +
                                                  rtb_TmpSignalConversionAtOrbitFollowerInport2
                                                  [2]);
                            rtb_CastToDouble_l = FlightMissionMode_norm_pv(u);
                        }

                        rtb_Sum1_k_idx_1 = std::abs(rtb_CastToDouble_l);
                        if (static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<boolean_T>(
                                static_cast<int32_T>(static_cast<int32_T>(std::
                                  isinf(rtb_Sum1_k_idx_1)) ^ 1))) & static_cast<
                                int32_T>(static_cast<boolean_T>
                                         (static_cast<int32_T>
                                          (static_cast<int32_T>(std::isnan
                                  (rtb_Sum1_k_idx_1)) ^ 1)))))) {
                            if (rtb_Sum1_k_idx_1 <= 2.2250738585072014E-308) {
                                a_0 = 4.94065645841247E-324;
                                rtb_Sum1_k_idx_1 = 4.94065645841247E-324;
                            } else {
                                frexp(rtb_Sum1_k_idx_1, &b_exponent);
                                a_0 = std::ldexp(1.0, static_cast<int32_T>
                                                 (b_exponent - 53));
                                frexp(rtb_Sum1_k_idx_1, &b_exponent_0);
                                rtb_Sum1_k_idx_1 = std::ldexp(1.0, static_cast<
                                    int32_T>(b_exponent_0 - 53));
                            }
                        } else {
                            a_0 = (rtNaN);
                            rtb_Sum1_k_idx_1 = (rtNaN);
                        }

                        if (FlightMissionMode_DW.obj.LookaheadDistance <= std::
                                fmax(std::sqrt(a_0), 5.0 * rtb_Sum1_k_idx_1) +
                                rtb_CastToDouble_l) {
                            FlightMissionMode_DW.obj.LookaheadDistance =
                                FlightMissionMode_DW.obj.LookaheadFactor *
                                rtb_CastToDouble_l;
                        }

                        a_tmp = rtb_TmpSignalConversionAtOrbitFollowerInport2[0]
                            - rtu_Pose[0];
                        rtb_CastToDouble_l =
                            rtb_TmpSignalConversionAtOrbitFollowerInport2[1] -
                            rtu_Pose[1];
                        a_0 = ((turnVector[0] -
                                rtb_TmpSignalConversionAtOrbitFollowerInport2[0])
                               * (turnVector[0] -
                                  rtb_TmpSignalConversionAtOrbitFollowerInport2
                                  [0]) + (turnVector[1] -
                                          rtb_TmpSignalConversionAtOrbitFollowerInport2
                                          [1]) * (turnVector[1] -
                                rtb_TmpSignalConversionAtOrbitFollowerInport2[1]))
                            + (turnVector[2] -
                               rtb_TmpSignalConversionAtOrbitFollowerInport2[2])
                            * (turnVector[2] -
                               rtb_TmpSignalConversionAtOrbitFollowerInport2[2]);
                        rtb_Sum1_k_tmp =
                            rtb_TmpSignalConversionAtOrbitFollowerInport2[2] -
                            rtu_Pose[2];
                        rtb_Sum1_k_idx_1 = ((rtb_LatitudeGCS_gv * a_tmp +
                                             rtb_Sum_n_tmp * rtb_CastToDouble_l)
                                            + yout_idx_0 * rtb_Sum1_k_tmp) * 2.0;
                        rtb_CastToDouble_l = std::sqrt(rtb_Sum1_k_idx_1 *
                            rtb_Sum1_k_idx_1 - (((a_tmp * a_tmp +
                            rtb_CastToDouble_l * rtb_CastToDouble_l) +
                            rtb_Sum1_k_tmp * rtb_Sum1_k_tmp) -
                                                FlightMissionMode_DW.obj.LookaheadDistance
                                                * FlightMissionMode_DW.obj.LookaheadDistance)
                            * (4.0 * a_0));
                        a_0 = std::fmax((-rtb_Sum1_k_idx_1 + rtb_CastToDouble_l)
                                        / 2.0 / a_0, (-rtb_Sum1_k_idx_1 -
                                         rtb_CastToDouble_l) / 2.0 / a_0);
                        turnVector[2] = (1.0 - a_0) *
                            rtb_TmpSignalConversionAtOrbitFollowerInport2[2] +
                            a_0 * turnVector[2];

                        // SignalConversion generated from: '<S180>/Waypoint Follower' 
                        rtb_Cos_j = rt_atan2d_snf(((1.0 - a_0) *
                            rtb_TmpSignalConversionAtOrbitFollowerInport2[1] +
                            a_0 * turnVector[1]) - rtu_Pose[1], ((1.0 - a_0) *
                            rtb_TmpSignalConversionAtOrbitFollowerInport2[0] +
                            a_0 * turnVector[0]) - rtu_Pose[0]);

                        // SignalConversion generated from: '<S180>/Waypoint Follower' 
                        rtb_MergeStatus = 0U;
                        rtb_Compare_em = false;
                        if (FlightMissionMode_DW.obj.LastWaypointFlag) {
                            rtb_Compare_em = true;
                        }

                        if (rtb_Compare_em) {
                            // SignalConversion generated from: '<S180>/Waypoint Follower' 
                            rtb_MergeStatus = 1U;
                        }

                        FlightMissionMode_DW.obj.LastWaypointFlag = false;
                    }
                }

                // End of Outputs for SubSystem: '<S176>/StartFromFirst'
            }

            // End of SwitchCase: '<S176>/Switch Case'

            // DataTypeConversion: '<S176>/Cast To Double'
            *rty_thisTaskStatus = static_cast<real_T>(rtb_MergeStatus);

            // Gain: '<S177>/Gain1'
            rtb_Sum_id = 0.017453292519943295 * rtu_Location->degHDG;

            // Sum: '<S178>/Sum' incorporates:
            //   Gain: '<S176>/inverse'

            rtb_LatitudeGCS_gv = rtu_Location->Alt + -rtb_Abs1_n;

            // DataTypeConversion: '<S176>/Param4'
            rtb_Down2Up_c = static_cast<real_T>(rtu_Parameters->Param4);

            // BusCreator: '<S176>/GuidanceCMDBusCreator' incorporates:
            //   DataTypeConversion: '<S176>/Param4'
            //   Gain: '<S176>/Down2Height'

            rty_GuidanceCmds->Height = -turnVector[2];
            rty_GuidanceCmds->AirSpeed = static_cast<real_T>
                (rtu_Parameters->Param4);
            rty_GuidanceCmds->HeadingAngle = rtb_Cos_j;

            // DataStoreRead: '<S176>/LatitudeGCS'
            rtw_pthread_mutex_lock(LatitudeGCS_m0);
            rtb_Cos_j = LatitudeGCS;
            rtw_pthread_mutex_unlock(LatitudeGCS_m0);

            // DataStoreRead: '<S176>/LongitudeGCS'
            rtw_pthread_mutex_lock(LongitudeGCS_m0);
            rtb_Abs1_n = LongitudeGCS;
            rtw_pthread_mutex_unlock(LongitudeGCS_m0);

            // Sum: '<S178>/Sum1' incorporates:
            //   Sum: '<S183>/Sum'

            rtb_Sum1_k_idx_0 = rtu_Location->Lat - rtb_Cos_j;
            rtb_Sum1_k_idx_1 = rtu_Location->Lon - rtb_Abs1_n;

            // Switch: '<S189>/Switch' incorporates:
            //   Abs: '<S189>/Abs'
            //   Bias: '<S189>/Bias'
            //   Bias: '<S189>/Bias1'
            //   Constant: '<S189>/Constant2'
            //   Constant: '<S190>/Constant'
            //   Math: '<S189>/Math Function1'
            //   RelationalOperator: '<S190>/Compare'

            if (std::abs(rtb_Sum1_k_idx_0) > 180.0) {
                rtb_AltitudeGCS_dj = rt_modd_snf(rtb_Sum1_k_idx_0 + 180.0, 360.0)
                    + -180.0;
            } else {
                rtb_AltitudeGCS_dj = rtb_Sum1_k_idx_0;
            }

            // End of Switch: '<S189>/Switch'

            // Abs: '<S186>/Abs1'
            rtb_Abs1_n = std::abs(rtb_AltitudeGCS_dj);

            // Switch: '<S186>/Switch' incorporates:
            //   Bias: '<S186>/Bias'
            //   Bias: '<S186>/Bias1'
            //   Constant: '<S182>/Constant'
            //   Constant: '<S182>/Constant1'
            //   Constant: '<S188>/Constant'
            //   Gain: '<S186>/Gain'
            //   Product: '<S186>/Divide1'
            //   RelationalOperator: '<S188>/Compare'
            //   Switch: '<S182>/Switch1'

            if (rtb_Abs1_n > 90.0) {
                // Signum: '<S186>/Sign1'
                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>(std::isnan
                        (rtb_AltitudeGCS_dj)) ^ 1))) {
                    if (rtb_AltitudeGCS_dj < 0.0) {
                        rtb_AltitudeGCS_dj = -1.0;
                    } else {
                        rtb_AltitudeGCS_dj = static_cast<real_T>
                            (rtb_AltitudeGCS_dj > 0.0);
                    }
                }

                // End of Signum: '<S186>/Sign1'
                rtb_AltitudeGCS_dj *= -(rtb_Abs1_n + -90.0) + 90.0;
                i = 180;
            } else {
                i = 0;
            }

            // End of Switch: '<S186>/Switch'

            // Sum: '<S182>/Sum'
            rtb_Switch_lo = static_cast<real_T>(i) + rtb_Sum1_k_idx_1;

            // Switch: '<S187>/Switch' incorporates:
            //   Abs: '<S187>/Abs'
            //   Bias: '<S187>/Bias'
            //   Bias: '<S187>/Bias1'
            //   Constant: '<S187>/Constant2'
            //   Constant: '<S191>/Constant'
            //   Math: '<S187>/Math Function1'
            //   RelationalOperator: '<S191>/Compare'

            if (std::abs(rtb_Switch_lo) > 180.0) {
                rtb_Switch_lo = rt_modd_snf(rtb_Switch_lo + 180.0, 360.0) +
                    -180.0;
            }

            // End of Switch: '<S187>/Switch'

            // UnitConversion: '<S200>/Unit Conversion'
            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            rtb_Cos_j *= 0.017453292519943295;

            // Trigonometry: '<S201>/Trigonometric Function1'
            a_0 = std::sin(rtb_Cos_j);

            // Sum: '<S201>/Sum1' incorporates:
            //   Constant: '<S201>/Constant'
            //   Product: '<S201>/Product1'

            a_0 = 1.0 - 0.0066943799901413295 * a_0 * a_0;

            // Product: '<S199>/Product1' incorporates:
            //   Constant: '<S199>/Constant1'
            //   Sqrt: '<S199>/sqrt'

            rtb_Sum1_k_idx_1 = 6.378137E+6 / std::sqrt(a_0);

            // Product: '<S199>/Product4' incorporates:
            //   Trigonometry: '<S199>/Trigonometric Function'

            rtb_Cos_j = rtb_Sum1_k_idx_1 * std::cos(rtb_Cos_j);

            // Product: '<S184>/dNorth' incorporates:
            //   Constant: '<S199>/Constant2'
            //   Product: '<S199>/Product3'
            //   Trigonometry: '<S199>/Trigonometric Function1'
            //   UnitConversion: '<S185>/Unit Conversion'

            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            rtb_Sum1_k_idx_1 = 0.017453292519943295 * rtb_AltitudeGCS_dj /
                rt_atan2d_snf(1.0, rtb_Sum1_k_idx_1 * 0.99330562000985867 / a_0);

            // Product: '<S184>/dEast' incorporates:
            //   Constant: '<S199>/Constant3'
            //   Trigonometry: '<S199>/Trigonometric Function2'
            //   UnitConversion: '<S185>/Unit Conversion'

            a_0 = 1.0 / rt_atan2d_snf(1.0, rtb_Cos_j) * (0.017453292519943295 *
                rtb_Switch_lo);

            // Reshape: '<S176>/Reshape' incorporates:
            //   Constant: '<S176>/InitialFlightPathAngle'
            //   Constant: '<S176>/InitialRollAngle'
            //   Constant: '<S176>/InitialRollAngleRate'
            //   Product: '<S184>/x*cos'
            //   Product: '<S184>/x*sin'
            //   Product: '<S184>/y*cos'
            //   Product: '<S184>/y*sin'
            //   Sum: '<S184>/Sum2'
            //   Sum: '<S184>/Sum3'

            rty_InitialState[0] = a_0 * 0.0 + rtb_Sum1_k_idx_1;
            rty_InitialState[1] = a_0 - rtb_Sum1_k_idx_1 * 0.0;
            rty_InitialState[2] = rtb_LatitudeGCS_gv;
            rty_InitialState[3] = rtb_Down2Up_c;
            rty_InitialState[4] = rtb_Sum_id;
            rty_InitialState[5] = 0.0;
            rty_InitialState[6] = 0.0;
            rty_InitialState[7] = 0.0;

            // End of Outputs for SubSystem: '<Root>/Mode55_FrmnWayPoint'
        }
        break;

      default:
        // Outputs for IfAction SubSystem: '<Root>/Mode255_WaitToStart' incorporates:
        //   ActionPort: '<S2>/Action Port'

        // SignalConversion generated from: '<S2>/thisTaskStatus'
        *rty_thisTaskStatus = 0.0;

        // SignalConversion generated from: '<S2>/GuidanceCmds'
        *rty_GuidanceCmds = FlightMissionMode_rtZFixedWingGuidanceBus;

        // SignalConversion generated from: '<S2>/InitialState '
        std::memset(&rty_InitialState[0], 0, static_cast<uint32_T>(sizeof(real_T)
                     << 3U));

        // End of Outputs for SubSystem: '<Root>/Mode255_WaitToStart'
        break;
    }

    FlightMissionMode_emxFree_real_T_n(&b_waypointsIn);
    FlightMissionMode_emxFree_real_T_n(&waypoints);
    FlightMissionMode_emxFree_real_T_n(&dummyWayPoint);
    FlightMissionMode_emxFree_char_T_o(&r);
}

// Model initialize function
void FlightMissionMode::initialize()
{
    // Registration code

    // initialize non-finites
    rt_InitInfAndNaN(sizeof(real_T));
}

// Constructor
FlightMissionMode::FlightMissionMode() :
    FlightMissionMode_DW(),
    self_RotateATRunWayHdg_k(),
    self_RotateATMissionHdg_k(),
    self_RotateUpward(),
    self_RotateATRunWayHdg(),
    self_RotateATMissionHdg_m(),
    self_RotateATMissionHdg(),
    FlightMissionMode_M()
{
    // Currently there is no constructor body generated.
}

// Destructor
FlightMissionMode::~FlightMissionMode()
{
    // Currently there is no destructor body generated.
}

// Real-Time Model get method
FlightMissionMode::RT_MODEL_FlightMissionMode_T * FlightMissionMode::getRTM()
{
    return (&FlightMissionMode_M);
}

// member function to setup error status pointer
void FlightMissionMode::setErrorStatusPointer(const char_T **rt_errorStatus)
{
    rtmSetErrorStatusPointer((&FlightMissionMode_M), rt_errorStatus);
}

//
// File trailer for generated code.
//
// [EOF]
//
