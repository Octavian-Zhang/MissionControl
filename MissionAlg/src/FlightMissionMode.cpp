//
// File: FlightMissionMode.cpp
//
// Code generated for Simulink model 'FlightMissionMode'.
//
// Model version                  : 4.33
// Simulink Coder version         : 9.8 (R2022b) 13-May-2022
// C/C++ source code generated on : Mon Nov 21 19:24:11 2022
//
// Target selection: ert.tlc
// Embedded hardware selection: ARM Compatible->ARM 64-bit (LLP64)
// Code generation objectives:
//    1. Safety precaution
//    2. Execution efficiency
//    3. RAM efficiency
//    4. ROM efficiency
// Validation result: Not run
//
#include "FlightMissionMode.h"
#include "rtwtypes.h"
#include "FlightMissionMode_types.h"
#include "MissionModes.h"
#include "DatalinkInterface.h"
#include <stdio.h>
#include <cmath>
#include <cstring>
#include "rt_atan2d_snf.h"
#include <stddef.h>
#include "sum_ftQQGuCy.h"
#include "mod_Cteiw4Qy.h"
#include "wrapToPi_8g8Yma1S.h"
#include <cstdlib>
#include "rt_modd_snf.h"
#include "rt_remd_snf.h"
#include "rt_invd3x3_snf.h"
#include "rt_mldivided3x3_snf.h"
#include "rt_mrdivide_U1d128x3_U2d3x3_Yd128x3_snf.h"
#include "rt_mrdivide_U1d1x3_U2d3x3_Yd1x3_snf.h"
#include "rt_mrdivide_U1d8192x3_U2d3x3_Yd8192x3_snf.h"
#include "FlightMissionMode_private.h"
#include "div_s32.h"

extern "C"
{

#include "rt_nonfinite.h"

}

// Named constants for Chart: '<S76>/Chart'
const uint8_T FlightMissionMode_IN_Bottom{ 1U };

const uint8_T FlightMissionMode_IN_Init{ 1U };

const uint8_T FlightMissionMode_IN_Left{ 2U };

const uint8_T FlightMissionMode_IN_NO_ACTIVE_CHILD{ 0U };

const uint8_T FlightMissionMode_IN_Right{ 3U };

const uint8_T FlightMissionMode_IN_Running{ 2U };

const uint8_T FlightMissionMode_IN_Top{ 4U };

// Named constants for Chart: '<Root>/PreemptableMissionModeSelector'
const uint8_T FlightMissionMode_IN_FlightMission{ 1U };

const uint8_T FlightMissionMode_IN_WaitToStart{ 2U };

const FixedWingGuidanceBus FlightMissionMode_rtZFixedWingGuidanceBus{
    0.0,                               // Height
    0.0,                               // AirSpeed
    0.0                                // HeadingAngle
};                                     // FixedWingGuidanceBus ground

// Forward declaration for local functions
static real_T FlightMissionMode_norm(const real_T x[3]);

// Forward declaration for local functions
static void FlightMissionMode_emxInit_char_T(emxArray_char_T_FlightMissionMode_T
    **pEmxArray, int32_T numDimensions);
static int8_T FlightMissionMode_filedata
    (DW_StartPointGenerator_FlightMissionMode_T *localDW);
static int8_T FlightMissionMode_cfopen(const char_T *cfilename, const char_T
    *cpermission, DW_StartPointGenerator_FlightMissionMode_T *localDW);
static real_T FlightMissionMode_fileManager
    (DW_StartPointGenerator_FlightMissionMode_T *localDW);
static void FlightMissionMode_emxEnsureCapacity_char_T
    (emxArray_char_T_FlightMissionMode_T *emxArray, int32_T oldNumel);
static void FlightMissionMode_fread(real_T fileID,
    emxArray_char_T_FlightMissionMode_T *A,
    DW_StartPointGenerator_FlightMissionMode_T *localDW);
static void FlightMissionMode_copysign(emxArray_char_T_FlightMissionMode_T *s1,
    int32_T *idx, const emxArray_char_T_FlightMissionMode_T *s, int32_T *k,
    int32_T n, boolean_T *foundsign, boolean_T *success);
static boolean_T FlightMissionMode_isUnitImag(const
    emxArray_char_T_FlightMissionMode_T *s, int32_T k, int32_T n);
static void FlightMissionMode_readNonFinite(const
    emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n, boolean_T
    *b_finite, real_T *fv);
static boolean_T FlightMissionMode_copydigits
    (emxArray_char_T_FlightMissionMode_T *s1, int32_T *idx, const
     emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n, boolean_T
     allowpoint);
static boolean_T FlightMissionMode_copyexponent
    (emxArray_char_T_FlightMissionMode_T *s1, int32_T *idx, const
     emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n);
static void FlightMissionMode_readfloat(emxArray_char_T_FlightMissionMode_T *s1,
    int32_T *idx, const emxArray_char_T_FlightMissionMode_T *s, int32_T *k,
    int32_T n, boolean_T *isimag, boolean_T *b_finite, real_T *nfv, boolean_T
    *foundsign, boolean_T *success);
static void FlightMissionMode_emxFree_char_T(emxArray_char_T_FlightMissionMode_T
    **pEmxArray);
static creal_T FlightMissionMode_str2double(const
    emxArray_char_T_FlightMissionMode_T *s);
static int32_T FlightMissionMode_cfclose(real_T fid,
    DW_StartPointGenerator_FlightMissionMode_T *localDW);
static void FlightMissionMode_strtok(const emxArray_char_T_FlightMissionMode_T
    *x, emxArray_char_T_FlightMissionMode_T *token,
    emxArray_char_T_FlightMissionMode_T *remain);
static void FlightMissionMode_strtok_j(const emxArray_char_T_FlightMissionMode_T
    *x, emxArray_char_T_FlightMissionMode_T *token);
static void FlightMissionMode_strtrim(const emxArray_char_T_FlightMissionMode_T *
    x, emxArray_char_T_FlightMissionMode_T *y);
static boolean_T FlightMissionMode_strcmp(const
    emxArray_char_T_FlightMissionMode_T *a);
static boolean_T FlightMissionMode_strcmp_f(const
    emxArray_char_T_FlightMissionMode_T *a);
static boolean_T FlightMissionMode_contains(const
    emxArray_char_T_FlightMissionMode_T *str);
static void FlightMissionMode_find_token(const
    emxArray_char_T_FlightMissionMode_T *x, int32_T *itoken, int32_T *iremain);
static void FlightMissionMode_strtok_jy(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token, emxArray_char_T_FlightMissionMode_T *remain);
static void FlightMissionMode_strtok_jyq(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token);
static boolean_T FlightMissionMode_strcmp_f4(const
    emxArray_char_T_FlightMissionMode_T *a);
static void FlightMissionMode_readINI(emxArray_char_T_FlightMissionMode_T *ret,
    DW_StartPointGenerator_FlightMissionMode_T *localDW);
static void FlightMissionMode_readINI_k(emxArray_char_T_FlightMissionMode_T *ret,
    DW_StartPointGenerator_FlightMissionMode_T *localDW);
static boolean_T FlightMissionMode_strcmp_f4p(const
    emxArray_char_T_FlightMissionMode_T *a);
static boolean_T FlightMissionMode_strcmp_f4pn(const
    emxArray_char_T_FlightMissionMode_T *a);
static uavDubinsConnection_FlightMissionMode_T
    *FlightMissionMode_uavDubinsConnection_uavDubinsConnection
    (uavDubinsConnection_FlightMissionMode_T *b_this, real_T varargin_2, real_T
     varargin_4, const real_T varargin_6[2]);
static uavDubinsConnection_FlightMissionMode_T
    *FlightMissionMode_DubinsObjSingleton_getConnector
    (DW_StartPointGenerator_FlightMissionMode_T *localDW);
static void* FlightMissionMode_uavDubinsBuildable_uavDubinsBuildable(real_T
    airSpeed, real_T maxRollAngle, const real_T flightPathAngle[2]);
static boolean_T FlightMissionMode_strcmp_f4pnp(const char_T a_data[], const
    int32_T a_size[2]);
static boolean_T FlightMissionMode_strcmp_f4pnpw(const char_T a_data[], const
    int32_T a_size[2]);
static void FlightMissionMode_uavDubinsPathSegment_uavDubinsPathSegment_c(const
    real_T varargin_1[4], const real_T varargin_2[4], real_T varargin_3, real_T
    varargin_4, real_T varargin_5, real_T varargin_6, const
    cell_wrap_0_FlightMissionMode_T varargin_7[4], const real_T varargin_8[4],
    uavDubinsPathSegment_FlightMissionMode_T *b_this);
static void FlightMissionMode_uavDubinsBuiltins_connect(const
    uavDubinsConnection_FlightMissionMode_T *obj, const real_T startPose[4],
    const real_T goalPose[4], real_T turningRadius,
    uavDubinsPathSegment_FlightMissionMode_T *pathSegObjs, real_T *pathCosts);
static void FlightMissionMode_emxInit_real_T(emxArray_real_T_FlightMissionMode_T
    **pEmxArray, int32_T numDimensions);
static void FlightMissionMode_strcmp_f4pnpw5(const
    cell_wrap_0_FlightMissionMode_T a[4], boolean_T b_bool[4]);
static boolean_T FlightMissionMode_any(const boolean_T x[4]);
static void FlightMissionMode_useConstantDim(real_T varargin_2_data[], const
    int32_T varargin_2_size[2]);
static void FlightMissionMode_emxFree_real_T(emxArray_real_T_FlightMissionMode_T
    **pEmxArray);
static void FlightMissionMode_eml_find(boolean_T x, int32_T i_data[], int32_T
    i_size[2]);
static void FlightMissionMode_emxEnsureCapacity_real_T
    (emxArray_real_T_FlightMissionMode_T *emxArray, int32_T oldNumel);
static boolean_T FlightMissionMode_strcmp_f4pnpw5g(const char_T a_data[], const
    int32_T a_size[2]);
static boolean_T FlightMissionMode_strcmp_f4pnpw5g3(const char_T a_data[], const
    int32_T a_size[2]);
static void FlightMissionMode_emxInit_boolean_T
    (emxArray_boolean_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions);
static void FlightMissionMode_emxEnsureCapacity_boolean_T
    (emxArray_boolean_T_FlightMissionMode_T *emxArray, int32_T oldNumel);
static void FlightMissionMode_emxFree_boolean_T
    (emxArray_boolean_T_FlightMissionMode_T **pEmxArray);
static void FlightMissionMode_binary_expand_op
    (emxArray_boolean_T_FlightMissionMode_T *in1, const
     emxArray_real_T_FlightMissionMode_T *in2, const
     emxArray_real_T_FlightMissionMode_T *in3);
static void FlightMissionMode_wrapToPi(emxArray_real_T_FlightMissionMode_T
    *theta);
static boolean_T FlightMissionMode_strcmp_f4pnpw5g32(const char_T a_data[],
    const int32_T a_size[2]);
static boolean_T FlightMissionMode_strcmp_f4pnpw5g325(const char_T a_data[],
    const int32_T a_size[2]);
static boolean_T FlightMissionMode_strcmp_f4pnpw5g325b(const char_T a_data[],
    const int32_T a_size[2]);
static boolean_T FlightMissionMode_strcmp_f4pnpw5g325bz(const char_T a_data[],
    const int32_T a_size[2]);
static void FlightMissionMode_mtimes(const emxArray_real_T_FlightMissionMode_T
    *A, const real_T B[4], emxArray_real_T_FlightMissionMode_T *C);
static void FlightMissionMode_uavDubinsPathSegment_interpolate(const real_T
    b_this_StartPose[4], const real_T b_this_GoalPose[4], real_T
    b_this_FlightPathAngle, real_T b_this_AirSpeed, real_T
    b_this_MinTurningRadius, real_T b_this_HelixRadius, const
    cell_wrap_0_FlightMissionMode_T b_this_MotionTypes[4], const real_T
    b_this_MotionLengths[4], real_T b_this_Length, real_T samples, real_T
    poses_data[], int32_T poses_size[2]);
static void FlightMissionMode_emxInit_int32_T
    (emxArray_int32_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions);
static void FlightMissionMode_emxEnsureCapacity_int32_T
    (emxArray_int32_T_FlightMissionMode_T *emxArray, int32_T oldNumel);
static void FlightMissionMode_emxFree_int32_T
    (emxArray_int32_T_FlightMissionMode_T **pEmxArray);
static void FlightMissionMode_merge(emxArray_int32_T_FlightMissionMode_T *idx,
    emxArray_real_T_FlightMissionMode_T *x, int32_T offset, int32_T np, int32_T
    nq, emxArray_int32_T_FlightMissionMode_T *iwork,
    emxArray_real_T_FlightMissionMode_T *xwork);
static void FlightMissionMode_merge_block(emxArray_int32_T_FlightMissionMode_T
    *idx, emxArray_real_T_FlightMissionMode_T *x, int32_T offset, int32_T n,
    int32_T preSortLevel, emxArray_int32_T_FlightMissionMode_T *iwork,
    emxArray_real_T_FlightMissionMode_T *xwork);
static void FlightMissionMode_sort(emxArray_real_T_FlightMissionMode_T *x);
static void FlightMissionMode_eml_find_j(const
    emxArray_boolean_T_FlightMissionMode_T *x,
    emxArray_int32_T_FlightMissionMode_T *i);
static void FlightMissionMode_uavDubinsPathSegment_interpolate_k(const real_T
    b_this_StartPose[4], const real_T b_this_GoalPose[4], real_T
    b_this_FlightPathAngle, real_T b_this_AirSpeed, real_T
    b_this_MinTurningRadius, real_T b_this_HelixRadius, const
    cell_wrap_0_FlightMissionMode_T b_this_MotionTypes[4], const real_T
    b_this_MotionLengths[4], real_T b_this_Length,
    emxArray_real_T_FlightMissionMode_T *samples,
    emxArray_real_T_FlightMissionMode_T *poses);
static void FlightMissionMode_genSegWP(const real_T start[4], const real_T ende
    [4], emxArray_real_T_FlightMissionMode_T *segWayPoints,
    DW_StartPointGenerator_FlightMissionMode_T *localDW);

// Forward declaration for local functions
static void FlightMissionMode_emxInit_char_T_b
    (emxArray_char_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions);
static int8_T FlightMissionMode_filedata_e
    (DW_WayPointGenerator_FlightMissionMode_T *localDW);
static int8_T FlightMissionMode_cfopen_j(const char_T *cfilename, const char_T
    *cpermission, DW_WayPointGenerator_FlightMissionMode_T *localDW);
static real_T FlightMissionMode_fileManager_o
    (DW_WayPointGenerator_FlightMissionMode_T *localDW);
static void FlightMissionMode_emxEnsureCapacity_char_T_o
    (emxArray_char_T_FlightMissionMode_T *emxArray, int32_T oldNumel);
static void FlightMissionMode_fread_b(real_T fileID,
    emxArray_char_T_FlightMissionMode_T *A,
    DW_WayPointGenerator_FlightMissionMode_T *localDW);
static void FlightMissionMode_copysign_l(emxArray_char_T_FlightMissionMode_T *s1,
    int32_T *idx, const emxArray_char_T_FlightMissionMode_T *s, int32_T *k,
    int32_T n, boolean_T *foundsign, boolean_T *success);
static boolean_T FlightMissionMode_isUnitImag_b(const
    emxArray_char_T_FlightMissionMode_T *s, int32_T k, int32_T n);
static void FlightMissionMode_readNonFinite_c(const
    emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n, boolean_T
    *b_finite, real_T *fv);
static boolean_T FlightMissionMode_copydigits_a
    (emxArray_char_T_FlightMissionMode_T *s1, int32_T *idx, const
     emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n, boolean_T
     allowpoint);
static boolean_T FlightMissionMode_copyexponent_m
    (emxArray_char_T_FlightMissionMode_T *s1, int32_T *idx, const
     emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n);
static void FlightMissionMode_readfloat_m(emxArray_char_T_FlightMissionMode_T
    *s1, int32_T *idx, const emxArray_char_T_FlightMissionMode_T *s, int32_T *k,
    int32_T n, boolean_T *isimag, boolean_T *b_finite, real_T *nfv, boolean_T
    *foundsign, boolean_T *success);
static void FlightMissionMode_emxFree_char_T_d
    (emxArray_char_T_FlightMissionMode_T **pEmxArray);
static creal_T FlightMissionMode_str2double_h(const
    emxArray_char_T_FlightMissionMode_T *s);
static int32_T FlightMissionMode_cfclose_h(real_T fid,
    DW_WayPointGenerator_FlightMissionMode_T *localDW);
static void FlightMissionMode_strtok_a(const emxArray_char_T_FlightMissionMode_T
    *x, emxArray_char_T_FlightMissionMode_T *token,
    emxArray_char_T_FlightMissionMode_T *remain);
static void FlightMissionMode_strtok_ac(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token);
static void FlightMissionMode_strtrim_l(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    y);
static boolean_T FlightMissionMode_strcmp_c(const
    emxArray_char_T_FlightMissionMode_T *a);
static boolean_T FlightMissionMode_strcmp_co(const
    emxArray_char_T_FlightMissionMode_T *a);
static boolean_T FlightMissionMode_contains_g(const
    emxArray_char_T_FlightMissionMode_T *str);
static void FlightMissionMode_find_token_e(const
    emxArray_char_T_FlightMissionMode_T *x, int32_T *itoken, int32_T *iremain);
static void FlightMissionMode_strtok_acx(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token, emxArray_char_T_FlightMissionMode_T *remain);
static void FlightMissionMode_strtok_acxd(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token);
static boolean_T FlightMissionMode_strcmp_cog(const
    emxArray_char_T_FlightMissionMode_T *a);
static void FlightMissionMode_readINI_i(emxArray_char_T_FlightMissionMode_T *ret,
    DW_WayPointGenerator_FlightMissionMode_T *localDW);
static void FlightMissionMode_readINI_iy(emxArray_char_T_FlightMissionMode_T
    *ret, DW_WayPointGenerator_FlightMissionMode_T *localDW);
static boolean_T FlightMissionMode_strcmp_cogh(const
    emxArray_char_T_FlightMissionMode_T *a);
static boolean_T FlightMissionMode_strcmp_coghz(const
    emxArray_char_T_FlightMissionMode_T *a);
static uavDubinsConnection_FlightMissionMode_g_T
    *FlightMissionMode_uavDubinsConnection_uavDubinsConnection_l
    (uavDubinsConnection_FlightMissionMode_g_T *b_this, real_T varargin_2,
     real_T varargin_4, const real_T varargin_6[2]);
static uavDubinsConnection_FlightMissionMode_g_T
    *FlightMissionMode_DubinsObjSingleton_getConnector_e
    (DW_WayPointGenerator_FlightMissionMode_T *localDW);
static void FlightMissionMode_emxInit_real_T_i
    (emxArray_real_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions);
static void* FlightMissionMode_uavDubinsBuildable_uavDubinsBuildable_d(real_T
    airSpeed, real_T maxRollAngle, const real_T flightPathAngle[2]);
static boolean_T FlightMissionMode_strcmp_coghzf(const char_T a_data[], const
    int32_T a_size[2]);
static boolean_T FlightMissionMode_strcmp_coghzfk(const char_T a_data[], const
    int32_T a_size[2]);
static void FlightMissionMode_uavDubinsPathSegment_uavDubinsPathSegment_gx(const
    real_T varargin_1[4], const real_T varargin_2[4], real_T varargin_3, real_T
    varargin_4, real_T varargin_5, real_T varargin_6, const
    cell_wrap_11_FlightMissionMode_T varargin_7[4], const real_T varargin_8[4],
    uavDubinsPathSegment_FlightMissionMode_c_T *b_this);
static void FlightMissionMode_uavDubinsBuiltins_connect_d(const
    uavDubinsConnection_FlightMissionMode_g_T *obj, const real_T startPose[4],
    const real_T goalPose[4], real_T turningRadius,
    uavDubinsPathSegment_FlightMissionMode_c_T *pathSegObjs, real_T *pathCosts);
static void FlightMissionMode_emxEnsureCapacity_real_T_a
    (emxArray_real_T_FlightMissionMode_T *emxArray, int32_T oldNumel);
static void FlightMissionMode_strcmp_coghzfkn(const
    cell_wrap_11_FlightMissionMode_T a[4], boolean_T b_bool[4]);
static boolean_T FlightMissionMode_any_h(const boolean_T x[4]);
static void FlightMissionMode_useConstantDim_l(real_T varargin_2_data[], const
    int32_T varargin_2_size[2]);
static void FlightMissionMode_emxInit_int32_T_j
    (emxArray_int32_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions);
static void FlightMissionMode_emxEnsureCapacity_int32_T_c
    (emxArray_int32_T_FlightMissionMode_T *emxArray, int32_T oldNumel);
static void FlightMissionMode_emxFree_real_T_c
    (emxArray_real_T_FlightMissionMode_T **pEmxArray);
static void FlightMissionMode_emxFree_int32_T_k
    (emxArray_int32_T_FlightMissionMode_T **pEmxArray);
static void FlightMissionMode_merge_n(emxArray_int32_T_FlightMissionMode_T *idx,
    emxArray_real_T_FlightMissionMode_T *x, int32_T offset, int32_T np, int32_T
    nq, emxArray_int32_T_FlightMissionMode_T *iwork,
    emxArray_real_T_FlightMissionMode_T *xwork);
static void FlightMissionMode_merge_block_o(emxArray_int32_T_FlightMissionMode_T
    *idx, emxArray_real_T_FlightMissionMode_T *x, int32_T offset, int32_T n,
    int32_T preSortLevel, emxArray_int32_T_FlightMissionMode_T *iwork,
    emxArray_real_T_FlightMissionMode_T *xwork);
static void FlightMissionMode_sort_d(emxArray_real_T_FlightMissionMode_T *x);
static void FlightMissionMode_emxInit_boolean_T_k
    (emxArray_boolean_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions);
static void FlightMissionMode_emxFree_boolean_T_d
    (emxArray_boolean_T_FlightMissionMode_T **pEmxArray);
static void FlightMissionMode_emxEnsureCapacity_boolean_T_p
    (emxArray_boolean_T_FlightMissionMode_T *emxArray, int32_T oldNumel);
static void FlightMissionMode_binary_expand_op_h
    (emxArray_boolean_T_FlightMissionMode_T *in1, const
     emxArray_real_T_FlightMissionMode_T *in2, const
     emxArray_real_T_FlightMissionMode_T *in3);
static void FlightMissionMode_wrapToPi_i(emxArray_real_T_FlightMissionMode_T
    *theta);
static void FlightMissionMode_eml_find_g(const
    emxArray_boolean_T_FlightMissionMode_T *x,
    emxArray_int32_T_FlightMissionMode_T *i);
static boolean_T FlightMissionMode_strcmp_coghzfkn4(const char_T a_data[], const
    int32_T a_size[2]);
static boolean_T FlightMissionMode_strcmp_coghzfkn4y(const char_T a_data[],
    const int32_T a_size[2]);
static boolean_T FlightMissionMode_strcmp_coghzfkn4yb(const char_T a_data[],
    const int32_T a_size[2]);
static boolean_T FlightMissionMode_strcmp_coghzfkn4ybo(const char_T a_data[],
    const int32_T a_size[2]);
static boolean_T FlightMissionMode_strcmp_coghzfkn4ybo3(const char_T a_data[],
    const int32_T a_size[2]);
static boolean_T FlightMissionMode_strcmp_coghzfkn4ybo3s(const char_T a_data[],
    const int32_T a_size[2]);
static void FlightMissionMode_mtimes_p(const emxArray_real_T_FlightMissionMode_T
    *A, const real_T B[4], emxArray_real_T_FlightMissionMode_T *C);
static void FlightMissionMode_uavDubinsPathSegment_interpolate_h(const real_T
    b_this_StartPose[4], const real_T b_this_GoalPose[4], real_T
    b_this_FlightPathAngle, real_T b_this_AirSpeed, real_T
    b_this_MinTurningRadius, real_T b_this_HelixRadius, const
    cell_wrap_11_FlightMissionMode_T b_this_MotionTypes[4], const real_T
    b_this_MotionLengths[4], real_T b_this_Length,
    emxArray_real_T_FlightMissionMode_T *samples,
    emxArray_real_T_FlightMissionMode_T *poses);
static void FlightMissionMode_genSegWP_g(const real_T start[4], const real_T
    ende[4], emxArray_real_T_FlightMissionMode_T *segWayPoints,
    DW_WayPointGenerator_FlightMissionMode_T *localDW);

// Forward declaration for local functions
static void FlightMissionMode_emxInit_char_T_e
    (emxArray_char_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions);
static int8_T FlightMissionMode_filedata_j(DW_ReadHomePoint_FlightMissionMode_T *
    localDW);
static int8_T FlightMissionMode_cfopen_f(const char_T *cfilename, const char_T
    *cpermission, DW_ReadHomePoint_FlightMissionMode_T *localDW);
static void FlightMissionMode_emxEnsureCapacity_char_T_c
    (emxArray_char_T_FlightMissionMode_T *emxArray, int32_T oldNumel);
static void FlightMissionMode_fread_o(real_T fileID,
    emxArray_char_T_FlightMissionMode_T *A, DW_ReadHomePoint_FlightMissionMode_T
    *localDW);
static void FlightMissionMode_copysign_m(emxArray_char_T_FlightMissionMode_T *s1,
    int32_T *idx, const emxArray_char_T_FlightMissionMode_T *s, int32_T *k,
    int32_T n, boolean_T *foundsign, boolean_T *success);
static boolean_T FlightMissionMode_isUnitImag_j(const
    emxArray_char_T_FlightMissionMode_T *s, int32_T k, int32_T n);
static void FlightMissionMode_readNonFinite_m(const
    emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n, boolean_T
    *b_finite, real_T *fv);
static boolean_T FlightMissionMode_copydigits_e
    (emxArray_char_T_FlightMissionMode_T *s1, int32_T *idx, const
     emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n, boolean_T
     allowpoint);
static boolean_T FlightMissionMode_copyexponent_h
    (emxArray_char_T_FlightMissionMode_T *s1, int32_T *idx, const
     emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n);
static void FlightMissionMode_readfloat_n(emxArray_char_T_FlightMissionMode_T
    *s1, int32_T *idx, const emxArray_char_T_FlightMissionMode_T *s, int32_T *k,
    int32_T n, boolean_T *isimag, boolean_T *b_finite, real_T *nfv, boolean_T
    *foundsign, boolean_T *success);
static void FlightMissionMode_emxFree_char_T_f
    (emxArray_char_T_FlightMissionMode_T **pEmxArray);
static creal_T FlightMissionMode_str2double_a(const
    emxArray_char_T_FlightMissionMode_T *s);
static int32_T FlightMissionMode_cfclose_i(real_T fid,
    DW_ReadHomePoint_FlightMissionMode_T *localDW);
static void FlightMissionMode_strtok_m(const emxArray_char_T_FlightMissionMode_T
    *x, emxArray_char_T_FlightMissionMode_T *token,
    emxArray_char_T_FlightMissionMode_T *remain);
static void FlightMissionMode_strtok_mm(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token);
static void FlightMissionMode_strtrim_e(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    y);
static boolean_T FlightMissionMode_strcmp_j(const
    emxArray_char_T_FlightMissionMode_T *a);
static boolean_T FlightMissionMode_strcmp_j3(const
    emxArray_char_T_FlightMissionMode_T *a);
static boolean_T FlightMissionMode_contains_p(const
    emxArray_char_T_FlightMissionMode_T *str);
static void FlightMissionMode_find_token_f(const
    emxArray_char_T_FlightMissionMode_T *x, int32_T *itoken, int32_T *iremain);
static void FlightMissionMode_strtok_mmp(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token, emxArray_char_T_FlightMissionMode_T *remain);
static boolean_T FlightMissionMode_strcmp_j3x(const
    emxArray_char_T_FlightMissionMode_T *a);
static boolean_T FlightMissionMode_strcmp_j3xs(const
    emxArray_char_T_FlightMissionMode_T *a);

// Forward declaration for local functions
static void FlightMissionMode_emxInit_char_T_ey
    (emxArray_char_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions);
static void FlightMissionMode_emxInit_real_T_h
    (emxArray_real_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions);
static void FlightMissionMode_emxFree_real_T_n
    (emxArray_real_T_FlightMissionMode_T **pEmxArray);
static void FlightMissionMode_emxFree_char_T_o
    (emxArray_char_T_FlightMissionMode_T **pEmxArray);
static int8_T FlightMissionMode_filedata_o(DW_FlightMissionMode_f_T *localDW);
static int8_T FlightMissionMode_cfopen_e(const char_T *cfilename, const char_T
    *cpermission, DW_FlightMissionMode_f_T *localDW);
static int8_T FlightMissionMode_filedata_m(DW_FlightMissionMode_f_T *localDW);
static int8_T FlightMissionMode_cfopen_d(const char_T *cfilename, const char_T
    *cpermission, DW_FlightMissionMode_f_T *localDW);
static int8_T FlightMissionMode_filedata_d(DW_FlightMissionMode_f_T *localDW);
static int8_T FlightMissionMode_cfopen_du(const char_T *cfilename, const char_T *
    cpermission, DW_FlightMissionMode_f_T *localDW);
static void FlightMissionMode_string_string(real_T val, char_T obj_Value_data[],
    int32_T obj_Value_size[2]);
static void FlightMissionMode_emxEnsureCapacity_char_T_g
    (emxArray_char_T_FlightMissionMode_T *emxArray, int32_T oldNumel);
static void FlightMissionMode_fread_h(real_T fileID,
    emxArray_char_T_FlightMissionMode_T *A, DW_FlightMissionMode_f_T *localDW);
static void FlightMissionMode_fread_ow(real_T fileID,
    emxArray_char_T_FlightMissionMode_T *A, DW_FlightMissionMode_f_T *localDW);
static void FlightMissionMode_fread_j(real_T fileID,
    emxArray_char_T_FlightMissionMode_T *A, DW_FlightMissionMode_f_T *localDW);
static void FlightMissionMode_copysign_j(emxArray_char_T_FlightMissionMode_T *s1,
    int32_T *idx, const emxArray_char_T_FlightMissionMode_T *s, int32_T *k,
    int32_T n, boolean_T *foundsign, boolean_T *success);
static boolean_T FlightMissionMode_isUnitImag_l(const
    emxArray_char_T_FlightMissionMode_T *s, int32_T k, int32_T n);
static void FlightMissionMode_readNonFinite_b(const
    emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n, boolean_T
    *b_finite, real_T *fv);
static boolean_T FlightMissionMode_copydigits_h
    (emxArray_char_T_FlightMissionMode_T *s1, int32_T *idx, const
     emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n, boolean_T
     allowpoint);
static boolean_T FlightMissionMode_copyexponent_f
    (emxArray_char_T_FlightMissionMode_T *s1, int32_T *idx, const
     emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n);
static void FlightMissionMode_readfloat_n0(emxArray_char_T_FlightMissionMode_T
    *s1, int32_T *idx, const emxArray_char_T_FlightMissionMode_T *s, int32_T *k,
    int32_T n, boolean_T *isimag, boolean_T *b_finite, real_T *nfv, boolean_T
    *foundsign, boolean_T *success);
static creal_T FlightMissionMode_str2double_k(const
    emxArray_char_T_FlightMissionMode_T *s);
static int32_T FlightMissionMode_cfclose_n(real_T fid, DW_FlightMissionMode_f_T *
    localDW);
static int32_T FlightMissionMode_cfclose_a(real_T fid, DW_FlightMissionMode_f_T *
    localDW);
static int32_T FlightMissionMode_cfclose_d(real_T fid, DW_FlightMissionMode_f_T *
    localDW);
static int8_T FlightMissionMode_filedata_i(DW_FlightMissionMode_f_T *localDW);
static int8_T FlightMissionMode_cfopen_h(const char_T cfilename_data[], const
    int32_T cfilename_size[2], const char_T *cpermission,
    DW_FlightMissionMode_f_T *localDW);
static int8_T FlightMissionMode_filedata_g(DW_FlightMissionMode_f_T *localDW);
static int8_T FlightMissionMode_cfopen_c(const char_T *cfilename, const char_T
    *cpermission, DW_FlightMissionMode_f_T *localDW);
static void FlightMissionMode_fread_hc(real_T fileID,
    emxArray_char_T_FlightMissionMode_T *A, DW_FlightMissionMode_f_T *localDW);
static int32_T FlightMissionMode_cfclose_k(real_T fid, DW_FlightMissionMode_f_T *
    localDW);
static int32_T FlightMissionMode_cfclose_h5(real_T fid, DW_FlightMissionMode_f_T
    *localDW);
static void FlightMissionMode_emxEnsureCapacity_real_T_c
    (emxArray_real_T_FlightMissionMode_T *emxArray, int32_T oldNumel);
static void FlightMissionMode_strtok_d(const emxArray_char_T_FlightMissionMode_T
    *x, emxArray_char_T_FlightMissionMode_T *token,
    emxArray_char_T_FlightMissionMode_T *remain);
static void FlightMissionMode_strtok_dq(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token);
static FILE* FlightMissionMode_fileManager_b(real_T varargin_1,
    DW_FlightMissionMode_f_T *localDW);
static void FlightMissionMode_fgetl(real_T fileID,
    emxArray_char_T_FlightMissionMode_T *out, DW_FlightMissionMode_f_T *localDW);
static void FlightMissionMode_strtrim_f(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    y);
static boolean_T FlightMissionMode_strcmp_b(const
    emxArray_char_T_FlightMissionMode_T *a);
static boolean_T FlightMissionMode_strcmp_bx(const
    emxArray_char_T_FlightMissionMode_T *a);
static boolean_T FlightMissionMode_contains_d(const
    emxArray_char_T_FlightMissionMode_T *str);
static void FlightMissionMode_find_token_m(const
    emxArray_char_T_FlightMissionMode_T *x, int32_T *itoken, int32_T *iremain);
static void FlightMissionMode_strtok_dq4(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token, emxArray_char_T_FlightMissionMode_T *remain);
static boolean_T FlightMissionMode_strcmp_bxk(const
    emxArray_char_T_FlightMissionMode_T *a);
static real_T FlightMissionMode_norm_p(const real_T x[2]);
static void FlightMissionMode_circshift(real_T a_data[], const int32_T a_size[2],
    real_T p);
static boolean_T FlightMissionMode_strcmp_bxki(const
    emxArray_char_T_FlightMissionMode_T *a);
static void FlightMissionMode_sind(real_T x_data[], const int32_T *x_size);
static void FlightMissionMode_cosd(real_T x_data[], const int32_T *x_size);
static void FlightMissionMode_binary_expand_op_puhaq(real_T in1_data[], int32_T *
    in1_size, const real_T in2_data[], const int32_T *in2_size, const real_T
    in3_data[], const int32_T in3_size[2], DW_FlightMissionMode_f_T *localDW);
static void FlightMissionMode_binary_expand_op_puha(real_T in1_data[], int32_T
    in1_size[2], const real_T in2_data[], const int32_T *in2_size, const real_T
    in3_data[], const int32_T *in3_size, const real_T in4_data[], const int32_T *
    in4_size, const real_T in5_data[], const int32_T *in5_size, const real_T
    in6_data[], const int32_T in6_size[2], const real_T in7_data[], const
    int32_T *in7_size, DW_FlightMissionMode_f_T *localDW);
static void FlightMissionMode_lla2ecef(const real_T llaPos_data[], const int32_T
    llaPos_size[2], real_T ecefPos_data[], int32_T ecefPos_size[2],
    DW_FlightMissionMode_f_T *localDW);
static void FlightMissionMode_minus_l(real_T in1_data[], int32_T in1_size[2],
    const real_T in2_data[], const int32_T in2_size[2], DW_FlightMissionMode_f_T
    *localDW);
static void FlightMissionMode_binary_expand_op_puh(real_T in1_data[], int32_T
    *in1_size, const real_T in2_data[], const int32_T *in2_size, const real_T
    in3_data[], const int32_T in3_size[2], const real_T in4_data[], const
    int32_T *in4_size);
static void FlightMissionMode_binary_expand_op_pu(real_T in1_data[], int32_T
    in1_size[2], const real_T in2_data[], const int32_T *in2_size, const real_T
    in3_data[], const int32_T in3_size[2], const real_T in4_data[], const
    int32_T *in4_size, const real_T in5_data[], const int32_T *in5_size, const
    real_T in6_data[], const int32_T *in6_size, const real_T in7_data[], const
    int32_T *in7_size, DW_FlightMissionMode_f_T *localDW);
static void FlightMissionMode_lla2ned(const real_T lla_data[], const int32_T
    lla_size[2], const real_T lla0[3], real_T xyzNED_data[], int32_T
    xyzNED_size[2], DW_FlightMissionMode_f_T *localDW);
static real_T FlightMissionMode_norm_pv(const real_T x[3]);
static void FlightMissionMode_WaypointFollowerBase_searchClosestPath
    (uav_sluav_internal_system_WaypointFollower_FlightMissionMode_cc_T *obj,
     const emxArray_real_T_FlightMissionMode_T *waypoints, const real_T
     currentPose[4]);
static int8_T FlightMissionMode_filedata_ei(DW_FlightMissionMode_f_T *localDW);
static int8_T FlightMissionMode_cfopen_j0(const char_T *cfilename, const char_T *
    cpermission, DW_FlightMissionMode_f_T *localDW);
static real_T FlightMissionMode_fileManager_f(DW_FlightMissionMode_f_T *localDW);
static void FlightMissionMode_fread_n(real_T fileID,
    emxArray_char_T_FlightMissionMode_T *A, DW_FlightMissionMode_f_T *localDW);
static int32_T FlightMissionMode_cfclose_p(real_T fid, DW_FlightMissionMode_f_T *
    localDW);
static boolean_T FlightMissionMode_strcmp_h(const
    emxArray_char_T_FlightMissionMode_T *a);
static boolean_T FlightMissionMode_strcmp_hb(const
    emxArray_char_T_FlightMissionMode_T *a);
static void FlightMissionMode_strtok_otld(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token);
static boolean_T FlightMissionMode_strcmp_hbq(const
    emxArray_char_T_FlightMissionMode_T *a);
static void FlightMissionMode_readINI_e(emxArray_char_T_FlightMissionMode_T *ret,
    DW_FlightMissionMode_f_T *localDW);
static void FlightMissionMode_readINI_ew(emxArray_char_T_FlightMissionMode_T
    *ret, DW_FlightMissionMode_f_T *localDW);
static boolean_T FlightMissionMode_strcmp_hbqn(const
    emxArray_char_T_FlightMissionMode_T *a);
static boolean_T FlightMissionMode_strcmp_hbqnf(const
    emxArray_char_T_FlightMissionMode_T *a);
static uavDubinsConnection_FlightMissionMode_T
    *FlightMissionMode_uavDubinsConnection_uavDubinsConnection_lg
    (uavDubinsConnection_FlightMissionMode_T *b_this, real_T varargin_2, real_T
     varargin_4, const real_T varargin_6[2]);
static uavDubinsConnection_FlightMissionMode_T
    *FlightMissionMode_DubinsObjSingleton_getConnector_p
    (DW_FlightMissionMode_f_T *localDW);
static void* FlightMissionMode_uavDubinsBuildable_uavDubinsBuildable_j(real_T
    airSpeed, real_T maxRollAngle, const real_T flightPathAngle[2]);
static boolean_T FlightMissionMode_strcmp_hbqnfp(const char_T a_data[], const
    int32_T a_size[2]);
static boolean_T FlightMissionMode_strcmp_hbqnfps(const char_T a_data[], const
    int32_T a_size[2]);
static void FlightMissionMode_uavDubinsPathSegment_uavDubinsPathSegment_hw(const
    real_T varargin_1[4], const real_T varargin_2[4], real_T varargin_3, real_T
    varargin_4, real_T varargin_5, real_T varargin_6, const
    cell_wrap_0_FlightMissionMode_T varargin_7[4], const real_T varargin_8[4],
    uavDubinsPathSegment_FlightMissionMode_T *b_this);
static void FlightMissionMode_uavDubinsBuiltins_connect_g(const
    uavDubinsConnection_FlightMissionMode_T *obj, const real_T startPose[4],
    const real_T goalPose[4], real_T turningRadius,
    uavDubinsPathSegment_FlightMissionMode_T *pathSegObjs, real_T *pathCosts);
static real_T FlightMissionMode_angdiff(real_T x, real_T y);
static void FlightMissionMode_eml_float_colon(real_T d, real_T b,
    emxArray_real_T_FlightMissionMode_T *y);
static void FlightMissionMode_strcmp_hbqnfpsg(const
    cell_wrap_0_FlightMissionMode_T a[4], boolean_T b_bool[4]);
static boolean_T FlightMissionMode_any_i(const boolean_T x[4]);
static void FlightMissionMode_useConstantDim_i(real_T varargin_2_data[], const
    int32_T varargin_2_size[2]);
static void FlightMissionMode_emxInit_int32_T_k
    (emxArray_int32_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions);
static void FlightMissionMode_emxEnsureCapacity_int32_T_j
    (emxArray_int32_T_FlightMissionMode_T *emxArray, int32_T oldNumel);
static void FlightMissionMode_emxFree_int32_T_a
    (emxArray_int32_T_FlightMissionMode_T **pEmxArray);
static void FlightMissionMode_merge_h(emxArray_int32_T_FlightMissionMode_T *idx,
    emxArray_real_T_FlightMissionMode_T *x, int32_T offset, int32_T np, int32_T
    nq, emxArray_int32_T_FlightMissionMode_T *iwork,
    emxArray_real_T_FlightMissionMode_T *xwork);
static void FlightMissionMode_merge_block_d(emxArray_int32_T_FlightMissionMode_T
    *idx, emxArray_real_T_FlightMissionMode_T *x, int32_T offset, int32_T n,
    int32_T preSortLevel, emxArray_int32_T_FlightMissionMode_T *iwork,
    emxArray_real_T_FlightMissionMode_T *xwork);
static void FlightMissionMode_sort_o(emxArray_real_T_FlightMissionMode_T *x);
static void FlightMissionMode_emxInit_boolean_T_c
    (emxArray_boolean_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions);
static void FlightMissionMode_emxFree_boolean_T_n
    (emxArray_boolean_T_FlightMissionMode_T **pEmxArray);
static void FlightMissionMode_emxEnsureCapacity_boolean_T_f
    (emxArray_boolean_T_FlightMissionMode_T *emxArray, int32_T oldNumel);
static void FlightMissionMode_binary_expand_op_p
    (emxArray_boolean_T_FlightMissionMode_T *in1, const
     emxArray_real_T_FlightMissionMode_T *in2, const
     emxArray_real_T_FlightMissionMode_T *in3);
static void FlightMissionMode_wrapToPi_n(emxArray_real_T_FlightMissionMode_T
    *theta);
static void FlightMissionMode_eml_find_m(const
    emxArray_boolean_T_FlightMissionMode_T *x,
    emxArray_int32_T_FlightMissionMode_T *i);
static boolean_T FlightMissionMode_strcmp_hbqnfpsg1(const char_T a_data[], const
    int32_T a_size[2]);
static boolean_T FlightMissionMode_strcmp_hbqnfpsg15(const char_T a_data[],
    const int32_T a_size[2]);
static boolean_T FlightMissionMode_strcmp_hbqnfpsg15d(const char_T a_data[],
    const int32_T a_size[2]);
static boolean_T FlightMissionMode_strcmp_hbqnfpsg15dl(const char_T a_data[],
    const int32_T a_size[2]);
static boolean_T FlightMissionMode_strcmp_hbqnfpsg15dly(const char_T a_data[],
    const int32_T a_size[2]);
static boolean_T FlightMissionMode_strcmp_hbqnfpsg15dlyq(const char_T a_data[],
    const int32_T a_size[2]);
static void FlightMissionMode_mtimes_g(const emxArray_real_T_FlightMissionMode_T
    *A, const real_T B[4], emxArray_real_T_FlightMissionMode_T *C);
static void FlightMissionMode_uavDubinsPathSegment_interpolate_b(const real_T
    b_this_StartPose[4], const real_T b_this_GoalPose[4], real_T
    b_this_FlightPathAngle, real_T b_this_AirSpeed, real_T
    b_this_MinTurningRadius, real_T b_this_HelixRadius, const
    cell_wrap_0_FlightMissionMode_T b_this_MotionTypes[4], const real_T
    b_this_MotionLengths[4], real_T b_this_Length,
    emxArray_real_T_FlightMissionMode_T *samples,
    emxArray_real_T_FlightMissionMode_T *poses);
static void FlightMissionMode_genSegWP_j(const real_T start[4], const real_T
    ende[4], emxArray_real_T_FlightMissionMode_T *segWayPoints,
    DW_FlightMissionMode_f_T *localDW);

// System initialize for atomic system:
void FlightMissionMode_RotateATMissionHdg_Init
    (DW_RotateATMissionHdg_FlightMissionMode_T *localDW)
{
    // Start for MATLABSystem: '<S40>/RotateATMissionHdg'
    localDW->objisempty = true;
    localDW->obj.isInitialized = 1;
}

// Output and update for atomic system:
void FlightMissionMode_RotateATMissionHdg(const real_T rtu_0[3],
    DW_RotateATMissionHdg_FlightMissionMode_T *localDW)
{
    real_T out[9];
    real_T ct_idx_0;
    real_T ct_idx_1;
    real_T ct_idx_2;
    real_T out_tmp;
    real_T out_tmp_0;
    real_T st_idx_0;
    real_T st_idx_1;
    real_T st_idx_2;

    // MATLABSystem: '<S40>/RotateATMissionHdg'
    ct_idx_0 = std::cos(rtu_0[0]);
    ct_idx_1 = std::cos(rtu_0[1]);
    ct_idx_2 = std::cos(rtu_0[2]);
    st_idx_0 = std::sin(rtu_0[0]);
    st_idx_1 = std::sin(rtu_0[1]);
    st_idx_2 = std::sin(rtu_0[2]);
    out[0] = ct_idx_0 * ct_idx_1;
    out_tmp = st_idx_1 * st_idx_2;
    out[3] = out_tmp * ct_idx_0 - st_idx_0 * ct_idx_2;
    out_tmp_0 = st_idx_1 * ct_idx_2;
    out[6] = out_tmp_0 * ct_idx_0 + st_idx_0 * st_idx_2;
    out[1] = st_idx_0 * ct_idx_1;
    out[4] = out_tmp * st_idx_0 + ct_idx_0 * ct_idx_2;
    out[7] = out_tmp_0 * st_idx_0 - ct_idx_0 * st_idx_2;
    out[2] = -st_idx_1;
    out[5] = ct_idx_1 * st_idx_2;
    out[8] = ct_idx_1 * ct_idx_2;

    // MATLABSystem: '<S40>/RotateATMissionHdg'
    std::memcpy(&localDW->RotateATMissionHdg[0], &out[0], static_cast<uint32_T>
                (9U * sizeof(real_T)));
}

static real_T FlightMissionMode_norm(const real_T x[3])
{
    real_T absxk;
    real_T scale;
    real_T t;
    real_T y;
    scale = 3.3121686421112381E-170;
    absxk = std::abs(x[0]);
    if (absxk > 3.3121686421112381E-170) {
        y = 1.0;
        scale = absxk;
    } else {
        t = absxk / 3.3121686421112381E-170;
        y = t * t;
    }

    absxk = std::abs(x[1]);
    if (absxk > scale) {
        t = scale / absxk;
        y = y * t * t + 1.0;
        scale = absxk;
    } else {
        t = absxk / scale;
        y += t * t;
    }

    absxk = std::abs(x[2]);
    if (absxk > scale) {
        t = scale / absxk;
        y = y * t * t + 1.0;
        scale = absxk;
    } else {
        t = absxk / scale;
        y += t * t;
    }

    return scale * std::sqrt(y);
}

// System initialize for atomic system:
void FlightMissionMode_WaypointFollower_Init
    (DW_WaypointFollower_FlightMissionMode_T *localDW)
{
    // Start for MATLABSystem: '<S105>/Waypoint Follower'
    localDW->obj.LastWaypointFlag = false;
    localDW->obj.StartFlag = true;
    localDW->obj.LookaheadFactor = 1.01;
    localDW->objisempty = true;
    localDW->obj.isInitialized = 1;
    localDW->obj.NumWaypoints = 0.0;

    // InitializeConditions for MATLABSystem: '<S105>/Waypoint Follower'
    localDW->obj.WaypointIndex = 1.0;
    for (int32_T i{0}; i < 384; i++) {
        // Start for MATLABSystem: '<S105>/Waypoint Follower'
        localDW->obj.WaypointsInternal[i] = 0.0;

        // InitializeConditions for MATLABSystem: '<S105>/Waypoint Follower'
        localDW->obj.WaypointsInternal[i] *= 0.0;
    }
}

// System reset for atomic system:
void FlightMissionMode_WaypointFollower_Reset
    (DW_WaypointFollower_FlightMissionMode_T *localDW)
{
    // InitializeConditions for MATLABSystem: '<S105>/Waypoint Follower'
    localDW->obj.WaypointIndex = 1.0;
    for (int32_T i{0}; i < 384; i++) {
        localDW->obj.WaypointsInternal[i] *= 0.0;
    }

    // End of InitializeConditions for MATLABSystem: '<S105>/Waypoint Follower'
}

// Output and update for atomic system:
void FlightMissionMode_WaypointFollower(const real_T rtu_0[4], const real_T
    rtu_1[384], real_T rtu_2, DW_WaypointFollower_FlightMissionMode_T *localDW)
{
    real_T b_waypointsIn_data[384];
    real_T waypoints_data[384];
    real_T b_waypointsIn[3];
    real_T rtu_0_0[3];
    real_T lambda;
    real_T r_idx_0;
    real_T r_idx_1;
    real_T r_idx_2;
    int32_T b_exponent;
    int32_T b_exponent_0;
    int32_T b_k;
    int32_T i1;
    int32_T ix;
    int32_T iy;
    int32_T x_tmp;
    uint8_T b_data[128];
    boolean_T x[381];
    boolean_T distinctWptsIdx[128];
    boolean_T y[127];
    boolean_T exitg1;
    boolean_T guard1{ false };

    boolean_T p;

    // MATLABSystem: '<S105>/Waypoint Follower'
    lambda = rtu_2;
    localDW->obj.LookaheadDistFlag = 0U;
    if (rtu_2 < 0.1) {
        lambda = 0.1;
        localDW->obj.LookaheadDistFlag = 1U;
    }

    localDW->obj.InitialPose[0] = 0.0;
    localDW->obj.InitialPose[1] = 0.0;
    localDW->obj.InitialPose[2] = 0.0;
    localDW->obj.InitialPose[3] = 0.0;
    localDW->obj.NumWaypoints = 128.0;
    guard1 = false;
    if (localDW->obj.NumWaypoints != 128.0) {
        guard1 = true;
    } else {
        boolean_T p_0;
        if (localDW->obj.NumWaypoints < 1.0) {
            iy = 0;
        } else {
            iy = static_cast<int32_T>(localDW->obj.NumWaypoints);
        }

        if (localDW->obj.NumWaypoints < 1.0) {
            i1 = 0;
        } else {
            i1 = static_cast<int32_T>(localDW->obj.NumWaypoints);
        }

        p = false;
        p_0 = false;
        if (iy == i1) {
            p_0 = true;
        }

        if (p_0 && (iy != 0) && (i1 != 0)) {
            b_k = 0;
            exitg1 = false;
            while ((!exitg1) && (b_k <= static_cast<int32_T>(static_cast<int32_T>
                     (i1 * 3) - 1))) {
                if (static_cast<boolean_T>(static_cast<int32_T>
                                           ((localDW->obj.WaypointsInternal[
                        static_cast<int32_T>(static_cast<int32_T>
                        (static_cast<int32_T>(b_k / iy) << 7) + b_k % iy)] ==
                        rtu_1[static_cast<int32_T>(static_cast<int32_T>(
                         static_cast<int32_T>(b_k / i1) << 7) + b_k % i1)]) ^ 1)))
                {
                    p_0 = false;
                    exitg1 = true;
                } else {
                    b_k = static_cast<int32_T>(b_k + 1);
                }
            }
        }

        if (p_0) {
            p = true;
        }

        if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(p) ^
              1))) {
            guard1 = true;
        }
    }

    if (guard1) {
        std::memcpy(&localDW->obj.WaypointsInternal[0], &rtu_1[0],
                    static_cast<uint32_T>(384U * sizeof(real_T)));
        localDW->obj.WaypointIndex = 1.0;
    }

    for (b_k = 0; b_k < 128; b_k++) {
        distinctWptsIdx[b_k] = true;
    }

    b_k = 0;
    i1 = 0;
    for (iy = 0; iy < 3; iy++) {
        for (ix = 0; ix < 127; ix++) {
            x_tmp = static_cast<int32_T>(ix + i1);
            x[static_cast<int32_T>(ix + b_k)] = (rtu_1[static_cast<int32_T>
                (x_tmp + 1)] != rtu_1[x_tmp]);
        }

        b_k = static_cast<int32_T>(b_k + 127);
        i1 = static_cast<int32_T>(i1 + 128);
    }

    i1 = 0;
    iy = 254;
    for (b_k = 0; b_k < 127; b_k++) {
        y[b_k] = false;
        i1 = static_cast<int32_T>(i1 + 1);
        iy = static_cast<int32_T>(iy + 1);
        ix = i1;
        exitg1 = false;
        while ((!exitg1) && (ix <= iy)) {
            if (x[static_cast<int32_T>(ix - 1)]) {
                y[b_k] = true;
                exitg1 = true;
            } else {
                ix = static_cast<int32_T>(ix + 127);
            }
        }

        distinctWptsIdx[b_k] = y[b_k];
    }

    i1 = 0;
    for (b_k = 0; b_k < 128; b_k++) {
        if (distinctWptsIdx[b_k]) {
            i1 = static_cast<int32_T>(i1 + 1);
        }
    }

    iy = i1;
    i1 = 0;
    for (b_k = 0; b_k < 128; b_k++) {
        if (distinctWptsIdx[b_k]) {
            b_data[i1] = static_cast<uint8_T>(static_cast<int32_T>(b_k + 1));
            i1 = static_cast<int32_T>(i1 + 1);
        }
    }

    for (b_k = 0; b_k < 3; b_k++) {
        for (i1 = 0; i1 <= static_cast<int32_T>(iy - 1); i1++) {
            b_waypointsIn_data[static_cast<int32_T>(i1 + static_cast<int32_T>(iy
                * b_k))] = rtu_1[static_cast<int32_T>(static_cast<int32_T>(
                static_cast<int32_T>(b_k << 7) + static_cast<int32_T>(b_data[i1]))
                - 1)];
        }
    }

    localDW->obj.LookaheadDistance = lambda;
    if (iy == 0) {
        // MATLABSystem: '<S105>/Waypoint Follower'
        localDW->WaypointFollower_o1[0] = lambda * std::cos(rtu_0[3]) + rtu_0[0];
        localDW->WaypointFollower_o1[1] = lambda * std::sin(rtu_0[3]) + rtu_0[1];
        localDW->WaypointFollower_o1[2] = lambda * 0.0 + rtu_0[2];
        lambda = rtu_0[3];

        // MATLABSystem: '<S105>/Waypoint Follower'
        localDW->WaypointFollower_o3 = rtu_0[3];

        // MATLABSystem: '<S105>/Waypoint Follower'
        localDW->WaypointFollower_o5 = 1U;
    } else {
        guard1 = false;
        if (iy == 1) {
            if (localDW->obj.StartFlag) {
                localDW->obj.InitialPose[0] = rtu_0[0];
                localDW->obj.InitialPose[1] = rtu_0[1];
                localDW->obj.InitialPose[2] = rtu_0[2];
                localDW->obj.InitialPose[3] = rtu_0[3];
            }

            b_waypointsIn[0] = b_waypointsIn_data[0] - rtu_0[0];
            b_waypointsIn[1] = b_waypointsIn_data[1] - rtu_0[1];
            b_waypointsIn[2] = b_waypointsIn_data[2] - rtu_0[2];
            if (FlightMissionMode_norm(b_waypointsIn) < 1.4901161193847656E-8) {
                // MATLABSystem: '<S105>/Waypoint Follower'
                localDW->WaypointFollower_o1[0] = lambda * std::cos(rtu_0[3]) +
                    rtu_0[0];
                localDW->WaypointFollower_o1[1] = lambda * std::sin(rtu_0[3]) +
                    rtu_0[1];
                localDW->WaypointFollower_o1[2] = lambda * 0.0 + rtu_0[2];
                lambda = rtu_0[3];

                // MATLABSystem: '<S105>/Waypoint Follower'
                localDW->WaypointFollower_o3 = rtu_0[3];

                // MATLABSystem: '<S105>/Waypoint Follower'
                localDW->WaypointFollower_o5 = 1U;
                localDW->obj.StartFlag = false;
            } else {
                localDW->obj.StartFlag = false;
                localDW->obj.NumWaypoints = 2.0;
                ix = static_cast<int32_T>(iy + 1);
                for (b_k = 0; b_k < 3; b_k++) {
                    x_tmp = static_cast<int32_T>(static_cast<int32_T>(iy + 1) *
                        b_k);
                    waypoints_data[x_tmp] = localDW->obj.InitialPose[b_k];
                    for (i1 = 0; i1 <= static_cast<int32_T>(iy - 1); i1++) {
                        waypoints_data[static_cast<int32_T>(static_cast<int32_T>
                            (i1 + x_tmp) + 1)] = b_waypointsIn_data
                            [static_cast<int32_T>(static_cast<int32_T>(iy * b_k)
                            + i1)];
                    }
                }

                guard1 = true;
            }
        } else {
            ix = iy;
            iy = static_cast<int32_T>(iy * 3);
            for (b_k = 0; b_k <= static_cast<int32_T>(iy - 1); b_k++) {
                waypoints_data[b_k] = b_waypointsIn_data[b_k];
            }

            guard1 = true;
        }

        if (guard1) {
            real_T b;
            real_T b_tmp_idx_2_tmp;
            real_T lambda_tmp;
            real_T rtu_0_tmp;
            real_T waypoints_tmp;
            real_T waypoints_tmp_0;
            real_T waypoints_tmp_1;
            boolean_T guard2{ false };

            p = false;
            if (localDW->obj.WaypointIndex == localDW->obj.NumWaypoints) {
                p = true;
            }

            if (p) {
                localDW->obj.LastWaypointFlag = true;
                localDW->obj.WaypointIndex--;
            }

            rtu_0_0[0] = rtu_0[0] - waypoints_data[static_cast<int32_T>(
                static_cast<int32_T>(localDW->obj.WaypointIndex + 1.0) - 1)];
            rtu_0_0[1] = rtu_0[1] - waypoints_data[static_cast<int32_T>(
                static_cast<int32_T>(static_cast<int32_T>
                (localDW->obj.WaypointIndex + 1.0) + ix) - 1)];
            rtu_0_0[2] = rtu_0[2] - waypoints_data[static_cast<int32_T>(
                static_cast<int32_T>(static_cast<int32_T>
                (localDW->obj.WaypointIndex + 1.0) + static_cast<int32_T>(ix <<
                1)) - 1)];
            guard2 = false;
            if (FlightMissionMode_norm(rtu_0_0) <= 100.0) {
                guard2 = true;
            } else {
                r_idx_0 = waypoints_data[static_cast<int32_T>
                    (static_cast<int32_T>(localDW->obj.WaypointIndex + 1.0) - 1)];
                b_waypointsIn[0] = rtu_0[0] - r_idx_0;
                rtu_0_0[0] = r_idx_0 - waypoints_data[static_cast<int32_T>(
                    static_cast<int32_T>(localDW->obj.WaypointIndex) - 1)];
                r_idx_0 = waypoints_data[static_cast<int32_T>
                    (static_cast<int32_T>(static_cast<int32_T>
                      (localDW->obj.WaypointIndex + 1.0) + ix) - 1)];
                b_waypointsIn[1] = rtu_0[1] - r_idx_0;
                rtu_0_0[1] = r_idx_0 - waypoints_data[static_cast<int32_T>(
                    static_cast<int32_T>(static_cast<int32_T>
                    (localDW->obj.WaypointIndex) + ix) - 1)];
                r_idx_2 = waypoints_data[static_cast<int32_T>
                    (static_cast<int32_T>(static_cast<int32_T>
                      (localDW->obj.WaypointIndex + 1.0) + static_cast<int32_T>
                      (ix << 1)) - 1)];
                b_waypointsIn[2] = rtu_0[2] - r_idx_2;
                rtu_0_tmp = waypoints_data[static_cast<int32_T>
                    (static_cast<int32_T>(static_cast<int32_T>(ix << 1) +
                      static_cast<int32_T>(localDW->obj.WaypointIndex)) - 1)];
                rtu_0_0[2] = r_idx_2 - rtu_0_tmp;
                lambda = FlightMissionMode_norm(rtu_0_0);
                b = FlightMissionMode_norm(b_waypointsIn);
                waypoints_tmp = waypoints_data[static_cast<int32_T>(static_cast<
                    int32_T>(localDW->obj.WaypointIndex) - 1)];
                r_idx_0 = waypoints_data[static_cast<int32_T>
                    (static_cast<int32_T>(localDW->obj.WaypointIndex + 1.0) - 1)];
                waypoints_tmp_0 = waypoints_data[static_cast<int32_T>(
                    static_cast<int32_T>(static_cast<int32_T>
                    (localDW->obj.WaypointIndex) + ix) - 1)];
                r_idx_1 = waypoints_data[static_cast<int32_T>
                    (static_cast<int32_T>(static_cast<int32_T>
                      (localDW->obj.WaypointIndex + 1.0) + ix) - 1)];
                lambda = ((r_idx_0 - waypoints_tmp) / lambda * (b_waypointsIn[0]
                           / b) + (r_idx_1 - waypoints_tmp_0) / lambda *
                          (b_waypointsIn[1] / b)) + (r_idx_2 - rtu_0_tmp) /
                    lambda * (b_waypointsIn[2] / b);
                if (std::isnan(lambda)) {
                    lambda = (rtNaN);
                } else if (lambda < 0.0) {
                    lambda = -1.0;
                } else {
                    lambda = static_cast<real_T>(lambda > 0.0);
                }

                if (lambda >= 0.0) {
                    guard2 = true;
                } else {
                    b_waypointsIn[0] = waypoints_tmp;
                    b_waypointsIn[1] = waypoints_tmp_0;
                    b_waypointsIn[2] = rtu_0_tmp;
                }
            }

            if (guard2) {
                localDW->obj.WaypointIndex++;
                p = false;
                if (localDW->obj.WaypointIndex == localDW->obj.NumWaypoints) {
                    p = true;
                }

                if (p) {
                    localDW->obj.LastWaypointFlag = true;
                    localDW->obj.WaypointIndex--;
                }

                b_waypointsIn[0] = waypoints_data[static_cast<int32_T>(
                    static_cast<int32_T>(localDW->obj.WaypointIndex) - 1)];
                r_idx_0 = waypoints_data[static_cast<int32_T>
                    (static_cast<int32_T>(localDW->obj.WaypointIndex + 1.0) - 1)];
                b_waypointsIn[1] = waypoints_data[static_cast<int32_T>(
                    static_cast<int32_T>(static_cast<int32_T>
                    (localDW->obj.WaypointIndex) + ix) - 1)];
                r_idx_1 = waypoints_data[static_cast<int32_T>
                    (static_cast<int32_T>(static_cast<int32_T>
                      (localDW->obj.WaypointIndex + 1.0) + ix) - 1)];
                b_waypointsIn[2] = waypoints_data[static_cast<int32_T>(
                    static_cast<int32_T>(static_cast<int32_T>(ix << 1) +
                    static_cast<int32_T>(localDW->obj.WaypointIndex)) - 1)];
                r_idx_2 = waypoints_data[static_cast<int32_T>
                    (static_cast<int32_T>(static_cast<int32_T>
                      (localDW->obj.WaypointIndex + 1.0) + static_cast<int32_T>
                      (ix << 1)) - 1)];
            }

            waypoints_tmp = r_idx_0 - b_waypointsIn[0];
            b = rtu_0[0] - b_waypointsIn[0];
            waypoints_tmp_0 = r_idx_1 - b_waypointsIn[1];
            rtu_0_tmp = rtu_0[1] - b_waypointsIn[1];
            waypoints_tmp_1 = r_idx_2 - b_waypointsIn[2];
            lambda_tmp = rtu_0[2] - b_waypointsIn[2];
            lambda = ((rtu_0_tmp * waypoints_tmp_0 + b * waypoints_tmp) +
                      lambda_tmp * waypoints_tmp_1) / ((waypoints_tmp_0 *
                waypoints_tmp_0 + waypoints_tmp * waypoints_tmp) +
                waypoints_tmp_1 * waypoints_tmp_1);
            if (lambda < 0.0) {
                rtu_0_0[0] = b;
                rtu_0_0[1] = rtu_0_tmp;
                rtu_0_0[2] = lambda_tmp;
                lambda = FlightMissionMode_norm(rtu_0_0);
            } else if (lambda > 1.0) {
                rtu_0_0[0] = rtu_0[0] - r_idx_0;
                rtu_0_0[1] = rtu_0[1] - r_idx_1;
                rtu_0_0[2] = rtu_0[2] - r_idx_2;
                lambda = FlightMissionMode_norm(rtu_0_0);
            } else {
                rtu_0_0[0] = rtu_0[0] - (lambda * waypoints_tmp + b_waypointsIn
                    [0]);
                rtu_0_0[1] = rtu_0[1] - (lambda * waypoints_tmp_0 +
                    b_waypointsIn[1]);
                rtu_0_0[2] = rtu_0[2] - (lambda * waypoints_tmp_1 +
                    b_waypointsIn[2]);
                lambda = FlightMissionMode_norm(rtu_0_0);
            }

            if (localDW->obj.LastWaypointFlag) {
                lambda = (((rtu_0[0] - b_waypointsIn[0]) * (r_idx_0 -
                            b_waypointsIn[0]) + (rtu_0[1] - b_waypointsIn[1]) *
                           (r_idx_1 - b_waypointsIn[1])) + (rtu_0[2] -
                           b_waypointsIn[2]) * (r_idx_2 - b_waypointsIn[2])) /
                    (((r_idx_0 - b_waypointsIn[0]) * (r_idx_0 - b_waypointsIn[0])
                      + (r_idx_1 - b_waypointsIn[1]) * (r_idx_1 - b_waypointsIn
                       [1])) + (r_idx_2 - b_waypointsIn[2]) * (r_idx_2 -
                      b_waypointsIn[2]));
                rtu_0_0[0] = rtu_0[0] - (lambda * waypoints_tmp + b_waypointsIn
                    [0]);
                rtu_0_0[1] = rtu_0[1] - (lambda * waypoints_tmp_0 +
                    b_waypointsIn[1]);
                rtu_0_0[2] = rtu_0[2] - (lambda * waypoints_tmp_1 +
                    b_waypointsIn[2]);
                lambda = FlightMissionMode_norm(rtu_0_0);
            }

            lambda_tmp = std::abs(lambda);
            if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                    (std::isinf(lambda_tmp)) | static_cast<int32_T>(std::isnan
                    (lambda_tmp))))) {
                b = (rtNaN);
                lambda_tmp = (rtNaN);
            } else if (lambda_tmp < 4.4501477170144028E-308) {
                b = 4.94065645841247E-324;
                lambda_tmp = 4.94065645841247E-324;
            } else {
                std::frexp(lambda_tmp, &b_exponent);
                b = std::ldexp(1.0, static_cast<int32_T>(b_exponent - 53));
                std::frexp(lambda_tmp, &b_exponent_0);
                lambda_tmp = std::ldexp(1.0, static_cast<int32_T>(b_exponent_0 -
                    53));
            }

            if (localDW->obj.LookaheadDistance <= std::fmax(std::sqrt(b), 5.0 *
                    lambda_tmp) + lambda) {
                localDW->obj.LookaheadDistance = localDW->obj.LookaheadFactor *
                    lambda;
            }

            lambda = b_waypointsIn[0] - rtu_0[0];
            lambda_tmp = b_waypointsIn[1] - rtu_0[1];
            rtu_0_tmp = ((r_idx_0 - b_waypointsIn[0]) * (r_idx_0 -
                          b_waypointsIn[0]) + (r_idx_1 - b_waypointsIn[1]) *
                         (r_idx_1 - b_waypointsIn[1])) + (r_idx_2 -
                b_waypointsIn[2]) * (r_idx_2 - b_waypointsIn[2]);
            b_tmp_idx_2_tmp = b_waypointsIn[2] - rtu_0[2];
            b = ((waypoints_tmp * lambda + waypoints_tmp_0 * lambda_tmp) +
                 waypoints_tmp_1 * b_tmp_idx_2_tmp) * 2.0;
            lambda_tmp = std::sqrt(b * b - (((lambda * lambda + lambda_tmp *
                lambda_tmp) + b_tmp_idx_2_tmp * b_tmp_idx_2_tmp) -
                                    localDW->obj.LookaheadDistance *
                                    localDW->obj.LookaheadDistance) * (4.0 *
                                    rtu_0_tmp));
            lambda = std::fmax((-b + lambda_tmp) / 2.0 / rtu_0_tmp, (-b -
                                lambda_tmp) / 2.0 / rtu_0_tmp);
            rtu_0_tmp = (1.0 - lambda) * b_waypointsIn[0] + lambda * r_idx_0;

            // MATLABSystem: '<S105>/Waypoint Follower'
            localDW->WaypointFollower_o1[0] = rtu_0_tmp;
            r_idx_0 = rtu_0_tmp;
            rtu_0_tmp = (1.0 - lambda) * b_waypointsIn[1] + lambda * r_idx_1;

            // MATLABSystem: '<S105>/Waypoint Follower'
            localDW->WaypointFollower_o1[1] = rtu_0_tmp;
            localDW->WaypointFollower_o1[2] = (1.0 - lambda) * b_waypointsIn[2]
                + lambda * r_idx_2;
            lambda = rt_atan2d_snf(rtu_0_tmp - rtu_0[1], r_idx_0 - rtu_0[0]);

            // MATLABSystem: '<S105>/Waypoint Follower'
            localDW->WaypointFollower_o3 = lambda;

            // MATLABSystem: '<S105>/Waypoint Follower'
            localDW->WaypointFollower_o5 = 0U;
            p = false;
            if (localDW->obj.LastWaypointFlag) {
                p = true;
            }

            if (p) {
                // MATLABSystem: '<S105>/Waypoint Follower'
                localDW->WaypointFollower_o5 = 1U;
            }

            localDW->obj.LastWaypointFlag = false;
        }
    }

    // MATLABSystem: '<S105>/Waypoint Follower'
    localDW->WaypointFollower_o2 = lambda;

    // MATLABSystem: '<S105>/Waypoint Follower'
    localDW->WaypointFollower_o4 = localDW->obj.LookaheadDistFlag;
}

//
// System initialize for atomic system:
//    '<S72>/SegmentSwitch'
//    '<S116>/SegmentSwitch'
//
void FlightMissionMode_SegmentSwitch_Init(real_T rty_LookAheadPoint[3], real_T
    *rty_DesiredCourse, RunWayLineSegment *rty_Status,
    DW_SegmentSwitch_FlightMissionMode_T *localDW)
{
    // Start for SwitchCase: '<S76>/Switch Case'
    localDW->SwitchCase_ActiveSubsystem = -1;

    // SystemInitialize for Chart: '<S76>/Chart'
    *rty_Status = RunWayLineSegment::None;

    // SystemInitialize for IfAction SubSystem: '<S76>/Left'

    // Constant: '<S105>/LookAheadDis'
    FlightMissionMode_WaypointFollower_Init(&localDW->WaypointFollower);

    // End of SystemInitialize for SubSystem: '<S76>/Left'

    // SystemInitialize for IfAction SubSystem: '<S76>/Top'

    // Constant: '<S107>/LookAheadDis'
    FlightMissionMode_WaypointFollower_Init(&localDW->WaypointFollower_k);

    // End of SystemInitialize for SubSystem: '<S76>/Top'

    // SystemInitialize for IfAction SubSystem: '<S76>/Right'

    // Constant: '<S106>/LookAheadDis'
    FlightMissionMode_WaypointFollower_Init(&localDW->WaypointFollower_n);

    // End of SystemInitialize for SubSystem: '<S76>/Right'

    // SystemInitialize for IfAction SubSystem: '<S76>/Bottom'

    // Constant: '<S102>/LookAheadDis'
    FlightMissionMode_WaypointFollower_Init(&localDW->WaypointFollower_i);

    // End of SystemInitialize for SubSystem: '<S76>/Bottom'

    // SystemInitialize for IfAction SubSystem: '<S76>/Initial'

    // Constant: '<S104>/LookAheadDis'
    FlightMissionMode_WaypointFollower_Init(&localDW->WaypointFollower_e);

    // End of SystemInitialize for SubSystem: '<S76>/Initial'

    // SystemInitialize for Merge: '<S76>/MergeDesiredCourse'
    *rty_DesiredCourse = 0.0;

    // SystemInitialize for Merge: '<S76>/MergeLookAheadP'
    rty_LookAheadPoint[0] = 0.0;
    rty_LookAheadPoint[1] = 0.0;
    rty_LookAheadPoint[2] = 0.0;
}

//
// System reset for atomic system:
//    '<S72>/SegmentSwitch'
//    '<S116>/SegmentSwitch'
//
void FlightMissionMode_SegmentSwitch_Reset(RunWayLineSegment *rty_Status,
    DW_SegmentSwitch_FlightMissionMode_T *localDW)
{
    // InitializeConditions for Memory: '<S76>/Memory'
    localDW->Memory_PreviousInput = 0.0;

    // SystemReset for Chart: '<S76>/Chart'
    localDW->temporalCounter_i1 = 0U;
    localDW->is_Running = FlightMissionMode_IN_NO_ACTIVE_CHILD;
    localDW->is_active_c3_PathPlanning = 0U;
    localDW->is_c3_PathPlanning = FlightMissionMode_IN_NO_ACTIVE_CHILD;
    *rty_Status = RunWayLineSegment::None;
}

//
// Disable for atomic system:
//    '<S72>/SegmentSwitch'
//    '<S116>/SegmentSwitch'
//
void FlightMissionMode_SegmentSwitch_Disable
    (DW_SegmentSwitch_FlightMissionMode_T *localDW)
{
    // Disable for SwitchCase: '<S76>/Switch Case'
    localDW->SwitchCase_ActiveSubsystem = -1;
}

//
// Output and update for atomic system:
//    '<S72>/SegmentSwitch'
//    '<S116>/SegmentSwitch'
//
void FlightMissionMode_SegmentSwitch(const boolean_T *rtu_Reset, const real_T
    rtu_Pose[4], const real_T rtu_RawWaypoint[1920], real_T rty_LookAheadPoint[3],
    real_T *rty_DesiredCourse, RunWayLineSegment *rty_Status, real_T
    rtp_LookAheadDis, DW_SegmentSwitch_FlightMissionMode_T *localDW)
{
    // local block i/o variables
    real_T rtb_Selector_i[384];
    real_T rtb_Selector_a[384];
    real_T rtb_Selector_h[384];
    real_T rtb_Selector_o[384];
    real_T rtb_Selector_a0[384];
    int8_T rtAction;
    int8_T rtPrevAction;

    // Chart: '<S76>/Chart' incorporates:
    //   Memory: '<S76>/Memory'

    // Gateway: SegmentSwitch/Chart
    if (static_cast<uint32_T>(localDW->temporalCounter_i1) < 7U) {
        localDW->temporalCounter_i1 = static_cast<uint8_T>(static_cast<uint32_T>
            (static_cast<uint32_T>(localDW->temporalCounter_i1) + 1U));
    }

    // During: SegmentSwitch/Chart
    if (static_cast<uint32_T>(localDW->is_active_c3_PathPlanning) == 0U) {
        // Entry: SegmentSwitch/Chart
        localDW->is_active_c3_PathPlanning = 1U;

        // Entry Internal: SegmentSwitch/Chart
        // Transition: '<S103>:2'
        localDW->is_c3_PathPlanning = FlightMissionMode_IN_Init;
        localDW->temporalCounter_i1 = 0U;
        *rty_Status = RunWayLineSegment::Init;
    } else if (localDW->is_c3_PathPlanning == FlightMissionMode_IN_Init) {
        // During 'Init': '<S103>:1'
        if (static_cast<boolean_T>(static_cast<int32_T>((static_cast<int32_T>
                (localDW->temporalCounter_i1) >= 5) &
                (localDW->Memory_PreviousInput == 1.0)))) {
            // Transition: '<S103>:4'
            localDW->is_c3_PathPlanning = FlightMissionMode_IN_Running;
            localDW->is_Running = FlightMissionMode_IN_Left;
            *rty_Status = RunWayLineSegment::Left;
        }

        // During 'Running': '<S103>:5'
    } else if (*rtu_Reset) {
        // Transition: '<S103>:15'
        // Exit Internal 'Running': '<S103>:5'
        localDW->is_Running = FlightMissionMode_IN_NO_ACTIVE_CHILD;
        localDW->is_c3_PathPlanning = FlightMissionMode_IN_Init;
        localDW->temporalCounter_i1 = 0U;
        *rty_Status = RunWayLineSegment::Init;
    } else {
        switch (localDW->is_Running) {
          case FlightMissionMode_IN_Bottom:
            // During 'Bottom': '<S103>:13'
            if (localDW->Memory_PreviousInput == 1.0) {
                // Transition: '<S103>:8'
                localDW->is_Running = FlightMissionMode_IN_Left;
                *rty_Status = RunWayLineSegment::Left;
            }
            break;

          case FlightMissionMode_IN_Left:
            // During 'Left': '<S103>:11'
            if (localDW->Memory_PreviousInput == 1.0) {
                // Transition: '<S103>:7'
                localDW->is_Running = FlightMissionMode_IN_Top;
                *rty_Status = RunWayLineSegment::Top;
            }
            break;

          case FlightMissionMode_IN_Right:
            // During 'Right': '<S103>:14'
            if (localDW->Memory_PreviousInput == 1.0) {
                // Transition: '<S103>:10'
                localDW->is_Running = FlightMissionMode_IN_Bottom;
                *rty_Status = RunWayLineSegment::Bottom;
            }
            break;

          default:
            // During 'Top': '<S103>:12'
            if (localDW->Memory_PreviousInput == 1.0) {
                // Transition: '<S103>:9'
                localDW->is_Running = FlightMissionMode_IN_Right;
                *rty_Status = RunWayLineSegment::Right;
            }
            break;
        }
    }

    // End of Chart: '<S76>/Chart'

    // SwitchCase: '<S76>/Switch Case' incorporates:
    //   Constant: '<S102>/LookAheadDis'
    //   Constant: '<S104>/LookAheadDis'
    //   Constant: '<S105>/LookAheadDis'
    //   Constant: '<S106>/LookAheadDis'
    //   Constant: '<S107>/LookAheadDis'

    rtPrevAction = localDW->SwitchCase_ActiveSubsystem;
    switch (*rty_Status) {
      case RunWayLineSegment::Left:
        rtAction = 0;
        break;

      case RunWayLineSegment::Top:
        rtAction = 1;
        break;

      case RunWayLineSegment::Right:
        rtAction = 2;
        break;

      case RunWayLineSegment::Bottom:
        rtAction = 3;
        break;

      case RunWayLineSegment::Init:
        rtAction = 4;
        break;

      default:
        rtAction = 5;
        break;
    }

    localDW->SwitchCase_ActiveSubsystem = rtAction;
    switch (rtAction) {
      case 0:
        if (static_cast<int32_T>(rtAction) != static_cast<int32_T>(rtPrevAction))
        {
            // SystemReset for IfAction SubSystem: '<S76>/Left' incorporates:
            //   ActionPort: '<S105>/Action Port'

            // SystemReset for SwitchCase: '<S76>/Switch Case'
            FlightMissionMode_WaypointFollower_Reset(&localDW->WaypointFollower);

            // End of SystemReset for SubSystem: '<S76>/Left'
        }

        // Outputs for IfAction SubSystem: '<S76>/Left' incorporates:
        //   ActionPort: '<S105>/Action Port'

        // Selector: '<S105>/Selector'
        std::memcpy(&rtb_Selector_a0[0], &rtu_RawWaypoint[0],
                    static_cast<uint32_T>(384U * sizeof(real_T)));
        FlightMissionMode_WaypointFollower(rtu_Pose, rtb_Selector_a0,
            rtp_LookAheadDis, &localDW->WaypointFollower);

        // SignalConversion generated from: '<S105>/Waypoint Follower' incorporates:
        //   Constant: '<S105>/LookAheadDis'
        //   MATLABSystem: '<S105>/Waypoint Follower'

        rty_LookAheadPoint[0] = localDW->WaypointFollower.WaypointFollower_o1[0];
        rty_LookAheadPoint[1] = localDW->WaypointFollower.WaypointFollower_o1[1];
        rty_LookAheadPoint[2] = localDW->WaypointFollower.WaypointFollower_o1[2];

        // SignalConversion generated from: '<S105>/Waypoint Follower'
        *rty_DesiredCourse = localDW->WaypointFollower.WaypointFollower_o2;

        // Merge: '<S76>/MergeStatus' incorporates:
        //   DataTypeConversion: '<S105>/Cast To Double'
        //   SignalConversion generated from: '<S105>/Waypoint Follower'

        localDW->MergeStatus = static_cast<real_T>
            (localDW->WaypointFollower.WaypointFollower_o5);

        // End of Outputs for SubSystem: '<S76>/Left'
        break;

      case 1:
        if (static_cast<int32_T>(rtAction) != static_cast<int32_T>(rtPrevAction))
        {
            // SystemReset for IfAction SubSystem: '<S76>/Top' incorporates:
            //   ActionPort: '<S107>/Action Port'

            // SystemReset for SwitchCase: '<S76>/Switch Case'
            FlightMissionMode_WaypointFollower_Reset
                (&localDW->WaypointFollower_k);

            // End of SystemReset for SubSystem: '<S76>/Top'
        }

        // Outputs for IfAction SubSystem: '<S76>/Top' incorporates:
        //   ActionPort: '<S107>/Action Port'

        // Selector: '<S107>/Selector'
        std::memcpy(&rtb_Selector_o[0], &rtu_RawWaypoint[384],
                    static_cast<uint32_T>(384U * sizeof(real_T)));
        FlightMissionMode_WaypointFollower(rtu_Pose, rtb_Selector_o,
            rtp_LookAheadDis, &localDW->WaypointFollower_k);

        // SignalConversion generated from: '<S107>/Waypoint Follower' incorporates:
        //   Constant: '<S107>/LookAheadDis'
        //   MATLABSystem: '<S107>/Waypoint Follower'

        rty_LookAheadPoint[0] = localDW->WaypointFollower_k.WaypointFollower_o1
            [0];
        rty_LookAheadPoint[1] = localDW->WaypointFollower_k.WaypointFollower_o1
            [1];
        rty_LookAheadPoint[2] = localDW->WaypointFollower_k.WaypointFollower_o1
            [2];

        // SignalConversion generated from: '<S107>/Waypoint Follower'
        *rty_DesiredCourse = localDW->WaypointFollower_k.WaypointFollower_o2;

        // Merge: '<S76>/MergeStatus' incorporates:
        //   DataTypeConversion: '<S107>/Cast To Double'
        //   SignalConversion generated from: '<S107>/Waypoint Follower'

        localDW->MergeStatus = static_cast<real_T>
            (localDW->WaypointFollower_k.WaypointFollower_o5);

        // End of Outputs for SubSystem: '<S76>/Top'
        break;

      case 2:
        if (static_cast<int32_T>(rtAction) != static_cast<int32_T>(rtPrevAction))
        {
            // SystemReset for IfAction SubSystem: '<S76>/Right' incorporates:
            //   ActionPort: '<S106>/Action Port'

            // SystemReset for SwitchCase: '<S76>/Switch Case'
            FlightMissionMode_WaypointFollower_Reset
                (&localDW->WaypointFollower_n);

            // End of SystemReset for SubSystem: '<S76>/Right'
        }

        // Outputs for IfAction SubSystem: '<S76>/Right' incorporates:
        //   ActionPort: '<S106>/Action Port'

        // Selector: '<S106>/Selector'
        std::memcpy(&rtb_Selector_h[0], &rtu_RawWaypoint[768],
                    static_cast<uint32_T>(384U * sizeof(real_T)));
        FlightMissionMode_WaypointFollower(rtu_Pose, rtb_Selector_h,
            rtp_LookAheadDis, &localDW->WaypointFollower_n);

        // SignalConversion generated from: '<S106>/Waypoint Follower' incorporates:
        //   Constant: '<S106>/LookAheadDis'
        //   MATLABSystem: '<S106>/Waypoint Follower'

        rty_LookAheadPoint[0] = localDW->WaypointFollower_n.WaypointFollower_o1
            [0];
        rty_LookAheadPoint[1] = localDW->WaypointFollower_n.WaypointFollower_o1
            [1];
        rty_LookAheadPoint[2] = localDW->WaypointFollower_n.WaypointFollower_o1
            [2];

        // SignalConversion generated from: '<S106>/Waypoint Follower'
        *rty_DesiredCourse = localDW->WaypointFollower_n.WaypointFollower_o2;

        // Merge: '<S76>/MergeStatus' incorporates:
        //   DataTypeConversion: '<S106>/Cast To Double'
        //   SignalConversion generated from: '<S106>/Waypoint Follower'

        localDW->MergeStatus = static_cast<real_T>
            (localDW->WaypointFollower_n.WaypointFollower_o5);

        // End of Outputs for SubSystem: '<S76>/Right'
        break;

      case 3:
        if (static_cast<int32_T>(rtAction) != static_cast<int32_T>(rtPrevAction))
        {
            // SystemReset for IfAction SubSystem: '<S76>/Bottom' incorporates:
            //   ActionPort: '<S102>/Action Port'

            // SystemReset for SwitchCase: '<S76>/Switch Case'
            FlightMissionMode_WaypointFollower_Reset
                (&localDW->WaypointFollower_i);

            // End of SystemReset for SubSystem: '<S76>/Bottom'
        }

        // Outputs for IfAction SubSystem: '<S76>/Bottom' incorporates:
        //   ActionPort: '<S102>/Action Port'

        // Selector: '<S102>/Selector'
        std::memcpy(&rtb_Selector_a[0], &rtu_RawWaypoint[1152],
                    static_cast<uint32_T>(384U * sizeof(real_T)));
        FlightMissionMode_WaypointFollower(rtu_Pose, rtb_Selector_a,
            rtp_LookAheadDis, &localDW->WaypointFollower_i);

        // SignalConversion generated from: '<S102>/Waypoint Follower' incorporates:
        //   Constant: '<S102>/LookAheadDis'
        //   MATLABSystem: '<S102>/Waypoint Follower'

        rty_LookAheadPoint[0] = localDW->WaypointFollower_i.WaypointFollower_o1
            [0];
        rty_LookAheadPoint[1] = localDW->WaypointFollower_i.WaypointFollower_o1
            [1];
        rty_LookAheadPoint[2] = localDW->WaypointFollower_i.WaypointFollower_o1
            [2];

        // SignalConversion generated from: '<S102>/Waypoint Follower'
        *rty_DesiredCourse = localDW->WaypointFollower_i.WaypointFollower_o2;

        // Merge: '<S76>/MergeStatus' incorporates:
        //   DataTypeConversion: '<S102>/Cast To Double'
        //   SignalConversion generated from: '<S102>/Waypoint Follower'

        localDW->MergeStatus = static_cast<real_T>
            (localDW->WaypointFollower_i.WaypointFollower_o5);

        // End of Outputs for SubSystem: '<S76>/Bottom'
        break;

      case 4:
        if (static_cast<int32_T>(rtAction) != static_cast<int32_T>(rtPrevAction))
        {
            // SystemReset for IfAction SubSystem: '<S76>/Initial' incorporates:
            //   ActionPort: '<S104>/Action Port'

            // SystemReset for SwitchCase: '<S76>/Switch Case'
            FlightMissionMode_WaypointFollower_Reset
                (&localDW->WaypointFollower_e);

            // End of SystemReset for SubSystem: '<S76>/Initial'
        }

        // Outputs for IfAction SubSystem: '<S76>/Initial' incorporates:
        //   ActionPort: '<S104>/Action Port'

        // Selector: '<S104>/Selector'
        std::memcpy(&rtb_Selector_i[0], &rtu_RawWaypoint[1536],
                    static_cast<uint32_T>(384U * sizeof(real_T)));
        FlightMissionMode_WaypointFollower(rtu_Pose, rtb_Selector_i,
            rtp_LookAheadDis, &localDW->WaypointFollower_e);

        // SignalConversion generated from: '<S104>/Waypoint Follower' incorporates:
        //   Constant: '<S104>/LookAheadDis'
        //   MATLABSystem: '<S104>/Waypoint Follower'

        rty_LookAheadPoint[0] = localDW->WaypointFollower_e.WaypointFollower_o1
            [0];
        rty_LookAheadPoint[1] = localDW->WaypointFollower_e.WaypointFollower_o1
            [1];
        rty_LookAheadPoint[2] = localDW->WaypointFollower_e.WaypointFollower_o1
            [2];

        // SignalConversion generated from: '<S104>/Waypoint Follower'
        *rty_DesiredCourse = localDW->WaypointFollower_e.WaypointFollower_o2;

        // Merge: '<S76>/MergeStatus' incorporates:
        //   DataTypeConversion: '<S104>/Cast To Double'
        //   SignalConversion generated from: '<S104>/Waypoint Follower'

        localDW->MergeStatus = static_cast<real_T>
            (localDW->WaypointFollower_e.WaypointFollower_o5);

        // End of Outputs for SubSystem: '<S76>/Initial'
        break;
    }

    // End of SwitchCase: '<S76>/Switch Case'

    // Update for Memory: '<S76>/Memory'
    localDW->Memory_PreviousInput = localDW->MergeStatus;
}

static void FlightMissionMode_emxInit_char_T(emxArray_char_T_FlightMissionMode_T
    **pEmxArray, int32_T numDimensions)
{
    emxArray_char_T_FlightMissionMode_T *emxArray;
    *pEmxArray = static_cast<emxArray_char_T_FlightMissionMode_T *>(std::malloc
        (sizeof(emxArray_char_T_FlightMissionMode_T)));
    emxArray = *pEmxArray;
    emxArray->data = static_cast<char_T *>(nullptr);
    emxArray->numDimensions = numDimensions;
    emxArray->size = static_cast<int32_T *>(std::malloc(static_cast<uint32_T>
        (sizeof(int32_T) * static_cast<uint32_T>(numDimensions))));
    emxArray->allocatedSize = 0;
    emxArray->canFreeData = true;
    for (int32_T i{0}; i <= static_cast<int32_T>(numDimensions - 1); i++) {
        emxArray->size[i] = 0;
    }
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static int8_T FlightMissionMode_filedata
    (DW_StartPointGenerator_FlightMissionMode_T *localDW)
{
    int32_T k;
    int8_T f;
    boolean_T exitg1;
    f = 0;
    k = 1;
    exitg1 = false;
    while ((!exitg1) && (static_cast<int32_T>(k - 1) < 20)) {
        if (localDW->eml_openfiles[static_cast<int32_T>(static_cast<int32_T>(
                static_cast<int8_T>(k)) - 1)] == NULL) {
            f = static_cast<int8_T>(k);
            exitg1 = true;
        } else {
            k = static_cast<int32_T>(k + 1);
        }
    }

    return f;
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static int8_T FlightMissionMode_cfopen(const char_T *cfilename, const char_T
    *cpermission, DW_StartPointGenerator_FlightMissionMode_T *localDW)
{
    int8_T fileid;
    int8_T j;
    fileid = -1;
    j = FlightMissionMode_filedata(localDW);
    if (static_cast<int32_T>(j) >= 1) {
        FILE* filestar;
        filestar = fopen(cfilename, cpermission);
        if (filestar != NULL) {
            int32_T tmp;
            localDW->eml_openfiles[static_cast<int32_T>(static_cast<int32_T>(j)
                - 1)] = filestar;
            tmp = static_cast<int32_T>(static_cast<int32_T>(j) + 2);
            if (static_cast<int32_T>(static_cast<int32_T>(j) + 2) > 127) {
                tmp = 127;
            }

            fileid = static_cast<int8_T>(tmp);
        }
    }

    return fileid;
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static real_T FlightMissionMode_fileManager
    (DW_StartPointGenerator_FlightMissionMode_T *localDW)
{
    real_T f;
    int8_T fileid;
    fileid = FlightMissionMode_cfopen("config.ini", "rb", localDW);
    f = static_cast<real_T>(fileid);
    return f;
}

static void FlightMissionMode_emxEnsureCapacity_char_T
    (emxArray_char_T_FlightMissionMode_T *emxArray, int32_T oldNumel)
{
    int32_T i;
    int32_T newNumel;
    void *newData;
    if (oldNumel < 0) {
        oldNumel = 0;
    }

    newNumel = 1;
    for (i = 0; i <= static_cast<int32_T>(emxArray->numDimensions - 1); i++) {
        newNumel = static_cast<int32_T>(newNumel * emxArray->size[i]);
    }

    if (newNumel > emxArray->allocatedSize) {
        i = emxArray->allocatedSize;
        if (i < 16) {
            i = 16;
        }

        while (i < newNumel) {
            if (i > 1073741823) {
                i = MAX_int32_T;
            } else {
                i = static_cast<int32_T>(i << 1);
            }
        }

        newData = std::calloc(static_cast<uint32_T>(i), sizeof(char_T));
        if (emxArray->data != nullptr) {
            std::memcpy(newData, emxArray->data, static_cast<uint32_T>(sizeof
                         (char_T) * static_cast<uint32_T>(oldNumel)));
            if (emxArray->canFreeData) {
                std::free(emxArray->data);
            }
        }

        emxArray->data = static_cast<char_T *>(newData);
        emxArray->allocatedSize = i;
        emxArray->canFreeData = true;
    }
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static void FlightMissionMode_fread(real_T fileID,
    emxArray_char_T_FlightMissionMode_T *A,
    DW_StartPointGenerator_FlightMissionMode_T *localDW)
{
    FILE* filestar;
    size_t nBytes;
    char_T tbuf[1024];
    int8_T fileid;
    nBytes = sizeof(char_T);
    fileid = static_cast<int8_T>(fileID);
    if (fileID != static_cast<real_T>(static_cast<int8_T>(fileID))) {
        fileid = -1;
    }

    if (static_cast<int32_T>(fileid) >= 3) {
        filestar = localDW->eml_openfiles[static_cast<int32_T>
            (static_cast<int32_T>(fileid) - 3)];
    } else {
        switch (static_cast<int32_T>(fileid)) {
          case 0:
            filestar = stdin;
            break;

          case 1:
            filestar = stdout;
            break;

          case 2:
            filestar = stderr;
            break;

          default:
            filestar = NULL;
            break;
        }
    }

    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
            static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
              static_cast<boolean_T>(static_cast<int32_T>((fileID != 0.0) ^ 1)))
             | static_cast<int32_T>(static_cast<boolean_T>(static_cast<int32_T>
               ((fileID != 1.0) ^ 1)))))) | static_cast<int32_T>
            (static_cast<boolean_T>(static_cast<int32_T>((fileID != 2.0) ^ 1))))))
    {
        filestar = NULL;
    }

    A->size[0] = 0;
    if (static_cast<boolean_T>(static_cast<int32_T>((filestar == NULL) ^ 1))) {
        int32_T c;
        c = 1;
        while (c > 0) {
            int32_T i;
            int32_T loop_ub;
            int32_T numRead;
            int32_T tmp;
            c = 0;
            numRead = 1;
            while (static_cast<boolean_T>(static_cast<int32_T>((c < 1024) &
                     (numRead > 0)))) {
                size_t numReadSizeT;
                numReadSizeT = fread(&tbuf[c], nBytes, (size_t)(1024 - c),
                                     filestar);
                numRead = (int32_T)numReadSizeT;
                c = static_cast<int32_T>(c + (int32_T)numReadSizeT);
            }

            numRead = A->size[0];
            if (c < 1) {
                i = -1;
                loop_ub = -1;
            } else {
                i = static_cast<int32_T>(c - 1);
                loop_ub = static_cast<int32_T>(c - 1);
            }

            tmp = A->size[0];
            A->size[0] = static_cast<int32_T>(static_cast<int32_T>(i + A->size[0])
                + 1);
            FlightMissionMode_emxEnsureCapacity_char_T(A, tmp);
            for (i = 0; i <= loop_ub; i++) {
                A->data[static_cast<int32_T>(numRead + i)] = tbuf[i];
            }
        }
    }
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static void FlightMissionMode_copysign(emxArray_char_T_FlightMissionMode_T *s1,
    int32_T *idx, const emxArray_char_T_FlightMissionMode_T *s, int32_T *k,
    int32_T n, boolean_T *foundsign, boolean_T *success)
{
    static const boolean_T b[128]{ false, false, false, false, false, false,
        false, false, false, true, true, true, true, true, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, true, true, true, true, true, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false };

    boolean_T exitg1;
    boolean_T isneg;
    isneg = false;
    *foundsign = false;
    exitg1 = false;
    while ((!exitg1) && (*k <= n)) {
        char_T tmp;
        tmp = s->data[static_cast<int32_T>(*k - 1)];
        if (tmp == '-') {
            isneg = static_cast<boolean_T>(static_cast<int32_T>
                (static_cast<int32_T>(isneg) ^ 1));
            *foundsign = true;
            *k = static_cast<int32_T>(*k + 1);
        } else if (tmp == ',') {
            *k = static_cast<int32_T>(*k + 1);
        } else if (tmp == '+') {
            *foundsign = true;
            *k = static_cast<int32_T>(*k + 1);
        } else if (static_cast<boolean_T>(static_cast<int32_T>
                    (static_cast<int32_T>(b[static_cast<int32_T>
                      (static_cast<int32_T>(static_cast<uint8_T>(tmp)) & 127)]) ^
                     1))) {
            exitg1 = true;
        } else {
            *k = static_cast<int32_T>(*k + 1);
        }
    }

    *success = (*k <= n);
    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
            (*success) & static_cast<int32_T>(isneg)))) {
        if ((*idx >= 2) && (s1->data[static_cast<int32_T>(*idx - 2)] == '-')) {
            s1->data[static_cast<int32_T>(*idx - 2)] = ' ';
        } else {
            s1->data[static_cast<int32_T>(*idx - 1)] = '-';
            *idx = static_cast<int32_T>(*idx + 1);
        }
    }
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static boolean_T FlightMissionMode_isUnitImag(const
    emxArray_char_T_FlightMissionMode_T *s, int32_T k, int32_T n)
{
    boolean_T p;
    p = false;
    if (k <= n) {
        char_T c_idx_0;
        c_idx_0 = s->data[static_cast<int32_T>(k - 1)];
        if (c_idx_0 == 'j') {
            p = true;
        } else if (c_idx_0 == 'i') {
            if (k >= static_cast<int32_T>(n - 1)) {
                p = true;
            } else {
                int32_T b_k;
                char_T c_idx_1;
                char_T c_idx_2;
                b_k = k;
                c_idx_0 = '\x00';
                while ((b_k <= n) && (s->data[static_cast<int32_T>(b_k - 1)] ==
                                      ',')) {
                    b_k = static_cast<int32_T>(b_k + 1);
                }

                if (b_k <= n) {
                    c_idx_0 = s->data[static_cast<int32_T>(b_k - 1)];
                }

                b_k = static_cast<int32_T>(b_k + 1);
                c_idx_1 = '\x00';
                while ((b_k <= n) && (s->data[static_cast<int32_T>(b_k - 1)] ==
                                      ',')) {
                    b_k = static_cast<int32_T>(b_k + 1);
                }

                if (b_k <= n) {
                    c_idx_1 = s->data[static_cast<int32_T>(b_k - 1)];
                }

                b_k = static_cast<int32_T>(b_k + 1);
                c_idx_2 = '\x00';
                while ((b_k <= n) && (s->data[static_cast<int32_T>(b_k - 1)] ==
                                      ',')) {
                    b_k = static_cast<int32_T>(b_k + 1);
                }

                if (b_k <= n) {
                    c_idx_2 = s->data[static_cast<int32_T>(b_k - 1)];
                }

                if (((c_idx_0 == 'I') || (c_idx_0 == 'i')) && ((c_idx_1 == 'N') ||
                     (c_idx_1 == 'n')) && ((c_idx_2 == 'F') || (c_idx_2 == 'f')))
                {
                } else if ((c_idx_0 == 'N') || (c_idx_0 == 'n')) {
                    if ((c_idx_1 == 'A') || (c_idx_1 == 'a')) {
                        if ((c_idx_2 != 'N') && (c_idx_2 != 'n')) {
                            p = true;
                        }
                    } else {
                        p = true;
                    }
                } else {
                    p = true;
                }
            }
        }
    }

    return p;
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static void FlightMissionMode_readNonFinite(const
    emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n, boolean_T
    *b_finite, real_T *fv)
{
    int32_T ksaved;
    char_T c_idx_0;
    char_T c_idx_1;
    char_T c_idx_2;
    ksaved = *k;
    c_idx_0 = '\x00';
    while ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == ',')) {
        *k = static_cast<int32_T>(*k + 1);
    }

    if (*k <= n) {
        c_idx_0 = s->data[static_cast<int32_T>(*k - 1)];
    }

    *k = static_cast<int32_T>(*k + 1);
    c_idx_1 = '\x00';
    while ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == ',')) {
        *k = static_cast<int32_T>(*k + 1);
    }

    if (*k <= n) {
        c_idx_1 = s->data[static_cast<int32_T>(*k - 1)];
    }

    *k = static_cast<int32_T>(*k + 1);
    c_idx_2 = '\x00';
    while ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == ',')) {
        *k = static_cast<int32_T>(*k + 1);
    }

    if (*k <= n) {
        c_idx_2 = s->data[static_cast<int32_T>(*k - 1)];
    }

    *k = static_cast<int32_T>(*k + 1);
    if (((c_idx_0 == 'I') || (c_idx_0 == 'i')) && ((c_idx_1 == 'N') || (c_idx_1 ==
          'n')) && ((c_idx_2 == 'F') || (c_idx_2 == 'f'))) {
        *b_finite = false;
        *fv = (rtInf);
    } else if (((c_idx_0 == 'N') || (c_idx_0 == 'n')) && ((c_idx_1 == 'A') ||
                (c_idx_1 == 'a')) && ((c_idx_2 == 'N') || (c_idx_2 == 'n'))) {
        *b_finite = false;
        *fv = (rtNaN);
    } else {
        *b_finite = true;
        *fv = 0.0;
        *k = ksaved;
    }
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static boolean_T FlightMissionMode_copydigits
    (emxArray_char_T_FlightMissionMode_T *s1, int32_T *idx, const
     emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n, boolean_T
     allowpoint)
{
    boolean_T exitg1;
    boolean_T haspoint;
    boolean_T success;
    success = (*k <= n);
    haspoint = false;
    exitg1 = false;
    while ((!exitg1) && (static_cast<boolean_T>(static_cast<int32_T>((*k <= n) &
              static_cast<int32_T>(success))))) {
        char_T tmp;
        tmp = s->data[static_cast<int32_T>(*k - 1)];
        if ((tmp >= '0') && (tmp <= '9')) {
            s1->data[static_cast<int32_T>(*idx - 1)] = tmp;
            *idx = static_cast<int32_T>(*idx + 1);
            *k = static_cast<int32_T>(*k + 1);
        } else if (tmp == '.') {
            success = static_cast<boolean_T>(static_cast<int32_T>
                (static_cast<int32_T>(static_cast<boolean_T>(static_cast<int32_T>
                (static_cast<int32_T>(haspoint) ^ 1))) & static_cast<int32_T>
                 (allowpoint)));
            if (success) {
                s1->data[static_cast<int32_T>(*idx - 1)] = '.';
                *idx = static_cast<int32_T>(*idx + 1);
                haspoint = true;
            }

            *k = static_cast<int32_T>(*k + 1);
        } else if (tmp == ',') {
            *k = static_cast<int32_T>(*k + 1);
        } else {
            exitg1 = true;
        }
    }

    return success;
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static boolean_T FlightMissionMode_copyexponent
    (emxArray_char_T_FlightMissionMode_T *s1, int32_T *idx, const
     emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n)
{
    int32_T b_k;
    boolean_T success;
    success = true;
    if (*k <= n) {
        char_T tmp;
        tmp = s->data[static_cast<int32_T>(*k - 1)];
        if ((tmp == 'E') || (tmp == 'e')) {
            int32_T kexp;
            boolean_T b_success;
            s1->data[static_cast<int32_T>(*idx - 1)] = 'e';
            *idx = static_cast<int32_T>(*idx + 1);
            *k = static_cast<int32_T>(*k + 1);
            while ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == ','))
            {
                *k = static_cast<int32_T>(*k + 1);
            }

            if (*k <= n) {
                if (s->data[static_cast<int32_T>(*k - 1)] == '-') {
                    s1->data[static_cast<int32_T>(*idx - 1)] = '-';
                    *idx = static_cast<int32_T>(*idx + 1);
                    *k = static_cast<int32_T>(*k + 1);
                } else if (s->data[static_cast<int32_T>(*k - 1)] == '+') {
                    *k = static_cast<int32_T>(*k + 1);
                }
            }

            kexp = *k;
            b_k = *k;
            b_success = FlightMissionMode_copydigits(s1, idx, s, &b_k, n, false);
            *k = b_k;
            if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                    (static_cast<boolean_T>(static_cast<int32_T>
                    (static_cast<int32_T>(b_success) ^ 1))) | (b_k <= kexp)))) {
                success = false;
            }
        }
    }

    return success;
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static void FlightMissionMode_readfloat(emxArray_char_T_FlightMissionMode_T *s1,
    int32_T *idx, const emxArray_char_T_FlightMissionMode_T *s, int32_T *k,
    int32_T n, boolean_T *isimag, boolean_T *b_finite, real_T *nfv, boolean_T
    *foundsign, boolean_T *success)
{
    static const boolean_T b[128]{ false, false, false, false, false, false,
        false, false, false, true, true, true, true, true, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, true, true, true, true, true, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false };

    int32_T b_idx;
    int32_T b_k;
    boolean_T a__3;
    *isimag = false;
    *b_finite = true;
    *nfv = 0.0;
    b_idx = *idx;
    b_k = *k;
    FlightMissionMode_copysign(s1, &b_idx, s, &b_k, n, foundsign, success);
    *idx = b_idx;
    *k = b_k;
    if (*success) {
        char_T tmp;
        boolean_T exitg1;
        if (FlightMissionMode_isUnitImag(s, b_k, n)) {
            *isimag = true;
            *k = static_cast<int32_T>(b_k + 1);
            exitg1 = false;
            while ((!exitg1) && (*k <= n)) {
                tmp = s->data[static_cast<int32_T>(*k - 1)];
                if (b[static_cast<int32_T>(static_cast<int32_T>(static_cast<
                        uint8_T>(tmp)) & 127)] || (tmp == '\x00') || (tmp == ','))
                {
                    *k = static_cast<int32_T>(*k + 1);
                } else {
                    exitg1 = true;
                }
            }

            if ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == '*')) {
                b_k = static_cast<int32_T>(*k + 1);
                FlightMissionMode_copysign(s1, &b_idx, s, &b_k, n, &a__3,
                    success);
                *idx = b_idx;
                if (*success) {
                    if (FlightMissionMode_isUnitImag(s, b_k, n)) {
                        *success = false;
                    } else {
                        FlightMissionMode_readNonFinite(s, &b_k, n, b_finite,
                            nfv);
                        if (*b_finite) {
                            *success = FlightMissionMode_copydigits(s1, idx, s,
                                &b_k, n, true);
                            if (*success) {
                                *success = FlightMissionMode_copyexponent(s1,
                                    idx, s, &b_k, n);
                            }
                        } else if ((b_idx >= 2) && (s1->data[static_cast<int32_T>
                                                    (b_idx - 2)] == '-')) {
                            *idx = static_cast<int32_T>(b_idx - 1);
                            s1->data[static_cast<int32_T>(b_idx - 2)] = ' ';
                            *nfv = -*nfv;
                        }

                        exitg1 = false;
                        while ((!exitg1) && (b_k <= n)) {
                            tmp = s->data[static_cast<int32_T>(b_k - 1)];
                            if (b[static_cast<int32_T>(static_cast<int32_T>(
                                    static_cast<uint8_T>(tmp)) & 127)] || (tmp ==
                                 '\x00') || (tmp == ',')) {
                                b_k = static_cast<int32_T>(b_k + 1);
                            } else {
                                exitg1 = true;
                            }
                        }

                        if ((b_k <= n) && (s->data[static_cast<int32_T>(b_k - 1)]
                                           == '*')) {
                            b_k = static_cast<int32_T>(b_k + 1);
                            exitg1 = false;
                            while ((!exitg1) && (b_k <= n)) {
                                tmp = s->data[static_cast<int32_T>(b_k - 1)];
                                if (b[static_cast<int32_T>(static_cast<int32_T>(
                                        static_cast<uint8_T>(tmp)) & 127)] ||
                                        (tmp == '\x00') || (tmp == ',')) {
                                    b_k = static_cast<int32_T>(b_k + 1);
                                } else {
                                    exitg1 = true;
                                }
                            }
                        }

                        if (b_k <= n) {
                            tmp = s->data[static_cast<int32_T>(b_k - 1)];
                            if ((tmp == 'i') || (tmp == 'j')) {
                                b_k = static_cast<int32_T>(b_k + 1);
                            }
                        }
                    }

                    exitg1 = false;
                    while ((!exitg1) && (b_k <= n)) {
                        tmp = s->data[static_cast<int32_T>(b_k - 1)];
                        if (b[static_cast<int32_T>(static_cast<int32_T>(
                                static_cast<uint8_T>(tmp)) & 127)] || (tmp ==
                                '\x00') || (tmp == ',')) {
                            b_k = static_cast<int32_T>(b_k + 1);
                        } else {
                            exitg1 = true;
                        }
                    }
                }

                *k = b_k;
            } else {
                s1->data[static_cast<int32_T>(b_idx - 1)] = '1';
                *idx = static_cast<int32_T>(b_idx + 1);
            }
        } else {
            FlightMissionMode_readNonFinite(s, &b_k, n, b_finite, nfv);
            *k = b_k;
            if (*b_finite) {
                *success = FlightMissionMode_copydigits(s1, idx, s, k, n, true);
                if (*success) {
                    *success = FlightMissionMode_copyexponent(s1, idx, s, k, n);
                }
            } else if ((b_idx >= 2) && (s1->data[static_cast<int32_T>(b_idx - 2)]
                        == '-')) {
                *idx = static_cast<int32_T>(b_idx - 1);
                s1->data[static_cast<int32_T>(b_idx - 2)] = ' ';
                *nfv = -*nfv;
            }

            exitg1 = false;
            while ((!exitg1) && (*k <= n)) {
                if (b[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(s->data[
                        static_cast<int32_T>(*k - 1)])) & 127)]) {
                    *k = static_cast<int32_T>(*k + 1);
                } else {
                    tmp = s->data[static_cast<int32_T>(*k - 1)];
                    if ((tmp == '\x00') || (tmp == ',')) {
                        *k = static_cast<int32_T>(*k + 1);
                    } else {
                        exitg1 = true;
                    }
                }
            }

            if ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == '*')) {
                *k = static_cast<int32_T>(*k + 1);
                while ((*k <= n) && (b[static_cast<int32_T>(static_cast<int32_T>
                         (static_cast<uint8_T>(s->data[static_cast<int32_T>(*k -
                            1)])) & 127)] || (s->data[static_cast<int32_T>(*k -
                          1)] == '\x00') || (s->data[static_cast<int32_T>(*k - 1)]
                         == ','))) {
                    *k = static_cast<int32_T>(*k + 1);
                }
            }

            if (*k <= n) {
                tmp = s->data[static_cast<int32_T>(*k - 1)];
                if ((tmp == 'i') || (tmp == 'j')) {
                    *k = static_cast<int32_T>(*k + 1);
                    *isimag = true;
                }
            }
        }

        exitg1 = false;
        while ((!exitg1) && (*k <= n)) {
            if (b[static_cast<int32_T>(static_cast<int32_T>(static_cast<uint8_T>
                    (s->data[static_cast<int32_T>(*k - 1)])) & 127)]) {
                *k = static_cast<int32_T>(*k + 1);
            } else {
                tmp = s->data[static_cast<int32_T>(*k - 1)];
                if ((tmp == '\x00') || (tmp == ',')) {
                    *k = static_cast<int32_T>(*k + 1);
                } else {
                    exitg1 = true;
                }
            }
        }
    }
}

static void FlightMissionMode_emxFree_char_T(emxArray_char_T_FlightMissionMode_T
    **pEmxArray)
{
    if (*pEmxArray != static_cast<emxArray_char_T_FlightMissionMode_T *>(nullptr))
    {
        if (((*pEmxArray)->data != static_cast<char_T *>(nullptr)) &&
                (*pEmxArray)->canFreeData) {
            std::free((*pEmxArray)->data);
        }

        std::free((*pEmxArray)->size);
        std::free(*pEmxArray);
        *pEmxArray = static_cast<emxArray_char_T_FlightMissionMode_T *>(nullptr);
    }
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static creal_T FlightMissionMode_str2double(const
    emxArray_char_T_FlightMissionMode_T *s)
{
    static const boolean_T c[128]{ false, false, false, false, false, false,
        false, false, false, true, true, true, true, true, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, true, true, true, true, true, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false };

    emxArray_char_T_FlightMissionMode_T *s1;
    creal_T x;
    real_T b_scanned1;
    real_T scanned1;
    real_T scanned2;
    int32_T idx;
    int32_T k;
    boolean_T a__1;
    boolean_T c_success;
    boolean_T foundsign;
    boolean_T isfinite1;
    boolean_T isimag1;
    boolean_T success;
    x.re = (rtNaN);
    x.im = 0.0;
    if (s->size[1] >= 1) {
        int32_T i;
        int32_T ntoread;
        boolean_T exitg1;
        FlightMissionMode_emxInit_char_T(&s1, 2);
        ntoread = 0;
        k = 1;
        exitg1 = false;
        while ((!exitg1) && (k <= s->size[1])) {
            char_T tmp;
            tmp = s->data[static_cast<int32_T>(k - 1)];
            if (c[static_cast<int32_T>(static_cast<int32_T>(static_cast<uint8_T>
                    (tmp)) & 127)] || (tmp == '\x00')) {
                k = static_cast<int32_T>(k + 1);
            } else {
                exitg1 = true;
            }
        }

        i = static_cast<int32_T>(s1->size[0] * s1->size[1]);
        s1->size[0] = 1;
        s1->size[1] = static_cast<int32_T>(s->size[1] + 2);
        FlightMissionMode_emxEnsureCapacity_char_T(s1, i);
        idx = s->size[1];
        for (i = 0; i <= static_cast<int32_T>(idx + 1); i++) {
            s1->data[i] = '\x00';
        }

        idx = 1;
        FlightMissionMode_readfloat(s1, &idx, s, &k, s->size[1], &isimag1,
            &isfinite1, &scanned1, &a__1, &success);
        if (isfinite1) {
            ntoread = 1;
        }

        if (success) {
            if (k <= s->size[1]) {
                s1->data[static_cast<int32_T>(idx - 1)] = ' ';
                idx = static_cast<int32_T>(idx + 1);
                FlightMissionMode_readfloat(s1, &idx, s, &k, s->size[1], &a__1,
                    &success, &scanned2, &foundsign, &c_success);
                if (success) {
                    ntoread = static_cast<int32_T>(ntoread + 1);
                }

                success = static_cast<boolean_T>(static_cast<int32_T>(
                    static_cast<int32_T>(static_cast<boolean_T>
                    (static_cast<int32_T>(static_cast<int32_T>
                    (static_cast<boolean_T>(static_cast<int32_T>
                    (static_cast<int32_T>(static_cast<boolean_T>
                    (static_cast<int32_T>(static_cast<int32_T>(isimag1) ^
                    static_cast<int32_T>(a__1)))) & static_cast<int32_T>
                     (foundsign)))) & (k > s->size[1])))) & static_cast<int32_T>
                    (c_success)));
            } else {
                scanned2 = 0.0;
            }
        } else {
            scanned2 = 0.0;
        }

        if (success) {
            s1->data[static_cast<int32_T>(idx - 1)] = '\x00';
            switch (ntoread) {
              case 2:
                ntoread = sscanf(&s1->data[0], "%lf %lf", &scanned1, &scanned2);
                if (ntoread != 2) {
                    scanned1 = (rtNaN);
                    scanned2 = (rtNaN);
                }
                break;

              case 1:
                ntoread = sscanf(&s1->data[0], "%lf", &b_scanned1);
                if (isfinite1) {
                    if (ntoread == 1) {
                        scanned1 = b_scanned1;
                    } else {
                        scanned1 = (rtNaN);
                    }
                } else if (ntoread == 1) {
                    scanned2 = b_scanned1;
                } else {
                    scanned2 = (rtNaN);
                }
                break;
            }

            if (isimag1) {
                x.re = scanned2;
                x.im = scanned1;
            } else {
                x.re = scanned1;
                x.im = scanned2;
            }
        }

        FlightMissionMode_emxFree_char_T(&s1);
    }

    return x;
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static int32_T FlightMissionMode_cfclose(real_T fid,
    DW_StartPointGenerator_FlightMissionMode_T *localDW)
{
    FILE* filestar;
    int32_T st;
    int8_T b_fileid;
    int8_T fileid;
    st = -1;
    fileid = static_cast<int8_T>(fid);
    if (fid != static_cast<real_T>(static_cast<int8_T>(fid))) {
        fileid = -1;
    }

    b_fileid = fileid;
    if (static_cast<int32_T>(fileid) < 0) {
        b_fileid = -1;
    }

    if (static_cast<int32_T>(b_fileid) >= 3) {
        filestar = localDW->eml_openfiles[static_cast<int32_T>
            (static_cast<int32_T>(b_fileid) - 3)];
    } else {
        switch (static_cast<int32_T>(b_fileid)) {
          case 0:
            filestar = stdin;
            break;

          case 1:
            filestar = stdout;
            break;

          case 2:
            filestar = stderr;
            break;

          default:
            filestar = NULL;
            break;
        }
    }

    if (static_cast<boolean_T>(static_cast<int32_T>((filestar != NULL) & (
            static_cast<int32_T>(fileid) >= 3)))) {
        int32_T cst;
        cst = fclose(filestar);
        if (cst == 0) {
            st = 0;
            localDW->eml_openfiles[static_cast<int32_T>(static_cast<int32_T>
                (fileid) - 3)] = NULL;
        }
    }

    return st;
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static void FlightMissionMode_strtok(const emxArray_char_T_FlightMissionMode_T
    *x, emxArray_char_T_FlightMissionMode_T *token,
    emxArray_char_T_FlightMissionMode_T *remain)
{
    int32_T b;
    int32_T i;
    int32_T itoken;
    int32_T k;
    int32_T n;
    n = x->size[1];
    k = 0;
    while ((static_cast<int32_T>(k + 1) <= n) && (x->data[k] == '\x0a')) {
        k = static_cast<int32_T>(k + 1);
    }

    itoken = static_cast<int32_T>(k + 1);
    while ((static_cast<int32_T>(k + 1) <= n) && (x->data[k] != '\x0a')) {
        k = static_cast<int32_T>(k + 1);
    }

    if (static_cast<int32_T>(k + 1) > x->size[1]) {
        n = 0;
        b = 0;
    } else {
        n = k;
        b = x->size[1];
    }

    i = static_cast<int32_T>(remain->size[0] * remain->size[1]);
    remain->size[0] = 1;
    b = static_cast<int32_T>(b - n);
    remain->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T(remain, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        remain->data[i] = x->data[static_cast<int32_T>(n + i)];
    }

    if (itoken > k) {
        itoken = 0;
        k = 0;
    } else {
        itoken = static_cast<int32_T>(itoken - 1);
    }

    i = static_cast<int32_T>(token->size[0] * token->size[1]);
    token->size[0] = 1;
    b = static_cast<int32_T>(k - itoken);
    token->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T(token, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        token->data[i] = x->data[static_cast<int32_T>(itoken + i)];
    }
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static void FlightMissionMode_strtok_j(const emxArray_char_T_FlightMissionMode_T
    *x, emxArray_char_T_FlightMissionMode_T *token)
{
    int32_T itoken;
    int32_T k;
    int32_T n;
    n = x->size[1];
    k = 1;
    while ((k <= n) && (x->data[static_cast<int32_T>(k - 1)] == ';')) {
        k = static_cast<int32_T>(k + 1);
    }

    itoken = k;
    while ((k <= n) && (x->data[static_cast<int32_T>(k - 1)] != ';')) {
        k = static_cast<int32_T>(k + 1);
    }

    if (itoken > static_cast<int32_T>(k - 1)) {
        n = 0;
        k = 0;
    } else {
        n = static_cast<int32_T>(itoken - 1);
        k = static_cast<int32_T>(k - 1);
    }

    itoken = static_cast<int32_T>(token->size[0] * token->size[1]);
    token->size[0] = 1;
    k = static_cast<int32_T>(k - n);
    token->size[1] = k;
    FlightMissionMode_emxEnsureCapacity_char_T(token, itoken);
    for (itoken = 0; itoken <= static_cast<int32_T>(k - 1); itoken++) {
        token->data[itoken] = x->data[static_cast<int32_T>(n + itoken)];
    }
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static void FlightMissionMode_strtrim(const emxArray_char_T_FlightMissionMode_T *
    x, emxArray_char_T_FlightMissionMode_T *y)
{
    static const boolean_T d[128]{ false, false, false, false, false, false,
        false, false, false, true, true, true, true, true, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, true, true, true, true, true, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false };

    int32_T b_j1;
    int32_T i;
    int32_T j2;
    b_j1 = 0;
    while ((static_cast<int32_T>(b_j1 + 1) <= x->size[1]) &&
            (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(d[
               static_cast<int32_T>(static_cast<int32_T>(static_cast<uint8_T>
                 (x->data[b_j1])) & 127)]) & (x->data[b_j1] != '\x00'))))) {
        b_j1 = static_cast<int32_T>(b_j1 + 1);
    }

    j2 = static_cast<int32_T>(x->size[1] - 1);
    while ((static_cast<int32_T>(j2 + 1) > 0) && (static_cast<boolean_T>(
             static_cast<int32_T>(static_cast<int32_T>(d[static_cast<int32_T>(
                static_cast<int32_T>(static_cast<uint8_T>(x->data[j2])) & 127)])
              & (x->data[j2] != '\x00'))))) {
        j2 = static_cast<int32_T>(j2 - 1);
    }

    if (static_cast<int32_T>(b_j1 + 1) > static_cast<int32_T>(j2 + 1)) {
        b_j1 = 0;
        j2 = -1;
    }

    i = static_cast<int32_T>(y->size[0] * y->size[1]);
    y->size[0] = 1;
    j2 = static_cast<int32_T>(j2 - b_j1);
    y->size[1] = static_cast<int32_T>(j2 + 1);
    FlightMissionMode_emxEnsureCapacity_char_T(y, i);
    for (i = 0; i <= j2; i++) {
        y->data[i] = x->data[static_cast<int32_T>(b_j1 + i)];
    }
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static boolean_T FlightMissionMode_strcmp(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[3]{ 'U', 'A', 'V' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T(aTmp, i);
        loop_ub = a->size[1];
        for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 3) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 3) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static boolean_T FlightMissionMode_strcmp_f(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[10]{ 'N', 'o', 'r', 'm', 'A', 'i', 'r', 'S', 'p', 'd'
    };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T(aTmp, i);
        loop_ub = a->size[1];
        for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 10) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 10) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static boolean_T FlightMissionMode_contains(const
    emxArray_char_T_FlightMissionMode_T *str)
{
    int32_T matchPos;
    matchPos = 0;
    int32_T exitg1;
    do {
        exitg1 = 0;
        if (matchPos <= static_cast<int32_T>(str->size[1] - 1)) {
            if (str->data[matchPos] == '=') {
                exitg1 = 1;
            } else {
                matchPos = static_cast<int32_T>(matchPos + 1);
            }
        } else {
            matchPos = -1;
            exitg1 = 1;
        }
    } while (exitg1 == 0);

    return static_cast<int32_T>(matchPos + 1) > 0;
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static void FlightMissionMode_find_token(const
    emxArray_char_T_FlightMissionMode_T *x, int32_T *itoken, int32_T *iremain)
{
    int32_T n;
    n = x->size[1];
    *iremain = 1;
    while ((*iremain <= n) && (x->data[static_cast<int32_T>(*iremain - 1)] ==
                               '=')) {
        *iremain = static_cast<int32_T>(*iremain + 1);
    }

    *itoken = *iremain;
    while ((*iremain <= n) && (x->data[static_cast<int32_T>(*iremain - 1)] !=
                               '=')) {
        *iremain = static_cast<int32_T>(*iremain + 1);
    }
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static void FlightMissionMode_strtok_jy(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token, emxArray_char_T_FlightMissionMode_T *remain)
{
    int32_T b;
    int32_T c;
    int32_T i;
    int32_T iremain;
    int32_T itoken;
    FlightMissionMode_find_token(x, &itoken, &iremain);
    if (iremain > x->size[1]) {
        c = 0;
        b = 0;
    } else {
        c = static_cast<int32_T>(iremain - 1);
        b = x->size[1];
    }

    i = static_cast<int32_T>(remain->size[0] * remain->size[1]);
    remain->size[0] = 1;
    b = static_cast<int32_T>(b - c);
    remain->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T(remain, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        remain->data[i] = x->data[static_cast<int32_T>(c + i)];
    }

    if (itoken > static_cast<int32_T>(iremain - 1)) {
        itoken = 0;
        iremain = 0;
    } else {
        itoken = static_cast<int32_T>(itoken - 1);
        iremain = static_cast<int32_T>(iremain - 1);
    }

    i = static_cast<int32_T>(token->size[0] * token->size[1]);
    token->size[0] = 1;
    b = static_cast<int32_T>(iremain - itoken);
    token->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T(token, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        token->data[i] = x->data[static_cast<int32_T>(itoken + i)];
    }
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static void FlightMissionMode_strtok_jyq(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token)
{
    int32_T i;
    int32_T iremain;
    int32_T itoken;
    FlightMissionMode_find_token(x, &itoken, &iremain);
    if (itoken > static_cast<int32_T>(iremain - 1)) {
        itoken = 0;
        iremain = 0;
    } else {
        itoken = static_cast<int32_T>(itoken - 1);
        iremain = static_cast<int32_T>(iremain - 1);
    }

    i = static_cast<int32_T>(token->size[0] * token->size[1]);
    token->size[0] = 1;
    iremain = static_cast<int32_T>(iremain - itoken);
    token->size[1] = iremain;
    FlightMissionMode_emxEnsureCapacity_char_T(token, i);
    for (i = 0; i <= static_cast<int32_T>(iremain - 1); i++) {
        token->data[i] = x->data[static_cast<int32_T>(itoken + i)];
    }
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static boolean_T FlightMissionMode_strcmp_f4(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[9]{ 'M', 'a', 'x', 'A', 'i', 'r', 'S', 'p', 'd' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T(aTmp, i);
        loop_ub = a->size[1];
        for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 9) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 9) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static void FlightMissionMode_readINI(emxArray_char_T_FlightMissionMode_T *ret,
    DW_StartPointGenerator_FlightMissionMode_T *localDW)
{
    static const char_T h[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T i[15]{ 'C', 'l', 'i', 'm', 'b', 'A', 'n', 'g', 'l', 'e',
        'L', 'i', 'm', 'i', 't' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    emxArray_char_T_FlightMissionMode_T *curKey;
    emxArray_char_T_FlightMissionMode_T *curLine;
    emxArray_char_T_FlightMissionMode_T *curSection;
    emxArray_char_T_FlightMissionMode_T *curVal;
    emxArray_char_T_FlightMissionMode_T *data;
    emxArray_char_T_FlightMissionMode_T *data_0;
    emxArray_char_T_FlightMissionMode_T *j;
    emxArray_char_T_FlightMissionMode_T *tmp;
    int32_T iremain;
    int32_T itoken;
    int8_T fileid;
    ret->size[0] = 1;
    ret->size[1] = 0;
    fileid = FlightMissionMode_cfopen("config.ini", "rb", localDW);
    if (static_cast<int32_T>(fileid) < 0) {
        printf("INI-file \"%s\" was not found or could not be read.\n",
               "config.ini");
        fflush(stdout);
    } else {
        int32_T i_0;
        int32_T loop_ub;
        FlightMissionMode_emxInit_char_T(&j, 1);
        FlightMissionMode_fread(static_cast<real_T>(fileid), j, localDW);
        FlightMissionMode_emxInit_char_T(&data, 2);
        i_0 = static_cast<int32_T>(data->size[0] * data->size[1]);
        data->size[0] = 1;
        data->size[1] = j->size[0];
        FlightMissionMode_emxEnsureCapacity_char_T(data, i_0);
        loop_ub = j->size[0];
        for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub - 1); i_0++) {
            data->data[i_0] = j->data[i_0];
        }

        FlightMissionMode_emxFree_char_T(&j);
        FlightMissionMode_cfclose(static_cast<real_T>(fileid), localDW);
        FlightMissionMode_emxInit_char_T(&curSection, 2);
        curSection->size[0] = 1;
        curSection->size[1] = 0;
        FlightMissionMode_emxInit_char_T(&curKey, 2);
        curKey->size[0] = 1;
        curKey->size[1] = 0;
        FlightMissionMode_emxInit_char_T(&curVal, 2);
        curVal->size[0] = 1;
        curVal->size[1] = 0;
        FlightMissionMode_emxInit_char_T(&curLine, 2);
        FlightMissionMode_emxInit_char_T(&aTmp, 2);
        FlightMissionMode_emxInit_char_T(&tmp, 2);
        FlightMissionMode_emxInit_char_T(&data_0, 2);
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (data->size[1] != 0) {
                boolean_T b_bool;
                i_0 = static_cast<int32_T>(data_0->size[0] * data_0->size[1]);
                data_0->size[0] = 1;
                data_0->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T(data_0, i_0);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (i_0 = 0; i_0 <= loop_ub; i_0++) {
                    data_0->data[i_0] = data->data[i_0];
                }

                FlightMissionMode_strtok(data_0, curLine, data);
                FlightMissionMode_strtok_j(curLine, tmp);
                FlightMissionMode_strtrim(tmp, curLine);
                if (curLine->size[1] >= 2) {
                    boolean_T guard1{ false };

                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                iremain = 0;
                                itoken = 0;
                            } else {
                                iremain = 1;
                                itoken = static_cast<int32_T>(curLine->size[1] -
                                    1);
                            }

                            i_0 = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(itoken - iremain);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T
                                (curSection, i_0);
                            for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub -
                                    1); i_0++) {
                                curSection->data[i_0] = curLine->data[
                                    static_cast<int32_T>(iremain + i_0)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains(curLine)) {
                            FlightMissionMode_strtok_jy(curLine, aTmp, curVal);
                            FlightMissionMode_find_token(curVal, &itoken,
                                &iremain);
                            if (itoken > static_cast<int32_T>(iremain - 1)) {
                                itoken = 0;
                                iremain = 0;
                            } else {
                                itoken = static_cast<int32_T>(itoken - 1);
                                iremain = static_cast<int32_T>(iremain - 1);
                            }

                            FlightMissionMode_strtrim(aTmp, curKey);
                            i_0 = static_cast<int32_T>(curLine->size[0] *
                                curLine->size[1]);
                            curLine->size[0] = 1;
                            loop_ub = static_cast<int32_T>(iremain - itoken);
                            curLine->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T(curLine,
                                i_0);
                            for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub -
                                    1); i_0++) {
                                curLine->data[i_0] = curVal->data
                                    [static_cast<int32_T>(itoken + i_0)];
                            }

                            FlightMissionMode_strtrim(curLine, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp(curSection)) {
                    if (curKey->size[1] == 0) {
                        aTmp->size[0] = 1;
                        aTmp->size[1] = 0;
                    } else {
                        i_0 = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
                        aTmp->size[0] = 1;
                        aTmp->size[1] = curKey->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T(aTmp, i_0);
                        loop_ub = curKey->size[1];
                        for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub - 1);
                                i_0++) {
                            aTmp->data[i_0] = curKey->data[i_0];
                        }
                    }

                    b_bool = false;
                    if (aTmp->size[1] == 15) {
                        iremain = 0;
                        int32_T exitg2;
                        do {
                            exitg2 = 0;
                            if (iremain < 15) {
                                if (h[static_cast<int32_T>(static_cast<int32_T>(
                                        static_cast<uint8_T>(aTmp->data[iremain]))
                                     & 127)] != h[static_cast<int32_T>(i[iremain])])
                                {
                                    exitg2 = 1;
                                } else {
                                    iremain = static_cast<int32_T>(iremain + 1);
                                }
                            } else {
                                b_bool = true;
                                exitg2 = 1;
                            }
                        } while (exitg2 == 0);
                    }

                    if (b_bool) {
                        i_0 = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                        ret->size[0] = 1;
                        ret->size[1] = curVal->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T(ret, i_0);
                        loop_ub = curVal->size[1];
                        for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub - 1);
                                i_0++) {
                            ret->data[i_0] = curVal->data[i_0];
                        }

                        exitg1 = 1;
                    }
                }
            } else {
                exitg1 = 1;
            }
        } while (exitg1 == 0);

        FlightMissionMode_emxFree_char_T(&data_0);
        FlightMissionMode_emxFree_char_T(&tmp);
        FlightMissionMode_emxFree_char_T(&aTmp);
        FlightMissionMode_emxFree_char_T(&curLine);
        FlightMissionMode_emxFree_char_T(&curVal);
        FlightMissionMode_emxFree_char_T(&curKey);
        FlightMissionMode_emxFree_char_T(&curSection);
        FlightMissionMode_emxFree_char_T(&data);
    }
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static void FlightMissionMode_readINI_k(emxArray_char_T_FlightMissionMode_T *ret,
    DW_StartPointGenerator_FlightMissionMode_T *localDW)
{
    static const char_T h[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T i[14]{ 'D', 'i', 'v', 'e', 'A', 'n', 'g', 'l', 'e', 'L',
        'i', 'm', 'i', 't' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    emxArray_char_T_FlightMissionMode_T *curKey;
    emxArray_char_T_FlightMissionMode_T *curLine;
    emxArray_char_T_FlightMissionMode_T *curSection;
    emxArray_char_T_FlightMissionMode_T *curVal;
    emxArray_char_T_FlightMissionMode_T *data;
    emxArray_char_T_FlightMissionMode_T *data_0;
    emxArray_char_T_FlightMissionMode_T *j;
    emxArray_char_T_FlightMissionMode_T *tmp;
    int32_T iremain;
    int32_T itoken;
    int8_T fileid;
    ret->size[0] = 1;
    ret->size[1] = 0;
    fileid = FlightMissionMode_cfopen("config.ini", "rb", localDW);
    if (static_cast<int32_T>(fileid) < 0) {
        printf("INI-file \"%s\" was not found or could not be read.\n",
               "config.ini");
        fflush(stdout);
    } else {
        int32_T i_0;
        int32_T loop_ub;
        FlightMissionMode_emxInit_char_T(&j, 1);
        FlightMissionMode_fread(static_cast<real_T>(fileid), j, localDW);
        FlightMissionMode_emxInit_char_T(&data, 2);
        i_0 = static_cast<int32_T>(data->size[0] * data->size[1]);
        data->size[0] = 1;
        data->size[1] = j->size[0];
        FlightMissionMode_emxEnsureCapacity_char_T(data, i_0);
        loop_ub = j->size[0];
        for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub - 1); i_0++) {
            data->data[i_0] = j->data[i_0];
        }

        FlightMissionMode_emxFree_char_T(&j);
        FlightMissionMode_cfclose(static_cast<real_T>(fileid), localDW);
        FlightMissionMode_emxInit_char_T(&curSection, 2);
        curSection->size[0] = 1;
        curSection->size[1] = 0;
        FlightMissionMode_emxInit_char_T(&curKey, 2);
        curKey->size[0] = 1;
        curKey->size[1] = 0;
        FlightMissionMode_emxInit_char_T(&curVal, 2);
        curVal->size[0] = 1;
        curVal->size[1] = 0;
        FlightMissionMode_emxInit_char_T(&curLine, 2);
        FlightMissionMode_emxInit_char_T(&aTmp, 2);
        FlightMissionMode_emxInit_char_T(&tmp, 2);
        FlightMissionMode_emxInit_char_T(&data_0, 2);
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (data->size[1] != 0) {
                boolean_T b_bool;
                i_0 = static_cast<int32_T>(data_0->size[0] * data_0->size[1]);
                data_0->size[0] = 1;
                data_0->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T(data_0, i_0);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (i_0 = 0; i_0 <= loop_ub; i_0++) {
                    data_0->data[i_0] = data->data[i_0];
                }

                FlightMissionMode_strtok(data_0, curLine, data);
                FlightMissionMode_strtok_j(curLine, tmp);
                FlightMissionMode_strtrim(tmp, curLine);
                if (curLine->size[1] >= 2) {
                    boolean_T guard1{ false };

                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                iremain = 0;
                                itoken = 0;
                            } else {
                                iremain = 1;
                                itoken = static_cast<int32_T>(curLine->size[1] -
                                    1);
                            }

                            i_0 = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(itoken - iremain);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T
                                (curSection, i_0);
                            for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub -
                                    1); i_0++) {
                                curSection->data[i_0] = curLine->data[
                                    static_cast<int32_T>(iremain + i_0)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains(curLine)) {
                            FlightMissionMode_strtok_jy(curLine, aTmp, curVal);
                            FlightMissionMode_find_token(curVal, &itoken,
                                &iremain);
                            if (itoken > static_cast<int32_T>(iremain - 1)) {
                                itoken = 0;
                                iremain = 0;
                            } else {
                                itoken = static_cast<int32_T>(itoken - 1);
                                iremain = static_cast<int32_T>(iremain - 1);
                            }

                            FlightMissionMode_strtrim(aTmp, curKey);
                            i_0 = static_cast<int32_T>(curLine->size[0] *
                                curLine->size[1]);
                            curLine->size[0] = 1;
                            loop_ub = static_cast<int32_T>(iremain - itoken);
                            curLine->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T(curLine,
                                i_0);
                            for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub -
                                    1); i_0++) {
                                curLine->data[i_0] = curVal->data
                                    [static_cast<int32_T>(itoken + i_0)];
                            }

                            FlightMissionMode_strtrim(curLine, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp(curSection)) {
                    if (curKey->size[1] == 0) {
                        aTmp->size[0] = 1;
                        aTmp->size[1] = 0;
                    } else {
                        i_0 = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
                        aTmp->size[0] = 1;
                        aTmp->size[1] = curKey->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T(aTmp, i_0);
                        loop_ub = curKey->size[1];
                        for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub - 1);
                                i_0++) {
                            aTmp->data[i_0] = curKey->data[i_0];
                        }
                    }

                    b_bool = false;
                    if (aTmp->size[1] == 14) {
                        iremain = 0;
                        int32_T exitg2;
                        do {
                            exitg2 = 0;
                            if (iremain < 14) {
                                if (h[static_cast<int32_T>(static_cast<int32_T>(
                                        static_cast<uint8_T>(aTmp->data[iremain]))
                                     & 127)] != h[static_cast<int32_T>(i[iremain])])
                                {
                                    exitg2 = 1;
                                } else {
                                    iremain = static_cast<int32_T>(iremain + 1);
                                }
                            } else {
                                b_bool = true;
                                exitg2 = 1;
                            }
                        } while (exitg2 == 0);
                    }

                    if (b_bool) {
                        i_0 = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                        ret->size[0] = 1;
                        ret->size[1] = curVal->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T(ret, i_0);
                        loop_ub = curVal->size[1];
                        for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub - 1);
                                i_0++) {
                            ret->data[i_0] = curVal->data[i_0];
                        }

                        exitg1 = 1;
                    }
                }
            } else {
                exitg1 = 1;
            }
        } while (exitg1 == 0);

        FlightMissionMode_emxFree_char_T(&data_0);
        FlightMissionMode_emxFree_char_T(&tmp);
        FlightMissionMode_emxFree_char_T(&aTmp);
        FlightMissionMode_emxFree_char_T(&curLine);
        FlightMissionMode_emxFree_char_T(&curVal);
        FlightMissionMode_emxFree_char_T(&curKey);
        FlightMissionMode_emxFree_char_T(&curSection);
        FlightMissionMode_emxFree_char_T(&data);
    }
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static boolean_T FlightMissionMode_strcmp_f4p(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[9]{ 'M', 'i', 'n', 'A', 'i', 'r', 'S', 'p', 'd' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T(aTmp, i);
        loop_ub = a->size[1];
        for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 9) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 9) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static boolean_T FlightMissionMode_strcmp_f4pn(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[12]{ 'M', 'a', 'x', 'R', 'o', 'l', 'l', 'A', 'n', 'g',
        'l', 'e' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T(aTmp, i);
        loop_ub = a->size[1];
        for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 12) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 12) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static uavDubinsConnection_FlightMissionMode_T
    *FlightMissionMode_uavDubinsConnection_uavDubinsConnection
    (uavDubinsConnection_FlightMissionMode_T *b_this, real_T varargin_2, real_T
     varargin_4, const real_T varargin_6[2])
{
    uavDubinsConnection_FlightMissionMode_T *c_this;
    real_T b_x;
    c_this = b_this;
    b_this->AirSpeed = 10.0;
    b_this->FlightPathAngleLimit[0] = varargin_6[0];
    b_this->FlightPathAngleLimit[1] = varargin_6[1];
    b_this->MaxRollAngle = varargin_4;
    b_x = b_this->MaxRollAngle;
    b_this->MinTurningRadius = b_this->AirSpeed * b_this->AirSpeed / (9.8 * std::
        tan(b_x));
    b_this->AirSpeed = varargin_2;
    b_x = b_this->MaxRollAngle;
    b_this->MinTurningRadius = b_this->AirSpeed * b_this->AirSpeed / (9.8 * std::
        tan(b_x));
    b_x = b_this->MaxRollAngle;
    b_this->MinTurningRadius = b_this->AirSpeed * b_this->AirSpeed / (9.8 * std::
        tan(b_x));
    return c_this;
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static uavDubinsConnection_FlightMissionMode_T
    *FlightMissionMode_DubinsObjSingleton_getConnector
    (DW_StartPointGenerator_FlightMissionMode_T *localDW)
{
    emxArray_char_T_FlightMissionMode_T *b_remainder;
    emxArray_char_T_FlightMissionMode_T *curKey;
    emxArray_char_T_FlightMissionMode_T *curLine;
    emxArray_char_T_FlightMissionMode_T *curSection;
    emxArray_char_T_FlightMissionMode_T *curVal;
    emxArray_char_T_FlightMissionMode_T *data;
    emxArray_char_T_FlightMissionMode_T *data_0;
    emxArray_char_T_FlightMissionMode_T *data_1;
    emxArray_char_T_FlightMissionMode_T *data_2;
    emxArray_char_T_FlightMissionMode_T *data_3;
    emxArray_char_T_FlightMissionMode_T *k;
    emxArray_char_T_FlightMissionMode_T *ret;
    emxArray_char_T_FlightMissionMode_T *tmp_1;
    emxArray_char_T_FlightMissionMode_T *tmp_2;
    emxArray_char_T_FlightMissionMode_T *tmp_3;
    emxArray_char_T_FlightMissionMode_T *tmp_4;
    emxArray_char_T_FlightMissionMode_T *tmp_5;
    emxArray_char_T_FlightMissionMode_T *tmp_6;
    emxArray_char_T_FlightMissionMode_T *tmp_7;
    emxArray_char_T_FlightMissionMode_T *tmp_8;
    uavDubinsConnection_FlightMissionMode_T *outputArg;
    real_T tmp_9[2];
    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
            (localDW->SingletonInstance_not_empty) ^ 1))) {
        creal_T tmp;
        creal_T tmp_0;
        real_T ClimbAngleLimit;
        real_T DiveAngleLimit;
        real_T fid;
        int32_T b;
        int32_T c;
        int32_T i;
        int32_T loop_ub;
        boolean_T b_bool;
        boolean_T exitg1;
        boolean_T guard1{ false };

        localDW->SingletonInstance.AirSpeed = 35.0;
        localDW->SingletonInstance.MaxRollAngle = 0.3490658503988659;
        localDW->SingletonInstance.FlightPathAngleLimit[0] = -0.175;
        localDW->SingletonInstance.FlightPathAngleLimit[1] = 0.175;
        FlightMissionMode_emxInit_char_T(&ret, 2);
        ret->size[0] = 1;
        ret->size[1] = 0;
        fid = FlightMissionMode_fileManager(localDW);
        FlightMissionMode_emxInit_char_T(&data, 2);
        FlightMissionMode_emxInit_char_T(&curSection, 2);
        FlightMissionMode_emxInit_char_T(&curKey, 2);
        FlightMissionMode_emxInit_char_T(&curVal, 2);
        FlightMissionMode_emxInit_char_T(&curLine, 2);
        FlightMissionMode_emxInit_char_T(&b_remainder, 2);
        FlightMissionMode_emxInit_char_T(&k, 1);
        if (fid < 0.0) {
            printf("INI-file \"%s\" was not found or could not be read.\n",
                   "config.ini");
            fflush(stdout);
        } else {
            FlightMissionMode_fread(fid, k, localDW);
            i = static_cast<int32_T>(data->size[0] * data->size[1]);
            data->size[0] = 1;
            data->size[1] = k->size[0];
            FlightMissionMode_emxEnsureCapacity_char_T(data, i);
            loop_ub = k->size[0];
            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                data->data[b] = k->data[b];
            }

            FlightMissionMode_cfclose(fid, localDW);
            curSection->size[0] = 1;
            curSection->size[1] = 0;
            curKey->size[0] = 1;
            curKey->size[1] = 0;
            curVal->size[0] = 1;
            curVal->size[1] = 0;
            FlightMissionMode_emxInit_char_T(&tmp_7, 2);
            FlightMissionMode_emxInit_char_T(&tmp_8, 2);
            FlightMissionMode_emxInit_char_T(&data_3, 2);
            exitg1 = false;
            while ((!exitg1) && (data->size[1] != 0)) {
                i = static_cast<int32_T>(data_3->size[0] * data_3->size[1]);
                data_3->size[0] = 1;
                data_3->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T(data_3, i);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (i = 0; i <= loop_ub; i++) {
                    data_3->data[i] = data->data[i];
                }

                FlightMissionMode_strtok(data_3, curLine, data);
                FlightMissionMode_strtok_j(curLine, tmp_8);
                FlightMissionMode_strtrim(tmp_8, curLine);
                if (curLine->size[1] >= 2) {
                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                c = 0;
                                b = 0;
                            } else {
                                c = 1;
                                b = static_cast<int32_T>(curLine->size[1] - 1);
                            }

                            i = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(b - c);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T
                                (curSection, i);
                            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1);
                                    b++) {
                                curSection->data[b] = curLine->data[static_cast<
                                    int32_T>(c + b)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains(curLine)) {
                            FlightMissionMode_strtok_jy(curLine, curVal,
                                b_remainder);
                            FlightMissionMode_strtrim(curVal, curKey);
                            FlightMissionMode_strtok_jyq(b_remainder, tmp_7);
                            FlightMissionMode_strtrim(tmp_7, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp(curSection) &&
                        FlightMissionMode_strcmp_f(curKey)) {
                    i = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                    ret->size[0] = 1;
                    ret->size[1] = curVal->size[1];
                    FlightMissionMode_emxEnsureCapacity_char_T(ret, i);
                    loop_ub = curVal->size[1];
                    for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                        ret->data[b] = curVal->data[b];
                    }

                    exitg1 = true;
                }
            }

            FlightMissionMode_emxFree_char_T(&data_3);
            FlightMissionMode_emxFree_char_T(&tmp_8);
            FlightMissionMode_emxFree_char_T(&tmp_7);
        }

        tmp = FlightMissionMode_str2double(ret);
        printf("Set UAV NormAirSpeed:\t\t%f\n", tmp.re);
        fflush(stdout);
        ret->size[0] = 1;
        ret->size[1] = 0;
        fid = FlightMissionMode_fileManager(localDW);
        if (fid < 0.0) {
            printf("INI-file \"%s\" was not found or could not be read.\n",
                   "config.ini");
            fflush(stdout);
        } else {
            FlightMissionMode_fread(fid, k, localDW);
            i = static_cast<int32_T>(data->size[0] * data->size[1]);
            data->size[0] = 1;
            data->size[1] = k->size[0];
            FlightMissionMode_emxEnsureCapacity_char_T(data, i);
            loop_ub = k->size[0];
            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                data->data[b] = k->data[b];
            }

            FlightMissionMode_cfclose(fid, localDW);
            curSection->size[0] = 1;
            curSection->size[1] = 0;
            curKey->size[0] = 1;
            curKey->size[1] = 0;
            curVal->size[0] = 1;
            curVal->size[1] = 0;
            FlightMissionMode_emxInit_char_T(&tmp_5, 2);
            FlightMissionMode_emxInit_char_T(&tmp_6, 2);
            FlightMissionMode_emxInit_char_T(&data_2, 2);
            exitg1 = false;
            while ((!exitg1) && (data->size[1] != 0)) {
                i = static_cast<int32_T>(data_2->size[0] * data_2->size[1]);
                data_2->size[0] = 1;
                data_2->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T(data_2, i);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (i = 0; i <= loop_ub; i++) {
                    data_2->data[i] = data->data[i];
                }

                FlightMissionMode_strtok(data_2, curLine, data);
                FlightMissionMode_strtok_j(curLine, tmp_6);
                FlightMissionMode_strtrim(tmp_6, curLine);
                if (curLine->size[1] >= 2) {
                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                c = 0;
                                b = 0;
                            } else {
                                c = 1;
                                b = static_cast<int32_T>(curLine->size[1] - 1);
                            }

                            i = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(b - c);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T
                                (curSection, i);
                            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1);
                                    b++) {
                                curSection->data[b] = curLine->data[static_cast<
                                    int32_T>(c + b)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains(curLine)) {
                            FlightMissionMode_strtok_jy(curLine, curVal,
                                b_remainder);
                            FlightMissionMode_strtrim(curVal, curKey);
                            FlightMissionMode_strtok_jyq(b_remainder, tmp_5);
                            FlightMissionMode_strtrim(tmp_5, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp(curSection) &&
                        FlightMissionMode_strcmp_f4(curKey)) {
                    i = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                    ret->size[0] = 1;
                    ret->size[1] = curVal->size[1];
                    FlightMissionMode_emxEnsureCapacity_char_T(ret, i);
                    loop_ub = curVal->size[1];
                    for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                        ret->data[b] = curVal->data[b];
                    }

                    exitg1 = true;
                }
            }

            FlightMissionMode_emxFree_char_T(&data_2);
            FlightMissionMode_emxFree_char_T(&tmp_6);
            FlightMissionMode_emxFree_char_T(&tmp_5);
        }

        tmp_0 = FlightMissionMode_str2double(ret);
        printf("Set UAV MaxAirSpeed:\t\t%f\n", tmp_0.re);
        fflush(stdout);
        ret->size[0] = 1;
        ret->size[1] = 0;
        fid = FlightMissionMode_fileManager(localDW);
        if (fid < 0.0) {
            printf("INI-file \"%s\" was not found or could not be read.\n",
                   "config.ini");
            fflush(stdout);
        } else {
            FlightMissionMode_fread(fid, k, localDW);
            i = static_cast<int32_T>(data->size[0] * data->size[1]);
            data->size[0] = 1;
            data->size[1] = k->size[0];
            FlightMissionMode_emxEnsureCapacity_char_T(data, i);
            loop_ub = k->size[0];
            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                data->data[b] = k->data[b];
            }

            FlightMissionMode_cfclose(fid, localDW);
            curSection->size[0] = 1;
            curSection->size[1] = 0;
            curKey->size[0] = 1;
            curKey->size[1] = 0;
            curVal->size[0] = 1;
            curVal->size[1] = 0;
            FlightMissionMode_emxInit_char_T(&tmp_3, 2);
            FlightMissionMode_emxInit_char_T(&tmp_4, 2);
            FlightMissionMode_emxInit_char_T(&data_1, 2);
            exitg1 = false;
            while ((!exitg1) && (data->size[1] != 0)) {
                i = static_cast<int32_T>(data_1->size[0] * data_1->size[1]);
                data_1->size[0] = 1;
                data_1->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T(data_1, i);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (i = 0; i <= loop_ub; i++) {
                    data_1->data[i] = data->data[i];
                }

                FlightMissionMode_strtok(data_1, curLine, data);
                FlightMissionMode_strtok_j(curLine, tmp_4);
                FlightMissionMode_strtrim(tmp_4, curLine);
                if (curLine->size[1] >= 2) {
                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                c = 0;
                                b = 0;
                            } else {
                                c = 1;
                                b = static_cast<int32_T>(curLine->size[1] - 1);
                            }

                            i = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(b - c);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T
                                (curSection, i);
                            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1);
                                    b++) {
                                curSection->data[b] = curLine->data[static_cast<
                                    int32_T>(c + b)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains(curLine)) {
                            FlightMissionMode_strtok_jy(curLine, curVal,
                                b_remainder);
                            FlightMissionMode_strtrim(curVal, curKey);
                            FlightMissionMode_strtok_jyq(b_remainder, tmp_3);
                            FlightMissionMode_strtrim(tmp_3, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp(curSection) &&
                        FlightMissionMode_strcmp_f4p(curKey)) {
                    i = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                    ret->size[0] = 1;
                    ret->size[1] = curVal->size[1];
                    FlightMissionMode_emxEnsureCapacity_char_T(ret, i);
                    loop_ub = curVal->size[1];
                    for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                        ret->data[b] = curVal->data[b];
                    }

                    exitg1 = true;
                }
            }

            FlightMissionMode_emxFree_char_T(&data_1);
            FlightMissionMode_emxFree_char_T(&tmp_4);
            FlightMissionMode_emxFree_char_T(&tmp_3);
        }

        tmp_0 = FlightMissionMode_str2double(ret);
        printf("Set UAV MinAirSpeed:\t\t%f\n", tmp_0.re);
        fflush(stdout);
        ret->size[0] = 1;
        ret->size[1] = 0;
        fid = FlightMissionMode_fileManager(localDW);
        if (fid < 0.0) {
            printf("INI-file \"%s\" was not found or could not be read.\n",
                   "config.ini");
            fflush(stdout);
        } else {
            FlightMissionMode_fread(fid, k, localDW);
            i = static_cast<int32_T>(data->size[0] * data->size[1]);
            data->size[0] = 1;
            data->size[1] = k->size[0];
            FlightMissionMode_emxEnsureCapacity_char_T(data, i);
            loop_ub = k->size[0];
            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                data->data[b] = k->data[b];
            }

            FlightMissionMode_cfclose(fid, localDW);
            curSection->size[0] = 1;
            curSection->size[1] = 0;
            curKey->size[0] = 1;
            curKey->size[1] = 0;
            curVal->size[0] = 1;
            curVal->size[1] = 0;
            FlightMissionMode_emxInit_char_T(&tmp_1, 2);
            FlightMissionMode_emxInit_char_T(&tmp_2, 2);
            FlightMissionMode_emxInit_char_T(&data_0, 2);
            exitg1 = false;
            while ((!exitg1) && (data->size[1] != 0)) {
                i = static_cast<int32_T>(data_0->size[0] * data_0->size[1]);
                data_0->size[0] = 1;
                data_0->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T(data_0, i);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (i = 0; i <= loop_ub; i++) {
                    data_0->data[i] = data->data[i];
                }

                FlightMissionMode_strtok(data_0, curLine, data);
                FlightMissionMode_strtok_j(curLine, tmp_2);
                FlightMissionMode_strtrim(tmp_2, curLine);
                if (curLine->size[1] >= 2) {
                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                c = 0;
                                b = 0;
                            } else {
                                c = 1;
                                b = static_cast<int32_T>(curLine->size[1] - 1);
                            }

                            i = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(b - c);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T
                                (curSection, i);
                            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1);
                                    b++) {
                                curSection->data[b] = curLine->data[static_cast<
                                    int32_T>(c + b)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains(curLine)) {
                            FlightMissionMode_strtok_jy(curLine, curVal,
                                b_remainder);
                            FlightMissionMode_strtrim(curVal, curKey);
                            FlightMissionMode_strtok_jyq(b_remainder, tmp_1);
                            FlightMissionMode_strtrim(tmp_1, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp(curSection) &&
                        FlightMissionMode_strcmp_f4pn(curKey)) {
                    i = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                    ret->size[0] = 1;
                    ret->size[1] = curVal->size[1];
                    FlightMissionMode_emxEnsureCapacity_char_T(ret, i);
                    loop_ub = curVal->size[1];
                    for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                        ret->data[b] = curVal->data[b];
                    }

                    exitg1 = true;
                }
            }

            FlightMissionMode_emxFree_char_T(&data_0);
            FlightMissionMode_emxFree_char_T(&tmp_2);
            FlightMissionMode_emxFree_char_T(&tmp_1);
        }

        FlightMissionMode_emxFree_char_T(&k);
        FlightMissionMode_emxFree_char_T(&b_remainder);
        FlightMissionMode_emxFree_char_T(&curLine);
        FlightMissionMode_emxFree_char_T(&curVal);
        FlightMissionMode_emxFree_char_T(&curKey);
        FlightMissionMode_emxFree_char_T(&curSection);
        FlightMissionMode_emxFree_char_T(&data);
        tmp_0 = FlightMissionMode_str2double(ret);
        fid = 0.017453292519943295 * tmp_0.re;
        printf("Set UAV MaxRollAngle:\t\t%f\n", fid);
        fflush(stdout);
        FlightMissionMode_readINI(ret, localDW);
        tmp_0 = FlightMissionMode_str2double(ret);
        ClimbAngleLimit = 0.017453292519943295 * tmp_0.re;
        printf("Set UAV ClimbAngleLimit:\t%f\n", ClimbAngleLimit);
        fflush(stdout);
        FlightMissionMode_readINI_k(ret, localDW);
        tmp_0 = FlightMissionMode_str2double(ret);
        FlightMissionMode_emxFree_char_T(&ret);
        DiveAngleLimit = 0.017453292519943295 * tmp_0.re;
        printf("Set UAV DiveAngleLimit:\t\t%f\n", DiveAngleLimit);
        fflush(stdout);
        if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(std::
                isnan(tmp.re)) ^ 1))) {
            localDW->SingletonInstance.AirSpeed = tmp.re;
        }

        if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(std::
                isnan(fid)) ^ 1))) {
            localDW->SingletonInstance.MaxRollAngle = fid;
        }

        if ((static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                (std::isnan(ClimbAngleLimit)) ^ 1))) && (static_cast<boolean_T>(
                static_cast<int32_T>(static_cast<int32_T>(std::isnan
                (DiveAngleLimit)) ^ 1)))) {
            localDW->SingletonInstance.FlightPathAngleLimit[0] = DiveAngleLimit;
            localDW->SingletonInstance.FlightPathAngleLimit[1] = ClimbAngleLimit;
        }

        for (i = 0; i < 2; i++) {
            tmp_9[i] = localDW->SingletonInstance.FlightPathAngleLimit[i];
        }

        FlightMissionMode_uavDubinsConnection_uavDubinsConnection
            (&localDW->SingletonInstance.Connector,
             localDW->SingletonInstance.AirSpeed,
             localDW->SingletonInstance.MaxRollAngle, tmp_9);
        localDW->SingletonInstance_not_empty = true;
    }

    outputArg = &localDW->SingletonInstance.Connector;
    return outputArg;
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static void* FlightMissionMode_uavDubinsBuildable_uavDubinsBuildable(real_T
    airSpeed, real_T maxRollAngle, const real_T flightPathAngle[2])
{
    real_T b_flightPathAngle[2];
    b_flightPathAngle[0] = flightPathAngle[0];
    b_flightPathAngle[1] = flightPathAngle[1];
    return uavDubinsConnectionObj(airSpeed, maxRollAngle, &b_flightPathAngle[0],
        nullptr, 0U);
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static boolean_T FlightMissionMode_strcmp_f4pnp(const char_T a_data[], const
    int32_T a_size[2])
{
    static const char_T b[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T c[2]{ 'H', 'L' };

    boolean_T b_bool;
    b_bool = false;
    if (a_size[1] == 2) {
        int32_T kstr;
        kstr = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (kstr < 2) {
                if (b[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(a_data[kstr]))
                                           & 127)] != b[static_cast<int32_T>
                        (c[kstr])]) {
                    exitg1 = 1;
                } else {
                    kstr = static_cast<int32_T>(kstr + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    return b_bool;
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static boolean_T FlightMissionMode_strcmp_f4pnpw(const char_T a_data[], const
    int32_T a_size[2])
{
    static const char_T b[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T c[2]{ 'H', 'R' };

    boolean_T b_bool;
    b_bool = false;
    if (a_size[1] == 2) {
        int32_T kstr;
        kstr = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (kstr < 2) {
                if (b[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(a_data[kstr]))
                                           & 127)] != b[static_cast<int32_T>
                        (c[kstr])]) {
                    exitg1 = 1;
                } else {
                    kstr = static_cast<int32_T>(kstr + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    return b_bool;
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static void FlightMissionMode_uavDubinsPathSegment_uavDubinsPathSegment_c(const
    real_T varargin_1[4], const real_T varargin_2[4], real_T varargin_3, real_T
    varargin_4, real_T varargin_5, real_T varargin_6, const
    cell_wrap_0_FlightMissionMode_T varargin_7[4], const real_T varargin_8[4],
    uavDubinsPathSegment_FlightMissionMode_T *b_this)
{
    static const char_T h[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K',
        'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',
        'Z', '[', '\\', ']', '^', '_', '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
        'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',
        'V', 'W', 'X', 'Y', 'Z', '{', '|', '}', '~', '\x7f' };

    real_T thetaWrap;
    int32_T f;
    b_this->MinTurningRadius = varargin_5;
    b_this->StartPose[0] = varargin_1[0];
    b_this->StartPose[1] = varargin_1[1];
    b_this->StartPose[2] = varargin_1[2];
    thetaWrap = mod_Cteiw4Qy(varargin_1[3]);
    b_this->StartPose[3] = thetaWrap;
    if (static_cast<boolean_T>(static_cast<int32_T>((thetaWrap == 0.0) &
            (varargin_1[3] > 0.0)))) {
        b_this->StartPose[3] = 6.2831853071795862;
    }

    wrapToPi_8g8Yma1S(&b_this->StartPose[3]);
    b_this->GoalPose[0] = varargin_2[0];
    b_this->GoalPose[1] = varargin_2[1];
    b_this->GoalPose[2] = varargin_2[2];
    thetaWrap = mod_Cteiw4Qy(varargin_2[3]);
    b_this->GoalPose[3] = thetaWrap;
    if (static_cast<boolean_T>(static_cast<int32_T>((thetaWrap == 0.0) &
            (varargin_2[3] > 0.0)))) {
        b_this->GoalPose[3] = 6.2831853071795862;
    }

    wrapToPi_8g8Yma1S(&b_this->GoalPose[3]);
    b_this->AirSpeed = varargin_4;
    b_this->HelixRadius = varargin_6;
    b_this->FlightPathAngle = varargin_3;
    b_this->MotionLengths[0] = varargin_8[0];
    b_this->MotionTypes[0] = varargin_7[0];
    b_this->MotionLengths[1] = varargin_8[1];
    b_this->MotionTypes[1] = varargin_7[1];
    b_this->MotionLengths[2] = varargin_8[2];
    b_this->MotionTypes[2] = varargin_7[2];
    b_this->MotionLengths[3] = varargin_8[3];
    b_this->MotionTypes[3] = varargin_7[3];
    b_this->MotionTypes[0].f1.size[0] = 1;
    b_this->MotionTypes[0].f1.size[1] = varargin_7[0].f1.size[1];
    f = varargin_7[0].f1.size[1];
    for (int32_T k{0}; k <= static_cast<int32_T>(f - 1); k++) {
        b_this->MotionTypes[0].f1.data[k] = h[static_cast<int32_T>(varargin_7[0]
            .f1.data[k])];
    }

    b_this->MotionTypes[1].f1.size[0] = 1;
    b_this->MotionTypes[1].f1.size[1] = 1;
    b_this->MotionTypes[1].f1.data[0] = h[static_cast<int32_T>
        (static_cast<int32_T>(static_cast<uint8_T>(varargin_7[1].f1.data[0])) &
         127)];
    b_this->MotionTypes[2].f1.size[0] = 1;
    b_this->MotionTypes[2].f1.size[1] = 1;
    b_this->MotionTypes[2].f1.data[0] = h[static_cast<int32_T>
        (static_cast<int32_T>(static_cast<uint8_T>(varargin_7[2].f1.data[0])) &
         127)];
    b_this->MotionTypes[3].f1.size[0] = 1;
    b_this->MotionTypes[3].f1.size[1] = varargin_7[3].f1.size[1];
    f = varargin_7[3].f1.size[1];
    for (int32_T k{0}; k <= static_cast<int32_T>(f - 1); k++) {
        b_this->MotionTypes[3].f1.data[k] = h[static_cast<int32_T>(varargin_7[3]
            .f1.data[k])];
    }

    if (FlightMissionMode_strcmp_f4pnp(b_this->MotionTypes[0].f1.data,
            b_this->MotionTypes[0].f1.size)) {
        b_this->MotionTypes[0].f1.size[0] = 1;
        b_this->MotionTypes[0].f1.size[1] = 2;
        b_this->MotionTypes[0].f1.data[0] = 'H';
        b_this->MotionTypes[0].f1.data[1] = 'l';
    } else if (FlightMissionMode_strcmp_f4pnpw(b_this->MotionTypes[0].f1.data,
                b_this->MotionTypes[0].f1.size)) {
        b_this->MotionTypes[0].f1.size[0] = 1;
        b_this->MotionTypes[0].f1.size[1] = 2;
        b_this->MotionTypes[0].f1.data[0] = 'H';
        b_this->MotionTypes[0].f1.data[1] = 'r';
    } else if (FlightMissionMode_strcmp_f4pnpw(b_this->MotionTypes[3].f1.data,
                b_this->MotionTypes[3].f1.size)) {
        b_this->MotionTypes[3].f1.size[0] = 1;
        b_this->MotionTypes[3].f1.size[1] = 2;
        b_this->MotionTypes[3].f1.data[0] = 'H';
        b_this->MotionTypes[3].f1.data[1] = 'r';
    } else if (FlightMissionMode_strcmp_f4pnp(b_this->MotionTypes[3].f1.data,
                b_this->MotionTypes[3].f1.size)) {
        b_this->MotionTypes[3].f1.size[0] = 1;
        b_this->MotionTypes[3].f1.size[1] = 2;
        b_this->MotionTypes[3].f1.data[0] = 'H';
        b_this->MotionTypes[3].f1.data[1] = 'l';
    }

    b_this->Length = ((varargin_8[0] + varargin_8[1]) + varargin_8[2]) +
        varargin_8[3];
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static void FlightMissionMode_uavDubinsBuiltins_connect(const
    uavDubinsConnection_FlightMissionMode_T *obj, const real_T startPose[4],
    const real_T goalPose[4], real_T turningRadius,
    uavDubinsPathSegment_FlightMissionMode_T *pathSegObjs, real_T *pathCosts)
{
    void* b_obj_UAVDubinsBuildableObj;
    cell_wrap_0_FlightMissionMode_T ac;
    cell_wrap_0_FlightMissionMode_T ad;
    cell_wrap_0_FlightMissionMode_T ae;
    cell_wrap_0_FlightMissionMode_T af;
    cell_wrap_0_FlightMissionMode_T bc;
    cell_wrap_0_FlightMissionMode_T bd;
    cell_wrap_0_FlightMissionMode_T be;
    cell_wrap_0_FlightMissionMode_T bf;
    cell_wrap_0_FlightMissionMode_T cc;
    cell_wrap_0_FlightMissionMode_T cd;
    cell_wrap_0_FlightMissionMode_T ce;
    cell_wrap_0_FlightMissionMode_T cf;
    cell_wrap_0_FlightMissionMode_T dc;
    cell_wrap_0_FlightMissionMode_T dd;
    cell_wrap_0_FlightMissionMode_T de;
    cell_wrap_0_FlightMissionMode_T df;
    cell_wrap_0_FlightMissionMode_T ec;
    cell_wrap_0_FlightMissionMode_T ed;
    cell_wrap_0_FlightMissionMode_T ee;
    cell_wrap_0_FlightMissionMode_T ef;
    cell_wrap_0_FlightMissionMode_T fc;
    cell_wrap_0_FlightMissionMode_T fd;
    cell_wrap_0_FlightMissionMode_T fe;
    cell_wrap_0_FlightMissionMode_T ff;
    cell_wrap_0_FlightMissionMode_T gc;
    cell_wrap_0_FlightMissionMode_T gd;
    cell_wrap_0_FlightMissionMode_T ge;
    cell_wrap_0_FlightMissionMode_T gf;
    cell_wrap_0_FlightMissionMode_T hc;
    cell_wrap_0_FlightMissionMode_T hd;
    cell_wrap_0_FlightMissionMode_T he;
    cell_wrap_0_FlightMissionMode_T hf;
    cell_wrap_0_FlightMissionMode_T ib;
    cell_wrap_0_FlightMissionMode_T ic;
    cell_wrap_0_FlightMissionMode_T id;
    cell_wrap_0_FlightMissionMode_T ie;
    cell_wrap_0_FlightMissionMode_T jb;
    cell_wrap_0_FlightMissionMode_T jc;
    cell_wrap_0_FlightMissionMode_T jd;
    cell_wrap_0_FlightMissionMode_T je;
    cell_wrap_0_FlightMissionMode_T jf;
    cell_wrap_0_FlightMissionMode_T kb;
    cell_wrap_0_FlightMissionMode_T kc;
    cell_wrap_0_FlightMissionMode_T kd;
    cell_wrap_0_FlightMissionMode_T ke;
    cell_wrap_0_FlightMissionMode_T kf;
    cell_wrap_0_FlightMissionMode_T lb;
    cell_wrap_0_FlightMissionMode_T lc;
    cell_wrap_0_FlightMissionMode_T ld;
    cell_wrap_0_FlightMissionMode_T le;
    cell_wrap_0_FlightMissionMode_T lf;
    cell_wrap_0_FlightMissionMode_T mb;
    cell_wrap_0_FlightMissionMode_T mc;
    cell_wrap_0_FlightMissionMode_T md;
    cell_wrap_0_FlightMissionMode_T me;
    cell_wrap_0_FlightMissionMode_T mf;
    cell_wrap_0_FlightMissionMode_T nb;
    cell_wrap_0_FlightMissionMode_T nc;
    cell_wrap_0_FlightMissionMode_T nd;
    cell_wrap_0_FlightMissionMode_T ne;
    cell_wrap_0_FlightMissionMode_T nf;
    cell_wrap_0_FlightMissionMode_T ob;
    cell_wrap_0_FlightMissionMode_T oc;
    cell_wrap_0_FlightMissionMode_T od;
    cell_wrap_0_FlightMissionMode_T oe;
    cell_wrap_0_FlightMissionMode_T of;
    cell_wrap_0_FlightMissionMode_T pb;
    cell_wrap_0_FlightMissionMode_T pc;
    cell_wrap_0_FlightMissionMode_T pd;
    cell_wrap_0_FlightMissionMode_T pe;
    cell_wrap_0_FlightMissionMode_T pf;
    cell_wrap_0_FlightMissionMode_T qb;
    cell_wrap_0_FlightMissionMode_T qc;
    cell_wrap_0_FlightMissionMode_T qd;
    cell_wrap_0_FlightMissionMode_T qe;
    cell_wrap_0_FlightMissionMode_T qf;
    cell_wrap_0_FlightMissionMode_T rb;
    cell_wrap_0_FlightMissionMode_T rc;
    cell_wrap_0_FlightMissionMode_T rd;
    cell_wrap_0_FlightMissionMode_T re;
    cell_wrap_0_FlightMissionMode_T rf;
    cell_wrap_0_FlightMissionMode_T sb;
    cell_wrap_0_FlightMissionMode_T sc;
    cell_wrap_0_FlightMissionMode_T sd;
    cell_wrap_0_FlightMissionMode_T se;
    cell_wrap_0_FlightMissionMode_T sf;
    cell_wrap_0_FlightMissionMode_T tb;
    cell_wrap_0_FlightMissionMode_T tc;
    cell_wrap_0_FlightMissionMode_T td;
    cell_wrap_0_FlightMissionMode_T te;
    cell_wrap_0_FlightMissionMode_T tf;
    cell_wrap_0_FlightMissionMode_T ub;
    cell_wrap_0_FlightMissionMode_T uc;
    cell_wrap_0_FlightMissionMode_T ud;
    cell_wrap_0_FlightMissionMode_T ue;
    cell_wrap_0_FlightMissionMode_T uf;
    cell_wrap_0_FlightMissionMode_T vb;
    cell_wrap_0_FlightMissionMode_T vc;
    cell_wrap_0_FlightMissionMode_T vd;
    cell_wrap_0_FlightMissionMode_T ve;
    cell_wrap_0_FlightMissionMode_T wb;
    cell_wrap_0_FlightMissionMode_T wc;
    cell_wrap_0_FlightMissionMode_T wd;
    cell_wrap_0_FlightMissionMode_T we;
    cell_wrap_0_FlightMissionMode_T xb;
    cell_wrap_0_FlightMissionMode_T xc;
    cell_wrap_0_FlightMissionMode_T xd;
    cell_wrap_0_FlightMissionMode_T xe;
    cell_wrap_0_FlightMissionMode_T yb;
    cell_wrap_0_FlightMissionMode_T yc;
    cell_wrap_0_FlightMissionMode_T yd;
    cell_wrap_0_FlightMissionMode_T ye;
    cell_wrap_22_FlightMissionMode_T motionTypes[28];
    cell_wrap_22_FlightMissionMode_T b;
    real_T g[16];
    real_T ml[16];
    real_T ml1[16];
    real_T s[16];
    real_T b_goalPose[4];
    real_T b_startPose[4];
    real_T ml1_0[4];
    real_T b_a;
    real_T b_fpa;
    real_T h;
    real_T mt;
    real_T mtr;
    int32_T tmp;
    ib.f1.size[0] = 1;
    ib.f1.size[1] = 1;
    ib.f1.data[0] = 'L';
    jb.f1.size[0] = 1;
    jb.f1.size[1] = 1;
    jb.f1.data[0] = 'S';
    kb.f1.size[0] = 1;
    kb.f1.size[1] = 1;
    kb.f1.data[0] = 'L';
    lb.f1.size[0] = 1;
    lb.f1.size[1] = 1;
    lb.f1.data[0] = 'N';
    b.f1[0] = ib;
    b.f1[1] = jb;
    b.f1[2] = kb;
    b.f1[3] = lb;
    mb.f1.size[0] = 1;
    mb.f1.size[1] = 1;
    mb.f1.data[0] = 'L';
    nb.f1.size[0] = 1;
    nb.f1.size[1] = 1;
    nb.f1.data[0] = 'S';
    ob.f1.size[0] = 1;
    ob.f1.size[1] = 1;
    ob.f1.data[0] = 'R';
    pb.f1.size[0] = 1;
    pb.f1.size[1] = 1;
    pb.f1.data[0] = 'N';
    qb.f1.size[0] = 1;
    qb.f1.size[1] = 1;
    qb.f1.data[0] = 'R';
    rb.f1.size[0] = 1;
    rb.f1.size[1] = 1;
    rb.f1.data[0] = 'S';
    sb.f1.size[0] = 1;
    sb.f1.size[1] = 1;
    sb.f1.data[0] = 'L';
    tb.f1.size[0] = 1;
    tb.f1.size[1] = 1;
    tb.f1.data[0] = 'N';
    ub.f1.size[0] = 1;
    ub.f1.size[1] = 1;
    ub.f1.data[0] = 'R';
    vb.f1.size[0] = 1;
    vb.f1.size[1] = 1;
    vb.f1.data[0] = 'S';
    wb.f1.size[0] = 1;
    wb.f1.size[1] = 1;
    wb.f1.data[0] = 'R';
    xb.f1.size[0] = 1;
    xb.f1.size[1] = 1;
    xb.f1.data[0] = 'N';
    yb.f1.size[0] = 1;
    yb.f1.size[1] = 1;
    yb.f1.data[0] = 'R';
    ac.f1.size[0] = 1;
    ac.f1.size[1] = 1;
    ac.f1.data[0] = 'L';
    bc.f1.size[0] = 1;
    bc.f1.size[1] = 1;
    bc.f1.data[0] = 'R';
    cc.f1.size[0] = 1;
    cc.f1.size[1] = 1;
    cc.f1.data[0] = 'N';
    dc.f1.size[0] = 1;
    dc.f1.size[1] = 1;
    dc.f1.data[0] = 'L';
    ec.f1.size[0] = 1;
    ec.f1.size[1] = 1;
    ec.f1.data[0] = 'R';
    fc.f1.size[0] = 1;
    fc.f1.size[1] = 1;
    fc.f1.data[0] = 'L';
    gc.f1.size[0] = 1;
    gc.f1.size[1] = 1;
    gc.f1.data[0] = 'N';
    hc.f1.size[0] = 1;
    hc.f1.size[1] = 2;
    ic.f1.size[0] = 1;
    ic.f1.size[1] = 1;
    ic.f1.data[0] = 'L';
    jc.f1.size[0] = 1;
    jc.f1.size[1] = 1;
    jc.f1.data[0] = 'S';
    kc.f1.size[0] = 1;
    kc.f1.size[1] = 1;
    kc.f1.data[0] = 'L';
    lc.f1.size[0] = 1;
    lc.f1.size[1] = 2;
    mc.f1.size[0] = 1;
    mc.f1.size[1] = 1;
    mc.f1.data[0] = 'L';
    nc.f1.size[0] = 1;
    nc.f1.size[1] = 1;
    nc.f1.data[0] = 'S';
    oc.f1.size[0] = 1;
    oc.f1.size[1] = 1;
    oc.f1.data[0] = 'R';
    pc.f1.size[0] = 1;
    pc.f1.size[1] = 2;
    qc.f1.size[0] = 1;
    qc.f1.size[1] = 1;
    qc.f1.data[0] = 'R';
    rc.f1.size[0] = 1;
    rc.f1.size[1] = 1;
    rc.f1.data[0] = 'S';
    sc.f1.size[0] = 1;
    sc.f1.size[1] = 1;
    sc.f1.data[0] = 'L';
    tc.f1.size[0] = 1;
    tc.f1.size[1] = 2;
    uc.f1.size[0] = 1;
    uc.f1.size[1] = 1;
    uc.f1.data[0] = 'R';
    vc.f1.size[0] = 1;
    vc.f1.size[1] = 1;
    vc.f1.data[0] = 'S';
    wc.f1.size[0] = 1;
    wc.f1.size[1] = 1;
    wc.f1.data[0] = 'R';
    xc.f1.size[0] = 1;
    xc.f1.size[1] = 2;
    yc.f1.size[0] = 1;
    yc.f1.size[1] = 1;
    yc.f1.data[0] = 'R';
    ad.f1.size[0] = 1;
    ad.f1.size[1] = 1;
    ad.f1.data[0] = 'L';
    bd.f1.size[0] = 1;
    bd.f1.size[1] = 1;
    bd.f1.data[0] = 'R';
    cd.f1.size[0] = 1;
    cd.f1.size[1] = 2;
    dd.f1.size[0] = 1;
    dd.f1.size[1] = 1;
    dd.f1.data[0] = 'L';
    ed.f1.size[0] = 1;
    ed.f1.size[1] = 1;
    ed.f1.data[0] = 'R';
    fd.f1.size[0] = 1;
    fd.f1.size[1] = 1;
    fd.f1.data[0] = 'L';
    gd.f1.size[0] = 1;
    gd.f1.size[1] = 1;
    gd.f1.data[0] = 'L';
    hd.f1.size[0] = 1;
    hd.f1.size[1] = 1;
    hd.f1.data[0] = 'S';
    id.f1.size[0] = 1;
    id.f1.size[1] = 1;
    id.f1.data[0] = 'L';
    jd.f1.size[0] = 1;
    jd.f1.size[1] = 2;
    kd.f1.size[0] = 1;
    kd.f1.size[1] = 1;
    kd.f1.data[0] = 'L';
    ld.f1.size[0] = 1;
    ld.f1.size[1] = 1;
    ld.f1.data[0] = 'S';
    md.f1.size[0] = 1;
    md.f1.size[1] = 1;
    md.f1.data[0] = 'R';
    nd.f1.size[0] = 1;
    nd.f1.size[1] = 2;
    od.f1.size[0] = 1;
    od.f1.size[1] = 1;
    od.f1.data[0] = 'R';
    pd.f1.size[0] = 1;
    pd.f1.size[1] = 1;
    pd.f1.data[0] = 'S';
    qd.f1.size[0] = 1;
    qd.f1.size[1] = 1;
    qd.f1.data[0] = 'L';
    rd.f1.size[0] = 1;
    rd.f1.size[1] = 2;
    sd.f1.size[0] = 1;
    sd.f1.size[1] = 1;
    sd.f1.data[0] = 'R';
    td.f1.size[0] = 1;
    td.f1.size[1] = 1;
    td.f1.data[0] = 'S';
    ud.f1.size[0] = 1;
    ud.f1.size[1] = 1;
    ud.f1.data[0] = 'R';
    vd.f1.size[0] = 1;
    vd.f1.size[1] = 2;
    wd.f1.size[0] = 1;
    wd.f1.size[1] = 1;
    wd.f1.data[0] = 'R';
    xd.f1.size[0] = 1;
    xd.f1.size[1] = 1;
    xd.f1.data[0] = 'L';
    yd.f1.size[0] = 1;
    yd.f1.size[1] = 1;
    yd.f1.data[0] = 'R';
    ae.f1.size[0] = 1;
    ae.f1.size[1] = 2;
    be.f1.size[0] = 1;
    be.f1.size[1] = 1;
    be.f1.data[0] = 'L';
    ce.f1.size[0] = 1;
    ce.f1.size[1] = 1;
    ce.f1.data[0] = 'R';
    de.f1.size[0] = 1;
    de.f1.size[1] = 1;
    de.f1.data[0] = 'L';
    ee.f1.size[0] = 1;
    ee.f1.size[1] = 2;
    hc.f1.data[0] = 'H';
    lc.f1.data[0] = 'H';
    pc.f1.data[0] = 'H';
    tc.f1.data[0] = 'H';
    xc.f1.data[0] = 'H';
    cd.f1.data[0] = 'H';
    jd.f1.data[0] = 'H';
    nd.f1.data[0] = 'H';
    rd.f1.data[0] = 'H';
    vd.f1.data[0] = 'H';
    ae.f1.data[0] = 'H';
    ee.f1.data[0] = 'H';
    hc.f1.data[1] = 'l';
    lc.f1.data[1] = 'l';
    pc.f1.data[1] = 'r';
    tc.f1.data[1] = 'r';
    xc.f1.data[1] = 'r';
    cd.f1.data[1] = 'l';
    jd.f1.data[1] = 'l';
    nd.f1.data[1] = 'r';
    rd.f1.data[1] = 'l';
    vd.f1.data[1] = 'r';
    ae.f1.data[1] = 'r';
    ee.f1.data[1] = 'l';
    fe.f1.size[0] = 1;
    fe.f1.size[1] = 1;
    fe.f1.data[0] = 'L';
    ge.f1.size[0] = 1;
    ge.f1.size[1] = 1;
    ge.f1.data[0] = 'R';
    he.f1.size[0] = 1;
    he.f1.size[1] = 1;
    he.f1.data[0] = 'S';
    ie.f1.size[0] = 1;
    ie.f1.size[1] = 1;
    ie.f1.data[0] = 'L';
    je.f1.size[0] = 1;
    je.f1.size[1] = 1;
    je.f1.data[0] = 'L';
    ke.f1.size[0] = 1;
    ke.f1.size[1] = 1;
    ke.f1.data[0] = 'R';
    le.f1.size[0] = 1;
    le.f1.size[1] = 1;
    le.f1.data[0] = 'S';
    me.f1.size[0] = 1;
    me.f1.size[1] = 1;
    me.f1.data[0] = 'R';
    ne.f1.size[0] = 1;
    ne.f1.size[1] = 1;
    ne.f1.data[0] = 'L';
    oe.f1.size[0] = 1;
    oe.f1.size[1] = 1;
    oe.f1.data[0] = 'R';
    pe.f1.size[0] = 1;
    pe.f1.size[1] = 1;
    pe.f1.data[0] = 'L';
    qe.f1.size[0] = 1;
    qe.f1.size[1] = 1;
    qe.f1.data[0] = 'R';
    re.f1.size[0] = 1;
    re.f1.size[1] = 1;
    re.f1.data[0] = 'R';
    se.f1.size[0] = 1;
    se.f1.size[1] = 1;
    se.f1.data[0] = 'L';
    te.f1.size[0] = 1;
    te.f1.size[1] = 1;
    te.f1.data[0] = 'S';
    ue.f1.size[0] = 1;
    ue.f1.size[1] = 1;
    ue.f1.data[0] = 'R';
    ve.f1.size[0] = 1;
    ve.f1.size[1] = 1;
    ve.f1.data[0] = 'R';
    we.f1.size[0] = 1;
    we.f1.size[1] = 1;
    we.f1.data[0] = 'L';
    xe.f1.size[0] = 1;
    xe.f1.size[1] = 1;
    xe.f1.data[0] = 'R';
    ye.f1.size[0] = 1;
    ye.f1.size[1] = 1;
    ye.f1.data[0] = 'L';
    af.f1.size[0] = 1;
    af.f1.size[1] = 1;
    af.f1.data[0] = 'R';
    bf.f1.size[0] = 1;
    bf.f1.size[1] = 1;
    bf.f1.data[0] = 'L';
    cf.f1.size[0] = 1;
    cf.f1.size[1] = 1;
    cf.f1.data[0] = 'S';
    df.f1.size[0] = 1;
    df.f1.size[1] = 1;
    df.f1.data[0] = 'L';
    ef.f1.size[0] = 1;
    ef.f1.size[1] = 1;
    ef.f1.data[0] = 'L';
    ff.f1.size[0] = 1;
    ff.f1.size[1] = 1;
    ff.f1.data[0] = 'S';
    gf.f1.size[0] = 1;
    gf.f1.size[1] = 1;
    gf.f1.data[0] = 'R';
    hf.f1.size[0] = 1;
    hf.f1.size[1] = 1;
    hf.f1.data[0] = 'L';
    jf.f1.size[0] = 1;
    jf.f1.size[1] = 1;
    jf.f1.data[0] = 'R';
    kf.f1.size[0] = 1;
    kf.f1.size[1] = 1;
    kf.f1.data[0] = 'S';
    lf.f1.size[0] = 1;
    lf.f1.size[1] = 1;
    lf.f1.data[0] = 'R';
    mf.f1.size[0] = 1;
    mf.f1.size[1] = 1;
    mf.f1.data[0] = 'L';
    nf.f1.size[0] = 1;
    nf.f1.size[1] = 1;
    nf.f1.data[0] = 'L';
    of.f1.size[0] = 1;
    of.f1.size[1] = 1;
    of.f1.data[0] = 'S';
    pf.f1.size[0] = 1;
    pf.f1.size[1] = 1;
    pf.f1.data[0] = 'L';
    qf.f1.size[0] = 1;
    qf.f1.size[1] = 1;
    qf.f1.data[0] = 'R';
    rf.f1.size[0] = 1;
    rf.f1.size[1] = 1;
    rf.f1.data[0] = 'R';
    sf.f1.size[0] = 1;
    sf.f1.size[1] = 1;
    sf.f1.data[0] = 'S';
    tf.f1.size[0] = 1;
    tf.f1.size[1] = 1;
    tf.f1.data[0] = 'L';
    uf.f1.size[0] = 1;
    uf.f1.size[1] = 1;
    uf.f1.data[0] = 'R';
    motionTypes[0] = b;
    b_obj_UAVDubinsBuildableObj =
        FlightMissionMode_uavDubinsBuildable_uavDubinsBuildable(obj->AirSpeed,
        obj->MaxRollAngle, obj->FlightPathAngleLimit);
    b_startPose[0] = startPose[0];
    b_goalPose[0] = goalPose[0];
    b_startPose[1] = startPose[1];
    b_goalPose[1] = goalPose[1];
    b_startPose[2] = startPose[2];
    b_goalPose[2] = goalPose[2];
    b_startPose[3] = startPose[3];
    b_goalPose[3] = goalPose[3];
    uavDubinsDistanceCodegen_real64(b_obj_UAVDubinsBuildableObj, &b_startPose[0],
        1U, &b_goalPose[0], 1U, true, turningRadius, &s[0], &g[0], &b_fpa, &b_a,
        &mtr, &h, &mt, &ml[0]);
    tmp = 0;
    for (int32_T i{0}; i < 4; i++) {
        ml1[tmp] = ml[i];
        ml1[static_cast<int32_T>(tmp + 1)] = ml[static_cast<int32_T>(i + 4)];
        ml1[static_cast<int32_T>(tmp + 2)] = ml[static_cast<int32_T>(i + 8)];
        ml1[static_cast<int32_T>(tmp + 3)] = ml[static_cast<int32_T>(i + 12)];
        tmp = static_cast<int32_T>(tmp + 4);
    }

    if (mt + 1.0 == 2.0) {
        motionTypes[0].f1[0] = mb;
        motionTypes[0].f1[1] = nb;
        motionTypes[0].f1[2] = ob;
        motionTypes[0].f1[3] = pb;
    }

    if (mt + 1.0 == 3.0) {
        motionTypes[0].f1[0] = qb;
        motionTypes[0].f1[1] = rb;
        motionTypes[0].f1[2] = sb;
        motionTypes[0].f1[3] = tb;
    }

    if (mt + 1.0 == 4.0) {
        motionTypes[0].f1[0] = ub;
        motionTypes[0].f1[1] = vb;
        motionTypes[0].f1[2] = wb;
        motionTypes[0].f1[3] = xb;
    }

    if (mt + 1.0 == 5.0) {
        motionTypes[0].f1[0] = yb;
        motionTypes[0].f1[1] = ac;
        motionTypes[0].f1[2] = bc;
        motionTypes[0].f1[3] = cc;
    }

    if (mt + 1.0 == 6.0) {
        motionTypes[0].f1[0] = dc;
        motionTypes[0].f1[1] = ec;
        motionTypes[0].f1[2] = fc;
        motionTypes[0].f1[3] = gc;
    }

    if (mt + 1.0 == 7.0) {
        motionTypes[0].f1[0] = hc;
        motionTypes[0].f1[1] = ic;
        motionTypes[0].f1[2] = jc;
        motionTypes[0].f1[3] = kc;
    }

    if (mt + 1.0 == 8.0) {
        motionTypes[0].f1[0] = lc;
        motionTypes[0].f1[1] = mc;
        motionTypes[0].f1[2] = nc;
        motionTypes[0].f1[3] = oc;
    }

    if (mt + 1.0 == 9.0) {
        motionTypes[0].f1[0] = pc;
        motionTypes[0].f1[1] = qc;
        motionTypes[0].f1[2] = rc;
        motionTypes[0].f1[3] = sc;
    }

    if (mt + 1.0 == 10.0) {
        motionTypes[0].f1[0] = tc;
        motionTypes[0].f1[1] = uc;
        motionTypes[0].f1[2] = vc;
        motionTypes[0].f1[3] = wc;
    }

    if (mt + 1.0 == 11.0) {
        motionTypes[0].f1[0] = xc;
        motionTypes[0].f1[1] = yc;
        motionTypes[0].f1[2] = ad;
        motionTypes[0].f1[3] = bd;
    }

    if (mt + 1.0 == 12.0) {
        motionTypes[0].f1[0] = cd;
        motionTypes[0].f1[1] = dd;
        motionTypes[0].f1[2] = ed;
        motionTypes[0].f1[3] = fd;
    }

    if (mt + 1.0 == 13.0) {
        motionTypes[0].f1[0] = gd;
        motionTypes[0].f1[1] = hd;
        motionTypes[0].f1[2] = id;
        motionTypes[0].f1[3] = jd;
    }

    if (mt + 1.0 == 14.0) {
        motionTypes[0].f1[0] = kd;
        motionTypes[0].f1[1] = ld;
        motionTypes[0].f1[2] = md;
        motionTypes[0].f1[3] = nd;
    }

    if (mt + 1.0 == 15.0) {
        motionTypes[0].f1[0] = od;
        motionTypes[0].f1[1] = pd;
        motionTypes[0].f1[2] = qd;
        motionTypes[0].f1[3] = rd;
    }

    if (mt + 1.0 == 16.0) {
        motionTypes[0].f1[0] = sd;
        motionTypes[0].f1[1] = td;
        motionTypes[0].f1[2] = ud;
        motionTypes[0].f1[3] = vd;
    }

    if (mt + 1.0 == 17.0) {
        motionTypes[0].f1[0] = wd;
        motionTypes[0].f1[1] = xd;
        motionTypes[0].f1[2] = yd;
        motionTypes[0].f1[3] = ae;
    }

    if (mt + 1.0 == 18.0) {
        motionTypes[0].f1[0] = be;
        motionTypes[0].f1[1] = ce;
        motionTypes[0].f1[2] = de;
        motionTypes[0].f1[3] = ee;
    }

    if (mt + 1.0 == 19.0) {
        motionTypes[0].f1[0] = fe;
        motionTypes[0].f1[1] = ge;
        motionTypes[0].f1[2] = he;
        motionTypes[0].f1[3] = ie;
    }

    if (mt + 1.0 == 20.0) {
        motionTypes[0].f1[0] = je;
        motionTypes[0].f1[1] = ke;
        motionTypes[0].f1[2] = le;
        motionTypes[0].f1[3] = me;
    }

    if (mt + 1.0 == 21.0) {
        motionTypes[0].f1[0] = ne;
        motionTypes[0].f1[1] = oe;
        motionTypes[0].f1[2] = pe;
        motionTypes[0].f1[3] = qe;
    }

    if (mt + 1.0 == 22.0) {
        motionTypes[0].f1[0] = re;
        motionTypes[0].f1[1] = se;
        motionTypes[0].f1[2] = te;
        motionTypes[0].f1[3] = ue;
    }

    if (mt + 1.0 == 23.0) {
        motionTypes[0].f1[0] = ve;
        motionTypes[0].f1[1] = we;
        motionTypes[0].f1[2] = xe;
        motionTypes[0].f1[3] = ye;
    }

    if (mt + 1.0 == 24.0) {
        motionTypes[0].f1[0] = af;
        motionTypes[0].f1[1] = bf;
        motionTypes[0].f1[2] = cf;
        motionTypes[0].f1[3] = df;
    }

    if (mt + 1.0 == 25.0) {
        motionTypes[0].f1[0] = ef;
        motionTypes[0].f1[1] = ff;
        motionTypes[0].f1[2] = gf;
        motionTypes[0].f1[3] = hf;
    }

    if (mt + 1.0 == 26.0) {
        motionTypes[0].f1[0] = jf;
        motionTypes[0].f1[1] = kf;
        motionTypes[0].f1[2] = lf;
        motionTypes[0].f1[3] = mf;
    }

    if (mt + 1.0 == 27.0) {
        motionTypes[0].f1[0] = nf;
        motionTypes[0].f1[1] = of;
        motionTypes[0].f1[2] = pf;
        motionTypes[0].f1[3] = qf;
    }

    if (mt + 1.0 == 28.0) {
        motionTypes[0].f1[0] = rf;
        motionTypes[0].f1[1] = sf;
        motionTypes[0].f1[2] = tf;
        motionTypes[0].f1[3] = uf;
    }

    b_startPose[0] = s[0];
    b_goalPose[0] = g[0];
    ml1_0[0] = ml1[0];
    b_startPose[1] = s[1];
    b_goalPose[1] = g[1];
    ml1_0[1] = ml1[4];
    b_startPose[2] = s[2];
    b_goalPose[2] = g[2];
    ml1_0[2] = ml1[8];
    b_startPose[3] = s[3];
    b_goalPose[3] = g[3];
    ml1_0[3] = ml1[12];
    FlightMissionMode_uavDubinsPathSegment_uavDubinsPathSegment_c(b_startPose,
        b_goalPose, b_fpa, b_a, mtr, h, motionTypes[0].f1, ml1_0, pathSegObjs);
    ml1_0[0] = ml1[0];
    ml1_0[1] = ml1[4];
    ml1_0[2] = ml1[8];
    ml1_0[3] = ml1[12];
    *pathCosts = sum_ftQQGuCy(ml1_0);
}

static void FlightMissionMode_emxInit_real_T(emxArray_real_T_FlightMissionMode_T
    **pEmxArray, int32_T numDimensions)
{
    emxArray_real_T_FlightMissionMode_T *emxArray;
    *pEmxArray = static_cast<emxArray_real_T_FlightMissionMode_T *>(std::malloc
        (sizeof(emxArray_real_T_FlightMissionMode_T)));
    emxArray = *pEmxArray;
    emxArray->data = static_cast<real_T *>(nullptr);
    emxArray->numDimensions = numDimensions;
    emxArray->size = static_cast<int32_T *>(std::malloc(static_cast<uint32_T>
        (sizeof(int32_T) * static_cast<uint32_T>(numDimensions))));
    emxArray->allocatedSize = 0;
    emxArray->canFreeData = true;
    for (int32_T i{0}; i <= static_cast<int32_T>(numDimensions - 1); i++) {
        emxArray->size[i] = 0;
    }
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static void FlightMissionMode_strcmp_f4pnpw5(const
    cell_wrap_0_FlightMissionMode_T a[4], boolean_T b_bool[4])
{
    b_bool[0] = false;
    if ((a[0].f1.size[1] == 1) && (a[0].f1.data[0] == 'N')) {
        b_bool[0] = true;
    }

    b_bool[1] = false;
    if ((a[1].f1.size[1] == 1) && (a[1].f1.data[0] == 'N')) {
        b_bool[1] = true;
    }

    b_bool[2] = false;
    if ((a[2].f1.size[1] == 1) && (a[2].f1.data[0] == 'N')) {
        b_bool[2] = true;
    }

    b_bool[3] = false;
    if ((a[3].f1.size[1] == 1) && (a[3].f1.data[0] == 'N')) {
        b_bool[3] = true;
    }
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static boolean_T FlightMissionMode_any(const boolean_T x[4])
{
    int32_T k;
    boolean_T exitg1;
    boolean_T y;
    y = false;
    k = 0;
    exitg1 = false;
    while ((!exitg1) && (k < 4)) {
        if (x[k]) {
            y = true;
            exitg1 = true;
        } else {
            k = static_cast<int32_T>(k + 1);
        }
    }

    return y;
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static void FlightMissionMode_useConstantDim(real_T varargin_2_data[], const
    int32_T varargin_2_size[2])
{
    int32_T b;
    b = static_cast<int32_T>(static_cast<uint8_T>(static_cast<int32_T>
        (varargin_2_size[1] - 1)));
    for (int32_T k{0}; k <= static_cast<int32_T>(b - 1); k++) {
        varargin_2_data[static_cast<int32_T>(k + 1)] += varargin_2_data[k];
    }
}

static void FlightMissionMode_emxFree_real_T(emxArray_real_T_FlightMissionMode_T
    **pEmxArray)
{
    if (*pEmxArray != static_cast<emxArray_real_T_FlightMissionMode_T *>(nullptr))
    {
        if (((*pEmxArray)->data != static_cast<real_T *>(nullptr)) &&
                (*pEmxArray)->canFreeData) {
            std::free((*pEmxArray)->data);
        }

        std::free((*pEmxArray)->size);
        std::free(*pEmxArray);
        *pEmxArray = static_cast<emxArray_real_T_FlightMissionMode_T *>(nullptr);
    }
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static void FlightMissionMode_eml_find(boolean_T x, int32_T i_data[], int32_T
    i_size[2])
{
    if (x) {
        i_size[0] = 1;
        i_size[1] = 1;
        i_data[0] = 1;
    } else {
        i_size[0] = 0;
        i_size[1] = 0;
    }
}

static void FlightMissionMode_emxEnsureCapacity_real_T
    (emxArray_real_T_FlightMissionMode_T *emxArray, int32_T oldNumel)
{
    int32_T i;
    int32_T newNumel;
    void *newData;
    if (oldNumel < 0) {
        oldNumel = 0;
    }

    newNumel = 1;
    for (i = 0; i <= static_cast<int32_T>(emxArray->numDimensions - 1); i++) {
        newNumel = static_cast<int32_T>(newNumel * emxArray->size[i]);
    }

    if (newNumel > emxArray->allocatedSize) {
        i = emxArray->allocatedSize;
        if (i < 16) {
            i = 16;
        }

        while (i < newNumel) {
            if (i > 1073741823) {
                i = MAX_int32_T;
            } else {
                i = static_cast<int32_T>(i << 1);
            }
        }

        newData = std::calloc(static_cast<uint32_T>(i), sizeof(real_T));
        if (emxArray->data != nullptr) {
            std::memcpy(newData, emxArray->data, static_cast<uint32_T>(sizeof
                         (real_T) * static_cast<uint32_T>(oldNumel)));
            if (emxArray->canFreeData) {
                std::free(emxArray->data);
            }
        }

        emxArray->data = static_cast<real_T *>(newData);
        emxArray->allocatedSize = i;
        emxArray->canFreeData = true;
    }
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static boolean_T FlightMissionMode_strcmp_f4pnpw5g(const char_T a_data[], const
    int32_T a_size[2])
{
    boolean_T b_bool;
    b_bool = false;
    if ((a_size[1] == 1) && (a_data[0] == 'N')) {
        b_bool = true;
    }

    return b_bool;
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static boolean_T FlightMissionMode_strcmp_f4pnpw5g3(const char_T a_data[], const
    int32_T a_size[2])
{
    static const char_T b[2]{ 'H', 'l' };

    boolean_T b_bool;
    b_bool = false;
    if (a_size[1] == 2) {
        int32_T kstr;
        kstr = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (kstr < 2) {
                if (a_data[kstr] != b[kstr]) {
                    exitg1 = 1;
                } else {
                    kstr = static_cast<int32_T>(kstr + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    return b_bool;
}

static void FlightMissionMode_emxInit_boolean_T
    (emxArray_boolean_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions)
{
    emxArray_boolean_T_FlightMissionMode_T *emxArray;
    *pEmxArray = static_cast<emxArray_boolean_T_FlightMissionMode_T *>(std::
        malloc(sizeof(emxArray_boolean_T_FlightMissionMode_T)));
    emxArray = *pEmxArray;
    emxArray->data = static_cast<boolean_T *>(nullptr);
    emxArray->numDimensions = numDimensions;
    emxArray->size = static_cast<int32_T *>(std::malloc(static_cast<uint32_T>
        (sizeof(int32_T) * static_cast<uint32_T>(numDimensions))));
    emxArray->allocatedSize = 0;
    emxArray->canFreeData = true;
    for (int32_T i{0}; i <= static_cast<int32_T>(numDimensions - 1); i++) {
        emxArray->size[i] = 0;
    }
}

static void FlightMissionMode_emxEnsureCapacity_boolean_T
    (emxArray_boolean_T_FlightMissionMode_T *emxArray, int32_T oldNumel)
{
    int32_T i;
    int32_T newNumel;
    void *newData;
    if (oldNumel < 0) {
        oldNumel = 0;
    }

    newNumel = 1;
    for (i = 0; i <= static_cast<int32_T>(emxArray->numDimensions - 1); i++) {
        newNumel = static_cast<int32_T>(newNumel * emxArray->size[i]);
    }

    if (newNumel > emxArray->allocatedSize) {
        i = emxArray->allocatedSize;
        if (i < 16) {
            i = 16;
        }

        while (i < newNumel) {
            if (i > 1073741823) {
                i = MAX_int32_T;
            } else {
                i = static_cast<int32_T>(i << 1);
            }
        }

        newData = std::calloc(static_cast<uint32_T>(i), sizeof(boolean_T));
        if (emxArray->data != nullptr) {
            std::memcpy(newData, emxArray->data, static_cast<uint32_T>(sizeof
                         (boolean_T) * static_cast<uint32_T>(oldNumel)));
            if (emxArray->canFreeData) {
                std::free(emxArray->data);
            }
        }

        emxArray->data = static_cast<boolean_T *>(newData);
        emxArray->allocatedSize = i;
        emxArray->canFreeData = true;
    }
}

static void FlightMissionMode_emxFree_boolean_T
    (emxArray_boolean_T_FlightMissionMode_T **pEmxArray)
{
    if (*pEmxArray != static_cast<emxArray_boolean_T_FlightMissionMode_T *>
            (nullptr)) {
        if (((*pEmxArray)->data != static_cast<boolean_T *>(nullptr)) &&
                (*pEmxArray)->canFreeData) {
            std::free((*pEmxArray)->data);
        }

        std::free((*pEmxArray)->size);
        std::free(*pEmxArray);
        *pEmxArray = static_cast<emxArray_boolean_T_FlightMissionMode_T *>
            (nullptr);
    }
}

static void FlightMissionMode_binary_expand_op
    (emxArray_boolean_T_FlightMissionMode_T *in1, const
     emxArray_real_T_FlightMissionMode_T *in2, const
     emxArray_real_T_FlightMissionMode_T *in3)
{
    int32_T i;
    int32_T loop_ub;
    int32_T stride_0_0;
    int32_T stride_1_0;
    i = in1->size[0];
    in1->size[0] = in3->size[0] == 1 ? in2->size[0] : in3->size[0];
    FlightMissionMode_emxEnsureCapacity_boolean_T(in1, i);
    stride_0_0 = (in2->size[0] != 1);
    stride_1_0 = (in3->size[0] != 1);
    loop_ub = in3->size[0] == 1 ? in2->size[0] : in3->size[0];
    for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
        in1->data[i] = static_cast<boolean_T>(static_cast<int32_T>((in2->data[
            static_cast<int32_T>(i * stride_0_0)] == 0.0) & (in3->data[
            static_cast<int32_T>(i * stride_1_0)] > 0.0)));
    }
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static void FlightMissionMode_wrapToPi(emxArray_real_T_FlightMissionMode_T
    *theta)
{
    emxArray_boolean_T_FlightMissionMode_T *x;
    emxArray_real_T_FlightMissionMode_T *y;
    int32_T k;
    int32_T nx;
    boolean_T b_y;
    boolean_T exitg1;
    nx = theta->size[0];
    FlightMissionMode_emxInit_real_T(&y, 1);
    k = y->size[0];
    y->size[0] = theta->size[0];
    FlightMissionMode_emxEnsureCapacity_real_T(y, k);
    for (k = 0; k <= static_cast<int32_T>(nx - 1); k++) {
        y->data[k] = std::abs(theta->data[k]);
    }

    FlightMissionMode_emxInit_boolean_T(&x, 1);
    k = x->size[0];
    x->size[0] = y->size[0];
    FlightMissionMode_emxEnsureCapacity_boolean_T(x, k);
    nx = y->size[0];
    for (k = 0; k <= static_cast<int32_T>(nx - 1); k++) {
        x->data[k] = (y->data[k] > 3.1415926535897931);
    }

    b_y = false;
    k = 1;
    exitg1 = false;
    while ((!exitg1) && (k <= x->size[0])) {
        if (x->data[static_cast<int32_T>(k - 1)]) {
            b_y = true;
            exitg1 = true;
        } else {
            k = static_cast<int32_T>(k + 1);
        }
    }

    if (b_y) {
        k = y->size[0];
        y->size[0] = theta->size[0];
        FlightMissionMode_emxEnsureCapacity_real_T(y, k);
        nx = theta->size[0];
        for (k = 0; k <= static_cast<int32_T>(nx - 1); k++) {
            y->data[k] = theta->data[k] + 3.1415926535897931;
        }

        k = theta->size[0];
        theta->size[0] = y->size[0];
        FlightMissionMode_emxEnsureCapacity_real_T(theta, k);
        nx = y->size[0];
        for (k = 0; k <= static_cast<int32_T>(nx - 1); k++) {
            theta->data[k] = mod_Cteiw4Qy(y->data[k]);
        }

        if (theta->size[0] == y->size[0]) {
            k = x->size[0];
            x->size[0] = theta->size[0];
            FlightMissionMode_emxEnsureCapacity_boolean_T(x, k);
            nx = theta->size[0];
            for (k = 0; k <= static_cast<int32_T>(nx - 1); k++) {
                x->data[k] = static_cast<boolean_T>(static_cast<int32_T>
                    ((theta->data[k] == 0.0) & (y->data[k] > 0.0)));
            }
        } else {
            FlightMissionMode_binary_expand_op(x, theta, y);
        }

        nx = x->size[0];
        for (k = 0; k <= static_cast<int32_T>(nx - 1); k++) {
            if (x->data[k]) {
                theta->data[k] = 6.2831853071795862;
            }
        }

        nx = theta->size[0];
        for (k = 0; k <= static_cast<int32_T>(nx - 1); k++) {
            theta->data[k] -= 3.1415926535897931;
        }
    }

    FlightMissionMode_emxFree_boolean_T(&x);
    FlightMissionMode_emxFree_real_T(&y);
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static boolean_T FlightMissionMode_strcmp_f4pnpw5g32(const char_T a_data[],
    const int32_T a_size[2])
{
    static const char_T b[2]{ 'H', 'r' };

    boolean_T b_bool;
    b_bool = false;
    if (a_size[1] == 2) {
        int32_T kstr;
        kstr = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (kstr < 2) {
                if (a_data[kstr] != b[kstr]) {
                    exitg1 = 1;
                } else {
                    kstr = static_cast<int32_T>(kstr + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    return b_bool;
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static boolean_T FlightMissionMode_strcmp_f4pnpw5g325(const char_T a_data[],
    const int32_T a_size[2])
{
    boolean_T b_bool;
    b_bool = false;
    if ((a_size[1] == 1) && (a_data[0] == 'L')) {
        b_bool = true;
    }

    return b_bool;
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static boolean_T FlightMissionMode_strcmp_f4pnpw5g325b(const char_T a_data[],
    const int32_T a_size[2])
{
    boolean_T b_bool;
    b_bool = false;
    if ((a_size[1] == 1) && (a_data[0] == 'R')) {
        b_bool = true;
    }

    return b_bool;
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static boolean_T FlightMissionMode_strcmp_f4pnpw5g325bz(const char_T a_data[],
    const int32_T a_size[2])
{
    boolean_T b_bool;
    b_bool = false;
    if ((a_size[1] == 1) && (a_data[0] == 'S')) {
        b_bool = true;
    }

    return b_bool;
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static void FlightMissionMode_mtimes(const emxArray_real_T_FlightMissionMode_T
    *A, const real_T B[4], emxArray_real_T_FlightMissionMode_T *C)
{
    int32_T j;
    int32_T m;
    m = A->size[0];
    j = static_cast<int32_T>(C->size[0] * C->size[1]);
    C->size[0] = A->size[0];
    C->size[1] = 2;
    FlightMissionMode_emxEnsureCapacity_real_T(C, j);
    for (j = 0; j < 2; j++) {
        int32_T boffset;
        int32_T coffset;
        coffset = static_cast<int32_T>(j * m);
        boffset = static_cast<int32_T>(j << 1);
        for (int32_T i{0}; i <= static_cast<int32_T>(m - 1); i++) {
            C->data[static_cast<int32_T>(coffset + i)] = A->data
                [static_cast<int32_T>(A->size[0] + i)] * B[static_cast<int32_T>
                (boffset + 1)] + A->data[i] * B[boffset];
        }
    }
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static void FlightMissionMode_uavDubinsPathSegment_interpolate(const real_T
    b_this_StartPose[4], const real_T b_this_GoalPose[4], real_T
    b_this_FlightPathAngle, real_T b_this_AirSpeed, real_T
    b_this_MinTurningRadius, real_T b_this_HelixRadius, const
    cell_wrap_0_FlightMissionMode_T b_this_MotionTypes[4], const real_T
    b_this_MotionLengths[4], real_T b_this_Length, real_T samples, real_T
    poses_data[], int32_T poses_size[2])
{
    emxArray_real_T_FlightMissionMode_T *S;
    emxArray_real_T_FlightMissionMode_T *c_x;
    emxArray_real_T_FlightMissionMode_T *d_x;
    emxArray_real_T_FlightMissionMode_T *p;
    real_T ns_data[12];
    real_T state[6];
    real_T TransformMatrix[4];
    real_T tempMotionLength_data[4];
    real_T transLength_data[4];
    real_T S_data[2];
    real_T tempSamples_data[2];
    real_T z_data[2];
    int32_T transLength_size[2];
    int32_T o_data;
    boolean_T tmp[4];
    poses_size[0] = 0;
    poses_size[1] = 6;
    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(std::
            isnan(b_this_Length)) ^ 1))) {
        real_T intermediateLength;
        real_T samples_tmp;
        real_T tempStartPose_idx_2;
        int32_T count;
        int32_T loop_ub;
        int32_T ns_size_idx_0;
        int32_T tempMotionLength_size_idx_1;
        tempStartPose_idx_2 = -b_this_StartPose[2];
        poses_size[0] = 1;
        poses_size[1] = 6;
        for (count = 0; count < 6; count++) {
            poses_data[count] = 0.0;
        }

        samples_tmp = std::cos(std::abs(b_this_FlightPathAngle));
        samples *= samples_tmp;
        TransformMatrix[0] = b_this_MotionLengths[0] * samples_tmp;
        TransformMatrix[1] = b_this_MotionLengths[1] * samples_tmp;
        TransformMatrix[2] = b_this_MotionLengths[2] * samples_tmp;
        tempMotionLength_size_idx_1 = 4;
        tempMotionLength_data[0] = TransformMatrix[0];
        tempMotionLength_data[1] = TransformMatrix[1];
        tempMotionLength_data[2] = TransformMatrix[2];
        tempMotionLength_data[3] = b_this_MotionLengths[3] * samples_tmp;
        FlightMissionMode_strcmp_f4pnpw5(b_this_MotionTypes, tmp);
        if (FlightMissionMode_any(tmp)) {
            tempMotionLength_size_idx_1 = 3;
            tempMotionLength_data[0] = TransformMatrix[0];
            tempMotionLength_data[1] = TransformMatrix[1];
            tempMotionLength_data[2] = TransformMatrix[2];
        }

        transLength_size[0] = 1;
        transLength_size[1] = tempMotionLength_size_idx_1;
        for (count = 0; count <= static_cast<int32_T>
                (tempMotionLength_size_idx_1 - 1); count++) {
            transLength_data[count] = tempMotionLength_data[count];
        }

        FlightMissionMode_useConstantDim(transLength_data, transLength_size);
        intermediateLength = 0.0;
        state[0] = b_this_StartPose[0];
        state[1] = -b_this_StartPose[1];
        state[3] = -b_this_StartPose[3];
        FlightMissionMode_emxInit_real_T(&c_x, 1);
        FlightMissionMode_emxInit_real_T(&d_x, 1);
        FlightMissionMode_emxInit_real_T(&p, 2);
        FlightMissionMode_emxInit_real_T(&S, 2);
        for (int32_T tempMotionLength_data_tmp{0}; tempMotionLength_data_tmp <=
                static_cast<int32_T>(tempMotionLength_size_idx_1 - 1);
                tempMotionLength_data_tmp++) {
            boolean_T x;
            if (static_cast<int32_T>(tempMotionLength_data_tmp + 1) == 1) {
                x = static_cast<boolean_T>(static_cast<int32_T>((samples <=
                    (intermediateLength + tempMotionLength_data[0]) + 1.0E-6) &
                    (samples >= intermediateLength)));
            } else {
                x = static_cast<boolean_T>(static_cast<int32_T>((samples <=
                    (intermediateLength +
                     tempMotionLength_data[tempMotionLength_data_tmp]) + 1.0E-6)
                    & (samples > intermediateLength)));
            }

            FlightMissionMode_eml_find(x, &o_data, transLength_size);
            if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                    (FlightMissionMode_strcmp_f4pnpw5g
                     (b_this_MotionTypes[tempMotionLength_data_tmp].f1.data,
                      b_this_MotionTypes[tempMotionLength_data_tmp].f1.size)) ^
                    1))) {
                real_T TransformMatrix_tmp;
                real_T TransformMatrix_tmp_0;
                real_T radius;
                int32_T tempSamples_size_idx_0;
                radius = b_this_MinTurningRadius;
                if (FlightMissionMode_strcmp_f4pnpw5g3
                        (b_this_MotionTypes[tempMotionLength_data_tmp].f1.data,
                         b_this_MotionTypes[tempMotionLength_data_tmp].f1.size))
                {
                    radius = b_this_HelixRadius;
                } else if (FlightMissionMode_strcmp_f4pnpw5g32
                           (b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.data,
                            b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.size)) {
                    radius = b_this_HelixRadius;
                }

                count = 0;
                tempSamples_size_idx_0 = 1;
                tempSamples_data[0] = 0.0;
                if (static_cast<boolean_T>(static_cast<int32_T>
                                           ((transLength_size[0] != 0) &
                                            (transLength_size[1] != 0)))) {
                    tempSamples_size_idx_0 = 2;
                    tempSamples_data[1] = 0.0;
                    count = 1;
                    tempSamples_data[0] = samples;
                    samples = -1.0;
                }

                tempSamples_data[count] =
                    transLength_data[tempMotionLength_data_tmp];
                for (count = 0; count <= static_cast<int32_T>
                        (tempSamples_size_idx_0 - 1); count++) {
                    S_data[count] = (tempSamples_data[count] -
                                     intermediateLength) / radius;
                }

                ns_size_idx_0 = tempSamples_size_idx_0;
                loop_ub = static_cast<int32_T>(tempSamples_size_idx_0 * 6);
                for (count = 0; count <= static_cast<int32_T>(loop_ub - 1);
                        count++) {
                    ns_data[count] = 0.0;
                }

                for (count = 0; count <= static_cast<int32_T>
                        (tempSamples_size_idx_0 - 1); count++) {
                    z_data[count] = tempStartPose_idx_2 + tempSamples_data[count];
                }

                TransformMatrix_tmp = std::sin(state[3]);
                TransformMatrix_tmp_0 = std::cos(state[3]);
                TransformMatrix[0] = TransformMatrix_tmp_0;
                TransformMatrix[2] = TransformMatrix_tmp;
                TransformMatrix[1] = -TransformMatrix_tmp;
                TransformMatrix[3] = TransformMatrix_tmp_0;
                if (b_this_Length != 0.0) {
                    TransformMatrix_tmp = -b_this_GoalPose[2] -
                        tempStartPose_idx_2;
                    TransformMatrix_tmp_0 = b_this_Length * samples_tmp;
                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        z_data[count] = tempSamples_data[count] /
                            TransformMatrix_tmp_0 * TransformMatrix_tmp +
                            tempStartPose_idx_2;
                    }
                }

                for (count = 0; count <= static_cast<int32_T>
                        (tempSamples_size_idx_0 - 1); count++) {
                    tempSamples_data[count] = b_this_FlightPathAngle;
                }

                if (FlightMissionMode_strcmp_f4pnpw5g3
                        (b_this_MotionTypes[tempMotionLength_data_tmp].f1.data,
                         b_this_MotionTypes[tempMotionLength_data_tmp].f1.size) ||
                    FlightMissionMode_strcmp_f4pnpw5g325
                        (b_this_MotionTypes[tempMotionLength_data_tmp].f1.data,
                         b_this_MotionTypes[tempMotionLength_data_tmp].f1.size))
                {
                    real_T state_0;
                    real_T state_1;
                    ns_size_idx_0 = c_x->size[0];
                    c_x->size[0] = tempSamples_size_idx_0;
                    FlightMissionMode_emxEnsureCapacity_real_T(c_x,
                        ns_size_idx_0);
                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        c_x->data[count] = S_data[count];
                    }

                    for (loop_ub = 0; loop_ub <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); loop_ub++) {
                        c_x->data[loop_ub] = std::sin(c_x->data[loop_ub]);
                    }

                    ns_size_idx_0 = d_x->size[0];
                    d_x->size[0] = tempSamples_size_idx_0;
                    FlightMissionMode_emxEnsureCapacity_real_T(d_x,
                        ns_size_idx_0);
                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        d_x->data[count] = S_data[count];
                    }

                    for (loop_ub = 0; loop_ub <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); loop_ub++) {
                        d_x->data[loop_ub] = std::cos(d_x->data[loop_ub]);
                    }

                    ns_size_idx_0 = static_cast<int32_T>(S->size[0] * S->size[1]);
                    S->size[0] = c_x->size[0];
                    S->size[1] = 2;
                    FlightMissionMode_emxEnsureCapacity_real_T(S, ns_size_idx_0);
                    loop_ub = c_x->size[0];
                    for (count = 0; count <= static_cast<int32_T>(loop_ub - 1);
                            count++) {
                        S->data[count] = c_x->data[count];
                    }

                    loop_ub = d_x->size[0];
                    for (count = 0; count <= static_cast<int32_T>(loop_ub - 1);
                            count++) {
                        S->data[static_cast<int32_T>(count + c_x->size[0])] =
                            1.0 - d_x->data[count];
                    }

                    FlightMissionMode_mtimes(S, TransformMatrix, p);
                    TransformMatrix_tmp = -rt_atan2d_snf(b_this_AirSpeed *
                        b_this_AirSpeed, 9.8 * radius);
                    TransformMatrix_tmp_0 = state[0];
                    state_0 = state[1];
                    state_1 = state[3];
                    ns_size_idx_0 = p->size[0];
                    loop_ub = p->size[0];
                    for (count = 0; count <= static_cast<int32_T>(loop_ub - 1);
                            count++) {
                        ns_data[count] = p->data[count] * radius +
                            TransformMatrix_tmp_0;
                        ns_data[static_cast<int32_T>(count + ns_size_idx_0)] =
                            p->data[static_cast<int32_T>(count + p->size[0])] *
                            radius + state_0;
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        ns_data[static_cast<int32_T>(count + static_cast<int32_T>
                            (ns_size_idx_0 << 1))] = z_data[count];
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        ns_data[static_cast<int32_T>(count + static_cast<int32_T>
                            (ns_size_idx_0 * 3))] = state_1 + S_data[count];
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        ns_data[static_cast<int32_T>(count + static_cast<int32_T>
                            (ns_size_idx_0 << 2))] = tempSamples_data[count];
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        ns_data[static_cast<int32_T>(count + static_cast<int32_T>
                            (ns_size_idx_0 * 5))] = TransformMatrix_tmp;
                    }
                } else if (FlightMissionMode_strcmp_f4pnpw5g32
                           (b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.data,
                            b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.size) || FlightMissionMode_strcmp_f4pnpw5g325b
                           (b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.data,
                            b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.size)) {
                    real_T state_0;
                    real_T state_1;
                    ns_size_idx_0 = c_x->size[0];
                    c_x->size[0] = tempSamples_size_idx_0;
                    FlightMissionMode_emxEnsureCapacity_real_T(c_x,
                        ns_size_idx_0);
                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        c_x->data[count] = S_data[count];
                    }

                    for (loop_ub = 0; loop_ub <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); loop_ub++) {
                        c_x->data[loop_ub] = std::sin(c_x->data[loop_ub]);
                    }

                    ns_size_idx_0 = d_x->size[0];
                    d_x->size[0] = tempSamples_size_idx_0;
                    FlightMissionMode_emxEnsureCapacity_real_T(d_x,
                        ns_size_idx_0);
                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        d_x->data[count] = S_data[count];
                    }

                    for (loop_ub = 0; loop_ub <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); loop_ub++) {
                        d_x->data[loop_ub] = std::cos(d_x->data[loop_ub]);
                    }

                    ns_size_idx_0 = static_cast<int32_T>(S->size[0] * S->size[1]);
                    S->size[0] = c_x->size[0];
                    S->size[1] = 2;
                    FlightMissionMode_emxEnsureCapacity_real_T(S, ns_size_idx_0);
                    loop_ub = c_x->size[0];
                    for (count = 0; count <= static_cast<int32_T>(loop_ub - 1);
                            count++) {
                        S->data[count] = c_x->data[count];
                    }

                    loop_ub = d_x->size[0];
                    for (count = 0; count <= static_cast<int32_T>(loop_ub - 1);
                            count++) {
                        S->data[static_cast<int32_T>(count + c_x->size[0])] =
                            d_x->data[count] - 1.0;
                    }

                    FlightMissionMode_mtimes(S, TransformMatrix, p);
                    TransformMatrix_tmp = rt_atan2d_snf(b_this_AirSpeed *
                        b_this_AirSpeed, 9.8 * radius);
                    TransformMatrix_tmp_0 = state[0];
                    state_0 = state[1];
                    state_1 = state[3];
                    ns_size_idx_0 = p->size[0];
                    loop_ub = p->size[0];
                    for (count = 0; count <= static_cast<int32_T>(loop_ub - 1);
                            count++) {
                        ns_data[count] = p->data[count] * radius +
                            TransformMatrix_tmp_0;
                        ns_data[static_cast<int32_T>(count + ns_size_idx_0)] =
                            p->data[static_cast<int32_T>(count + p->size[0])] *
                            radius + state_0;
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        ns_data[static_cast<int32_T>(count + static_cast<int32_T>
                            (ns_size_idx_0 << 1))] = z_data[count];
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        ns_data[static_cast<int32_T>(count + static_cast<int32_T>
                            (ns_size_idx_0 * 3))] = state_1 - S_data[count];
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        ns_data[static_cast<int32_T>(count + static_cast<int32_T>
                            (ns_size_idx_0 << 2))] = tempSamples_data[count];
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        ns_data[static_cast<int32_T>(count + static_cast<int32_T>
                            (ns_size_idx_0 * 5))] = TransformMatrix_tmp;
                    }
                } else if (FlightMissionMode_strcmp_f4pnpw5g325bz
                           (b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.data,
                            b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.size)) {
                    real_T state_0;
                    ns_size_idx_0 = static_cast<int32_T>(S->size[0] * S->size[1]);
                    S->size[0] = tempSamples_size_idx_0;
                    S->size[1] = 2;
                    FlightMissionMode_emxEnsureCapacity_real_T(S, ns_size_idx_0);
                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        S->data[count] = S_data[count];
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        S->data[static_cast<int32_T>(count +
                            tempSamples_size_idx_0)] = 0.0;
                    }

                    FlightMissionMode_mtimes(S, TransformMatrix, p);
                    TransformMatrix_tmp_0 = state[0];
                    state_0 = state[1];
                    ns_size_idx_0 = p->size[0];
                    loop_ub = p->size[0];
                    for (count = 0; count <= static_cast<int32_T>(loop_ub - 1);
                            count++) {
                        ns_data[count] = p->data[count] * radius +
                            TransformMatrix_tmp_0;
                        ns_data[static_cast<int32_T>(count + ns_size_idx_0)] =
                            p->data[static_cast<int32_T>(count + p->size[0])] *
                            radius + state_0;
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        ns_data[static_cast<int32_T>(count + static_cast<int32_T>
                            (ns_size_idx_0 << 1))] = z_data[count];
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        ns_data[static_cast<int32_T>(count + static_cast<int32_T>
                            (ns_size_idx_0 * 3))] = state[3];
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        ns_data[static_cast<int32_T>(count + static_cast<int32_T>
                            (ns_size_idx_0 << 2))] = tempSamples_data[count];
                    }

                    for (count = 0; count <= static_cast<int32_T>
                            (tempSamples_size_idx_0 - 1); count++) {
                        ns_data[static_cast<int32_T>(count + static_cast<int32_T>
                            (ns_size_idx_0 * 5))] = 0.0;
                    }
                }

                if (static_cast<boolean_T>(static_cast<int32_T>
                                           ((transLength_size[0] != 0) &
                                            (transLength_size[1] != 0)))) {
                    if (static_cast<int32_T>(ns_size_idx_0 - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = 0;
                    }

                    if (loop_ub >= 0) {
                        for (count = 0; count < 6; count++) {
                            poses_data[count] = ns_data[static_cast<int32_T>
                                (ns_size_idx_0 * count)];
                        }
                    }

                    if (static_cast<int32_T>(ns_size_idx_0 - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = 0;
                    }

                    if (loop_ub >= 0) {
                        poses_data[0] = ns_data[0];
                    }

                    if (static_cast<int32_T>(ns_size_idx_0 - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = 0;
                    }

                    if (loop_ub >= 0) {
                        poses_data[1] = -ns_data[ns_size_idx_0];
                    }

                    if (static_cast<int32_T>(ns_size_idx_0 - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = 0;
                    }

                    if (loop_ub >= 0) {
                        poses_data[2] = -ns_data[static_cast<int32_T>
                            (ns_size_idx_0 << 1)];
                    }

                    if (static_cast<int32_T>(ns_size_idx_0 - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = 0;
                    }

                    if (loop_ub >= 0) {
                        poses_data[3] = -ns_data[static_cast<int32_T>
                            (ns_size_idx_0 * 3)];
                    }
                }

                for (count = 0; count < 6; count++) {
                    state[count] = ns_data[static_cast<int32_T>
                        (static_cast<int32_T>(static_cast<int32_T>(ns_size_idx_0
                           * count) + ns_size_idx_0) - 1)];
                }
            }

            intermediateLength +=
                tempMotionLength_data[tempMotionLength_data_tmp];
        }

        FlightMissionMode_emxFree_real_T(&S);
        FlightMissionMode_emxFree_real_T(&p);
        FlightMissionMode_emxFree_real_T(&d_x);
        ns_size_idx_0 = c_x->size[0];
        c_x->size[0] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T(c_x, ns_size_idx_0);
        c_x->data[0] = poses_data[3];
        FlightMissionMode_wrapToPi(c_x);
        loop_ub = c_x->size[0];
        for (count = 0; count <= static_cast<int32_T>(loop_ub - 1); count++) {
            poses_data[3] = c_x->data[count];
        }

        FlightMissionMode_emxFree_real_T(&c_x);
    }
}

static void FlightMissionMode_emxInit_int32_T
    (emxArray_int32_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions)
{
    emxArray_int32_T_FlightMissionMode_T *emxArray;
    *pEmxArray = static_cast<emxArray_int32_T_FlightMissionMode_T *>(std::malloc
        (sizeof(emxArray_int32_T_FlightMissionMode_T)));
    emxArray = *pEmxArray;
    emxArray->data = static_cast<int32_T *>(nullptr);
    emxArray->numDimensions = numDimensions;
    emxArray->size = static_cast<int32_T *>(std::malloc(static_cast<uint32_T>
        (sizeof(int32_T) * static_cast<uint32_T>(numDimensions))));
    emxArray->allocatedSize = 0;
    emxArray->canFreeData = true;
    for (int32_T i{0}; i <= static_cast<int32_T>(numDimensions - 1); i++) {
        emxArray->size[i] = 0;
    }
}

static void FlightMissionMode_emxEnsureCapacity_int32_T
    (emxArray_int32_T_FlightMissionMode_T *emxArray, int32_T oldNumel)
{
    int32_T i;
    int32_T newNumel;
    void *newData;
    if (oldNumel < 0) {
        oldNumel = 0;
    }

    newNumel = 1;
    for (i = 0; i <= static_cast<int32_T>(emxArray->numDimensions - 1); i++) {
        newNumel = static_cast<int32_T>(newNumel * emxArray->size[i]);
    }

    if (newNumel > emxArray->allocatedSize) {
        i = emxArray->allocatedSize;
        if (i < 16) {
            i = 16;
        }

        while (i < newNumel) {
            if (i > 1073741823) {
                i = MAX_int32_T;
            } else {
                i = static_cast<int32_T>(i << 1);
            }
        }

        newData = std::calloc(static_cast<uint32_T>(i), sizeof(int32_T));
        if (emxArray->data != nullptr) {
            std::memcpy(newData, emxArray->data, static_cast<uint32_T>(sizeof
                         (int32_T) * static_cast<uint32_T>(oldNumel)));
            if (emxArray->canFreeData) {
                std::free(emxArray->data);
            }
        }

        emxArray->data = static_cast<int32_T *>(newData);
        emxArray->allocatedSize = i;
        emxArray->canFreeData = true;
    }
}

static void FlightMissionMode_emxFree_int32_T
    (emxArray_int32_T_FlightMissionMode_T **pEmxArray)
{
    if (*pEmxArray != static_cast<emxArray_int32_T_FlightMissionMode_T *>
            (nullptr)) {
        if (((*pEmxArray)->data != static_cast<int32_T *>(nullptr)) &&
                (*pEmxArray)->canFreeData) {
            std::free((*pEmxArray)->data);
        }

        std::free((*pEmxArray)->size);
        std::free(*pEmxArray);
        *pEmxArray = static_cast<emxArray_int32_T_FlightMissionMode_T *>(nullptr);
    }
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static void FlightMissionMode_merge(emxArray_int32_T_FlightMissionMode_T *idx,
    emxArray_real_T_FlightMissionMode_T *x, int32_T offset, int32_T np, int32_T
    nq, emxArray_int32_T_FlightMissionMode_T *iwork,
    emxArray_real_T_FlightMissionMode_T *xwork)
{
    if (nq != 0) {
        int32_T iout;
        int32_T n;
        int32_T q;
        int32_T qend;
        qend = static_cast<int32_T>(np + nq);
        for (q = 0; q <= static_cast<int32_T>(qend - 1); q++) {
            iwork->data[q] = idx->data[static_cast<int32_T>(offset + q)];
            xwork->data[q] = x->data[static_cast<int32_T>(offset + q)];
        }

        n = 0;
        q = np;
        iout = static_cast<int32_T>(offset - 1);
        int32_T exitg1;
        do {
            exitg1 = 0;
            iout = static_cast<int32_T>(iout + 1);
            if (xwork->data[n] <= xwork->data[q]) {
                idx->data[iout] = iwork->data[n];
                x->data[iout] = xwork->data[n];
                if (static_cast<int32_T>(n + 1) < np) {
                    n = static_cast<int32_T>(n + 1);
                } else {
                    exitg1 = 1;
                }
            } else {
                idx->data[iout] = iwork->data[q];
                x->data[iout] = xwork->data[q];
                if (static_cast<int32_T>(q + 1) < qend) {
                    q = static_cast<int32_T>(q + 1);
                } else {
                    qend = static_cast<int32_T>(iout - n);
                    for (q = static_cast<int32_T>(n + 1); q <= np; q++) {
                        iout = static_cast<int32_T>(qend + q);
                        idx->data[iout] = iwork->data[static_cast<int32_T>(q - 1)];
                        x->data[iout] = xwork->data[static_cast<int32_T>(q - 1)];
                    }

                    exitg1 = 1;
                }
            }
        } while (exitg1 == 0);
    }
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static void FlightMissionMode_merge_block(emxArray_int32_T_FlightMissionMode_T
    *idx, emxArray_real_T_FlightMissionMode_T *x, int32_T offset, int32_T n,
    int32_T preSortLevel, emxArray_int32_T_FlightMissionMode_T *iwork,
    emxArray_real_T_FlightMissionMode_T *xwork)
{
    int32_T bLen;
    int32_T nPairs;
    nPairs = static_cast<int32_T>(n >> preSortLevel);
    bLen = static_cast<int32_T>(1 << preSortLevel);
    while (nPairs > 1) {
        int32_T nTail;
        int32_T tailOffset;
        if (static_cast<uint32_T>(static_cast<uint32_T>(nPairs) & 1U) != 0U) {
            nPairs = static_cast<int32_T>(nPairs - 1);
            tailOffset = static_cast<int32_T>(bLen * nPairs);
            nTail = static_cast<int32_T>(n - tailOffset);
            if (nTail > bLen) {
                FlightMissionMode_merge(idx, x, static_cast<int32_T>(offset +
                    tailOffset), bLen, static_cast<int32_T>(nTail - bLen), iwork,
                                        xwork);
            }
        }

        nTail = static_cast<int32_T>(bLen << 1);
        nPairs = static_cast<int32_T>(nPairs >> 1);
        for (tailOffset = 0; tailOffset <= static_cast<int32_T>(nPairs - 1);
                tailOffset++) {
            FlightMissionMode_merge(idx, x, static_cast<int32_T>(offset +
                static_cast<int32_T>(tailOffset * nTail)), bLen, bLen, iwork,
                                    xwork);
        }

        bLen = nTail;
    }

    if (n > bLen) {
        FlightMissionMode_merge(idx, x, offset, bLen, static_cast<int32_T>(n -
            bLen), iwork, xwork);
    }
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static void FlightMissionMode_sort(emxArray_real_T_FlightMissionMode_T *x)
{
    emxArray_int32_T_FlightMissionMode_T *idx;
    emxArray_int32_T_FlightMissionMode_T *iwork;
    emxArray_real_T_FlightMissionMode_T *b_x;
    emxArray_real_T_FlightMissionMode_T *xwork;
    real_T b_xwork[256];
    real_T x4[4];
    int32_T b_iwork[256];
    int32_T idx4[4];
    int32_T b_iwork_tmp;
    int32_T ib;
    int32_T n;
    int8_T perm[4];
    FlightMissionMode_emxInit_real_T(&b_x, 2);
    b_iwork_tmp = static_cast<int32_T>(b_x->size[0] * b_x->size[1]);
    b_x->size[0] = 1;
    b_x->size[1] = x->size[1];
    FlightMissionMode_emxEnsureCapacity_real_T(b_x, b_iwork_tmp);
    n = x->size[1];
    for (ib = 0; ib <= static_cast<int32_T>(n - 1); ib++) {
        b_x->data[ib] = x->data[ib];
    }

    if (x->size[1] != 0) {
        int32_T blockOffset;
        int32_T i1;
        int32_T i2;
        int32_T i3;
        int32_T i4;
        int32_T nBlocks;
        int32_T wOffset;
        FlightMissionMode_emxInit_int32_T(&idx, 2);
        b_iwork_tmp = static_cast<int32_T>(idx->size[0] * idx->size[1]);
        idx->size[0] = 1;
        idx->size[1] = x->size[1];
        FlightMissionMode_emxEnsureCapacity_int32_T(idx, b_iwork_tmp);
        n = x->size[1];
        for (ib = 0; ib <= static_cast<int32_T>(n - 1); ib++) {
            idx->data[ib] = 0;
        }

        b_iwork_tmp = static_cast<int32_T>(b_x->size[0] * b_x->size[1]);
        b_x->size[0] = 1;
        b_x->size[1] = x->size[1];
        FlightMissionMode_emxEnsureCapacity_real_T(b_x, b_iwork_tmp);
        n = x->size[1];
        for (ib = 0; ib <= static_cast<int32_T>(n - 1); ib++) {
            b_x->data[ib] = x->data[ib];
        }

        n = static_cast<int32_T>(x->size[1] - 1);
        x4[0] = 0.0;
        idx4[0] = 0;
        x4[1] = 0.0;
        idx4[1] = 0;
        x4[2] = 0.0;
        idx4[2] = 0;
        x4[3] = 0.0;
        idx4[3] = 0;
        FlightMissionMode_emxInit_int32_T(&iwork, 1);
        FlightMissionMode_emxInit_real_T(&xwork, 1);
        nBlocks = x->size[1];
        b_iwork_tmp = xwork->size[0];
        xwork->size[0] = x->size[1];
        FlightMissionMode_emxEnsureCapacity_real_T(xwork, b_iwork_tmp);
        for (ib = 0; ib <= static_cast<int32_T>(nBlocks - 1); ib++) {
            xwork->data[ib] = 0.0;
        }

        nBlocks = 0;
        ib = -1;
        for (wOffset = 0; wOffset <= n; wOffset++) {
            if (std::isnan(b_x->data[wOffset])) {
                i1 = static_cast<int32_T>(n - nBlocks);
                idx->data[i1] = static_cast<int32_T>(wOffset + 1);
                xwork->data[i1] = b_x->data[wOffset];
                nBlocks = static_cast<int32_T>(nBlocks + 1);
            } else {
                ib = static_cast<int32_T>(ib + 1);
                idx4[ib] = static_cast<int32_T>(wOffset + 1);
                x4[ib] = b_x->data[wOffset];
                if (static_cast<int32_T>(ib + 1) == 4) {
                    real_T tmp;
                    real_T tmp_0;
                    ib = static_cast<int32_T>(wOffset - nBlocks);
                    if (x4[0] <= x4[1]) {
                        i1 = 1;
                        i2 = 2;
                    } else {
                        i1 = 2;
                        i2 = 1;
                    }

                    if (x4[2] <= x4[3]) {
                        i3 = 3;
                        i4 = 4;
                    } else {
                        i3 = 4;
                        i4 = 3;
                    }

                    tmp = x4[static_cast<int32_T>(i1 - 1)];
                    tmp_0 = x4[static_cast<int32_T>(i3 - 1)];
                    if (tmp <= tmp_0) {
                        tmp = x4[static_cast<int32_T>(i2 - 1)];
                        if (tmp <= tmp_0) {
                            perm[0] = static_cast<int8_T>(i1);
                            perm[1] = static_cast<int8_T>(i2);
                            perm[2] = static_cast<int8_T>(i3);
                            perm[3] = static_cast<int8_T>(i4);
                        } else if (tmp <= x4[static_cast<int32_T>(i4 - 1)]) {
                            perm[0] = static_cast<int8_T>(i1);
                            perm[1] = static_cast<int8_T>(i3);
                            perm[2] = static_cast<int8_T>(i2);
                            perm[3] = static_cast<int8_T>(i4);
                        } else {
                            perm[0] = static_cast<int8_T>(i1);
                            perm[1] = static_cast<int8_T>(i3);
                            perm[2] = static_cast<int8_T>(i4);
                            perm[3] = static_cast<int8_T>(i2);
                        }
                    } else {
                        tmp_0 = x4[static_cast<int32_T>(i4 - 1)];
                        if (tmp <= tmp_0) {
                            if (x4[static_cast<int32_T>(i2 - 1)] <= tmp_0) {
                                perm[0] = static_cast<int8_T>(i3);
                                perm[1] = static_cast<int8_T>(i1);
                                perm[2] = static_cast<int8_T>(i2);
                                perm[3] = static_cast<int8_T>(i4);
                            } else {
                                perm[0] = static_cast<int8_T>(i3);
                                perm[1] = static_cast<int8_T>(i1);
                                perm[2] = static_cast<int8_T>(i4);
                                perm[3] = static_cast<int8_T>(i2);
                            }
                        } else {
                            perm[0] = static_cast<int8_T>(i3);
                            perm[1] = static_cast<int8_T>(i4);
                            perm[2] = static_cast<int8_T>(i1);
                            perm[3] = static_cast<int8_T>(i2);
                        }
                    }

                    idx->data[static_cast<int32_T>(ib - 3)] = idx4[static_cast<
                        int32_T>(static_cast<int32_T>(perm[0]) - 1)];
                    idx->data[static_cast<int32_T>(ib - 2)] = idx4
                        [static_cast<int32_T>(static_cast<int32_T>(perm[1]) - 1)];
                    idx->data[static_cast<int32_T>(ib - 1)] = idx4
                        [static_cast<int32_T>(static_cast<int32_T>(perm[2]) - 1)];
                    idx->data[ib] = idx4[static_cast<int32_T>
                        (static_cast<int32_T>(perm[3]) - 1)];
                    b_x->data[static_cast<int32_T>(ib - 3)] = x4
                        [static_cast<int32_T>(static_cast<int32_T>(perm[0]) - 1)];
                    b_x->data[static_cast<int32_T>(ib - 2)] = x4
                        [static_cast<int32_T>(static_cast<int32_T>(perm[1]) - 1)];
                    b_x->data[static_cast<int32_T>(ib - 1)] = x4
                        [static_cast<int32_T>(static_cast<int32_T>(perm[2]) - 1)];
                    b_x->data[ib] = x4[static_cast<int32_T>(static_cast<int32_T>
                        (perm[3]) - 1)];
                    ib = -1;
                }
            }
        }

        wOffset = static_cast<int32_T>(x->size[1] - nBlocks);
        if (static_cast<int32_T>(ib + 1) > 0) {
            perm[1] = 0;
            perm[2] = 0;
            perm[3] = 0;
            switch (static_cast<int32_T>(ib + 1)) {
              case 1:
                perm[0] = 1;
                break;

              case 2:
                if (x4[0] <= x4[1]) {
                    perm[0] = 1;
                    perm[1] = 2;
                } else {
                    perm[0] = 2;
                    perm[1] = 1;
                }
                break;

              default:
                if (x4[0] <= x4[1]) {
                    if (x4[1] <= x4[2]) {
                        perm[0] = 1;
                        perm[1] = 2;
                        perm[2] = 3;
                    } else if (x4[0] <= x4[2]) {
                        perm[0] = 1;
                        perm[1] = 3;
                        perm[2] = 2;
                    } else {
                        perm[0] = 3;
                        perm[1] = 1;
                        perm[2] = 2;
                    }
                } else if (x4[0] <= x4[2]) {
                    perm[0] = 2;
                    perm[1] = 1;
                    perm[2] = 3;
                } else if (x4[1] <= x4[2]) {
                    perm[0] = 2;
                    perm[1] = 3;
                    perm[2] = 1;
                } else {
                    perm[0] = 3;
                    perm[1] = 2;
                    perm[2] = 1;
                }
                break;
            }

            i2 = static_cast<int32_T>(static_cast<uint8_T>(static_cast<int32_T>
                (ib + 1)));
            for (i1 = 0; i1 <= static_cast<int32_T>(i2 - 1); i1++) {
                int8_T perm_0;
                perm_0 = perm[i1];
                b_iwork_tmp = static_cast<int32_T>(static_cast<int32_T>(
                    static_cast<int32_T>(wOffset - ib) + i1) - 1);
                idx->data[b_iwork_tmp] = idx4[static_cast<int32_T>
                    (static_cast<int32_T>(perm_0) - 1)];
                b_x->data[b_iwork_tmp] = x4[static_cast<int32_T>
                    (static_cast<int32_T>(perm_0) - 1)];
            }
        }

        i1 = static_cast<int32_T>(nBlocks >> 1);
        for (ib = 0; ib <= static_cast<int32_T>(i1 - 1); ib++) {
            blockOffset = static_cast<int32_T>(wOffset + ib);
            i2 = idx->data[blockOffset];
            b_iwork_tmp = static_cast<int32_T>(n - ib);
            idx->data[blockOffset] = idx->data[b_iwork_tmp];
            idx->data[b_iwork_tmp] = i2;
            i2 = static_cast<int32_T>(wOffset + ib);
            blockOffset = static_cast<int32_T>(n - ib);
            b_x->data[i2] = xwork->data[blockOffset];
            b_x->data[blockOffset] = xwork->data[i2];
        }

        if (static_cast<uint32_T>(static_cast<uint32_T>(nBlocks) & 1U) != 0U) {
            i2 = static_cast<int32_T>(wOffset + i1);
            b_x->data[i2] = xwork->data[i2];
        }

        n = x->size[1];
        b_iwork_tmp = iwork->size[0];
        iwork->size[0] = x->size[1];
        FlightMissionMode_emxEnsureCapacity_int32_T(iwork, b_iwork_tmp);
        for (ib = 0; ib <= static_cast<int32_T>(n - 1); ib++) {
            iwork->data[ib] = 0;
        }

        n = static_cast<int32_T>(x->size[1] - nBlocks);
        wOffset = 2;
        if (n > 1) {
            if (x->size[1] >= 256) {
                nBlocks = static_cast<int32_T>(n >> 8);
                if (nBlocks > 0) {
                    for (wOffset = 0; wOffset <= static_cast<int32_T>(nBlocks -
                            1); wOffset++) {
                        i2 = static_cast<int32_T>(static_cast<int32_T>(wOffset <<
                            8) - 1);
                        for (ib = 0; ib < 6; ib++) {
                            int32_T d;
                            i3 = static_cast<int32_T>(1 << static_cast<int32_T>
                                (ib + 2));
                            i4 = static_cast<int32_T>(i3 << 1);
                            d = static_cast<int32_T>(256 >> static_cast<int32_T>
                                (ib + 3));
                            for (i1 = 0; i1 <= static_cast<int32_T>(d - 1); i1++)
                            {
                                int32_T p;
                                int32_T q;
                                blockOffset = static_cast<int32_T>
                                    (static_cast<int32_T>(i1 * i4) + i2);
                                for (p = 0; p <= static_cast<int32_T>(i4 - 1); p
                                        ++) {
                                    b_iwork_tmp = static_cast<int32_T>(
                                        static_cast<int32_T>(blockOffset + p) +
                                        1);
                                    b_iwork[p] = idx->data[b_iwork_tmp];
                                    b_xwork[p] = b_x->data[b_iwork_tmp];
                                }

                                p = 0;
                                q = i3;
                                int32_T exitg1;
                                do {
                                    exitg1 = 0;
                                    blockOffset = static_cast<int32_T>
                                        (blockOffset + 1);
                                    if (b_xwork[p] <= b_xwork[q]) {
                                        idx->data[blockOffset] = b_iwork[p];
                                        b_x->data[blockOffset] = b_xwork[p];
                                        if (static_cast<int32_T>(p + 1) < i3) {
                                            p = static_cast<int32_T>(p + 1);
                                        } else {
                                            exitg1 = 1;
                                        }
                                    } else {
                                        idx->data[blockOffset] = b_iwork[q];
                                        b_x->data[blockOffset] = b_xwork[q];
                                        if (static_cast<int32_T>(q + 1) < i4) {
                                            q = static_cast<int32_T>(q + 1);
                                        } else {
                                            q = static_cast<int32_T>(blockOffset
                                                - p);
                                            for (blockOffset =
                                                    static_cast<int32_T>(p + 1);
                                                 blockOffset <= i3; blockOffset
                                                    ++) {
                                                b_iwork_tmp =
                                                    static_cast<int32_T>(q +
                                                    blockOffset);
                                                idx->data[b_iwork_tmp] =
                                                    b_iwork[static_cast<int32_T>
                                                    (blockOffset - 1)];
                                                b_x->data[b_iwork_tmp] =
                                                    b_xwork[static_cast<int32_T>
                                                    (blockOffset - 1)];
                                            }

                                            exitg1 = 1;
                                        }
                                    }
                                } while (exitg1 == 0);
                            }
                        }
                    }

                    nBlocks = static_cast<int32_T>(nBlocks << 8);
                    wOffset = static_cast<int32_T>(n - nBlocks);
                    if (wOffset > 0) {
                        FlightMissionMode_merge_block(idx, b_x, nBlocks, wOffset,
                            2, iwork, xwork);
                    }

                    wOffset = 8;
                }
            }

            FlightMissionMode_merge_block(idx, b_x, 0, n, wOffset, iwork, xwork);
        }

        FlightMissionMode_emxFree_real_T(&xwork);
        FlightMissionMode_emxFree_int32_T(&iwork);
        FlightMissionMode_emxFree_int32_T(&idx);
    }

    b_iwork_tmp = static_cast<int32_T>(x->size[0] * x->size[1]);
    x->size[0] = 1;
    x->size[1] = b_x->size[1];
    FlightMissionMode_emxEnsureCapacity_real_T(x, b_iwork_tmp);
    n = b_x->size[1];
    for (ib = 0; ib <= static_cast<int32_T>(n - 1); ib++) {
        x->data[ib] = b_x->data[ib];
    }

    FlightMissionMode_emxFree_real_T(&b_x);
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static void FlightMissionMode_eml_find_j(const
    emxArray_boolean_T_FlightMissionMode_T *x,
    emxArray_int32_T_FlightMissionMode_T *i)
{
    int32_T idx;
    int32_T ii;
    int32_T nx;
    boolean_T exitg1;
    nx = x->size[1];
    idx = 0;
    ii = static_cast<int32_T>(i->size[0] * i->size[1]);
    i->size[0] = 1;
    i->size[1] = x->size[1];
    FlightMissionMode_emxEnsureCapacity_int32_T(i, ii);
    ii = 0;
    exitg1 = false;
    while ((!exitg1) && (ii <= static_cast<int32_T>(nx - 1))) {
        if (x->data[ii]) {
            idx = static_cast<int32_T>(idx + 1);
            i->data[static_cast<int32_T>(idx - 1)] = static_cast<int32_T>(ii + 1);
            if (idx >= nx) {
                exitg1 = true;
            } else {
                ii = static_cast<int32_T>(ii + 1);
            }
        } else {
            ii = static_cast<int32_T>(ii + 1);
        }
    }

    if (x->size[1] == 1) {
        if (idx == 0) {
            i->size[0] = 1;
            i->size[1] = 0;
        }
    } else if (idx < 1) {
        i->size[1] = 0;
    } else {
        ii = static_cast<int32_T>(i->size[0] * i->size[1]);
        i->size[1] = idx;
        FlightMissionMode_emxEnsureCapacity_int32_T(i, ii);
    }
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static void FlightMissionMode_uavDubinsPathSegment_interpolate_k(const real_T
    b_this_StartPose[4], const real_T b_this_GoalPose[4], real_T
    b_this_FlightPathAngle, real_T b_this_AirSpeed, real_T
    b_this_MinTurningRadius, real_T b_this_HelixRadius, const
    cell_wrap_0_FlightMissionMode_T b_this_MotionTypes[4], const real_T
    b_this_MotionLengths[4], real_T b_this_Length,
    emxArray_real_T_FlightMissionMode_T *samples,
    emxArray_real_T_FlightMissionMode_T *poses)
{
    emxArray_boolean_T_FlightMissionMode_T *tempSamplesIndex;
    emxArray_boolean_T_FlightMissionMode_T *tempSamplesIndex_0;
    emxArray_int32_T_FlightMissionMode_T *bb;
    emxArray_real_T_FlightMissionMode_T *S;
    emxArray_real_T_FlightMissionMode_T *S_0;
    emxArray_real_T_FlightMissionMode_T *d_x;
    emxArray_real_T_FlightMissionMode_T *ns;
    emxArray_real_T_FlightMissionMode_T *p;
    emxArray_real_T_FlightMissionMode_T *tempSamples;
    emxArray_real_T_FlightMissionMode_T *z;
    real_T state[6];
    real_T TransformMatrix[4];
    real_T tempMotionLength_data[4];
    real_T transLength_data[4];
    int32_T transLength_size[2];
    boolean_T tmp[4];
    poses->size[0] = 0;
    poses->size[1] = 6;
    if ((static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(std::
            isnan(b_this_Length)) ^ 1))) && (samples->size[1] != 0)) {
        real_T b_b_tmp;
        real_T intermediateLength;
        real_T startIndex;
        real_T tempStartPose_idx_2;
        int32_T loop_ub;
        int32_T tempMotionLength_size_idx_1;
        tempStartPose_idx_2 = -b_this_StartPose[2];
        loop_ub = static_cast<int32_T>(poses->size[0] * poses->size[1]);
        poses->size[0] = samples->size[1];
        poses->size[1] = 6;
        FlightMissionMode_emxEnsureCapacity_real_T(poses, loop_ub);
        loop_ub = static_cast<int32_T>(samples->size[1] * 6);
        for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                static_cast<int32_T>(loop_ub - 1); transLength_data_tmp++) {
            poses->data[transLength_data_tmp] = 0.0;
        }

        b_b_tmp = std::cos(std::abs(b_this_FlightPathAngle));
        loop_ub = static_cast<int32_T>(samples->size[0] * samples->size[1]);
        samples->size[0] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T(samples, loop_ub);
        loop_ub = static_cast<int32_T>(samples->size[1] - 1);
        for (int32_T transLength_data_tmp{0}; transLength_data_tmp <= loop_ub;
                transLength_data_tmp++) {
            samples->data[transLength_data_tmp] *= b_b_tmp;
        }

        TransformMatrix[0] = b_this_MotionLengths[0] * b_b_tmp;
        TransformMatrix[1] = b_this_MotionLengths[1] * b_b_tmp;
        TransformMatrix[2] = b_this_MotionLengths[2] * b_b_tmp;
        tempMotionLength_size_idx_1 = 4;
        tempMotionLength_data[0] = TransformMatrix[0];
        tempMotionLength_data[1] = TransformMatrix[1];
        tempMotionLength_data[2] = TransformMatrix[2];
        tempMotionLength_data[3] = b_this_MotionLengths[3] * b_b_tmp;
        FlightMissionMode_strcmp_f4pnpw5(b_this_MotionTypes, tmp);
        if (FlightMissionMode_any(tmp)) {
            tempMotionLength_size_idx_1 = 3;
            tempMotionLength_data[0] = TransformMatrix[0];
            tempMotionLength_data[1] = TransformMatrix[1];
            tempMotionLength_data[2] = TransformMatrix[2];
        }

        transLength_size[0] = 1;
        transLength_size[1] = tempMotionLength_size_idx_1;
        for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                static_cast<int32_T>(tempMotionLength_size_idx_1 - 1);
                transLength_data_tmp++) {
            transLength_data[transLength_data_tmp] =
                tempMotionLength_data[transLength_data_tmp];
        }

        FlightMissionMode_useConstantDim(transLength_data, transLength_size);
        FlightMissionMode_sort(samples);
        intermediateLength = 0.0;
        startIndex = 1.0;
        state[0] = b_this_StartPose[0];
        state[1] = -b_this_StartPose[1];
        state[3] = -b_this_StartPose[3];
        FlightMissionMode_emxInit_boolean_T(&tempSamplesIndex, 2);
        FlightMissionMode_emxInit_real_T(&tempSamples, 1);
        FlightMissionMode_emxInit_real_T(&S, 1);
        FlightMissionMode_emxInit_real_T(&ns, 2);
        FlightMissionMode_emxInit_real_T(&z, 1);
        FlightMissionMode_emxInit_real_T(&p, 2);
        FlightMissionMode_emxInit_real_T(&d_x, 1);
        FlightMissionMode_emxInit_int32_T(&bb, 2);
        FlightMissionMode_emxInit_boolean_T(&tempSamplesIndex_0, 2);
        FlightMissionMode_emxInit_real_T(&S_0, 2);
        for (int32_T tempMotionLength_data_tmp{0}; tempMotionLength_data_tmp <=
                static_cast<int32_T>(tempMotionLength_size_idx_1 - 1);
                tempMotionLength_data_tmp++) {
            real_T radius;
            if (static_cast<int32_T>(tempMotionLength_data_tmp + 1) == 1) {
                loop_ub = static_cast<int32_T>(tempSamplesIndex->size[0] *
                    tempSamplesIndex->size[1]);
                tempSamplesIndex->size[0] = 1;
                tempSamplesIndex->size[1] = samples->size[1];
                FlightMissionMode_emxEnsureCapacity_boolean_T(tempSamplesIndex,
                    loop_ub);
                radius = (intermediateLength + tempMotionLength_data[0]) +
                    1.0E-6;
                loop_ub = samples->size[1];
                for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                        static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                        ++) {
                    tempSamplesIndex->data[transLength_data_tmp] =
                        static_cast<boolean_T>(static_cast<int32_T>
                        ((samples->data[transLength_data_tmp] >=
                          intermediateLength) & (samples->
                        data[transLength_data_tmp] <= radius)));
                }
            } else {
                loop_ub = static_cast<int32_T>(tempSamplesIndex->size[0] *
                    tempSamplesIndex->size[1]);
                tempSamplesIndex->size[0] = 1;
                tempSamplesIndex->size[1] = samples->size[1];
                FlightMissionMode_emxEnsureCapacity_boolean_T(tempSamplesIndex,
                    loop_ub);
                radius = (intermediateLength +
                          tempMotionLength_data[tempMotionLength_data_tmp]) +
                    1.0E-6;
                loop_ub = samples->size[1];
                for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                        static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                        ++) {
                    tempSamplesIndex->data[transLength_data_tmp] =
                        static_cast<boolean_T>(static_cast<int32_T>
                        ((samples->data[transLength_data_tmp] >
                          intermediateLength) & (samples->
                        data[transLength_data_tmp] <= radius)));
                }
            }

            loop_ub = static_cast<int32_T>(tempSamplesIndex_0->size[0] *
                tempSamplesIndex_0->size[1]);
            tempSamplesIndex_0->size[0] = 1;
            tempSamplesIndex_0->size[1] = tempSamplesIndex->size[1];
            FlightMissionMode_emxEnsureCapacity_boolean_T(tempSamplesIndex_0,
                loop_ub);
            loop_ub = tempSamplesIndex->size[1];
            for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                    static_cast<int32_T>(loop_ub - 1); transLength_data_tmp++) {
                tempSamplesIndex_0->data[transLength_data_tmp] =
                    tempSamplesIndex->data[transLength_data_tmp];
            }

            FlightMissionMode_eml_find_j(tempSamplesIndex_0, bb);
            if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                    (FlightMissionMode_strcmp_f4pnpw5g
                     (b_this_MotionTypes[tempMotionLength_data_tmp].f1.data,
                      b_this_MotionTypes[tempMotionLength_data_tmp].f1.size)) ^
                    1))) {
                real_T TransformMatrix_tmp;
                real_T TransformMatrix_tmp_0;
                int32_T count;
                int32_T tempMotionLength_data_tmp_0;
                radius = b_this_MinTurningRadius;
                if (FlightMissionMode_strcmp_f4pnpw5g3
                        (b_this_MotionTypes[tempMotionLength_data_tmp].f1.data,
                         b_this_MotionTypes[tempMotionLength_data_tmp].f1.size))
                {
                    radius = b_this_HelixRadius;
                } else if (FlightMissionMode_strcmp_f4pnpw5g32
                           (b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.data,
                            b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.size)) {
                    radius = b_this_HelixRadius;
                }

                count = 0;
                loop_ub = tempSamples->size[0];
                tempSamples->size[0] = 1;
                FlightMissionMode_emxEnsureCapacity_real_T(tempSamples, loop_ub);
                tempSamples->data[0] = 0.0;
                if (bb->size[1] != 0) {
                    loop_ub = tempSamples->size[0];
                    tempSamples->size[0] = static_cast<int32_T>(bb->size[1] + 1);
                    FlightMissionMode_emxEnsureCapacity_real_T(tempSamples,
                        loop_ub);
                    loop_ub = bb->size[1];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         loop_ub; transLength_data_tmp++) {
                        tempSamples->data[transLength_data_tmp] = 0.0;
                    }

                    if (static_cast<boolean_T>(static_cast<int32_T>((
                            static_cast<real_T>(static_cast<int32_T>(bb->size[1]
                             + 1)) - 1.0 < 1.0) ^ 1))) {
                        count = bb->size[1];
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(count - 1); transLength_data_tmp++)
                    {
                        tempSamples->data[transLength_data_tmp] = samples->data[
                            static_cast<int32_T>(bb->data[transLength_data_tmp]
                            - 1)];
                    }

                    count = bb->size[1];
                    loop_ub = bb->size[1];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        samples->data[static_cast<int32_T>(bb->
                            data[transLength_data_tmp] - 1)] = -1.0;
                    }
                }

                tempSamples->data[count] =
                    transLength_data[tempMotionLength_data_tmp];
                loop_ub = S->size[0];
                S->size[0] = tempSamples->size[0];
                FlightMissionMode_emxEnsureCapacity_real_T(S, loop_ub);
                loop_ub = tempSamples->size[0];
                for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                        static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                        ++) {
                    S->data[transLength_data_tmp] = (tempSamples->
                        data[transLength_data_tmp] - intermediateLength) /
                        radius;
                }

                loop_ub = static_cast<int32_T>(ns->size[0] * ns->size[1]);
                ns->size[0] = S->size[0];
                ns->size[1] = 6;
                FlightMissionMode_emxEnsureCapacity_real_T(ns, loop_ub);
                loop_ub = static_cast<int32_T>(S->size[0] * 6);
                for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                        static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                        ++) {
                    ns->data[transLength_data_tmp] = 0.0;
                }

                loop_ub = z->size[0];
                z->size[0] = tempSamples->size[0];
                FlightMissionMode_emxEnsureCapacity_real_T(z, loop_ub);
                loop_ub = tempSamples->size[0];
                for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                        static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                        ++) {
                    z->data[transLength_data_tmp] = tempStartPose_idx_2 +
                        tempSamples->data[transLength_data_tmp];
                }

                TransformMatrix_tmp = std::sin(state[3]);
                TransformMatrix_tmp_0 = std::cos(state[3]);
                TransformMatrix[0] = TransformMatrix_tmp_0;
                TransformMatrix[2] = TransformMatrix_tmp;
                TransformMatrix[1] = -TransformMatrix_tmp;
                TransformMatrix[3] = TransformMatrix_tmp_0;
                if (b_this_Length != 0.0) {
                    TransformMatrix_tmp = -b_this_GoalPose[2] -
                        tempStartPose_idx_2;
                    TransformMatrix_tmp_0 = b_this_Length * b_b_tmp;
                    loop_ub = z->size[0];
                    z->size[0] = tempSamples->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T(z, loop_ub);
                    loop_ub = tempSamples->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        z->data[transLength_data_tmp] = tempSamples->
                            data[transLength_data_tmp] / TransformMatrix_tmp_0 *
                            TransformMatrix_tmp + tempStartPose_idx_2;
                    }
                }

                if (FlightMissionMode_strcmp_f4pnpw5g3
                        (b_this_MotionTypes[tempMotionLength_data_tmp].f1.data,
                         b_this_MotionTypes[tempMotionLength_data_tmp].f1.size) ||
                    FlightMissionMode_strcmp_f4pnpw5g325
                        (b_this_MotionTypes[tempMotionLength_data_tmp].f1.data,
                         b_this_MotionTypes[tempMotionLength_data_tmp].f1.size))
                {
                    real_T state_0;
                    real_T state_1;
                    loop_ub = tempSamples->size[0];
                    tempSamples->size[0] = S->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T(tempSamples,
                        loop_ub);
                    loop_ub = S->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        tempSamples->data[transLength_data_tmp] = S->
                            data[transLength_data_tmp];
                    }

                    count = S->size[0];
                    for (loop_ub = 0; loop_ub <= static_cast<int32_T>(count - 1);
                         loop_ub++) {
                        tempSamples->data[loop_ub] = std::sin(tempSamples->
                            data[loop_ub]);
                    }

                    loop_ub = d_x->size[0];
                    d_x->size[0] = S->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T(d_x, loop_ub);
                    loop_ub = S->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        d_x->data[transLength_data_tmp] = S->
                            data[transLength_data_tmp];
                    }

                    count = S->size[0];
                    for (loop_ub = 0; loop_ub <= static_cast<int32_T>(count - 1);
                         loop_ub++) {
                        d_x->data[loop_ub] = std::cos(d_x->data[loop_ub]);
                    }

                    loop_ub = static_cast<int32_T>(S_0->size[0] * S_0->size[1]);
                    S_0->size[0] = tempSamples->size[0];
                    S_0->size[1] = 2;
                    FlightMissionMode_emxEnsureCapacity_real_T(S_0, loop_ub);
                    loop_ub = tempSamples->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        S_0->data[transLength_data_tmp] = tempSamples->
                            data[transLength_data_tmp];
                    }

                    loop_ub = d_x->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        S_0->data[static_cast<int32_T>(transLength_data_tmp +
                            tempSamples->size[0])] = 1.0 - d_x->
                            data[transLength_data_tmp];
                    }

                    FlightMissionMode_mtimes(S_0, TransformMatrix, p);
                    TransformMatrix_tmp = rt_atan2d_snf(b_this_AirSpeed *
                        b_this_AirSpeed, 9.8 * radius);
                    TransformMatrix_tmp_0 = state[0];
                    state_0 = state[1];
                    state_1 = state[3];
                    count = S->size[0];
                    tempMotionLength_data_tmp_0 = S->size[0];
                    loop_ub = static_cast<int32_T>(ns->size[0] * ns->size[1]);
                    ns->size[0] = p->size[0];
                    ns->size[1] = 6;
                    FlightMissionMode_emxEnsureCapacity_real_T(ns, loop_ub);
                    loop_ub = p->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        ns->data[transLength_data_tmp] = p->
                            data[transLength_data_tmp] * radius +
                            TransformMatrix_tmp_0;
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            ns->size[0])] = p->data[static_cast<int32_T>
                            (transLength_data_tmp + p->size[0])] * radius +
                            state_0;
                    }

                    loop_ub = z->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] << 1))] = z->
                            data[transLength_data_tmp];
                    }

                    loop_ub = S->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] * 3))] = state_1 +
                            S->data[transLength_data_tmp];
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(count - 1); transLength_data_tmp++)
                    {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] << 2))] =
                            b_this_FlightPathAngle;
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(tempMotionLength_data_tmp_0 - 1);
                            transLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] * 5))] =
                            -TransformMatrix_tmp;
                    }
                } else if (FlightMissionMode_strcmp_f4pnpw5g32
                           (b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.data,
                            b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.size) || FlightMissionMode_strcmp_f4pnpw5g325b
                           (b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.data,
                            b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.size)) {
                    real_T state_0;
                    real_T state_1;
                    loop_ub = tempSamples->size[0];
                    tempSamples->size[0] = S->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T(tempSamples,
                        loop_ub);
                    loop_ub = S->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        tempSamples->data[transLength_data_tmp] = S->
                            data[transLength_data_tmp];
                    }

                    count = S->size[0];
                    for (loop_ub = 0; loop_ub <= static_cast<int32_T>(count - 1);
                         loop_ub++) {
                        tempSamples->data[loop_ub] = std::sin(tempSamples->
                            data[loop_ub]);
                    }

                    loop_ub = d_x->size[0];
                    d_x->size[0] = S->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T(d_x, loop_ub);
                    loop_ub = S->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        d_x->data[transLength_data_tmp] = S->
                            data[transLength_data_tmp];
                    }

                    count = S->size[0];
                    for (loop_ub = 0; loop_ub <= static_cast<int32_T>(count - 1);
                         loop_ub++) {
                        d_x->data[loop_ub] = std::cos(d_x->data[loop_ub]);
                    }

                    loop_ub = static_cast<int32_T>(S_0->size[0] * S_0->size[1]);
                    S_0->size[0] = tempSamples->size[0];
                    S_0->size[1] = 2;
                    FlightMissionMode_emxEnsureCapacity_real_T(S_0, loop_ub);
                    loop_ub = tempSamples->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        S_0->data[transLength_data_tmp] = tempSamples->
                            data[transLength_data_tmp];
                    }

                    loop_ub = d_x->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        S_0->data[static_cast<int32_T>(transLength_data_tmp +
                            tempSamples->size[0])] = d_x->
                            data[transLength_data_tmp] - 1.0;
                    }

                    FlightMissionMode_mtimes(S_0, TransformMatrix, p);
                    TransformMatrix_tmp = rt_atan2d_snf(b_this_AirSpeed *
                        b_this_AirSpeed, 9.8 * radius);
                    TransformMatrix_tmp_0 = state[0];
                    state_0 = state[1];
                    state_1 = state[3];
                    count = S->size[0];
                    tempMotionLength_data_tmp_0 = S->size[0];
                    loop_ub = static_cast<int32_T>(ns->size[0] * ns->size[1]);
                    ns->size[0] = p->size[0];
                    ns->size[1] = 6;
                    FlightMissionMode_emxEnsureCapacity_real_T(ns, loop_ub);
                    loop_ub = p->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        ns->data[transLength_data_tmp] = p->
                            data[transLength_data_tmp] * radius +
                            TransformMatrix_tmp_0;
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            ns->size[0])] = p->data[static_cast<int32_T>
                            (transLength_data_tmp + p->size[0])] * radius +
                            state_0;
                    }

                    loop_ub = z->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] << 1))] = z->
                            data[transLength_data_tmp];
                    }

                    loop_ub = S->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] * 3))] = state_1 -
                            S->data[transLength_data_tmp];
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(count - 1); transLength_data_tmp++)
                    {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] << 2))] =
                            b_this_FlightPathAngle;
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(tempMotionLength_data_tmp_0 - 1);
                            transLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] * 5))] =
                            TransformMatrix_tmp;
                    }
                } else if (FlightMissionMode_strcmp_f4pnpw5g325bz
                           (b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.data,
                            b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.size)) {
                    real_T state_0;
                    int32_T S_idx_0;
                    count = S->size[0];
                    loop_ub = static_cast<int32_T>(S_0->size[0] * S_0->size[1]);
                    S_0->size[0] = S->size[0];
                    S_0->size[1] = 2;
                    FlightMissionMode_emxEnsureCapacity_real_T(S_0, loop_ub);
                    loop_ub = S->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        S_0->data[transLength_data_tmp] = S->
                            data[transLength_data_tmp];
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(count - 1); transLength_data_tmp++)
                    {
                        S_0->data[static_cast<int32_T>(transLength_data_tmp +
                            S->size[0])] = 0.0;
                    }

                    FlightMissionMode_mtimes(S_0, TransformMatrix, p);
                    TransformMatrix_tmp_0 = state[0];
                    state_0 = state[1];
                    count = S->size[0];
                    tempMotionLength_data_tmp_0 = S->size[0];
                    S_idx_0 = S->size[0];
                    loop_ub = static_cast<int32_T>(ns->size[0] * ns->size[1]);
                    ns->size[0] = p->size[0];
                    ns->size[1] = 6;
                    FlightMissionMode_emxEnsureCapacity_real_T(ns, loop_ub);
                    loop_ub = p->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        ns->data[transLength_data_tmp] = p->
                            data[transLength_data_tmp] * radius +
                            TransformMatrix_tmp_0;
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            ns->size[0])] = p->data[static_cast<int32_T>
                            (transLength_data_tmp + p->size[0])] * radius +
                            state_0;
                    }

                    loop_ub = z->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] << 1))] = z->
                            data[transLength_data_tmp];
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(count - 1); transLength_data_tmp++)
                    {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] * 3))] = state[3];
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(tempMotionLength_data_tmp_0 - 1);
                            transLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] << 2))] =
                            b_this_FlightPathAngle;
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(S_idx_0 - 1); transLength_data_tmp
                            ++) {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] * 5))] = 0.0;
                    }
                }

                if (bb->size[1] != 0) {
                    if (startIndex > (startIndex + static_cast<real_T>(bb->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <
                         6; transLength_data_tmp++) {
                        for (tempMotionLength_data_tmp_0 = 0;
                                tempMotionLength_data_tmp_0 <= loop_ub;
                                tempMotionLength_data_tmp_0++) {
                            poses->data[static_cast<int32_T>(static_cast<int32_T>
                                (static_cast<int32_T>(count +
                                tempMotionLength_data_tmp_0) +
                                 static_cast<int32_T>(poses->size[0] *
                                transLength_data_tmp)) - 1)] = ns->data[
                                static_cast<int32_T>(static_cast<int32_T>
                                (ns->size[0] * transLength_data_tmp) +
                                tempMotionLength_data_tmp_0)];
                        }
                    }

                    if (startIndex > (startIndex + static_cast<real_T>(bb->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         loop_ub; transLength_data_tmp++) {
                        poses->data[static_cast<int32_T>(static_cast<int32_T>
                            (count + transLength_data_tmp) - 1)] = ns->
                            data[transLength_data_tmp];
                    }

                    if (startIndex > (startIndex + static_cast<real_T>(bb->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         loop_ub; transLength_data_tmp++) {
                        poses->data[static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>(count + transLength_data_tmp) +
                            poses->size[0]) - 1)] = -ns->data
                            [static_cast<int32_T>(transLength_data_tmp +
                            ns->size[0])];
                    }

                    if (startIndex > (startIndex + static_cast<real_T>(bb->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         loop_ub; transLength_data_tmp++) {
                        poses->data[static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>(count + transLength_data_tmp) +
                            static_cast<int32_T>(poses->size[0] << 1)) - 1)] =
                            -ns->data[static_cast<int32_T>(static_cast<int32_T>
                            (ns->size[0] << 1) + transLength_data_tmp)];
                    }

                    if (startIndex > (startIndex + static_cast<real_T>(bb->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         loop_ub; transLength_data_tmp++) {
                        poses->data[static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>(count + transLength_data_tmp) +
                            static_cast<int32_T>(poses->size[0] * 3)) - 1)] =
                            -ns->data[static_cast<int32_T>(static_cast<int32_T>
                            (ns->size[0] * 3) + transLength_data_tmp)];
                    }
                }

                count = ns->size[0];
                for (int32_T transLength_data_tmp{0}; transLength_data_tmp < 6;
                        transLength_data_tmp++) {
                    state[transLength_data_tmp] = ns->data[static_cast<int32_T>(
                        static_cast<int32_T>(static_cast<int32_T>(ns->size[0] *
                        transLength_data_tmp) + count) - 1)];
                }

                startIndex += static_cast<real_T>(bb->size[1]);
            }

            intermediateLength +=
                tempMotionLength_data[tempMotionLength_data_tmp];
        }

        FlightMissionMode_emxFree_real_T(&S_0);
        FlightMissionMode_emxFree_boolean_T(&tempSamplesIndex_0);
        FlightMissionMode_emxFree_int32_T(&bb);
        FlightMissionMode_emxFree_real_T(&d_x);
        FlightMissionMode_emxFree_real_T(&p);
        FlightMissionMode_emxFree_real_T(&z);
        FlightMissionMode_emxFree_real_T(&ns);
        FlightMissionMode_emxFree_real_T(&S);
        FlightMissionMode_emxFree_boolean_T(&tempSamplesIndex);
        loop_ub = tempSamples->size[0];
        tempSamples->size[0] = poses->size[0];
        FlightMissionMode_emxEnsureCapacity_real_T(tempSamples, loop_ub);
        loop_ub = poses->size[0];
        for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                static_cast<int32_T>(loop_ub - 1); transLength_data_tmp++) {
            tempSamples->data[transLength_data_tmp] = poses->data
                [static_cast<int32_T>(static_cast<int32_T>(poses->size[0] * 3) +
                transLength_data_tmp)];
        }

        FlightMissionMode_wrapToPi(tempSamples);
        loop_ub = tempSamples->size[0];
        for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                static_cast<int32_T>(loop_ub - 1); transLength_data_tmp++) {
            poses->data[static_cast<int32_T>(transLength_data_tmp +
                static_cast<int32_T>(poses->size[0] * 3))] = tempSamples->
                data[transLength_data_tmp];
        }

        FlightMissionMode_emxFree_real_T(&tempSamples);
    }
}

// Function for MATLAB Function: '<S77>/StartPointGenerator'
static void FlightMissionMode_genSegWP(const real_T start[4], const real_T ende
    [4], emxArray_real_T_FlightMissionMode_T *segWayPoints,
    DW_StartPointGenerator_FlightMissionMode_T *localDW)
{
    emxArray_real_T_FlightMissionMode_T *lengths;
    emxArray_real_T_FlightMissionMode_T *poses;
    uavDubinsConnection_FlightMissionMode_T *obj;
    uavDubinsPathSegment_FlightMissionMode_T pathSegObj;
    real_T a__1;
    int32_T k;
    int32_T n;
    int32_T nm1d2;
    obj = FlightMissionMode_DubinsObjSingleton_getConnector(localDW);
    FlightMissionMode_uavDubinsBuiltins_connect(obj, start, ende,
        obj->MinTurningRadius, &pathSegObj, &a__1);
    a__1 = std::fmax(2.2204460492503131E-16, pathSegObj.Length / 128.0);
    FlightMissionMode_emxInit_real_T(&lengths, 2);
    if (std::isnan(pathSegObj.Length)) {
        k = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        lengths->size[1] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T(lengths, k);
        lengths->data[0] = (rtNaN);
    } else if (pathSegObj.Length < 0.0) {
        lengths->size[0] = 1;
        lengths->size[1] = 0;
    } else if (std::isinf(pathSegObj.Length) && std::isinf(a__1)) {
        k = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        lengths->size[1] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T(lengths, k);
        lengths->data[0] = (rtNaN);
    } else if (std::isinf(a__1)) {
        k = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        lengths->size[1] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T(lengths, k);
        lengths->data[0] = 0.0;
    } else if (std::floor(a__1) == a__1) {
        k = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        nm1d2 = static_cast<int32_T>(pathSegObj.Length / a__1);
        lengths->size[1] = static_cast<int32_T>(nm1d2 + 1);
        FlightMissionMode_emxEnsureCapacity_real_T(lengths, k);
        for (k = 0; k <= nm1d2; k++) {
            lengths->data[k] = a__1 * static_cast<real_T>(k);
        }
    } else {
        real_T apnd;
        real_T cdiff;
        real_T ndbl;
        ndbl = std::floor(pathSegObj.Length / a__1 + 0.5);
        apnd = ndbl * a__1;
        cdiff = apnd - pathSegObj.Length;
        if (std::abs(cdiff) < 4.4408920985006262E-16 * std::fmax(0.0, std::abs
                (pathSegObj.Length))) {
            ndbl++;
            apnd = pathSegObj.Length;
        } else if (cdiff > 0.0) {
            apnd = (ndbl - 1.0) * a__1;
        } else {
            ndbl++;
        }

        if (ndbl >= 0.0) {
            n = static_cast<int32_T>(static_cast<int32_T>(ndbl) - 1);
        } else {
            n = -1;
        }

        k = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        lengths->size[1] = static_cast<int32_T>(n + 1);
        FlightMissionMode_emxEnsureCapacity_real_T(lengths, k);
        if (static_cast<int32_T>(n + 1) > 0) {
            lengths->data[0] = 0.0;
            if (static_cast<int32_T>(n + 1) > 1) {
                lengths->data[n] = apnd;
                nm1d2 = static_cast<int32_T>(n / 2);
                for (k = 0; k <= static_cast<int32_T>(nm1d2 - 2); k++) {
                    ndbl = (static_cast<real_T>(k) + 1.0) * a__1;
                    lengths->data[static_cast<int32_T>(k + 1)] = ndbl;
                    lengths->data[static_cast<int32_T>(static_cast<int32_T>(n -
                        k) - 1)] = apnd - ndbl;
                }

                if (static_cast<int32_T>(nm1d2 << 1) == n) {
                    lengths->data[nm1d2] = apnd / 2.0;
                } else {
                    ndbl = static_cast<real_T>(nm1d2) * a__1;
                    lengths->data[nm1d2] = ndbl;
                    lengths->data[static_cast<int32_T>(nm1d2 + 1)] = apnd - ndbl;
                }
            }
        }
    }

    FlightMissionMode_emxInit_real_T(&poses, 2);
    FlightMissionMode_uavDubinsPathSegment_interpolate_k(pathSegObj.StartPose,
        pathSegObj.GoalPose, pathSegObj.FlightPathAngle, pathSegObj.AirSpeed,
        pathSegObj.MinTurningRadius, pathSegObj.HelixRadius,
        pathSegObj.MotionTypes, pathSegObj.MotionLengths, pathSegObj.Length,
        lengths, poses);
    FlightMissionMode_emxFree_real_T(&lengths);
    k = static_cast<int32_T>(segWayPoints->size[0] * segWayPoints->size[1]);
    segWayPoints->size[0] = poses->size[0];
    segWayPoints->size[1] = 3;
    FlightMissionMode_emxEnsureCapacity_real_T(segWayPoints, k);
    nm1d2 = poses->size[0];
    for (k = 0; k < 3; k++) {
        for (n = 0; n <= static_cast<int32_T>(nm1d2 - 1); n++) {
            segWayPoints->data[static_cast<int32_T>(n + static_cast<int32_T>
                (segWayPoints->size[0] * k))] = poses->data[static_cast<int32_T>
                (static_cast<int32_T>(poses->size[0] * k) + n)];
        }
    }

    FlightMissionMode_emxFree_real_T(&poses);
}

//
// System initialize for atomic system:
//    '<S77>/StartPointGenerator'
//    '<S121>/StartPointGenerator'
//
void FlightMissionMode_StartPointGenerator_Init
    (DW_StartPointGenerator_FlightMissionMode_T *localDW)
{
    FILE* a;
    a = NULL;
    for (int32_T i{0}; i < 20; i++) {
        localDW->eml_openfiles[i] = a;
    }
}

//
// System reset for atomic system:
//    '<S77>/StartPointGenerator'
//    '<S121>/StartPointGenerator'
//
void FlightMissionMode_StartPointGenerator_Reset
    (DW_StartPointGenerator_FlightMissionMode_T *localDW)
{
    FILE* a;
    localDW->SingletonInstance_not_empty = false;
    a = NULL;
    for (int32_T i{0}; i < 20; i++) {
        localDW->eml_openfiles[i] = a;
    }
}

//
// Output and update for atomic system:
//    '<S77>/StartPointGenerator'
//    '<S121>/StartPointGenerator'
//
void FlightMissionMode_StartPointGenerator(real_T rtu_Length, real_T
    rtu_RunWayUAV, real_T rtu_PosIDX, real_T rty_initWayPoint[384], real_T
    rty_startPose[5], DW_StartPointGenerator_FlightMissionMode_T *localDW)
{
    static const int8_T b[5]{ 0, 1, 2, 3, 5 };

    emxArray_real_T_FlightMissionMode_T *c;
    emxArray_real_T_FlightMissionMode_T *dummyinitWP;
    uavDubinsConnection_FlightMissionMode_T *obj;
    uavDubinsPathSegment_FlightMissionMode_T pathSegObj;
    real_T midpose_data[6];
    real_T LUp_0[5];
    real_T PosIDX_0[5];
    real_T LDp[4];
    real_T LUp[4];
    real_T InterUAVLength;
    real_T PosIDX;
    int32_T midpose_size[2];
    int32_T i;
    int32_T loop_ub;

    // MATLAB Function 'StartPointGenerator': '<S109>:1'
    // '<S109>:1:4'
    LUp[0] = rtu_Length / 2.0;
    LUp[1] = 0.0;
    LUp[2] = 0.0;
    LUp[3] = 0.0;

    // '<S109>:1:5'
    LDp[0] = -rtu_Length / 2.0;
    LDp[1] = 0.0;
    LDp[2] = 0.0;
    LDp[3] = 0.0;

    // '<S109>:1:7'
    obj = FlightMissionMode_DubinsObjSingleton_getConnector(localDW);
    FlightMissionMode_uavDubinsBuiltins_connect(obj, LUp, LDp,
        obj->MinTurningRadius, &pathSegObj, &InterUAVLength);

    // '<S109>:1:8'
    // '<S109>:1:10'
    InterUAVLength = (pathSegObj.Length + rtu_Length) / rtu_RunWayUAV;

    // '<S109>:1:13'
    // '<S109>:1:14'
    // '<S109>:1:17'
    PosIDX = (rtu_PosIDX - ((rtu_RunWayUAV - std::floor(pathSegObj.Length /
                 InterUAVLength)) - 1.0)) - 1.0;

    // '<S109>:1:21'
    FlightMissionMode_emxInit_real_T(&dummyinitWP, 2);
    FlightMissionMode_emxInit_real_T(&c, 2);
    if (PosIDX > 0.0) {
        // '<S109>:1:24'
        // '<S109>:1:26'
        FlightMissionMode_uavDubinsPathSegment_interpolate(pathSegObj.StartPose,
            pathSegObj.GoalPose, pathSegObj.FlightPathAngle, pathSegObj.AirSpeed,
            pathSegObj.MinTurningRadius, pathSegObj.HelixRadius,
            pathSegObj.MotionTypes, pathSegObj.MotionLengths, pathSegObj.Length,
            InterUAVLength * PosIDX, midpose_data, midpose_size);

        // '<S109>:1:27'
        for (i = 0; i < 5; i++) {
            rty_startPose[i] = midpose_data[static_cast<int32_T>(midpose_size[0]
                * static_cast<int32_T>(b[i]))];
        }

        // '<S109>:1:28'
        LUp[0] = midpose_data[0];
        LUp[1] = midpose_data[midpose_size[0]];
        LUp[2] = midpose_data[static_cast<int32_T>(midpose_size[0] << 1)];
        LUp[3] = midpose_data[static_cast<int32_T>(midpose_size[0] * 3)];
        FlightMissionMode_genSegWP(LUp, LDp, c, localDW);
        i = static_cast<int32_T>(dummyinitWP->size[0] * dummyinitWP->size[1]);
        dummyinitWP->size[0] = static_cast<int32_T>(c->size[0] + 1);
        dummyinitWP->size[1] = 3;
        FlightMissionMode_emxEnsureCapacity_real_T(dummyinitWP, i);
        loop_ub = c->size[0];
        for (i = 0; i < 3; i++) {
            dummyinitWP->data[static_cast<int32_T>(dummyinitWP->size[0] * i)] =
                0.0;
            for (int32_T i_0{0}; i_0 <= static_cast<int32_T>(loop_ub - 1); i_0++)
            {
                dummyinitWP->data[static_cast<int32_T>(static_cast<int32_T>(i_0
                    + static_cast<int32_T>(dummyinitWP->size[0] * i)) + 1)] =
                    c->data[static_cast<int32_T>(static_cast<int32_T>(c->size[0]
                    * i) + i_0)];
            }
        }
    } else {
        // '<S109>:1:31'
        LUp_0[0] = LUp[0];
        LUp_0[1] = 0.0;
        LUp_0[2] = 0.0;
        LUp_0[3] = 0.0;
        LUp_0[4] = 0.0;
        PosIDX_0[0] = PosIDX * InterUAVLength;
        PosIDX_0[1] = 0.0;
        PosIDX_0[2] = 0.0;
        PosIDX_0[3] = 0.0;
        PosIDX_0[4] = 0.0;
        for (i = 0; i < 5; i++) {
            rty_startPose[i] = LUp_0[i] + PosIDX_0[i];
        }

        // '<S109>:1:32'
        FlightMissionMode_genSegWP(LUp, LDp, c, localDW);
        i = static_cast<int32_T>(dummyinitWP->size[0] * dummyinitWP->size[1]);
        dummyinitWP->size[0] = static_cast<int32_T>(c->size[0] + 1);
        dummyinitWP->size[1] = 3;
        FlightMissionMode_emxEnsureCapacity_real_T(dummyinitWP, i);
        loop_ub = c->size[0];
        for (i = 0; i < 3; i++) {
            dummyinitWP->data[static_cast<int32_T>(dummyinitWP->size[0] * i)] =
                0.0;
            for (int32_T i_0{0}; i_0 <= static_cast<int32_T>(loop_ub - 1); i_0++)
            {
                dummyinitWP->data[static_cast<int32_T>(static_cast<int32_T>(i_0
                    + static_cast<int32_T>(dummyinitWP->size[0] * i)) + 1)] =
                    c->data[static_cast<int32_T>(static_cast<int32_T>(c->size[0]
                    * i) + i_0)];
            }
        }
    }

    FlightMissionMode_emxFree_real_T(&c);

    // '<S109>:1:35'
    loop_ub = static_cast<int32_T>(dummyinitWP->size[0] - 128);
    for (i = 0; i < 3; i++) {
        for (int32_T i_0{0}; i_0 < 128; i_0++) {
            rty_initWayPoint[static_cast<int32_T>(i_0 + static_cast<int32_T>(i <<
                7))] = dummyinitWP->data[static_cast<int32_T>
                (static_cast<int32_T>(i_0 + loop_ub) + static_cast<int32_T>
                 (dummyinitWP->size[0] * i))];
        }
    }

    FlightMissionMode_emxFree_real_T(&dummyinitWP);
}

//
// Output and update for atomic system:
//    '<S110>/minus'
//    '<S155>/minus'
//
void FlightMissionMode_minus(const real_T rtu_uP[384], const real_T rtu_uN[3],
    real_T rty_y[384])
{
    // MATLAB Function 'minus': '<S114>:1'
    // '<S114>:1:3'
    for (int32_T jcol{0}; jcol < 3; jcol++) {
        int32_T ibmat;
        ibmat = static_cast<int32_T>(jcol << 7);
        for (int32_T itilerow{0}; itilerow < 128; itilerow++) {
            rty_y[static_cast<int32_T>(ibmat + itilerow)] = rtu_uN[jcol];
        }
    }

    for (int32_T jcol{0}; jcol < 384; jcol++) {
        rty_y[jcol] = rtu_uP[jcol] - rty_y[jcol];
    }
}

//
// Output and update for atomic system:
//    '<S110>/biasNED'
//    '<S155>/biasNED'
//
void FlightMissionMode_biasNED(const real_T rtu_MissionNED[3], const real_T
    rtu_IndivRotWP[384], real_T rty_nedWayPoint[384])
{
    real_T b[384];

    // MATLAB Function 'biasNED': '<S113>:1'
    // '<S113>:1:4'
    for (int32_T jcol{0}; jcol < 3; jcol++) {
        int32_T ibmat;
        ibmat = static_cast<int32_T>(jcol << 7);
        for (int32_T itilerow{0}; itilerow < 128; itilerow++) {
            b[static_cast<int32_T>(ibmat + itilerow)] = rtu_MissionNED[jcol];
        }
    }

    for (int32_T jcol{0}; jcol < 128; jcol++) {
        rty_nedWayPoint[jcol] = rtu_IndivRotWP[jcol] + b[jcol];
        rty_nedWayPoint[static_cast<int32_T>(jcol + 128)] = rtu_IndivRotWP[
            static_cast<int32_T>(jcol + 128)] + b[static_cast<int32_T>(jcol +
            128)];
        rty_nedWayPoint[static_cast<int32_T>(jcol + 256)] = rtu_IndivRotWP[
            static_cast<int32_T>(jcol + 256)] + b[static_cast<int32_T>(jcol +
            256)];
    }
}

static void FlightMissionMode_emxInit_char_T_b
    (emxArray_char_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions)
{
    emxArray_char_T_FlightMissionMode_T *emxArray;
    *pEmxArray = static_cast<emxArray_char_T_FlightMissionMode_T *>(std::malloc
        (sizeof(emxArray_char_T_FlightMissionMode_T)));
    emxArray = *pEmxArray;
    emxArray->data = static_cast<char_T *>(nullptr);
    emxArray->numDimensions = numDimensions;
    emxArray->size = static_cast<int32_T *>(std::malloc(static_cast<uint32_T>
        (sizeof(int32_T) * static_cast<uint32_T>(numDimensions))));
    emxArray->allocatedSize = 0;
    emxArray->canFreeData = true;
    for (int32_T i{0}; i <= static_cast<int32_T>(numDimensions - 1); i++) {
        emxArray->size[i] = 0;
    }
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static int8_T FlightMissionMode_filedata_e
    (DW_WayPointGenerator_FlightMissionMode_T *localDW)
{
    int32_T k;
    int8_T f;
    boolean_T exitg1;
    f = 0;
    k = 1;
    exitg1 = false;
    while ((!exitg1) && (static_cast<int32_T>(k - 1) < 20)) {
        if (localDW->eml_openfiles[static_cast<int32_T>(static_cast<int32_T>(
                static_cast<int8_T>(k)) - 1)] == NULL) {
            f = static_cast<int8_T>(k);
            exitg1 = true;
        } else {
            k = static_cast<int32_T>(k + 1);
        }
    }

    return f;
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static int8_T FlightMissionMode_cfopen_j(const char_T *cfilename, const char_T
    *cpermission, DW_WayPointGenerator_FlightMissionMode_T *localDW)
{
    int8_T fileid;
    int8_T j;
    fileid = -1;
    j = FlightMissionMode_filedata_e(localDW);
    if (static_cast<int32_T>(j) >= 1) {
        FILE* filestar;
        filestar = fopen(cfilename, cpermission);
        if (filestar != NULL) {
            int32_T tmp;
            localDW->eml_openfiles[static_cast<int32_T>(static_cast<int32_T>(j)
                - 1)] = filestar;
            tmp = static_cast<int32_T>(static_cast<int32_T>(j) + 2);
            if (static_cast<int32_T>(static_cast<int32_T>(j) + 2) > 127) {
                tmp = 127;
            }

            fileid = static_cast<int8_T>(tmp);
        }
    }

    return fileid;
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static real_T FlightMissionMode_fileManager_o
    (DW_WayPointGenerator_FlightMissionMode_T *localDW)
{
    real_T f;
    int8_T fileid;
    fileid = FlightMissionMode_cfopen_j("config.ini", "rb", localDW);
    f = static_cast<real_T>(fileid);
    return f;
}

static void FlightMissionMode_emxEnsureCapacity_char_T_o
    (emxArray_char_T_FlightMissionMode_T *emxArray, int32_T oldNumel)
{
    int32_T i;
    int32_T newNumel;
    void *newData;
    if (oldNumel < 0) {
        oldNumel = 0;
    }

    newNumel = 1;
    for (i = 0; i <= static_cast<int32_T>(emxArray->numDimensions - 1); i++) {
        newNumel = static_cast<int32_T>(newNumel * emxArray->size[i]);
    }

    if (newNumel > emxArray->allocatedSize) {
        i = emxArray->allocatedSize;
        if (i < 16) {
            i = 16;
        }

        while (i < newNumel) {
            if (i > 1073741823) {
                i = MAX_int32_T;
            } else {
                i = static_cast<int32_T>(i << 1);
            }
        }

        newData = std::calloc(static_cast<uint32_T>(i), sizeof(char_T));
        if (emxArray->data != nullptr) {
            std::memcpy(newData, emxArray->data, static_cast<uint32_T>(sizeof
                         (char_T) * static_cast<uint32_T>(oldNumel)));
            if (emxArray->canFreeData) {
                std::free(emxArray->data);
            }
        }

        emxArray->data = static_cast<char_T *>(newData);
        emxArray->allocatedSize = i;
        emxArray->canFreeData = true;
    }
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static void FlightMissionMode_fread_b(real_T fileID,
    emxArray_char_T_FlightMissionMode_T *A,
    DW_WayPointGenerator_FlightMissionMode_T *localDW)
{
    FILE* filestar;
    size_t nBytes;
    char_T tbuf[1024];
    int8_T fileid;
    nBytes = sizeof(char_T);
    fileid = static_cast<int8_T>(fileID);
    if (fileID != static_cast<real_T>(static_cast<int8_T>(fileID))) {
        fileid = -1;
    }

    if (static_cast<int32_T>(fileid) >= 3) {
        filestar = localDW->eml_openfiles[static_cast<int32_T>
            (static_cast<int32_T>(fileid) - 3)];
    } else {
        switch (static_cast<int32_T>(fileid)) {
          case 0:
            filestar = stdin;
            break;

          case 1:
            filestar = stdout;
            break;

          case 2:
            filestar = stderr;
            break;

          default:
            filestar = NULL;
            break;
        }
    }

    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
            static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
              static_cast<boolean_T>(static_cast<int32_T>((fileID != 0.0) ^ 1)))
             | static_cast<int32_T>(static_cast<boolean_T>(static_cast<int32_T>
               ((fileID != 1.0) ^ 1)))))) | static_cast<int32_T>
            (static_cast<boolean_T>(static_cast<int32_T>((fileID != 2.0) ^ 1))))))
    {
        filestar = NULL;
    }

    A->size[0] = 0;
    if (static_cast<boolean_T>(static_cast<int32_T>((filestar == NULL) ^ 1))) {
        int32_T c;
        c = 1;
        while (c > 0) {
            int32_T i;
            int32_T loop_ub;
            int32_T numRead;
            int32_T tmp;
            c = 0;
            numRead = 1;
            while (static_cast<boolean_T>(static_cast<int32_T>((c < 1024) &
                     (numRead > 0)))) {
                size_t numReadSizeT;
                numReadSizeT = fread(&tbuf[c], nBytes, (size_t)(1024 - c),
                                     filestar);
                numRead = (int32_T)numReadSizeT;
                c = static_cast<int32_T>(c + (int32_T)numReadSizeT);
            }

            numRead = A->size[0];
            if (c < 1) {
                i = -1;
                loop_ub = -1;
            } else {
                i = static_cast<int32_T>(c - 1);
                loop_ub = static_cast<int32_T>(c - 1);
            }

            tmp = A->size[0];
            A->size[0] = static_cast<int32_T>(static_cast<int32_T>(i + A->size[0])
                + 1);
            FlightMissionMode_emxEnsureCapacity_char_T_o(A, tmp);
            for (i = 0; i <= loop_ub; i++) {
                A->data[static_cast<int32_T>(numRead + i)] = tbuf[i];
            }
        }
    }
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static void FlightMissionMode_copysign_l(emxArray_char_T_FlightMissionMode_T *s1,
    int32_T *idx, const emxArray_char_T_FlightMissionMode_T *s, int32_T *k,
    int32_T n, boolean_T *foundsign, boolean_T *success)
{
    static const boolean_T b[128]{ false, false, false, false, false, false,
        false, false, false, true, true, true, true, true, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, true, true, true, true, true, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false };

    boolean_T exitg1;
    boolean_T isneg;
    isneg = false;
    *foundsign = false;
    exitg1 = false;
    while ((!exitg1) && (*k <= n)) {
        char_T tmp;
        tmp = s->data[static_cast<int32_T>(*k - 1)];
        if (tmp == '-') {
            isneg = static_cast<boolean_T>(static_cast<int32_T>
                (static_cast<int32_T>(isneg) ^ 1));
            *foundsign = true;
            *k = static_cast<int32_T>(*k + 1);
        } else if (tmp == ',') {
            *k = static_cast<int32_T>(*k + 1);
        } else if (tmp == '+') {
            *foundsign = true;
            *k = static_cast<int32_T>(*k + 1);
        } else if (static_cast<boolean_T>(static_cast<int32_T>
                    (static_cast<int32_T>(b[static_cast<int32_T>
                      (static_cast<int32_T>(static_cast<uint8_T>(tmp)) & 127)]) ^
                     1))) {
            exitg1 = true;
        } else {
            *k = static_cast<int32_T>(*k + 1);
        }
    }

    *success = (*k <= n);
    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
            (*success) & static_cast<int32_T>(isneg)))) {
        if ((*idx >= 2) && (s1->data[static_cast<int32_T>(*idx - 2)] == '-')) {
            s1->data[static_cast<int32_T>(*idx - 2)] = ' ';
        } else {
            s1->data[static_cast<int32_T>(*idx - 1)] = '-';
            *idx = static_cast<int32_T>(*idx + 1);
        }
    }
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static boolean_T FlightMissionMode_isUnitImag_b(const
    emxArray_char_T_FlightMissionMode_T *s, int32_T k, int32_T n)
{
    boolean_T p;
    p = false;
    if (k <= n) {
        char_T c_idx_0;
        c_idx_0 = s->data[static_cast<int32_T>(k - 1)];
        if (c_idx_0 == 'j') {
            p = true;
        } else if (c_idx_0 == 'i') {
            if (k >= static_cast<int32_T>(n - 1)) {
                p = true;
            } else {
                int32_T b_k;
                char_T c_idx_1;
                char_T c_idx_2;
                b_k = k;
                c_idx_0 = '\x00';
                while ((b_k <= n) && (s->data[static_cast<int32_T>(b_k - 1)] ==
                                      ',')) {
                    b_k = static_cast<int32_T>(b_k + 1);
                }

                if (b_k <= n) {
                    c_idx_0 = s->data[static_cast<int32_T>(b_k - 1)];
                }

                b_k = static_cast<int32_T>(b_k + 1);
                c_idx_1 = '\x00';
                while ((b_k <= n) && (s->data[static_cast<int32_T>(b_k - 1)] ==
                                      ',')) {
                    b_k = static_cast<int32_T>(b_k + 1);
                }

                if (b_k <= n) {
                    c_idx_1 = s->data[static_cast<int32_T>(b_k - 1)];
                }

                b_k = static_cast<int32_T>(b_k + 1);
                c_idx_2 = '\x00';
                while ((b_k <= n) && (s->data[static_cast<int32_T>(b_k - 1)] ==
                                      ',')) {
                    b_k = static_cast<int32_T>(b_k + 1);
                }

                if (b_k <= n) {
                    c_idx_2 = s->data[static_cast<int32_T>(b_k - 1)];
                }

                if (((c_idx_0 == 'I') || (c_idx_0 == 'i')) && ((c_idx_1 == 'N') ||
                     (c_idx_1 == 'n')) && ((c_idx_2 == 'F') || (c_idx_2 == 'f')))
                {
                } else if ((c_idx_0 == 'N') || (c_idx_0 == 'n')) {
                    if ((c_idx_1 == 'A') || (c_idx_1 == 'a')) {
                        if ((c_idx_2 != 'N') && (c_idx_2 != 'n')) {
                            p = true;
                        }
                    } else {
                        p = true;
                    }
                } else {
                    p = true;
                }
            }
        }
    }

    return p;
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static void FlightMissionMode_readNonFinite_c(const
    emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n, boolean_T
    *b_finite, real_T *fv)
{
    int32_T ksaved;
    char_T c_idx_0;
    char_T c_idx_1;
    char_T c_idx_2;
    ksaved = *k;
    c_idx_0 = '\x00';
    while ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == ',')) {
        *k = static_cast<int32_T>(*k + 1);
    }

    if (*k <= n) {
        c_idx_0 = s->data[static_cast<int32_T>(*k - 1)];
    }

    *k = static_cast<int32_T>(*k + 1);
    c_idx_1 = '\x00';
    while ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == ',')) {
        *k = static_cast<int32_T>(*k + 1);
    }

    if (*k <= n) {
        c_idx_1 = s->data[static_cast<int32_T>(*k - 1)];
    }

    *k = static_cast<int32_T>(*k + 1);
    c_idx_2 = '\x00';
    while ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == ',')) {
        *k = static_cast<int32_T>(*k + 1);
    }

    if (*k <= n) {
        c_idx_2 = s->data[static_cast<int32_T>(*k - 1)];
    }

    *k = static_cast<int32_T>(*k + 1);
    if (((c_idx_0 == 'I') || (c_idx_0 == 'i')) && ((c_idx_1 == 'N') || (c_idx_1 ==
          'n')) && ((c_idx_2 == 'F') || (c_idx_2 == 'f'))) {
        *b_finite = false;
        *fv = (rtInf);
    } else if (((c_idx_0 == 'N') || (c_idx_0 == 'n')) && ((c_idx_1 == 'A') ||
                (c_idx_1 == 'a')) && ((c_idx_2 == 'N') || (c_idx_2 == 'n'))) {
        *b_finite = false;
        *fv = (rtNaN);
    } else {
        *b_finite = true;
        *fv = 0.0;
        *k = ksaved;
    }
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static boolean_T FlightMissionMode_copydigits_a
    (emxArray_char_T_FlightMissionMode_T *s1, int32_T *idx, const
     emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n, boolean_T
     allowpoint)
{
    boolean_T exitg1;
    boolean_T haspoint;
    boolean_T success;
    success = (*k <= n);
    haspoint = false;
    exitg1 = false;
    while ((!exitg1) && (static_cast<boolean_T>(static_cast<int32_T>((*k <= n) &
              static_cast<int32_T>(success))))) {
        char_T tmp;
        tmp = s->data[static_cast<int32_T>(*k - 1)];
        if ((tmp >= '0') && (tmp <= '9')) {
            s1->data[static_cast<int32_T>(*idx - 1)] = tmp;
            *idx = static_cast<int32_T>(*idx + 1);
            *k = static_cast<int32_T>(*k + 1);
        } else if (tmp == '.') {
            success = static_cast<boolean_T>(static_cast<int32_T>
                (static_cast<int32_T>(static_cast<boolean_T>(static_cast<int32_T>
                (static_cast<int32_T>(haspoint) ^ 1))) & static_cast<int32_T>
                 (allowpoint)));
            if (success) {
                s1->data[static_cast<int32_T>(*idx - 1)] = '.';
                *idx = static_cast<int32_T>(*idx + 1);
                haspoint = true;
            }

            *k = static_cast<int32_T>(*k + 1);
        } else if (tmp == ',') {
            *k = static_cast<int32_T>(*k + 1);
        } else {
            exitg1 = true;
        }
    }

    return success;
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static boolean_T FlightMissionMode_copyexponent_m
    (emxArray_char_T_FlightMissionMode_T *s1, int32_T *idx, const
     emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n)
{
    int32_T b_k;
    boolean_T success;
    success = true;
    if (*k <= n) {
        char_T tmp;
        tmp = s->data[static_cast<int32_T>(*k - 1)];
        if ((tmp == 'E') || (tmp == 'e')) {
            int32_T kexp;
            boolean_T b_success;
            s1->data[static_cast<int32_T>(*idx - 1)] = 'e';
            *idx = static_cast<int32_T>(*idx + 1);
            *k = static_cast<int32_T>(*k + 1);
            while ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == ','))
            {
                *k = static_cast<int32_T>(*k + 1);
            }

            if (*k <= n) {
                if (s->data[static_cast<int32_T>(*k - 1)] == '-') {
                    s1->data[static_cast<int32_T>(*idx - 1)] = '-';
                    *idx = static_cast<int32_T>(*idx + 1);
                    *k = static_cast<int32_T>(*k + 1);
                } else if (s->data[static_cast<int32_T>(*k - 1)] == '+') {
                    *k = static_cast<int32_T>(*k + 1);
                }
            }

            kexp = *k;
            b_k = *k;
            b_success = FlightMissionMode_copydigits_a(s1, idx, s, &b_k, n,
                false);
            *k = b_k;
            if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                    (static_cast<boolean_T>(static_cast<int32_T>
                    (static_cast<int32_T>(b_success) ^ 1))) | (b_k <= kexp)))) {
                success = false;
            }
        }
    }

    return success;
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static void FlightMissionMode_readfloat_m(emxArray_char_T_FlightMissionMode_T
    *s1, int32_T *idx, const emxArray_char_T_FlightMissionMode_T *s, int32_T *k,
    int32_T n, boolean_T *isimag, boolean_T *b_finite, real_T *nfv, boolean_T
    *foundsign, boolean_T *success)
{
    static const boolean_T b[128]{ false, false, false, false, false, false,
        false, false, false, true, true, true, true, true, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, true, true, true, true, true, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false };

    int32_T b_idx;
    int32_T b_k;
    boolean_T a__3;
    *isimag = false;
    *b_finite = true;
    *nfv = 0.0;
    b_idx = *idx;
    b_k = *k;
    FlightMissionMode_copysign_l(s1, &b_idx, s, &b_k, n, foundsign, success);
    *idx = b_idx;
    *k = b_k;
    if (*success) {
        char_T tmp;
        boolean_T exitg1;
        if (FlightMissionMode_isUnitImag_b(s, b_k, n)) {
            *isimag = true;
            *k = static_cast<int32_T>(b_k + 1);
            exitg1 = false;
            while ((!exitg1) && (*k <= n)) {
                tmp = s->data[static_cast<int32_T>(*k - 1)];
                if (b[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(tmp)) & 127)] ||
                    (tmp == '\x00') || (tmp == ',')) {
                    *k = static_cast<int32_T>(*k + 1);
                } else {
                    exitg1 = true;
                }
            }

            if ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == '*')) {
                b_k = static_cast<int32_T>(*k + 1);
                FlightMissionMode_copysign_l(s1, &b_idx, s, &b_k, n, &a__3,
                    success);
                *idx = b_idx;
                if (*success) {
                    if (FlightMissionMode_isUnitImag_b(s, b_k, n)) {
                        *success = false;
                    } else {
                        FlightMissionMode_readNonFinite_c(s, &b_k, n, b_finite,
                            nfv);
                        if (*b_finite) {
                            *success = FlightMissionMode_copydigits_a(s1, idx, s,
                                &b_k, n, true);
                            if (*success) {
                                *success = FlightMissionMode_copyexponent_m(s1,
                                    idx, s, &b_k, n);
                            }
                        } else if ((b_idx >= 2) && (s1->data[static_cast<int32_T>
                                                    (b_idx - 2)] == '-')) {
                            *idx = static_cast<int32_T>(b_idx - 1);
                            s1->data[static_cast<int32_T>(b_idx - 2)] = ' ';
                            *nfv = -*nfv;
                        }

                        exitg1 = false;
                        while ((!exitg1) && (b_k <= n)) {
                            tmp = s->data[static_cast<int32_T>(b_k - 1)];
                            if (b[static_cast<int32_T>(static_cast<int32_T>(
                                    static_cast<uint8_T>(tmp)) & 127)] || (tmp ==
                                 '\x00') || (tmp == ',')) {
                                b_k = static_cast<int32_T>(b_k + 1);
                            } else {
                                exitg1 = true;
                            }
                        }

                        if ((b_k <= n) && (s->data[static_cast<int32_T>(b_k - 1)]
                                           == '*')) {
                            b_k = static_cast<int32_T>(b_k + 1);
                            exitg1 = false;
                            while ((!exitg1) && (b_k <= n)) {
                                tmp = s->data[static_cast<int32_T>(b_k - 1)];
                                if (b[static_cast<int32_T>(static_cast<int32_T>(
                                        static_cast<uint8_T>(tmp)) & 127)] ||
                                        (tmp == '\x00') || (tmp == ',')) {
                                    b_k = static_cast<int32_T>(b_k + 1);
                                } else {
                                    exitg1 = true;
                                }
                            }
                        }

                        if (b_k <= n) {
                            tmp = s->data[static_cast<int32_T>(b_k - 1)];
                            if ((tmp == 'i') || (tmp == 'j')) {
                                b_k = static_cast<int32_T>(b_k + 1);
                            }
                        }
                    }

                    exitg1 = false;
                    while ((!exitg1) && (b_k <= n)) {
                        tmp = s->data[static_cast<int32_T>(b_k - 1)];
                        if (b[static_cast<int32_T>(static_cast<int32_T>(
                                static_cast<uint8_T>(tmp)) & 127)] || (tmp ==
                                '\x00') || (tmp == ',')) {
                            b_k = static_cast<int32_T>(b_k + 1);
                        } else {
                            exitg1 = true;
                        }
                    }
                }

                *k = b_k;
            } else {
                s1->data[static_cast<int32_T>(b_idx - 1)] = '1';
                *idx = static_cast<int32_T>(b_idx + 1);
            }
        } else {
            FlightMissionMode_readNonFinite_c(s, &b_k, n, b_finite, nfv);
            *k = b_k;
            if (*b_finite) {
                *success = FlightMissionMode_copydigits_a(s1, idx, s, k, n, true);
                if (*success) {
                    *success = FlightMissionMode_copyexponent_m(s1, idx, s, k, n);
                }
            } else if ((b_idx >= 2) && (s1->data[static_cast<int32_T>(b_idx - 2)]
                        == '-')) {
                *idx = static_cast<int32_T>(b_idx - 1);
                s1->data[static_cast<int32_T>(b_idx - 2)] = ' ';
                *nfv = -*nfv;
            }

            exitg1 = false;
            while ((!exitg1) && (*k <= n)) {
                if (b[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(s->data[
                        static_cast<int32_T>(*k - 1)])) & 127)]) {
                    *k = static_cast<int32_T>(*k + 1);
                } else {
                    tmp = s->data[static_cast<int32_T>(*k - 1)];
                    if ((tmp == '\x00') || (tmp == ',')) {
                        *k = static_cast<int32_T>(*k + 1);
                    } else {
                        exitg1 = true;
                    }
                }
            }

            if ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == '*')) {
                *k = static_cast<int32_T>(*k + 1);
                while ((*k <= n) && (b[static_cast<int32_T>(static_cast<int32_T>
                         (static_cast<uint8_T>(s->data[static_cast<int32_T>(*k -
                            1)])) & 127)] || (s->data[static_cast<int32_T>(*k -
                          1)] == '\x00') || (s->data[static_cast<int32_T>(*k - 1)]
                         == ','))) {
                    *k = static_cast<int32_T>(*k + 1);
                }
            }

            if (*k <= n) {
                tmp = s->data[static_cast<int32_T>(*k - 1)];
                if ((tmp == 'i') || (tmp == 'j')) {
                    *k = static_cast<int32_T>(*k + 1);
                    *isimag = true;
                }
            }
        }

        exitg1 = false;
        while ((!exitg1) && (*k <= n)) {
            if (b[static_cast<int32_T>(static_cast<int32_T>(static_cast<uint8_T>
                    (s->data[static_cast<int32_T>(*k - 1)])) & 127)]) {
                *k = static_cast<int32_T>(*k + 1);
            } else {
                tmp = s->data[static_cast<int32_T>(*k - 1)];
                if ((tmp == '\x00') || (tmp == ',')) {
                    *k = static_cast<int32_T>(*k + 1);
                } else {
                    exitg1 = true;
                }
            }
        }
    }
}

static void FlightMissionMode_emxFree_char_T_d
    (emxArray_char_T_FlightMissionMode_T **pEmxArray)
{
    if (*pEmxArray != static_cast<emxArray_char_T_FlightMissionMode_T *>(nullptr))
    {
        if (((*pEmxArray)->data != static_cast<char_T *>(nullptr)) &&
                (*pEmxArray)->canFreeData) {
            std::free((*pEmxArray)->data);
        }

        std::free((*pEmxArray)->size);
        std::free(*pEmxArray);
        *pEmxArray = static_cast<emxArray_char_T_FlightMissionMode_T *>(nullptr);
    }
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static creal_T FlightMissionMode_str2double_h(const
    emxArray_char_T_FlightMissionMode_T *s)
{
    static const boolean_T c[128]{ false, false, false, false, false, false,
        false, false, false, true, true, true, true, true, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, true, true, true, true, true, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false };

    emxArray_char_T_FlightMissionMode_T *s1;
    creal_T x;
    real_T b_scanned1;
    real_T scanned1;
    real_T scanned2;
    int32_T idx;
    int32_T k;
    boolean_T a__1;
    boolean_T c_success;
    boolean_T foundsign;
    boolean_T isfinite1;
    boolean_T isimag1;
    boolean_T success;
    x.re = (rtNaN);
    x.im = 0.0;
    if (s->size[1] >= 1) {
        int32_T i;
        int32_T ntoread;
        boolean_T exitg1;
        FlightMissionMode_emxInit_char_T_b(&s1, 2);
        ntoread = 0;
        k = 1;
        exitg1 = false;
        while ((!exitg1) && (k <= s->size[1])) {
            char_T tmp;
            tmp = s->data[static_cast<int32_T>(k - 1)];
            if (c[static_cast<int32_T>(static_cast<int32_T>(static_cast<uint8_T>
                    (tmp)) & 127)] || (tmp == '\x00')) {
                k = static_cast<int32_T>(k + 1);
            } else {
                exitg1 = true;
            }
        }

        i = static_cast<int32_T>(s1->size[0] * s1->size[1]);
        s1->size[0] = 1;
        s1->size[1] = static_cast<int32_T>(s->size[1] + 2);
        FlightMissionMode_emxEnsureCapacity_char_T_o(s1, i);
        idx = s->size[1];
        for (i = 0; i <= static_cast<int32_T>(idx + 1); i++) {
            s1->data[i] = '\x00';
        }

        idx = 1;
        FlightMissionMode_readfloat_m(s1, &idx, s, &k, s->size[1], &isimag1,
            &isfinite1, &scanned1, &a__1, &success);
        if (isfinite1) {
            ntoread = 1;
        }

        if (success) {
            if (k <= s->size[1]) {
                s1->data[static_cast<int32_T>(idx - 1)] = ' ';
                idx = static_cast<int32_T>(idx + 1);
                FlightMissionMode_readfloat_m(s1, &idx, s, &k, s->size[1], &a__1,
                    &success, &scanned2, &foundsign, &c_success);
                if (success) {
                    ntoread = static_cast<int32_T>(ntoread + 1);
                }

                success = static_cast<boolean_T>(static_cast<int32_T>(
                    static_cast<int32_T>(static_cast<boolean_T>
                    (static_cast<int32_T>(static_cast<int32_T>
                    (static_cast<boolean_T>(static_cast<int32_T>
                    (static_cast<int32_T>(static_cast<boolean_T>
                    (static_cast<int32_T>(static_cast<int32_T>(isimag1) ^
                    static_cast<int32_T>(a__1)))) & static_cast<int32_T>
                     (foundsign)))) & (k > s->size[1])))) & static_cast<int32_T>
                    (c_success)));
            } else {
                scanned2 = 0.0;
            }
        } else {
            scanned2 = 0.0;
        }

        if (success) {
            s1->data[static_cast<int32_T>(idx - 1)] = '\x00';
            switch (ntoread) {
              case 2:
                ntoread = sscanf(&s1->data[0], "%lf %lf", &scanned1, &scanned2);
                if (ntoread != 2) {
                    scanned1 = (rtNaN);
                    scanned2 = (rtNaN);
                }
                break;

              case 1:
                ntoread = sscanf(&s1->data[0], "%lf", &b_scanned1);
                if (isfinite1) {
                    if (ntoread == 1) {
                        scanned1 = b_scanned1;
                    } else {
                        scanned1 = (rtNaN);
                    }
                } else if (ntoread == 1) {
                    scanned2 = b_scanned1;
                } else {
                    scanned2 = (rtNaN);
                }
                break;
            }

            if (isimag1) {
                x.re = scanned2;
                x.im = scanned1;
            } else {
                x.re = scanned1;
                x.im = scanned2;
            }
        }

        FlightMissionMode_emxFree_char_T_d(&s1);
    }

    return x;
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static int32_T FlightMissionMode_cfclose_h(real_T fid,
    DW_WayPointGenerator_FlightMissionMode_T *localDW)
{
    FILE* filestar;
    int32_T st;
    int8_T b_fileid;
    int8_T fileid;
    st = -1;
    fileid = static_cast<int8_T>(fid);
    if (fid != static_cast<real_T>(static_cast<int8_T>(fid))) {
        fileid = -1;
    }

    b_fileid = fileid;
    if (static_cast<int32_T>(fileid) < 0) {
        b_fileid = -1;
    }

    if (static_cast<int32_T>(b_fileid) >= 3) {
        filestar = localDW->eml_openfiles[static_cast<int32_T>
            (static_cast<int32_T>(b_fileid) - 3)];
    } else {
        switch (static_cast<int32_T>(b_fileid)) {
          case 0:
            filestar = stdin;
            break;

          case 1:
            filestar = stdout;
            break;

          case 2:
            filestar = stderr;
            break;

          default:
            filestar = NULL;
            break;
        }
    }

    if (static_cast<boolean_T>(static_cast<int32_T>((filestar != NULL) & (
            static_cast<int32_T>(fileid) >= 3)))) {
        int32_T cst;
        cst = fclose(filestar);
        if (cst == 0) {
            st = 0;
            localDW->eml_openfiles[static_cast<int32_T>(static_cast<int32_T>
                (fileid) - 3)] = NULL;
        }
    }

    return st;
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static void FlightMissionMode_strtok_a(const emxArray_char_T_FlightMissionMode_T
    *x, emxArray_char_T_FlightMissionMode_T *token,
    emxArray_char_T_FlightMissionMode_T *remain)
{
    int32_T b;
    int32_T i;
    int32_T itoken;
    int32_T k;
    int32_T n;
    n = x->size[1];
    k = 0;
    while ((static_cast<int32_T>(k + 1) <= n) && (x->data[k] == '\x0a')) {
        k = static_cast<int32_T>(k + 1);
    }

    itoken = static_cast<int32_T>(k + 1);
    while ((static_cast<int32_T>(k + 1) <= n) && (x->data[k] != '\x0a')) {
        k = static_cast<int32_T>(k + 1);
    }

    if (static_cast<int32_T>(k + 1) > x->size[1]) {
        n = 0;
        b = 0;
    } else {
        n = k;
        b = x->size[1];
    }

    i = static_cast<int32_T>(remain->size[0] * remain->size[1]);
    remain->size[0] = 1;
    b = static_cast<int32_T>(b - n);
    remain->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T_o(remain, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        remain->data[i] = x->data[static_cast<int32_T>(n + i)];
    }

    if (itoken > k) {
        itoken = 0;
        k = 0;
    } else {
        itoken = static_cast<int32_T>(itoken - 1);
    }

    i = static_cast<int32_T>(token->size[0] * token->size[1]);
    token->size[0] = 1;
    b = static_cast<int32_T>(k - itoken);
    token->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T_o(token, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        token->data[i] = x->data[static_cast<int32_T>(itoken + i)];
    }
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static void FlightMissionMode_strtok_ac(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token)
{
    int32_T itoken;
    int32_T k;
    int32_T n;
    n = x->size[1];
    k = 1;
    while ((k <= n) && (x->data[static_cast<int32_T>(k - 1)] == ';')) {
        k = static_cast<int32_T>(k + 1);
    }

    itoken = k;
    while ((k <= n) && (x->data[static_cast<int32_T>(k - 1)] != ';')) {
        k = static_cast<int32_T>(k + 1);
    }

    if (itoken > static_cast<int32_T>(k - 1)) {
        n = 0;
        k = 0;
    } else {
        n = static_cast<int32_T>(itoken - 1);
        k = static_cast<int32_T>(k - 1);
    }

    itoken = static_cast<int32_T>(token->size[0] * token->size[1]);
    token->size[0] = 1;
    k = static_cast<int32_T>(k - n);
    token->size[1] = k;
    FlightMissionMode_emxEnsureCapacity_char_T_o(token, itoken);
    for (itoken = 0; itoken <= static_cast<int32_T>(k - 1); itoken++) {
        token->data[itoken] = x->data[static_cast<int32_T>(n + itoken)];
    }
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static void FlightMissionMode_strtrim_l(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    y)
{
    static const boolean_T d[128]{ false, false, false, false, false, false,
        false, false, false, true, true, true, true, true, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, true, true, true, true, true, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false };

    int32_T b_j1;
    int32_T i;
    int32_T j2;
    b_j1 = 0;
    while ((static_cast<int32_T>(b_j1 + 1) <= x->size[1]) &&
            (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(d[
               static_cast<int32_T>(static_cast<int32_T>(static_cast<uint8_T>
                 (x->data[b_j1])) & 127)]) & (x->data[b_j1] != '\x00'))))) {
        b_j1 = static_cast<int32_T>(b_j1 + 1);
    }

    j2 = static_cast<int32_T>(x->size[1] - 1);
    while ((static_cast<int32_T>(j2 + 1) > 0) && (static_cast<boolean_T>(
             static_cast<int32_T>(static_cast<int32_T>(d[static_cast<int32_T>(
                static_cast<int32_T>(static_cast<uint8_T>(x->data[j2])) & 127)])
              & (x->data[j2] != '\x00'))))) {
        j2 = static_cast<int32_T>(j2 - 1);
    }

    if (static_cast<int32_T>(b_j1 + 1) > static_cast<int32_T>(j2 + 1)) {
        b_j1 = 0;
        j2 = -1;
    }

    i = static_cast<int32_T>(y->size[0] * y->size[1]);
    y->size[0] = 1;
    j2 = static_cast<int32_T>(j2 - b_j1);
    y->size[1] = static_cast<int32_T>(j2 + 1);
    FlightMissionMode_emxEnsureCapacity_char_T_o(y, i);
    for (i = 0; i <= j2; i++) {
        y->data[i] = x->data[static_cast<int32_T>(b_j1 + i)];
    }
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static boolean_T FlightMissionMode_strcmp_c(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[3]{ 'U', 'A', 'V' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_b(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_o(aTmp, i);
        loop_ub = a->size[1];
        for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 3) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 3) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_d(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static boolean_T FlightMissionMode_strcmp_co(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[10]{ 'N', 'o', 'r', 'm', 'A', 'i', 'r', 'S', 'p', 'd'
    };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_b(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_o(aTmp, i);
        loop_ub = a->size[1];
        for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 10) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 10) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_d(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static boolean_T FlightMissionMode_contains_g(const
    emxArray_char_T_FlightMissionMode_T *str)
{
    int32_T matchPos;
    matchPos = 0;
    int32_T exitg1;
    do {
        exitg1 = 0;
        if (matchPos <= static_cast<int32_T>(str->size[1] - 1)) {
            if (str->data[matchPos] == '=') {
                exitg1 = 1;
            } else {
                matchPos = static_cast<int32_T>(matchPos + 1);
            }
        } else {
            matchPos = -1;
            exitg1 = 1;
        }
    } while (exitg1 == 0);

    return static_cast<int32_T>(matchPos + 1) > 0;
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static void FlightMissionMode_find_token_e(const
    emxArray_char_T_FlightMissionMode_T *x, int32_T *itoken, int32_T *iremain)
{
    int32_T n;
    n = x->size[1];
    *iremain = 1;
    while ((*iremain <= n) && (x->data[static_cast<int32_T>(*iremain - 1)] ==
                               '=')) {
        *iremain = static_cast<int32_T>(*iremain + 1);
    }

    *itoken = *iremain;
    while ((*iremain <= n) && (x->data[static_cast<int32_T>(*iremain - 1)] !=
                               '=')) {
        *iremain = static_cast<int32_T>(*iremain + 1);
    }
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static void FlightMissionMode_strtok_acx(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token, emxArray_char_T_FlightMissionMode_T *remain)
{
    int32_T b;
    int32_T c;
    int32_T i;
    int32_T iremain;
    int32_T itoken;
    FlightMissionMode_find_token_e(x, &itoken, &iremain);
    if (iremain > x->size[1]) {
        c = 0;
        b = 0;
    } else {
        c = static_cast<int32_T>(iremain - 1);
        b = x->size[1];
    }

    i = static_cast<int32_T>(remain->size[0] * remain->size[1]);
    remain->size[0] = 1;
    b = static_cast<int32_T>(b - c);
    remain->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T_o(remain, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        remain->data[i] = x->data[static_cast<int32_T>(c + i)];
    }

    if (itoken > static_cast<int32_T>(iremain - 1)) {
        itoken = 0;
        iremain = 0;
    } else {
        itoken = static_cast<int32_T>(itoken - 1);
        iremain = static_cast<int32_T>(iremain - 1);
    }

    i = static_cast<int32_T>(token->size[0] * token->size[1]);
    token->size[0] = 1;
    b = static_cast<int32_T>(iremain - itoken);
    token->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T_o(token, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        token->data[i] = x->data[static_cast<int32_T>(itoken + i)];
    }
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static void FlightMissionMode_strtok_acxd(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token)
{
    int32_T i;
    int32_T iremain;
    int32_T itoken;
    FlightMissionMode_find_token_e(x, &itoken, &iremain);
    if (itoken > static_cast<int32_T>(iremain - 1)) {
        itoken = 0;
        iremain = 0;
    } else {
        itoken = static_cast<int32_T>(itoken - 1);
        iremain = static_cast<int32_T>(iremain - 1);
    }

    i = static_cast<int32_T>(token->size[0] * token->size[1]);
    token->size[0] = 1;
    iremain = static_cast<int32_T>(iremain - itoken);
    token->size[1] = iremain;
    FlightMissionMode_emxEnsureCapacity_char_T_o(token, i);
    for (i = 0; i <= static_cast<int32_T>(iremain - 1); i++) {
        token->data[i] = x->data[static_cast<int32_T>(itoken + i)];
    }
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static boolean_T FlightMissionMode_strcmp_cog(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[9]{ 'M', 'a', 'x', 'A', 'i', 'r', 'S', 'p', 'd' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_b(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_o(aTmp, i);
        loop_ub = a->size[1];
        for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 9) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 9) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_d(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static void FlightMissionMode_readINI_i(emxArray_char_T_FlightMissionMode_T *ret,
    DW_WayPointGenerator_FlightMissionMode_T *localDW)
{
    static const char_T h[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T i[15]{ 'C', 'l', 'i', 'm', 'b', 'A', 'n', 'g', 'l', 'e',
        'L', 'i', 'm', 'i', 't' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    emxArray_char_T_FlightMissionMode_T *curKey;
    emxArray_char_T_FlightMissionMode_T *curLine;
    emxArray_char_T_FlightMissionMode_T *curSection;
    emxArray_char_T_FlightMissionMode_T *curVal;
    emxArray_char_T_FlightMissionMode_T *data;
    emxArray_char_T_FlightMissionMode_T *data_0;
    emxArray_char_T_FlightMissionMode_T *j;
    emxArray_char_T_FlightMissionMode_T *tmp;
    int32_T iremain;
    int32_T itoken;
    int8_T fileid;
    ret->size[0] = 1;
    ret->size[1] = 0;
    fileid = FlightMissionMode_cfopen_j("config.ini", "rb", localDW);
    if (static_cast<int32_T>(fileid) < 0) {
        printf("INI-file \"%s\" was not found or could not be read.\n",
               "config.ini");
        fflush(stdout);
    } else {
        int32_T i_0;
        int32_T loop_ub;
        FlightMissionMode_emxInit_char_T_b(&j, 1);
        FlightMissionMode_fread_b(static_cast<real_T>(fileid), j, localDW);
        FlightMissionMode_emxInit_char_T_b(&data, 2);
        i_0 = static_cast<int32_T>(data->size[0] * data->size[1]);
        data->size[0] = 1;
        data->size[1] = j->size[0];
        FlightMissionMode_emxEnsureCapacity_char_T_o(data, i_0);
        loop_ub = j->size[0];
        for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub - 1); i_0++) {
            data->data[i_0] = j->data[i_0];
        }

        FlightMissionMode_emxFree_char_T_d(&j);
        FlightMissionMode_cfclose_h(static_cast<real_T>(fileid), localDW);
        FlightMissionMode_emxInit_char_T_b(&curSection, 2);
        curSection->size[0] = 1;
        curSection->size[1] = 0;
        FlightMissionMode_emxInit_char_T_b(&curKey, 2);
        curKey->size[0] = 1;
        curKey->size[1] = 0;
        FlightMissionMode_emxInit_char_T_b(&curVal, 2);
        curVal->size[0] = 1;
        curVal->size[1] = 0;
        FlightMissionMode_emxInit_char_T_b(&curLine, 2);
        FlightMissionMode_emxInit_char_T_b(&aTmp, 2);
        FlightMissionMode_emxInit_char_T_b(&tmp, 2);
        FlightMissionMode_emxInit_char_T_b(&data_0, 2);
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (data->size[1] != 0) {
                boolean_T b_bool;
                i_0 = static_cast<int32_T>(data_0->size[0] * data_0->size[1]);
                data_0->size[0] = 1;
                data_0->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_o(data_0, i_0);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (i_0 = 0; i_0 <= loop_ub; i_0++) {
                    data_0->data[i_0] = data->data[i_0];
                }

                FlightMissionMode_strtok_a(data_0, curLine, data);
                FlightMissionMode_strtok_ac(curLine, tmp);
                FlightMissionMode_strtrim_l(tmp, curLine);
                if (curLine->size[1] >= 2) {
                    boolean_T guard1{ false };

                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                iremain = 0;
                                itoken = 0;
                            } else {
                                iremain = 1;
                                itoken = static_cast<int32_T>(curLine->size[1] -
                                    1);
                            }

                            i_0 = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(itoken - iremain);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_o
                                (curSection, i_0);
                            for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub -
                                    1); i_0++) {
                                curSection->data[i_0] = curLine->data[
                                    static_cast<int32_T>(iremain + i_0)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains_g(curLine)) {
                            FlightMissionMode_strtok_acx(curLine, aTmp, curVal);
                            FlightMissionMode_find_token_e(curVal, &itoken,
                                &iremain);
                            if (itoken > static_cast<int32_T>(iremain - 1)) {
                                itoken = 0;
                                iremain = 0;
                            } else {
                                itoken = static_cast<int32_T>(itoken - 1);
                                iremain = static_cast<int32_T>(iremain - 1);
                            }

                            FlightMissionMode_strtrim_l(aTmp, curKey);
                            i_0 = static_cast<int32_T>(curLine->size[0] *
                                curLine->size[1]);
                            curLine->size[0] = 1;
                            loop_ub = static_cast<int32_T>(iremain - itoken);
                            curLine->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_o(curLine,
                                i_0);
                            for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub -
                                    1); i_0++) {
                                curLine->data[i_0] = curVal->data
                                    [static_cast<int32_T>(itoken + i_0)];
                            }

                            FlightMissionMode_strtrim_l(curLine, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp_c(curSection)) {
                    if (curKey->size[1] == 0) {
                        aTmp->size[0] = 1;
                        aTmp->size[1] = 0;
                    } else {
                        i_0 = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
                        aTmp->size[0] = 1;
                        aTmp->size[1] = curKey->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_o(aTmp, i_0);
                        loop_ub = curKey->size[1];
                        for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub - 1);
                                i_0++) {
                            aTmp->data[i_0] = curKey->data[i_0];
                        }
                    }

                    b_bool = false;
                    if (aTmp->size[1] == 15) {
                        iremain = 0;
                        int32_T exitg2;
                        do {
                            exitg2 = 0;
                            if (iremain < 15) {
                                if (h[static_cast<int32_T>(static_cast<int32_T>(
                                        static_cast<uint8_T>(aTmp->data[iremain]))
                                     & 127)] != h[static_cast<int32_T>(i[iremain])])
                                {
                                    exitg2 = 1;
                                } else {
                                    iremain = static_cast<int32_T>(iremain + 1);
                                }
                            } else {
                                b_bool = true;
                                exitg2 = 1;
                            }
                        } while (exitg2 == 0);
                    }

                    if (b_bool) {
                        i_0 = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                        ret->size[0] = 1;
                        ret->size[1] = curVal->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_o(ret, i_0);
                        loop_ub = curVal->size[1];
                        for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub - 1);
                                i_0++) {
                            ret->data[i_0] = curVal->data[i_0];
                        }

                        exitg1 = 1;
                    }
                }
            } else {
                exitg1 = 1;
            }
        } while (exitg1 == 0);

        FlightMissionMode_emxFree_char_T_d(&data_0);
        FlightMissionMode_emxFree_char_T_d(&tmp);
        FlightMissionMode_emxFree_char_T_d(&aTmp);
        FlightMissionMode_emxFree_char_T_d(&curLine);
        FlightMissionMode_emxFree_char_T_d(&curVal);
        FlightMissionMode_emxFree_char_T_d(&curKey);
        FlightMissionMode_emxFree_char_T_d(&curSection);
        FlightMissionMode_emxFree_char_T_d(&data);
    }
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static void FlightMissionMode_readINI_iy(emxArray_char_T_FlightMissionMode_T
    *ret, DW_WayPointGenerator_FlightMissionMode_T *localDW)
{
    static const char_T h[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T i[14]{ 'D', 'i', 'v', 'e', 'A', 'n', 'g', 'l', 'e', 'L',
        'i', 'm', 'i', 't' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    emxArray_char_T_FlightMissionMode_T *curKey;
    emxArray_char_T_FlightMissionMode_T *curLine;
    emxArray_char_T_FlightMissionMode_T *curSection;
    emxArray_char_T_FlightMissionMode_T *curVal;
    emxArray_char_T_FlightMissionMode_T *data;
    emxArray_char_T_FlightMissionMode_T *data_0;
    emxArray_char_T_FlightMissionMode_T *j;
    emxArray_char_T_FlightMissionMode_T *tmp;
    int32_T iremain;
    int32_T itoken;
    int8_T fileid;
    ret->size[0] = 1;
    ret->size[1] = 0;
    fileid = FlightMissionMode_cfopen_j("config.ini", "rb", localDW);
    if (static_cast<int32_T>(fileid) < 0) {
        printf("INI-file \"%s\" was not found or could not be read.\n",
               "config.ini");
        fflush(stdout);
    } else {
        int32_T i_0;
        int32_T loop_ub;
        FlightMissionMode_emxInit_char_T_b(&j, 1);
        FlightMissionMode_fread_b(static_cast<real_T>(fileid), j, localDW);
        FlightMissionMode_emxInit_char_T_b(&data, 2);
        i_0 = static_cast<int32_T>(data->size[0] * data->size[1]);
        data->size[0] = 1;
        data->size[1] = j->size[0];
        FlightMissionMode_emxEnsureCapacity_char_T_o(data, i_0);
        loop_ub = j->size[0];
        for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub - 1); i_0++) {
            data->data[i_0] = j->data[i_0];
        }

        FlightMissionMode_emxFree_char_T_d(&j);
        FlightMissionMode_cfclose_h(static_cast<real_T>(fileid), localDW);
        FlightMissionMode_emxInit_char_T_b(&curSection, 2);
        curSection->size[0] = 1;
        curSection->size[1] = 0;
        FlightMissionMode_emxInit_char_T_b(&curKey, 2);
        curKey->size[0] = 1;
        curKey->size[1] = 0;
        FlightMissionMode_emxInit_char_T_b(&curVal, 2);
        curVal->size[0] = 1;
        curVal->size[1] = 0;
        FlightMissionMode_emxInit_char_T_b(&curLine, 2);
        FlightMissionMode_emxInit_char_T_b(&aTmp, 2);
        FlightMissionMode_emxInit_char_T_b(&tmp, 2);
        FlightMissionMode_emxInit_char_T_b(&data_0, 2);
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (data->size[1] != 0) {
                boolean_T b_bool;
                i_0 = static_cast<int32_T>(data_0->size[0] * data_0->size[1]);
                data_0->size[0] = 1;
                data_0->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_o(data_0, i_0);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (i_0 = 0; i_0 <= loop_ub; i_0++) {
                    data_0->data[i_0] = data->data[i_0];
                }

                FlightMissionMode_strtok_a(data_0, curLine, data);
                FlightMissionMode_strtok_ac(curLine, tmp);
                FlightMissionMode_strtrim_l(tmp, curLine);
                if (curLine->size[1] >= 2) {
                    boolean_T guard1{ false };

                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                iremain = 0;
                                itoken = 0;
                            } else {
                                iremain = 1;
                                itoken = static_cast<int32_T>(curLine->size[1] -
                                    1);
                            }

                            i_0 = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(itoken - iremain);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_o
                                (curSection, i_0);
                            for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub -
                                    1); i_0++) {
                                curSection->data[i_0] = curLine->data[
                                    static_cast<int32_T>(iremain + i_0)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains_g(curLine)) {
                            FlightMissionMode_strtok_acx(curLine, aTmp, curVal);
                            FlightMissionMode_find_token_e(curVal, &itoken,
                                &iremain);
                            if (itoken > static_cast<int32_T>(iremain - 1)) {
                                itoken = 0;
                                iremain = 0;
                            } else {
                                itoken = static_cast<int32_T>(itoken - 1);
                                iremain = static_cast<int32_T>(iremain - 1);
                            }

                            FlightMissionMode_strtrim_l(aTmp, curKey);
                            i_0 = static_cast<int32_T>(curLine->size[0] *
                                curLine->size[1]);
                            curLine->size[0] = 1;
                            loop_ub = static_cast<int32_T>(iremain - itoken);
                            curLine->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_o(curLine,
                                i_0);
                            for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub -
                                    1); i_0++) {
                                curLine->data[i_0] = curVal->data
                                    [static_cast<int32_T>(itoken + i_0)];
                            }

                            FlightMissionMode_strtrim_l(curLine, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp_c(curSection)) {
                    if (curKey->size[1] == 0) {
                        aTmp->size[0] = 1;
                        aTmp->size[1] = 0;
                    } else {
                        i_0 = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
                        aTmp->size[0] = 1;
                        aTmp->size[1] = curKey->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_o(aTmp, i_0);
                        loop_ub = curKey->size[1];
                        for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub - 1);
                                i_0++) {
                            aTmp->data[i_0] = curKey->data[i_0];
                        }
                    }

                    b_bool = false;
                    if (aTmp->size[1] == 14) {
                        iremain = 0;
                        int32_T exitg2;
                        do {
                            exitg2 = 0;
                            if (iremain < 14) {
                                if (h[static_cast<int32_T>(static_cast<int32_T>(
                                        static_cast<uint8_T>(aTmp->data[iremain]))
                                     & 127)] != h[static_cast<int32_T>(i[iremain])])
                                {
                                    exitg2 = 1;
                                } else {
                                    iremain = static_cast<int32_T>(iremain + 1);
                                }
                            } else {
                                b_bool = true;
                                exitg2 = 1;
                            }
                        } while (exitg2 == 0);
                    }

                    if (b_bool) {
                        i_0 = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                        ret->size[0] = 1;
                        ret->size[1] = curVal->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_o(ret, i_0);
                        loop_ub = curVal->size[1];
                        for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub - 1);
                                i_0++) {
                            ret->data[i_0] = curVal->data[i_0];
                        }

                        exitg1 = 1;
                    }
                }
            } else {
                exitg1 = 1;
            }
        } while (exitg1 == 0);

        FlightMissionMode_emxFree_char_T_d(&data_0);
        FlightMissionMode_emxFree_char_T_d(&tmp);
        FlightMissionMode_emxFree_char_T_d(&aTmp);
        FlightMissionMode_emxFree_char_T_d(&curLine);
        FlightMissionMode_emxFree_char_T_d(&curVal);
        FlightMissionMode_emxFree_char_T_d(&curKey);
        FlightMissionMode_emxFree_char_T_d(&curSection);
        FlightMissionMode_emxFree_char_T_d(&data);
    }
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static boolean_T FlightMissionMode_strcmp_cogh(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[9]{ 'M', 'i', 'n', 'A', 'i', 'r', 'S', 'p', 'd' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_b(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_o(aTmp, i);
        loop_ub = a->size[1];
        for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 9) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 9) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_d(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static boolean_T FlightMissionMode_strcmp_coghz(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[12]{ 'M', 'a', 'x', 'R', 'o', 'l', 'l', 'A', 'n', 'g',
        'l', 'e' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_b(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_o(aTmp, i);
        loop_ub = a->size[1];
        for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 12) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 12) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_d(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static uavDubinsConnection_FlightMissionMode_g_T
    *FlightMissionMode_uavDubinsConnection_uavDubinsConnection_l
    (uavDubinsConnection_FlightMissionMode_g_T *b_this, real_T varargin_2,
     real_T varargin_4, const real_T varargin_6[2])
{
    uavDubinsConnection_FlightMissionMode_g_T *c_this;
    real_T b_x;
    c_this = b_this;
    b_this->AirSpeed = 10.0;
    b_this->FlightPathAngleLimit[0] = varargin_6[0];
    b_this->FlightPathAngleLimit[1] = varargin_6[1];
    b_this->MaxRollAngle = varargin_4;
    b_x = b_this->MaxRollAngle;
    b_this->MinTurningRadius = b_this->AirSpeed * b_this->AirSpeed / (9.8 * std::
        tan(b_x));
    b_this->AirSpeed = varargin_2;
    b_x = b_this->MaxRollAngle;
    b_this->MinTurningRadius = b_this->AirSpeed * b_this->AirSpeed / (9.8 * std::
        tan(b_x));
    b_x = b_this->MaxRollAngle;
    b_this->MinTurningRadius = b_this->AirSpeed * b_this->AirSpeed / (9.8 * std::
        tan(b_x));
    return c_this;
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static uavDubinsConnection_FlightMissionMode_g_T
    *FlightMissionMode_DubinsObjSingleton_getConnector_e
    (DW_WayPointGenerator_FlightMissionMode_T *localDW)
{
    emxArray_char_T_FlightMissionMode_T *b_remainder;
    emxArray_char_T_FlightMissionMode_T *curKey;
    emxArray_char_T_FlightMissionMode_T *curLine;
    emxArray_char_T_FlightMissionMode_T *curSection;
    emxArray_char_T_FlightMissionMode_T *curVal;
    emxArray_char_T_FlightMissionMode_T *data;
    emxArray_char_T_FlightMissionMode_T *data_0;
    emxArray_char_T_FlightMissionMode_T *data_1;
    emxArray_char_T_FlightMissionMode_T *data_2;
    emxArray_char_T_FlightMissionMode_T *data_3;
    emxArray_char_T_FlightMissionMode_T *k;
    emxArray_char_T_FlightMissionMode_T *ret;
    emxArray_char_T_FlightMissionMode_T *tmp_1;
    emxArray_char_T_FlightMissionMode_T *tmp_2;
    emxArray_char_T_FlightMissionMode_T *tmp_3;
    emxArray_char_T_FlightMissionMode_T *tmp_4;
    emxArray_char_T_FlightMissionMode_T *tmp_5;
    emxArray_char_T_FlightMissionMode_T *tmp_6;
    emxArray_char_T_FlightMissionMode_T *tmp_7;
    emxArray_char_T_FlightMissionMode_T *tmp_8;
    uavDubinsConnection_FlightMissionMode_g_T *outputArg;
    real_T tmp_9[2];
    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
            (localDW->SingletonInstance_not_empty) ^ 1))) {
        creal_T tmp;
        creal_T tmp_0;
        real_T ClimbAngleLimit;
        real_T DiveAngleLimit;
        real_T fid;
        int32_T b;
        int32_T c;
        int32_T i;
        int32_T loop_ub;
        boolean_T b_bool;
        boolean_T exitg1;
        boolean_T guard1{ false };

        localDW->SingletonInstance.AirSpeed = 35.0;
        localDW->SingletonInstance.MaxRollAngle = 0.3490658503988659;
        localDW->SingletonInstance.FlightPathAngleLimit[0] = -0.175;
        localDW->SingletonInstance.FlightPathAngleLimit[1] = 0.175;
        FlightMissionMode_emxInit_char_T_b(&ret, 2);
        ret->size[0] = 1;
        ret->size[1] = 0;
        fid = FlightMissionMode_fileManager_o(localDW);
        FlightMissionMode_emxInit_char_T_b(&data, 2);
        FlightMissionMode_emxInit_char_T_b(&curSection, 2);
        FlightMissionMode_emxInit_char_T_b(&curKey, 2);
        FlightMissionMode_emxInit_char_T_b(&curVal, 2);
        FlightMissionMode_emxInit_char_T_b(&curLine, 2);
        FlightMissionMode_emxInit_char_T_b(&b_remainder, 2);
        FlightMissionMode_emxInit_char_T_b(&k, 1);
        if (fid < 0.0) {
            printf("INI-file \"%s\" was not found or could not be read.\n",
                   "config.ini");
            fflush(stdout);
        } else {
            FlightMissionMode_fread_b(fid, k, localDW);
            i = static_cast<int32_T>(data->size[0] * data->size[1]);
            data->size[0] = 1;
            data->size[1] = k->size[0];
            FlightMissionMode_emxEnsureCapacity_char_T_o(data, i);
            loop_ub = k->size[0];
            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                data->data[b] = k->data[b];
            }

            FlightMissionMode_cfclose_h(fid, localDW);
            curSection->size[0] = 1;
            curSection->size[1] = 0;
            curKey->size[0] = 1;
            curKey->size[1] = 0;
            curVal->size[0] = 1;
            curVal->size[1] = 0;
            FlightMissionMode_emxInit_char_T_b(&tmp_7, 2);
            FlightMissionMode_emxInit_char_T_b(&tmp_8, 2);
            FlightMissionMode_emxInit_char_T_b(&data_3, 2);
            exitg1 = false;
            while ((!exitg1) && (data->size[1] != 0)) {
                i = static_cast<int32_T>(data_3->size[0] * data_3->size[1]);
                data_3->size[0] = 1;
                data_3->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_o(data_3, i);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (i = 0; i <= loop_ub; i++) {
                    data_3->data[i] = data->data[i];
                }

                FlightMissionMode_strtok_a(data_3, curLine, data);
                FlightMissionMode_strtok_ac(curLine, tmp_8);
                FlightMissionMode_strtrim_l(tmp_8, curLine);
                if (curLine->size[1] >= 2) {
                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                c = 0;
                                b = 0;
                            } else {
                                c = 1;
                                b = static_cast<int32_T>(curLine->size[1] - 1);
                            }

                            i = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(b - c);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_o
                                (curSection, i);
                            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1);
                                    b++) {
                                curSection->data[b] = curLine->data[static_cast<
                                    int32_T>(c + b)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains_g(curLine)) {
                            FlightMissionMode_strtok_acx(curLine, curVal,
                                b_remainder);
                            FlightMissionMode_strtrim_l(curVal, curKey);
                            FlightMissionMode_strtok_acxd(b_remainder, tmp_7);
                            FlightMissionMode_strtrim_l(tmp_7, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp_c(curSection) &&
                        FlightMissionMode_strcmp_co(curKey)) {
                    i = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                    ret->size[0] = 1;
                    ret->size[1] = curVal->size[1];
                    FlightMissionMode_emxEnsureCapacity_char_T_o(ret, i);
                    loop_ub = curVal->size[1];
                    for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                        ret->data[b] = curVal->data[b];
                    }

                    exitg1 = true;
                }
            }

            FlightMissionMode_emxFree_char_T_d(&data_3);
            FlightMissionMode_emxFree_char_T_d(&tmp_8);
            FlightMissionMode_emxFree_char_T_d(&tmp_7);
        }

        tmp = FlightMissionMode_str2double_h(ret);
        printf("Set UAV NormAirSpeed:\t\t%f\n", tmp.re);
        fflush(stdout);
        ret->size[0] = 1;
        ret->size[1] = 0;
        fid = FlightMissionMode_fileManager_o(localDW);
        if (fid < 0.0) {
            printf("INI-file \"%s\" was not found or could not be read.\n",
                   "config.ini");
            fflush(stdout);
        } else {
            FlightMissionMode_fread_b(fid, k, localDW);
            i = static_cast<int32_T>(data->size[0] * data->size[1]);
            data->size[0] = 1;
            data->size[1] = k->size[0];
            FlightMissionMode_emxEnsureCapacity_char_T_o(data, i);
            loop_ub = k->size[0];
            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                data->data[b] = k->data[b];
            }

            FlightMissionMode_cfclose_h(fid, localDW);
            curSection->size[0] = 1;
            curSection->size[1] = 0;
            curKey->size[0] = 1;
            curKey->size[1] = 0;
            curVal->size[0] = 1;
            curVal->size[1] = 0;
            FlightMissionMode_emxInit_char_T_b(&tmp_5, 2);
            FlightMissionMode_emxInit_char_T_b(&tmp_6, 2);
            FlightMissionMode_emxInit_char_T_b(&data_2, 2);
            exitg1 = false;
            while ((!exitg1) && (data->size[1] != 0)) {
                i = static_cast<int32_T>(data_2->size[0] * data_2->size[1]);
                data_2->size[0] = 1;
                data_2->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_o(data_2, i);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (i = 0; i <= loop_ub; i++) {
                    data_2->data[i] = data->data[i];
                }

                FlightMissionMode_strtok_a(data_2, curLine, data);
                FlightMissionMode_strtok_ac(curLine, tmp_6);
                FlightMissionMode_strtrim_l(tmp_6, curLine);
                if (curLine->size[1] >= 2) {
                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                c = 0;
                                b = 0;
                            } else {
                                c = 1;
                                b = static_cast<int32_T>(curLine->size[1] - 1);
                            }

                            i = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(b - c);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_o
                                (curSection, i);
                            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1);
                                    b++) {
                                curSection->data[b] = curLine->data[static_cast<
                                    int32_T>(c + b)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains_g(curLine)) {
                            FlightMissionMode_strtok_acx(curLine, curVal,
                                b_remainder);
                            FlightMissionMode_strtrim_l(curVal, curKey);
                            FlightMissionMode_strtok_acxd(b_remainder, tmp_5);
                            FlightMissionMode_strtrim_l(tmp_5, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp_c(curSection) &&
                        FlightMissionMode_strcmp_cog(curKey)) {
                    i = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                    ret->size[0] = 1;
                    ret->size[1] = curVal->size[1];
                    FlightMissionMode_emxEnsureCapacity_char_T_o(ret, i);
                    loop_ub = curVal->size[1];
                    for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                        ret->data[b] = curVal->data[b];
                    }

                    exitg1 = true;
                }
            }

            FlightMissionMode_emxFree_char_T_d(&data_2);
            FlightMissionMode_emxFree_char_T_d(&tmp_6);
            FlightMissionMode_emxFree_char_T_d(&tmp_5);
        }

        tmp_0 = FlightMissionMode_str2double_h(ret);
        printf("Set UAV MaxAirSpeed:\t\t%f\n", tmp_0.re);
        fflush(stdout);
        ret->size[0] = 1;
        ret->size[1] = 0;
        fid = FlightMissionMode_fileManager_o(localDW);
        if (fid < 0.0) {
            printf("INI-file \"%s\" was not found or could not be read.\n",
                   "config.ini");
            fflush(stdout);
        } else {
            FlightMissionMode_fread_b(fid, k, localDW);
            i = static_cast<int32_T>(data->size[0] * data->size[1]);
            data->size[0] = 1;
            data->size[1] = k->size[0];
            FlightMissionMode_emxEnsureCapacity_char_T_o(data, i);
            loop_ub = k->size[0];
            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                data->data[b] = k->data[b];
            }

            FlightMissionMode_cfclose_h(fid, localDW);
            curSection->size[0] = 1;
            curSection->size[1] = 0;
            curKey->size[0] = 1;
            curKey->size[1] = 0;
            curVal->size[0] = 1;
            curVal->size[1] = 0;
            FlightMissionMode_emxInit_char_T_b(&tmp_3, 2);
            FlightMissionMode_emxInit_char_T_b(&tmp_4, 2);
            FlightMissionMode_emxInit_char_T_b(&data_1, 2);
            exitg1 = false;
            while ((!exitg1) && (data->size[1] != 0)) {
                i = static_cast<int32_T>(data_1->size[0] * data_1->size[1]);
                data_1->size[0] = 1;
                data_1->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_o(data_1, i);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (i = 0; i <= loop_ub; i++) {
                    data_1->data[i] = data->data[i];
                }

                FlightMissionMode_strtok_a(data_1, curLine, data);
                FlightMissionMode_strtok_ac(curLine, tmp_4);
                FlightMissionMode_strtrim_l(tmp_4, curLine);
                if (curLine->size[1] >= 2) {
                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                c = 0;
                                b = 0;
                            } else {
                                c = 1;
                                b = static_cast<int32_T>(curLine->size[1] - 1);
                            }

                            i = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(b - c);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_o
                                (curSection, i);
                            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1);
                                    b++) {
                                curSection->data[b] = curLine->data[static_cast<
                                    int32_T>(c + b)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains_g(curLine)) {
                            FlightMissionMode_strtok_acx(curLine, curVal,
                                b_remainder);
                            FlightMissionMode_strtrim_l(curVal, curKey);
                            FlightMissionMode_strtok_acxd(b_remainder, tmp_3);
                            FlightMissionMode_strtrim_l(tmp_3, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp_c(curSection) &&
                        FlightMissionMode_strcmp_cogh(curKey)) {
                    i = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                    ret->size[0] = 1;
                    ret->size[1] = curVal->size[1];
                    FlightMissionMode_emxEnsureCapacity_char_T_o(ret, i);
                    loop_ub = curVal->size[1];
                    for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                        ret->data[b] = curVal->data[b];
                    }

                    exitg1 = true;
                }
            }

            FlightMissionMode_emxFree_char_T_d(&data_1);
            FlightMissionMode_emxFree_char_T_d(&tmp_4);
            FlightMissionMode_emxFree_char_T_d(&tmp_3);
        }

        tmp_0 = FlightMissionMode_str2double_h(ret);
        printf("Set UAV MinAirSpeed:\t\t%f\n", tmp_0.re);
        fflush(stdout);
        ret->size[0] = 1;
        ret->size[1] = 0;
        fid = FlightMissionMode_fileManager_o(localDW);
        if (fid < 0.0) {
            printf("INI-file \"%s\" was not found or could not be read.\n",
                   "config.ini");
            fflush(stdout);
        } else {
            FlightMissionMode_fread_b(fid, k, localDW);
            i = static_cast<int32_T>(data->size[0] * data->size[1]);
            data->size[0] = 1;
            data->size[1] = k->size[0];
            FlightMissionMode_emxEnsureCapacity_char_T_o(data, i);
            loop_ub = k->size[0];
            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                data->data[b] = k->data[b];
            }

            FlightMissionMode_cfclose_h(fid, localDW);
            curSection->size[0] = 1;
            curSection->size[1] = 0;
            curKey->size[0] = 1;
            curKey->size[1] = 0;
            curVal->size[0] = 1;
            curVal->size[1] = 0;
            FlightMissionMode_emxInit_char_T_b(&tmp_1, 2);
            FlightMissionMode_emxInit_char_T_b(&tmp_2, 2);
            FlightMissionMode_emxInit_char_T_b(&data_0, 2);
            exitg1 = false;
            while ((!exitg1) && (data->size[1] != 0)) {
                i = static_cast<int32_T>(data_0->size[0] * data_0->size[1]);
                data_0->size[0] = 1;
                data_0->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_o(data_0, i);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (i = 0; i <= loop_ub; i++) {
                    data_0->data[i] = data->data[i];
                }

                FlightMissionMode_strtok_a(data_0, curLine, data);
                FlightMissionMode_strtok_ac(curLine, tmp_2);
                FlightMissionMode_strtrim_l(tmp_2, curLine);
                if (curLine->size[1] >= 2) {
                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                c = 0;
                                b = 0;
                            } else {
                                c = 1;
                                b = static_cast<int32_T>(curLine->size[1] - 1);
                            }

                            i = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(b - c);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_o
                                (curSection, i);
                            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1);
                                    b++) {
                                curSection->data[b] = curLine->data[static_cast<
                                    int32_T>(c + b)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains_g(curLine)) {
                            FlightMissionMode_strtok_acx(curLine, curVal,
                                b_remainder);
                            FlightMissionMode_strtrim_l(curVal, curKey);
                            FlightMissionMode_strtok_acxd(b_remainder, tmp_1);
                            FlightMissionMode_strtrim_l(tmp_1, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp_c(curSection) &&
                        FlightMissionMode_strcmp_coghz(curKey)) {
                    i = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                    ret->size[0] = 1;
                    ret->size[1] = curVal->size[1];
                    FlightMissionMode_emxEnsureCapacity_char_T_o(ret, i);
                    loop_ub = curVal->size[1];
                    for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                        ret->data[b] = curVal->data[b];
                    }

                    exitg1 = true;
                }
            }

            FlightMissionMode_emxFree_char_T_d(&data_0);
            FlightMissionMode_emxFree_char_T_d(&tmp_2);
            FlightMissionMode_emxFree_char_T_d(&tmp_1);
        }

        FlightMissionMode_emxFree_char_T_d(&k);
        FlightMissionMode_emxFree_char_T_d(&b_remainder);
        FlightMissionMode_emxFree_char_T_d(&curLine);
        FlightMissionMode_emxFree_char_T_d(&curVal);
        FlightMissionMode_emxFree_char_T_d(&curKey);
        FlightMissionMode_emxFree_char_T_d(&curSection);
        FlightMissionMode_emxFree_char_T_d(&data);
        tmp_0 = FlightMissionMode_str2double_h(ret);
        fid = 0.017453292519943295 * tmp_0.re;
        printf("Set UAV MaxRollAngle:\t\t%f\n", fid);
        fflush(stdout);
        FlightMissionMode_readINI_i(ret, localDW);
        tmp_0 = FlightMissionMode_str2double_h(ret);
        ClimbAngleLimit = 0.017453292519943295 * tmp_0.re;
        printf("Set UAV ClimbAngleLimit:\t%f\n", ClimbAngleLimit);
        fflush(stdout);
        FlightMissionMode_readINI_iy(ret, localDW);
        tmp_0 = FlightMissionMode_str2double_h(ret);
        FlightMissionMode_emxFree_char_T_d(&ret);
        DiveAngleLimit = 0.017453292519943295 * tmp_0.re;
        printf("Set UAV DiveAngleLimit:\t\t%f\n", DiveAngleLimit);
        fflush(stdout);
        if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(std::
                isnan(tmp.re)) ^ 1))) {
            localDW->SingletonInstance.AirSpeed = tmp.re;
        }

        if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(std::
                isnan(fid)) ^ 1))) {
            localDW->SingletonInstance.MaxRollAngle = fid;
        }

        if ((static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                (std::isnan(ClimbAngleLimit)) ^ 1))) && (static_cast<boolean_T>(
                static_cast<int32_T>(static_cast<int32_T>(std::isnan
                (DiveAngleLimit)) ^ 1)))) {
            localDW->SingletonInstance.FlightPathAngleLimit[0] = DiveAngleLimit;
            localDW->SingletonInstance.FlightPathAngleLimit[1] = ClimbAngleLimit;
        }

        for (i = 0; i < 2; i++) {
            tmp_9[i] = localDW->SingletonInstance.FlightPathAngleLimit[i];
        }

        FlightMissionMode_uavDubinsConnection_uavDubinsConnection_l
            (&localDW->SingletonInstance.Connector,
             localDW->SingletonInstance.AirSpeed,
             localDW->SingletonInstance.MaxRollAngle, tmp_9);
        localDW->SingletonInstance_not_empty = true;
    }

    outputArg = &localDW->SingletonInstance.Connector;
    return outputArg;
}

static void FlightMissionMode_emxInit_real_T_i
    (emxArray_real_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions)
{
    emxArray_real_T_FlightMissionMode_T *emxArray;
    *pEmxArray = static_cast<emxArray_real_T_FlightMissionMode_T *>(std::malloc
        (sizeof(emxArray_real_T_FlightMissionMode_T)));
    emxArray = *pEmxArray;
    emxArray->data = static_cast<real_T *>(nullptr);
    emxArray->numDimensions = numDimensions;
    emxArray->size = static_cast<int32_T *>(std::malloc(static_cast<uint32_T>
        (sizeof(int32_T) * static_cast<uint32_T>(numDimensions))));
    emxArray->allocatedSize = 0;
    emxArray->canFreeData = true;
    for (int32_T i{0}; i <= static_cast<int32_T>(numDimensions - 1); i++) {
        emxArray->size[i] = 0;
    }
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static void* FlightMissionMode_uavDubinsBuildable_uavDubinsBuildable_d(real_T
    airSpeed, real_T maxRollAngle, const real_T flightPathAngle[2])
{
    real_T b_flightPathAngle[2];
    b_flightPathAngle[0] = flightPathAngle[0];
    b_flightPathAngle[1] = flightPathAngle[1];
    return uavDubinsConnectionObj(airSpeed, maxRollAngle, &b_flightPathAngle[0],
        nullptr, 0U);
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static boolean_T FlightMissionMode_strcmp_coghzf(const char_T a_data[], const
    int32_T a_size[2])
{
    static const char_T b[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T c[2]{ 'H', 'L' };

    boolean_T b_bool;
    b_bool = false;
    if (a_size[1] == 2) {
        int32_T kstr;
        kstr = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (kstr < 2) {
                if (b[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(a_data[kstr]))
                                           & 127)] != b[static_cast<int32_T>
                        (c[kstr])]) {
                    exitg1 = 1;
                } else {
                    kstr = static_cast<int32_T>(kstr + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    return b_bool;
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static boolean_T FlightMissionMode_strcmp_coghzfk(const char_T a_data[], const
    int32_T a_size[2])
{
    static const char_T b[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T c[2]{ 'H', 'R' };

    boolean_T b_bool;
    b_bool = false;
    if (a_size[1] == 2) {
        int32_T kstr;
        kstr = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (kstr < 2) {
                if (b[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(a_data[kstr]))
                                           & 127)] != b[static_cast<int32_T>
                        (c[kstr])]) {
                    exitg1 = 1;
                } else {
                    kstr = static_cast<int32_T>(kstr + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    return b_bool;
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static void FlightMissionMode_uavDubinsPathSegment_uavDubinsPathSegment_gx(const
    real_T varargin_1[4], const real_T varargin_2[4], real_T varargin_3, real_T
    varargin_4, real_T varargin_5, real_T varargin_6, const
    cell_wrap_11_FlightMissionMode_T varargin_7[4], const real_T varargin_8[4],
    uavDubinsPathSegment_FlightMissionMode_c_T *b_this)
{
    static const char_T h[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K',
        'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',
        'Z', '[', '\\', ']', '^', '_', '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
        'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',
        'V', 'W', 'X', 'Y', 'Z', '{', '|', '}', '~', '\x7f' };

    real_T thetaWrap;
    int32_T f;
    b_this->MinTurningRadius = varargin_5;
    b_this->StartPose[0] = varargin_1[0];
    b_this->StartPose[1] = varargin_1[1];
    b_this->StartPose[2] = varargin_1[2];
    thetaWrap = mod_Cteiw4Qy(varargin_1[3]);
    b_this->StartPose[3] = thetaWrap;
    if (static_cast<boolean_T>(static_cast<int32_T>((thetaWrap == 0.0) &
            (varargin_1[3] > 0.0)))) {
        b_this->StartPose[3] = 6.2831853071795862;
    }

    wrapToPi_8g8Yma1S(&b_this->StartPose[3]);
    b_this->GoalPose[0] = varargin_2[0];
    b_this->GoalPose[1] = varargin_2[1];
    b_this->GoalPose[2] = varargin_2[2];
    thetaWrap = mod_Cteiw4Qy(varargin_2[3]);
    b_this->GoalPose[3] = thetaWrap;
    if (static_cast<boolean_T>(static_cast<int32_T>((thetaWrap == 0.0) &
            (varargin_2[3] > 0.0)))) {
        b_this->GoalPose[3] = 6.2831853071795862;
    }

    wrapToPi_8g8Yma1S(&b_this->GoalPose[3]);
    b_this->AirSpeed = varargin_4;
    b_this->HelixRadius = varargin_6;
    b_this->FlightPathAngle = varargin_3;
    b_this->MotionLengths[0] = varargin_8[0];
    b_this->MotionTypes[0] = varargin_7[0];
    b_this->MotionLengths[1] = varargin_8[1];
    b_this->MotionTypes[1] = varargin_7[1];
    b_this->MotionLengths[2] = varargin_8[2];
    b_this->MotionTypes[2] = varargin_7[2];
    b_this->MotionLengths[3] = varargin_8[3];
    b_this->MotionTypes[3] = varargin_7[3];
    b_this->MotionTypes[0].f1.size[0] = 1;
    b_this->MotionTypes[0].f1.size[1] = varargin_7[0].f1.size[1];
    f = varargin_7[0].f1.size[1];
    for (int32_T k{0}; k <= static_cast<int32_T>(f - 1); k++) {
        b_this->MotionTypes[0].f1.data[k] = h[static_cast<int32_T>(varargin_7[0]
            .f1.data[k])];
    }

    b_this->MotionTypes[1].f1.size[0] = 1;
    b_this->MotionTypes[1].f1.size[1] = 1;
    b_this->MotionTypes[1].f1.data[0] = h[static_cast<int32_T>
        (static_cast<int32_T>(static_cast<uint8_T>(varargin_7[1].f1.data[0])) &
         127)];
    b_this->MotionTypes[2].f1.size[0] = 1;
    b_this->MotionTypes[2].f1.size[1] = 1;
    b_this->MotionTypes[2].f1.data[0] = h[static_cast<int32_T>
        (static_cast<int32_T>(static_cast<uint8_T>(varargin_7[2].f1.data[0])) &
         127)];
    b_this->MotionTypes[3].f1.size[0] = 1;
    b_this->MotionTypes[3].f1.size[1] = varargin_7[3].f1.size[1];
    f = varargin_7[3].f1.size[1];
    for (int32_T k{0}; k <= static_cast<int32_T>(f - 1); k++) {
        b_this->MotionTypes[3].f1.data[k] = h[static_cast<int32_T>(varargin_7[3]
            .f1.data[k])];
    }

    if (FlightMissionMode_strcmp_coghzf(b_this->MotionTypes[0].f1.data,
            b_this->MotionTypes[0].f1.size)) {
        b_this->MotionTypes[0].f1.size[0] = 1;
        b_this->MotionTypes[0].f1.size[1] = 2;
        b_this->MotionTypes[0].f1.data[0] = 'H';
        b_this->MotionTypes[0].f1.data[1] = 'l';
    } else if (FlightMissionMode_strcmp_coghzfk(b_this->MotionTypes[0].f1.data,
                b_this->MotionTypes[0].f1.size)) {
        b_this->MotionTypes[0].f1.size[0] = 1;
        b_this->MotionTypes[0].f1.size[1] = 2;
        b_this->MotionTypes[0].f1.data[0] = 'H';
        b_this->MotionTypes[0].f1.data[1] = 'r';
    } else if (FlightMissionMode_strcmp_coghzfk(b_this->MotionTypes[3].f1.data,
                b_this->MotionTypes[3].f1.size)) {
        b_this->MotionTypes[3].f1.size[0] = 1;
        b_this->MotionTypes[3].f1.size[1] = 2;
        b_this->MotionTypes[3].f1.data[0] = 'H';
        b_this->MotionTypes[3].f1.data[1] = 'r';
    } else if (FlightMissionMode_strcmp_coghzf(b_this->MotionTypes[3].f1.data,
                b_this->MotionTypes[3].f1.size)) {
        b_this->MotionTypes[3].f1.size[0] = 1;
        b_this->MotionTypes[3].f1.size[1] = 2;
        b_this->MotionTypes[3].f1.data[0] = 'H';
        b_this->MotionTypes[3].f1.data[1] = 'l';
    }

    b_this->Length = ((varargin_8[0] + varargin_8[1]) + varargin_8[2]) +
        varargin_8[3];
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static void FlightMissionMode_uavDubinsBuiltins_connect_d(const
    uavDubinsConnection_FlightMissionMode_g_T *obj, const real_T startPose[4],
    const real_T goalPose[4], real_T turningRadius,
    uavDubinsPathSegment_FlightMissionMode_c_T *pathSegObjs, real_T *pathCosts)
{
    void* b_obj_UAVDubinsBuildableObj;
    cell_wrap_11_FlightMissionMode_T ac;
    cell_wrap_11_FlightMissionMode_T ad;
    cell_wrap_11_FlightMissionMode_T ae;
    cell_wrap_11_FlightMissionMode_T af;
    cell_wrap_11_FlightMissionMode_T bc;
    cell_wrap_11_FlightMissionMode_T bd;
    cell_wrap_11_FlightMissionMode_T be;
    cell_wrap_11_FlightMissionMode_T bf;
    cell_wrap_11_FlightMissionMode_T cc;
    cell_wrap_11_FlightMissionMode_T cd;
    cell_wrap_11_FlightMissionMode_T ce;
    cell_wrap_11_FlightMissionMode_T cf;
    cell_wrap_11_FlightMissionMode_T dc;
    cell_wrap_11_FlightMissionMode_T dd;
    cell_wrap_11_FlightMissionMode_T de;
    cell_wrap_11_FlightMissionMode_T df;
    cell_wrap_11_FlightMissionMode_T ec;
    cell_wrap_11_FlightMissionMode_T ed;
    cell_wrap_11_FlightMissionMode_T ee;
    cell_wrap_11_FlightMissionMode_T ef;
    cell_wrap_11_FlightMissionMode_T fc;
    cell_wrap_11_FlightMissionMode_T fd;
    cell_wrap_11_FlightMissionMode_T fe;
    cell_wrap_11_FlightMissionMode_T ff;
    cell_wrap_11_FlightMissionMode_T gc;
    cell_wrap_11_FlightMissionMode_T gd;
    cell_wrap_11_FlightMissionMode_T ge;
    cell_wrap_11_FlightMissionMode_T gf;
    cell_wrap_11_FlightMissionMode_T hc;
    cell_wrap_11_FlightMissionMode_T hd;
    cell_wrap_11_FlightMissionMode_T he;
    cell_wrap_11_FlightMissionMode_T hf;
    cell_wrap_11_FlightMissionMode_T ib;
    cell_wrap_11_FlightMissionMode_T ic;
    cell_wrap_11_FlightMissionMode_T id;
    cell_wrap_11_FlightMissionMode_T ie;
    cell_wrap_11_FlightMissionMode_T jb;
    cell_wrap_11_FlightMissionMode_T jc;
    cell_wrap_11_FlightMissionMode_T jd;
    cell_wrap_11_FlightMissionMode_T je;
    cell_wrap_11_FlightMissionMode_T jf;
    cell_wrap_11_FlightMissionMode_T kb;
    cell_wrap_11_FlightMissionMode_T kc;
    cell_wrap_11_FlightMissionMode_T kd;
    cell_wrap_11_FlightMissionMode_T ke;
    cell_wrap_11_FlightMissionMode_T kf;
    cell_wrap_11_FlightMissionMode_T lb;
    cell_wrap_11_FlightMissionMode_T lc;
    cell_wrap_11_FlightMissionMode_T ld;
    cell_wrap_11_FlightMissionMode_T le;
    cell_wrap_11_FlightMissionMode_T lf;
    cell_wrap_11_FlightMissionMode_T mb;
    cell_wrap_11_FlightMissionMode_T mc;
    cell_wrap_11_FlightMissionMode_T md;
    cell_wrap_11_FlightMissionMode_T me;
    cell_wrap_11_FlightMissionMode_T mf;
    cell_wrap_11_FlightMissionMode_T nb;
    cell_wrap_11_FlightMissionMode_T nc;
    cell_wrap_11_FlightMissionMode_T nd;
    cell_wrap_11_FlightMissionMode_T ne;
    cell_wrap_11_FlightMissionMode_T nf;
    cell_wrap_11_FlightMissionMode_T ob;
    cell_wrap_11_FlightMissionMode_T oc;
    cell_wrap_11_FlightMissionMode_T od;
    cell_wrap_11_FlightMissionMode_T oe;
    cell_wrap_11_FlightMissionMode_T of;
    cell_wrap_11_FlightMissionMode_T pb;
    cell_wrap_11_FlightMissionMode_T pc;
    cell_wrap_11_FlightMissionMode_T pd;
    cell_wrap_11_FlightMissionMode_T pe;
    cell_wrap_11_FlightMissionMode_T pf;
    cell_wrap_11_FlightMissionMode_T qb;
    cell_wrap_11_FlightMissionMode_T qc;
    cell_wrap_11_FlightMissionMode_T qd;
    cell_wrap_11_FlightMissionMode_T qe;
    cell_wrap_11_FlightMissionMode_T qf;
    cell_wrap_11_FlightMissionMode_T rb;
    cell_wrap_11_FlightMissionMode_T rc;
    cell_wrap_11_FlightMissionMode_T rd;
    cell_wrap_11_FlightMissionMode_T re;
    cell_wrap_11_FlightMissionMode_T rf;
    cell_wrap_11_FlightMissionMode_T sb;
    cell_wrap_11_FlightMissionMode_T sc;
    cell_wrap_11_FlightMissionMode_T sd;
    cell_wrap_11_FlightMissionMode_T se;
    cell_wrap_11_FlightMissionMode_T sf;
    cell_wrap_11_FlightMissionMode_T tb;
    cell_wrap_11_FlightMissionMode_T tc;
    cell_wrap_11_FlightMissionMode_T td;
    cell_wrap_11_FlightMissionMode_T te;
    cell_wrap_11_FlightMissionMode_T tf;
    cell_wrap_11_FlightMissionMode_T ub;
    cell_wrap_11_FlightMissionMode_T uc;
    cell_wrap_11_FlightMissionMode_T ud;
    cell_wrap_11_FlightMissionMode_T ue;
    cell_wrap_11_FlightMissionMode_T uf;
    cell_wrap_11_FlightMissionMode_T vb;
    cell_wrap_11_FlightMissionMode_T vc;
    cell_wrap_11_FlightMissionMode_T vd;
    cell_wrap_11_FlightMissionMode_T ve;
    cell_wrap_11_FlightMissionMode_T wb;
    cell_wrap_11_FlightMissionMode_T wc;
    cell_wrap_11_FlightMissionMode_T wd;
    cell_wrap_11_FlightMissionMode_T we;
    cell_wrap_11_FlightMissionMode_T xb;
    cell_wrap_11_FlightMissionMode_T xc;
    cell_wrap_11_FlightMissionMode_T xd;
    cell_wrap_11_FlightMissionMode_T xe;
    cell_wrap_11_FlightMissionMode_T yb;
    cell_wrap_11_FlightMissionMode_T yc;
    cell_wrap_11_FlightMissionMode_T yd;
    cell_wrap_11_FlightMissionMode_T ye;
    cell_wrap_22_FlightMissionMode_j_T motionTypes[28];
    cell_wrap_22_FlightMissionMode_j_T b;
    real_T g[16];
    real_T ml[16];
    real_T ml1[16];
    real_T s[16];
    real_T b_goalPose[4];
    real_T b_startPose[4];
    real_T ml1_0[4];
    real_T b_a;
    real_T b_fpa;
    real_T h;
    real_T mt;
    real_T mtr;
    int32_T tmp;
    ib.f1.size[0] = 1;
    ib.f1.size[1] = 1;
    ib.f1.data[0] = 'L';
    jb.f1.size[0] = 1;
    jb.f1.size[1] = 1;
    jb.f1.data[0] = 'S';
    kb.f1.size[0] = 1;
    kb.f1.size[1] = 1;
    kb.f1.data[0] = 'L';
    lb.f1.size[0] = 1;
    lb.f1.size[1] = 1;
    lb.f1.data[0] = 'N';
    b.f1[0] = ib;
    b.f1[1] = jb;
    b.f1[2] = kb;
    b.f1[3] = lb;
    mb.f1.size[0] = 1;
    mb.f1.size[1] = 1;
    mb.f1.data[0] = 'L';
    nb.f1.size[0] = 1;
    nb.f1.size[1] = 1;
    nb.f1.data[0] = 'S';
    ob.f1.size[0] = 1;
    ob.f1.size[1] = 1;
    ob.f1.data[0] = 'R';
    pb.f1.size[0] = 1;
    pb.f1.size[1] = 1;
    pb.f1.data[0] = 'N';
    qb.f1.size[0] = 1;
    qb.f1.size[1] = 1;
    qb.f1.data[0] = 'R';
    rb.f1.size[0] = 1;
    rb.f1.size[1] = 1;
    rb.f1.data[0] = 'S';
    sb.f1.size[0] = 1;
    sb.f1.size[1] = 1;
    sb.f1.data[0] = 'L';
    tb.f1.size[0] = 1;
    tb.f1.size[1] = 1;
    tb.f1.data[0] = 'N';
    ub.f1.size[0] = 1;
    ub.f1.size[1] = 1;
    ub.f1.data[0] = 'R';
    vb.f1.size[0] = 1;
    vb.f1.size[1] = 1;
    vb.f1.data[0] = 'S';
    wb.f1.size[0] = 1;
    wb.f1.size[1] = 1;
    wb.f1.data[0] = 'R';
    xb.f1.size[0] = 1;
    xb.f1.size[1] = 1;
    xb.f1.data[0] = 'N';
    yb.f1.size[0] = 1;
    yb.f1.size[1] = 1;
    yb.f1.data[0] = 'R';
    ac.f1.size[0] = 1;
    ac.f1.size[1] = 1;
    ac.f1.data[0] = 'L';
    bc.f1.size[0] = 1;
    bc.f1.size[1] = 1;
    bc.f1.data[0] = 'R';
    cc.f1.size[0] = 1;
    cc.f1.size[1] = 1;
    cc.f1.data[0] = 'N';
    dc.f1.size[0] = 1;
    dc.f1.size[1] = 1;
    dc.f1.data[0] = 'L';
    ec.f1.size[0] = 1;
    ec.f1.size[1] = 1;
    ec.f1.data[0] = 'R';
    fc.f1.size[0] = 1;
    fc.f1.size[1] = 1;
    fc.f1.data[0] = 'L';
    gc.f1.size[0] = 1;
    gc.f1.size[1] = 1;
    gc.f1.data[0] = 'N';
    hc.f1.size[0] = 1;
    hc.f1.size[1] = 2;
    ic.f1.size[0] = 1;
    ic.f1.size[1] = 1;
    ic.f1.data[0] = 'L';
    jc.f1.size[0] = 1;
    jc.f1.size[1] = 1;
    jc.f1.data[0] = 'S';
    kc.f1.size[0] = 1;
    kc.f1.size[1] = 1;
    kc.f1.data[0] = 'L';
    lc.f1.size[0] = 1;
    lc.f1.size[1] = 2;
    mc.f1.size[0] = 1;
    mc.f1.size[1] = 1;
    mc.f1.data[0] = 'L';
    nc.f1.size[0] = 1;
    nc.f1.size[1] = 1;
    nc.f1.data[0] = 'S';
    oc.f1.size[0] = 1;
    oc.f1.size[1] = 1;
    oc.f1.data[0] = 'R';
    pc.f1.size[0] = 1;
    pc.f1.size[1] = 2;
    qc.f1.size[0] = 1;
    qc.f1.size[1] = 1;
    qc.f1.data[0] = 'R';
    rc.f1.size[0] = 1;
    rc.f1.size[1] = 1;
    rc.f1.data[0] = 'S';
    sc.f1.size[0] = 1;
    sc.f1.size[1] = 1;
    sc.f1.data[0] = 'L';
    tc.f1.size[0] = 1;
    tc.f1.size[1] = 2;
    uc.f1.size[0] = 1;
    uc.f1.size[1] = 1;
    uc.f1.data[0] = 'R';
    vc.f1.size[0] = 1;
    vc.f1.size[1] = 1;
    vc.f1.data[0] = 'S';
    wc.f1.size[0] = 1;
    wc.f1.size[1] = 1;
    wc.f1.data[0] = 'R';
    xc.f1.size[0] = 1;
    xc.f1.size[1] = 2;
    yc.f1.size[0] = 1;
    yc.f1.size[1] = 1;
    yc.f1.data[0] = 'R';
    ad.f1.size[0] = 1;
    ad.f1.size[1] = 1;
    ad.f1.data[0] = 'L';
    bd.f1.size[0] = 1;
    bd.f1.size[1] = 1;
    bd.f1.data[0] = 'R';
    cd.f1.size[0] = 1;
    cd.f1.size[1] = 2;
    dd.f1.size[0] = 1;
    dd.f1.size[1] = 1;
    dd.f1.data[0] = 'L';
    ed.f1.size[0] = 1;
    ed.f1.size[1] = 1;
    ed.f1.data[0] = 'R';
    fd.f1.size[0] = 1;
    fd.f1.size[1] = 1;
    fd.f1.data[0] = 'L';
    gd.f1.size[0] = 1;
    gd.f1.size[1] = 1;
    gd.f1.data[0] = 'L';
    hd.f1.size[0] = 1;
    hd.f1.size[1] = 1;
    hd.f1.data[0] = 'S';
    id.f1.size[0] = 1;
    id.f1.size[1] = 1;
    id.f1.data[0] = 'L';
    jd.f1.size[0] = 1;
    jd.f1.size[1] = 2;
    kd.f1.size[0] = 1;
    kd.f1.size[1] = 1;
    kd.f1.data[0] = 'L';
    ld.f1.size[0] = 1;
    ld.f1.size[1] = 1;
    ld.f1.data[0] = 'S';
    md.f1.size[0] = 1;
    md.f1.size[1] = 1;
    md.f1.data[0] = 'R';
    nd.f1.size[0] = 1;
    nd.f1.size[1] = 2;
    od.f1.size[0] = 1;
    od.f1.size[1] = 1;
    od.f1.data[0] = 'R';
    pd.f1.size[0] = 1;
    pd.f1.size[1] = 1;
    pd.f1.data[0] = 'S';
    qd.f1.size[0] = 1;
    qd.f1.size[1] = 1;
    qd.f1.data[0] = 'L';
    rd.f1.size[0] = 1;
    rd.f1.size[1] = 2;
    sd.f1.size[0] = 1;
    sd.f1.size[1] = 1;
    sd.f1.data[0] = 'R';
    td.f1.size[0] = 1;
    td.f1.size[1] = 1;
    td.f1.data[0] = 'S';
    ud.f1.size[0] = 1;
    ud.f1.size[1] = 1;
    ud.f1.data[0] = 'R';
    vd.f1.size[0] = 1;
    vd.f1.size[1] = 2;
    wd.f1.size[0] = 1;
    wd.f1.size[1] = 1;
    wd.f1.data[0] = 'R';
    xd.f1.size[0] = 1;
    xd.f1.size[1] = 1;
    xd.f1.data[0] = 'L';
    yd.f1.size[0] = 1;
    yd.f1.size[1] = 1;
    yd.f1.data[0] = 'R';
    ae.f1.size[0] = 1;
    ae.f1.size[1] = 2;
    be.f1.size[0] = 1;
    be.f1.size[1] = 1;
    be.f1.data[0] = 'L';
    ce.f1.size[0] = 1;
    ce.f1.size[1] = 1;
    ce.f1.data[0] = 'R';
    de.f1.size[0] = 1;
    de.f1.size[1] = 1;
    de.f1.data[0] = 'L';
    ee.f1.size[0] = 1;
    ee.f1.size[1] = 2;
    hc.f1.data[0] = 'H';
    lc.f1.data[0] = 'H';
    pc.f1.data[0] = 'H';
    tc.f1.data[0] = 'H';
    xc.f1.data[0] = 'H';
    cd.f1.data[0] = 'H';
    jd.f1.data[0] = 'H';
    nd.f1.data[0] = 'H';
    rd.f1.data[0] = 'H';
    vd.f1.data[0] = 'H';
    ae.f1.data[0] = 'H';
    ee.f1.data[0] = 'H';
    hc.f1.data[1] = 'l';
    lc.f1.data[1] = 'l';
    pc.f1.data[1] = 'r';
    tc.f1.data[1] = 'r';
    xc.f1.data[1] = 'r';
    cd.f1.data[1] = 'l';
    jd.f1.data[1] = 'l';
    nd.f1.data[1] = 'r';
    rd.f1.data[1] = 'l';
    vd.f1.data[1] = 'r';
    ae.f1.data[1] = 'r';
    ee.f1.data[1] = 'l';
    fe.f1.size[0] = 1;
    fe.f1.size[1] = 1;
    fe.f1.data[0] = 'L';
    ge.f1.size[0] = 1;
    ge.f1.size[1] = 1;
    ge.f1.data[0] = 'R';
    he.f1.size[0] = 1;
    he.f1.size[1] = 1;
    he.f1.data[0] = 'S';
    ie.f1.size[0] = 1;
    ie.f1.size[1] = 1;
    ie.f1.data[0] = 'L';
    je.f1.size[0] = 1;
    je.f1.size[1] = 1;
    je.f1.data[0] = 'L';
    ke.f1.size[0] = 1;
    ke.f1.size[1] = 1;
    ke.f1.data[0] = 'R';
    le.f1.size[0] = 1;
    le.f1.size[1] = 1;
    le.f1.data[0] = 'S';
    me.f1.size[0] = 1;
    me.f1.size[1] = 1;
    me.f1.data[0] = 'R';
    ne.f1.size[0] = 1;
    ne.f1.size[1] = 1;
    ne.f1.data[0] = 'L';
    oe.f1.size[0] = 1;
    oe.f1.size[1] = 1;
    oe.f1.data[0] = 'R';
    pe.f1.size[0] = 1;
    pe.f1.size[1] = 1;
    pe.f1.data[0] = 'L';
    qe.f1.size[0] = 1;
    qe.f1.size[1] = 1;
    qe.f1.data[0] = 'R';
    re.f1.size[0] = 1;
    re.f1.size[1] = 1;
    re.f1.data[0] = 'R';
    se.f1.size[0] = 1;
    se.f1.size[1] = 1;
    se.f1.data[0] = 'L';
    te.f1.size[0] = 1;
    te.f1.size[1] = 1;
    te.f1.data[0] = 'S';
    ue.f1.size[0] = 1;
    ue.f1.size[1] = 1;
    ue.f1.data[0] = 'R';
    ve.f1.size[0] = 1;
    ve.f1.size[1] = 1;
    ve.f1.data[0] = 'R';
    we.f1.size[0] = 1;
    we.f1.size[1] = 1;
    we.f1.data[0] = 'L';
    xe.f1.size[0] = 1;
    xe.f1.size[1] = 1;
    xe.f1.data[0] = 'R';
    ye.f1.size[0] = 1;
    ye.f1.size[1] = 1;
    ye.f1.data[0] = 'L';
    af.f1.size[0] = 1;
    af.f1.size[1] = 1;
    af.f1.data[0] = 'R';
    bf.f1.size[0] = 1;
    bf.f1.size[1] = 1;
    bf.f1.data[0] = 'L';
    cf.f1.size[0] = 1;
    cf.f1.size[1] = 1;
    cf.f1.data[0] = 'S';
    df.f1.size[0] = 1;
    df.f1.size[1] = 1;
    df.f1.data[0] = 'L';
    ef.f1.size[0] = 1;
    ef.f1.size[1] = 1;
    ef.f1.data[0] = 'L';
    ff.f1.size[0] = 1;
    ff.f1.size[1] = 1;
    ff.f1.data[0] = 'S';
    gf.f1.size[0] = 1;
    gf.f1.size[1] = 1;
    gf.f1.data[0] = 'R';
    hf.f1.size[0] = 1;
    hf.f1.size[1] = 1;
    hf.f1.data[0] = 'L';
    jf.f1.size[0] = 1;
    jf.f1.size[1] = 1;
    jf.f1.data[0] = 'R';
    kf.f1.size[0] = 1;
    kf.f1.size[1] = 1;
    kf.f1.data[0] = 'S';
    lf.f1.size[0] = 1;
    lf.f1.size[1] = 1;
    lf.f1.data[0] = 'R';
    mf.f1.size[0] = 1;
    mf.f1.size[1] = 1;
    mf.f1.data[0] = 'L';
    nf.f1.size[0] = 1;
    nf.f1.size[1] = 1;
    nf.f1.data[0] = 'L';
    of.f1.size[0] = 1;
    of.f1.size[1] = 1;
    of.f1.data[0] = 'S';
    pf.f1.size[0] = 1;
    pf.f1.size[1] = 1;
    pf.f1.data[0] = 'L';
    qf.f1.size[0] = 1;
    qf.f1.size[1] = 1;
    qf.f1.data[0] = 'R';
    rf.f1.size[0] = 1;
    rf.f1.size[1] = 1;
    rf.f1.data[0] = 'R';
    sf.f1.size[0] = 1;
    sf.f1.size[1] = 1;
    sf.f1.data[0] = 'S';
    tf.f1.size[0] = 1;
    tf.f1.size[1] = 1;
    tf.f1.data[0] = 'L';
    uf.f1.size[0] = 1;
    uf.f1.size[1] = 1;
    uf.f1.data[0] = 'R';
    motionTypes[0] = b;
    b_obj_UAVDubinsBuildableObj =
        FlightMissionMode_uavDubinsBuildable_uavDubinsBuildable_d(obj->AirSpeed,
        obj->MaxRollAngle, obj->FlightPathAngleLimit);
    b_startPose[0] = startPose[0];
    b_goalPose[0] = goalPose[0];
    b_startPose[1] = startPose[1];
    b_goalPose[1] = goalPose[1];
    b_startPose[2] = startPose[2];
    b_goalPose[2] = goalPose[2];
    b_startPose[3] = startPose[3];
    b_goalPose[3] = goalPose[3];
    uavDubinsDistanceCodegen_real64(b_obj_UAVDubinsBuildableObj, &b_startPose[0],
        1U, &b_goalPose[0], 1U, true, turningRadius, &s[0], &g[0], &b_fpa, &b_a,
        &mtr, &h, &mt, &ml[0]);
    tmp = 0;
    for (int32_T i{0}; i < 4; i++) {
        ml1[tmp] = ml[i];
        ml1[static_cast<int32_T>(tmp + 1)] = ml[static_cast<int32_T>(i + 4)];
        ml1[static_cast<int32_T>(tmp + 2)] = ml[static_cast<int32_T>(i + 8)];
        ml1[static_cast<int32_T>(tmp + 3)] = ml[static_cast<int32_T>(i + 12)];
        tmp = static_cast<int32_T>(tmp + 4);
    }

    if (mt + 1.0 == 2.0) {
        motionTypes[0].f1[0] = mb;
        motionTypes[0].f1[1] = nb;
        motionTypes[0].f1[2] = ob;
        motionTypes[0].f1[3] = pb;
    }

    if (mt + 1.0 == 3.0) {
        motionTypes[0].f1[0] = qb;
        motionTypes[0].f1[1] = rb;
        motionTypes[0].f1[2] = sb;
        motionTypes[0].f1[3] = tb;
    }

    if (mt + 1.0 == 4.0) {
        motionTypes[0].f1[0] = ub;
        motionTypes[0].f1[1] = vb;
        motionTypes[0].f1[2] = wb;
        motionTypes[0].f1[3] = xb;
    }

    if (mt + 1.0 == 5.0) {
        motionTypes[0].f1[0] = yb;
        motionTypes[0].f1[1] = ac;
        motionTypes[0].f1[2] = bc;
        motionTypes[0].f1[3] = cc;
    }

    if (mt + 1.0 == 6.0) {
        motionTypes[0].f1[0] = dc;
        motionTypes[0].f1[1] = ec;
        motionTypes[0].f1[2] = fc;
        motionTypes[0].f1[3] = gc;
    }

    if (mt + 1.0 == 7.0) {
        motionTypes[0].f1[0] = hc;
        motionTypes[0].f1[1] = ic;
        motionTypes[0].f1[2] = jc;
        motionTypes[0].f1[3] = kc;
    }

    if (mt + 1.0 == 8.0) {
        motionTypes[0].f1[0] = lc;
        motionTypes[0].f1[1] = mc;
        motionTypes[0].f1[2] = nc;
        motionTypes[0].f1[3] = oc;
    }

    if (mt + 1.0 == 9.0) {
        motionTypes[0].f1[0] = pc;
        motionTypes[0].f1[1] = qc;
        motionTypes[0].f1[2] = rc;
        motionTypes[0].f1[3] = sc;
    }

    if (mt + 1.0 == 10.0) {
        motionTypes[0].f1[0] = tc;
        motionTypes[0].f1[1] = uc;
        motionTypes[0].f1[2] = vc;
        motionTypes[0].f1[3] = wc;
    }

    if (mt + 1.0 == 11.0) {
        motionTypes[0].f1[0] = xc;
        motionTypes[0].f1[1] = yc;
        motionTypes[0].f1[2] = ad;
        motionTypes[0].f1[3] = bd;
    }

    if (mt + 1.0 == 12.0) {
        motionTypes[0].f1[0] = cd;
        motionTypes[0].f1[1] = dd;
        motionTypes[0].f1[2] = ed;
        motionTypes[0].f1[3] = fd;
    }

    if (mt + 1.0 == 13.0) {
        motionTypes[0].f1[0] = gd;
        motionTypes[0].f1[1] = hd;
        motionTypes[0].f1[2] = id;
        motionTypes[0].f1[3] = jd;
    }

    if (mt + 1.0 == 14.0) {
        motionTypes[0].f1[0] = kd;
        motionTypes[0].f1[1] = ld;
        motionTypes[0].f1[2] = md;
        motionTypes[0].f1[3] = nd;
    }

    if (mt + 1.0 == 15.0) {
        motionTypes[0].f1[0] = od;
        motionTypes[0].f1[1] = pd;
        motionTypes[0].f1[2] = qd;
        motionTypes[0].f1[3] = rd;
    }

    if (mt + 1.0 == 16.0) {
        motionTypes[0].f1[0] = sd;
        motionTypes[0].f1[1] = td;
        motionTypes[0].f1[2] = ud;
        motionTypes[0].f1[3] = vd;
    }

    if (mt + 1.0 == 17.0) {
        motionTypes[0].f1[0] = wd;
        motionTypes[0].f1[1] = xd;
        motionTypes[0].f1[2] = yd;
        motionTypes[0].f1[3] = ae;
    }

    if (mt + 1.0 == 18.0) {
        motionTypes[0].f1[0] = be;
        motionTypes[0].f1[1] = ce;
        motionTypes[0].f1[2] = de;
        motionTypes[0].f1[3] = ee;
    }

    if (mt + 1.0 == 19.0) {
        motionTypes[0].f1[0] = fe;
        motionTypes[0].f1[1] = ge;
        motionTypes[0].f1[2] = he;
        motionTypes[0].f1[3] = ie;
    }

    if (mt + 1.0 == 20.0) {
        motionTypes[0].f1[0] = je;
        motionTypes[0].f1[1] = ke;
        motionTypes[0].f1[2] = le;
        motionTypes[0].f1[3] = me;
    }

    if (mt + 1.0 == 21.0) {
        motionTypes[0].f1[0] = ne;
        motionTypes[0].f1[1] = oe;
        motionTypes[0].f1[2] = pe;
        motionTypes[0].f1[3] = qe;
    }

    if (mt + 1.0 == 22.0) {
        motionTypes[0].f1[0] = re;
        motionTypes[0].f1[1] = se;
        motionTypes[0].f1[2] = te;
        motionTypes[0].f1[3] = ue;
    }

    if (mt + 1.0 == 23.0) {
        motionTypes[0].f1[0] = ve;
        motionTypes[0].f1[1] = we;
        motionTypes[0].f1[2] = xe;
        motionTypes[0].f1[3] = ye;
    }

    if (mt + 1.0 == 24.0) {
        motionTypes[0].f1[0] = af;
        motionTypes[0].f1[1] = bf;
        motionTypes[0].f1[2] = cf;
        motionTypes[0].f1[3] = df;
    }

    if (mt + 1.0 == 25.0) {
        motionTypes[0].f1[0] = ef;
        motionTypes[0].f1[1] = ff;
        motionTypes[0].f1[2] = gf;
        motionTypes[0].f1[3] = hf;
    }

    if (mt + 1.0 == 26.0) {
        motionTypes[0].f1[0] = jf;
        motionTypes[0].f1[1] = kf;
        motionTypes[0].f1[2] = lf;
        motionTypes[0].f1[3] = mf;
    }

    if (mt + 1.0 == 27.0) {
        motionTypes[0].f1[0] = nf;
        motionTypes[0].f1[1] = of;
        motionTypes[0].f1[2] = pf;
        motionTypes[0].f1[3] = qf;
    }

    if (mt + 1.0 == 28.0) {
        motionTypes[0].f1[0] = rf;
        motionTypes[0].f1[1] = sf;
        motionTypes[0].f1[2] = tf;
        motionTypes[0].f1[3] = uf;
    }

    b_startPose[0] = s[0];
    b_goalPose[0] = g[0];
    ml1_0[0] = ml1[0];
    b_startPose[1] = s[1];
    b_goalPose[1] = g[1];
    ml1_0[1] = ml1[4];
    b_startPose[2] = s[2];
    b_goalPose[2] = g[2];
    ml1_0[2] = ml1[8];
    b_startPose[3] = s[3];
    b_goalPose[3] = g[3];
    ml1_0[3] = ml1[12];
    FlightMissionMode_uavDubinsPathSegment_uavDubinsPathSegment_gx(b_startPose,
        b_goalPose, b_fpa, b_a, mtr, h, motionTypes[0].f1, ml1_0, pathSegObjs);
    ml1_0[0] = ml1[0];
    ml1_0[1] = ml1[4];
    ml1_0[2] = ml1[8];
    ml1_0[3] = ml1[12];
    *pathCosts = sum_ftQQGuCy(ml1_0);
}

static void FlightMissionMode_emxEnsureCapacity_real_T_a
    (emxArray_real_T_FlightMissionMode_T *emxArray, int32_T oldNumel)
{
    int32_T i;
    int32_T newNumel;
    void *newData;
    if (oldNumel < 0) {
        oldNumel = 0;
    }

    newNumel = 1;
    for (i = 0; i <= static_cast<int32_T>(emxArray->numDimensions - 1); i++) {
        newNumel = static_cast<int32_T>(newNumel * emxArray->size[i]);
    }

    if (newNumel > emxArray->allocatedSize) {
        i = emxArray->allocatedSize;
        if (i < 16) {
            i = 16;
        }

        while (i < newNumel) {
            if (i > 1073741823) {
                i = MAX_int32_T;
            } else {
                i = static_cast<int32_T>(i << 1);
            }
        }

        newData = std::calloc(static_cast<uint32_T>(i), sizeof(real_T));
        if (emxArray->data != nullptr) {
            std::memcpy(newData, emxArray->data, static_cast<uint32_T>(sizeof
                         (real_T) * static_cast<uint32_T>(oldNumel)));
            if (emxArray->canFreeData) {
                std::free(emxArray->data);
            }
        }

        emxArray->data = static_cast<real_T *>(newData);
        emxArray->allocatedSize = i;
        emxArray->canFreeData = true;
    }
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static void FlightMissionMode_strcmp_coghzfkn(const
    cell_wrap_11_FlightMissionMode_T a[4], boolean_T b_bool[4])
{
    b_bool[0] = false;
    if ((a[0].f1.size[1] == 1) && (a[0].f1.data[0] == 'N')) {
        b_bool[0] = true;
    }

    b_bool[1] = false;
    if ((a[1].f1.size[1] == 1) && (a[1].f1.data[0] == 'N')) {
        b_bool[1] = true;
    }

    b_bool[2] = false;
    if ((a[2].f1.size[1] == 1) && (a[2].f1.data[0] == 'N')) {
        b_bool[2] = true;
    }

    b_bool[3] = false;
    if ((a[3].f1.size[1] == 1) && (a[3].f1.data[0] == 'N')) {
        b_bool[3] = true;
    }
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static boolean_T FlightMissionMode_any_h(const boolean_T x[4])
{
    int32_T k;
    boolean_T exitg1;
    boolean_T y;
    y = false;
    k = 0;
    exitg1 = false;
    while ((!exitg1) && (k < 4)) {
        if (x[k]) {
            y = true;
            exitg1 = true;
        } else {
            k = static_cast<int32_T>(k + 1);
        }
    }

    return y;
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static void FlightMissionMode_useConstantDim_l(real_T varargin_2_data[], const
    int32_T varargin_2_size[2])
{
    int32_T b;
    b = static_cast<int32_T>(static_cast<uint8_T>(static_cast<int32_T>
        (varargin_2_size[1] - 1)));
    for (int32_T k{0}; k <= static_cast<int32_T>(b - 1); k++) {
        varargin_2_data[static_cast<int32_T>(k + 1)] += varargin_2_data[k];
    }
}

static void FlightMissionMode_emxInit_int32_T_j
    (emxArray_int32_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions)
{
    emxArray_int32_T_FlightMissionMode_T *emxArray;
    *pEmxArray = static_cast<emxArray_int32_T_FlightMissionMode_T *>(std::malloc
        (sizeof(emxArray_int32_T_FlightMissionMode_T)));
    emxArray = *pEmxArray;
    emxArray->data = static_cast<int32_T *>(nullptr);
    emxArray->numDimensions = numDimensions;
    emxArray->size = static_cast<int32_T *>(std::malloc(static_cast<uint32_T>
        (sizeof(int32_T) * static_cast<uint32_T>(numDimensions))));
    emxArray->allocatedSize = 0;
    emxArray->canFreeData = true;
    for (int32_T i{0}; i <= static_cast<int32_T>(numDimensions - 1); i++) {
        emxArray->size[i] = 0;
    }
}

static void FlightMissionMode_emxEnsureCapacity_int32_T_c
    (emxArray_int32_T_FlightMissionMode_T *emxArray, int32_T oldNumel)
{
    int32_T i;
    int32_T newNumel;
    void *newData;
    if (oldNumel < 0) {
        oldNumel = 0;
    }

    newNumel = 1;
    for (i = 0; i <= static_cast<int32_T>(emxArray->numDimensions - 1); i++) {
        newNumel = static_cast<int32_T>(newNumel * emxArray->size[i]);
    }

    if (newNumel > emxArray->allocatedSize) {
        i = emxArray->allocatedSize;
        if (i < 16) {
            i = 16;
        }

        while (i < newNumel) {
            if (i > 1073741823) {
                i = MAX_int32_T;
            } else {
                i = static_cast<int32_T>(i << 1);
            }
        }

        newData = std::calloc(static_cast<uint32_T>(i), sizeof(int32_T));
        if (emxArray->data != nullptr) {
            std::memcpy(newData, emxArray->data, static_cast<uint32_T>(sizeof
                         (int32_T) * static_cast<uint32_T>(oldNumel)));
            if (emxArray->canFreeData) {
                std::free(emxArray->data);
            }
        }

        emxArray->data = static_cast<int32_T *>(newData);
        emxArray->allocatedSize = i;
        emxArray->canFreeData = true;
    }
}

static void FlightMissionMode_emxFree_real_T_c
    (emxArray_real_T_FlightMissionMode_T **pEmxArray)
{
    if (*pEmxArray != static_cast<emxArray_real_T_FlightMissionMode_T *>(nullptr))
    {
        if (((*pEmxArray)->data != static_cast<real_T *>(nullptr)) &&
                (*pEmxArray)->canFreeData) {
            std::free((*pEmxArray)->data);
        }

        std::free((*pEmxArray)->size);
        std::free(*pEmxArray);
        *pEmxArray = static_cast<emxArray_real_T_FlightMissionMode_T *>(nullptr);
    }
}

static void FlightMissionMode_emxFree_int32_T_k
    (emxArray_int32_T_FlightMissionMode_T **pEmxArray)
{
    if (*pEmxArray != static_cast<emxArray_int32_T_FlightMissionMode_T *>
            (nullptr)) {
        if (((*pEmxArray)->data != static_cast<int32_T *>(nullptr)) &&
                (*pEmxArray)->canFreeData) {
            std::free((*pEmxArray)->data);
        }

        std::free((*pEmxArray)->size);
        std::free(*pEmxArray);
        *pEmxArray = static_cast<emxArray_int32_T_FlightMissionMode_T *>(nullptr);
    }
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static void FlightMissionMode_merge_n(emxArray_int32_T_FlightMissionMode_T *idx,
    emxArray_real_T_FlightMissionMode_T *x, int32_T offset, int32_T np, int32_T
    nq, emxArray_int32_T_FlightMissionMode_T *iwork,
    emxArray_real_T_FlightMissionMode_T *xwork)
{
    if (nq != 0) {
        int32_T iout;
        int32_T n;
        int32_T q;
        int32_T qend;
        qend = static_cast<int32_T>(np + nq);
        for (q = 0; q <= static_cast<int32_T>(qend - 1); q++) {
            iwork->data[q] = idx->data[static_cast<int32_T>(offset + q)];
            xwork->data[q] = x->data[static_cast<int32_T>(offset + q)];
        }

        n = 0;
        q = np;
        iout = static_cast<int32_T>(offset - 1);
        int32_T exitg1;
        do {
            exitg1 = 0;
            iout = static_cast<int32_T>(iout + 1);
            if (xwork->data[n] <= xwork->data[q]) {
                idx->data[iout] = iwork->data[n];
                x->data[iout] = xwork->data[n];
                if (static_cast<int32_T>(n + 1) < np) {
                    n = static_cast<int32_T>(n + 1);
                } else {
                    exitg1 = 1;
                }
            } else {
                idx->data[iout] = iwork->data[q];
                x->data[iout] = xwork->data[q];
                if (static_cast<int32_T>(q + 1) < qend) {
                    q = static_cast<int32_T>(q + 1);
                } else {
                    qend = static_cast<int32_T>(iout - n);
                    for (q = static_cast<int32_T>(n + 1); q <= np; q++) {
                        iout = static_cast<int32_T>(qend + q);
                        idx->data[iout] = iwork->data[static_cast<int32_T>(q - 1)];
                        x->data[iout] = xwork->data[static_cast<int32_T>(q - 1)];
                    }

                    exitg1 = 1;
                }
            }
        } while (exitg1 == 0);
    }
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static void FlightMissionMode_merge_block_o(emxArray_int32_T_FlightMissionMode_T
    *idx, emxArray_real_T_FlightMissionMode_T *x, int32_T offset, int32_T n,
    int32_T preSortLevel, emxArray_int32_T_FlightMissionMode_T *iwork,
    emxArray_real_T_FlightMissionMode_T *xwork)
{
    int32_T bLen;
    int32_T nPairs;
    nPairs = static_cast<int32_T>(n >> preSortLevel);
    bLen = static_cast<int32_T>(1 << preSortLevel);
    while (nPairs > 1) {
        int32_T nTail;
        int32_T tailOffset;
        if (static_cast<uint32_T>(static_cast<uint32_T>(nPairs) & 1U) != 0U) {
            nPairs = static_cast<int32_T>(nPairs - 1);
            tailOffset = static_cast<int32_T>(bLen * nPairs);
            nTail = static_cast<int32_T>(n - tailOffset);
            if (nTail > bLen) {
                FlightMissionMode_merge_n(idx, x, static_cast<int32_T>(offset +
                    tailOffset), bLen, static_cast<int32_T>(nTail - bLen), iwork,
                    xwork);
            }
        }

        nTail = static_cast<int32_T>(bLen << 1);
        nPairs = static_cast<int32_T>(nPairs >> 1);
        for (tailOffset = 0; tailOffset <= static_cast<int32_T>(nPairs - 1);
                tailOffset++) {
            FlightMissionMode_merge_n(idx, x, static_cast<int32_T>(offset +
                static_cast<int32_T>(tailOffset * nTail)), bLen, bLen, iwork,
                xwork);
        }

        bLen = nTail;
    }

    if (n > bLen) {
        FlightMissionMode_merge_n(idx, x, offset, bLen, static_cast<int32_T>(n -
            bLen), iwork, xwork);
    }
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static void FlightMissionMode_sort_d(emxArray_real_T_FlightMissionMode_T *x)
{
    emxArray_int32_T_FlightMissionMode_T *idx;
    emxArray_int32_T_FlightMissionMode_T *iwork;
    emxArray_real_T_FlightMissionMode_T *b_x;
    emxArray_real_T_FlightMissionMode_T *xwork;
    real_T b_xwork[256];
    real_T x4[4];
    int32_T b_iwork[256];
    int32_T idx4[4];
    int32_T b_iwork_tmp;
    int32_T ib;
    int32_T n;
    int8_T perm[4];
    FlightMissionMode_emxInit_real_T_i(&b_x, 2);
    b_iwork_tmp = static_cast<int32_T>(b_x->size[0] * b_x->size[1]);
    b_x->size[0] = 1;
    b_x->size[1] = x->size[1];
    FlightMissionMode_emxEnsureCapacity_real_T_a(b_x, b_iwork_tmp);
    n = x->size[1];
    for (ib = 0; ib <= static_cast<int32_T>(n - 1); ib++) {
        b_x->data[ib] = x->data[ib];
    }

    if (x->size[1] != 0) {
        int32_T blockOffset;
        int32_T i1;
        int32_T i2;
        int32_T i3;
        int32_T i4;
        int32_T nBlocks;
        int32_T wOffset;
        FlightMissionMode_emxInit_int32_T_j(&idx, 2);
        b_iwork_tmp = static_cast<int32_T>(idx->size[0] * idx->size[1]);
        idx->size[0] = 1;
        idx->size[1] = x->size[1];
        FlightMissionMode_emxEnsureCapacity_int32_T_c(idx, b_iwork_tmp);
        n = x->size[1];
        for (ib = 0; ib <= static_cast<int32_T>(n - 1); ib++) {
            idx->data[ib] = 0;
        }

        b_iwork_tmp = static_cast<int32_T>(b_x->size[0] * b_x->size[1]);
        b_x->size[0] = 1;
        b_x->size[1] = x->size[1];
        FlightMissionMode_emxEnsureCapacity_real_T_a(b_x, b_iwork_tmp);
        n = x->size[1];
        for (ib = 0; ib <= static_cast<int32_T>(n - 1); ib++) {
            b_x->data[ib] = x->data[ib];
        }

        n = static_cast<int32_T>(x->size[1] - 1);
        x4[0] = 0.0;
        idx4[0] = 0;
        x4[1] = 0.0;
        idx4[1] = 0;
        x4[2] = 0.0;
        idx4[2] = 0;
        x4[3] = 0.0;
        idx4[3] = 0;
        FlightMissionMode_emxInit_int32_T_j(&iwork, 1);
        FlightMissionMode_emxInit_real_T_i(&xwork, 1);
        nBlocks = x->size[1];
        b_iwork_tmp = xwork->size[0];
        xwork->size[0] = x->size[1];
        FlightMissionMode_emxEnsureCapacity_real_T_a(xwork, b_iwork_tmp);
        for (ib = 0; ib <= static_cast<int32_T>(nBlocks - 1); ib++) {
            xwork->data[ib] = 0.0;
        }

        nBlocks = 0;
        ib = -1;
        for (wOffset = 0; wOffset <= n; wOffset++) {
            if (std::isnan(b_x->data[wOffset])) {
                i1 = static_cast<int32_T>(n - nBlocks);
                idx->data[i1] = static_cast<int32_T>(wOffset + 1);
                xwork->data[i1] = b_x->data[wOffset];
                nBlocks = static_cast<int32_T>(nBlocks + 1);
            } else {
                ib = static_cast<int32_T>(ib + 1);
                idx4[ib] = static_cast<int32_T>(wOffset + 1);
                x4[ib] = b_x->data[wOffset];
                if (static_cast<int32_T>(ib + 1) == 4) {
                    real_T tmp;
                    real_T tmp_0;
                    ib = static_cast<int32_T>(wOffset - nBlocks);
                    if (x4[0] <= x4[1]) {
                        i1 = 1;
                        i2 = 2;
                    } else {
                        i1 = 2;
                        i2 = 1;
                    }

                    if (x4[2] <= x4[3]) {
                        i3 = 3;
                        i4 = 4;
                    } else {
                        i3 = 4;
                        i4 = 3;
                    }

                    tmp = x4[static_cast<int32_T>(i1 - 1)];
                    tmp_0 = x4[static_cast<int32_T>(i3 - 1)];
                    if (tmp <= tmp_0) {
                        tmp = x4[static_cast<int32_T>(i2 - 1)];
                        if (tmp <= tmp_0) {
                            perm[0] = static_cast<int8_T>(i1);
                            perm[1] = static_cast<int8_T>(i2);
                            perm[2] = static_cast<int8_T>(i3);
                            perm[3] = static_cast<int8_T>(i4);
                        } else if (tmp <= x4[static_cast<int32_T>(i4 - 1)]) {
                            perm[0] = static_cast<int8_T>(i1);
                            perm[1] = static_cast<int8_T>(i3);
                            perm[2] = static_cast<int8_T>(i2);
                            perm[3] = static_cast<int8_T>(i4);
                        } else {
                            perm[0] = static_cast<int8_T>(i1);
                            perm[1] = static_cast<int8_T>(i3);
                            perm[2] = static_cast<int8_T>(i4);
                            perm[3] = static_cast<int8_T>(i2);
                        }
                    } else {
                        tmp_0 = x4[static_cast<int32_T>(i4 - 1)];
                        if (tmp <= tmp_0) {
                            if (x4[static_cast<int32_T>(i2 - 1)] <= tmp_0) {
                                perm[0] = static_cast<int8_T>(i3);
                                perm[1] = static_cast<int8_T>(i1);
                                perm[2] = static_cast<int8_T>(i2);
                                perm[3] = static_cast<int8_T>(i4);
                            } else {
                                perm[0] = static_cast<int8_T>(i3);
                                perm[1] = static_cast<int8_T>(i1);
                                perm[2] = static_cast<int8_T>(i4);
                                perm[3] = static_cast<int8_T>(i2);
                            }
                        } else {
                            perm[0] = static_cast<int8_T>(i3);
                            perm[1] = static_cast<int8_T>(i4);
                            perm[2] = static_cast<int8_T>(i1);
                            perm[3] = static_cast<int8_T>(i2);
                        }
                    }

                    idx->data[static_cast<int32_T>(ib - 3)] = idx4
                        [static_cast<int32_T>(static_cast<int32_T>(perm[0]) - 1)];
                    idx->data[static_cast<int32_T>(ib - 2)] = idx4
                        [static_cast<int32_T>(static_cast<int32_T>(perm[1]) - 1)];
                    idx->data[static_cast<int32_T>(ib - 1)] = idx4
                        [static_cast<int32_T>(static_cast<int32_T>(perm[2]) - 1)];
                    idx->data[ib] = idx4[static_cast<int32_T>
                        (static_cast<int32_T>(perm[3]) - 1)];
                    b_x->data[static_cast<int32_T>(ib - 3)] = x4
                        [static_cast<int32_T>(static_cast<int32_T>(perm[0]) - 1)];
                    b_x->data[static_cast<int32_T>(ib - 2)] = x4
                        [static_cast<int32_T>(static_cast<int32_T>(perm[1]) - 1)];
                    b_x->data[static_cast<int32_T>(ib - 1)] = x4
                        [static_cast<int32_T>(static_cast<int32_T>(perm[2]) - 1)];
                    b_x->data[ib] = x4[static_cast<int32_T>(static_cast<int32_T>
                        (perm[3]) - 1)];
                    ib = -1;
                }
            }
        }

        wOffset = static_cast<int32_T>(x->size[1] - nBlocks);
        if (static_cast<int32_T>(ib + 1) > 0) {
            perm[1] = 0;
            perm[2] = 0;
            perm[3] = 0;
            switch (static_cast<int32_T>(ib + 1)) {
              case 1:
                perm[0] = 1;
                break;

              case 2:
                if (x4[0] <= x4[1]) {
                    perm[0] = 1;
                    perm[1] = 2;
                } else {
                    perm[0] = 2;
                    perm[1] = 1;
                }
                break;

              default:
                if (x4[0] <= x4[1]) {
                    if (x4[1] <= x4[2]) {
                        perm[0] = 1;
                        perm[1] = 2;
                        perm[2] = 3;
                    } else if (x4[0] <= x4[2]) {
                        perm[0] = 1;
                        perm[1] = 3;
                        perm[2] = 2;
                    } else {
                        perm[0] = 3;
                        perm[1] = 1;
                        perm[2] = 2;
                    }
                } else if (x4[0] <= x4[2]) {
                    perm[0] = 2;
                    perm[1] = 1;
                    perm[2] = 3;
                } else if (x4[1] <= x4[2]) {
                    perm[0] = 2;
                    perm[1] = 3;
                    perm[2] = 1;
                } else {
                    perm[0] = 3;
                    perm[1] = 2;
                    perm[2] = 1;
                }
                break;
            }

            i2 = static_cast<int32_T>(static_cast<uint8_T>(static_cast<int32_T>
                (ib + 1)));
            for (i1 = 0; i1 <= static_cast<int32_T>(i2 - 1); i1++) {
                int8_T perm_0;
                perm_0 = perm[i1];
                b_iwork_tmp = static_cast<int32_T>(static_cast<int32_T>(
                    static_cast<int32_T>(wOffset - ib) + i1) - 1);
                idx->data[b_iwork_tmp] = idx4[static_cast<int32_T>
                    (static_cast<int32_T>(perm_0) - 1)];
                b_x->data[b_iwork_tmp] = x4[static_cast<int32_T>
                    (static_cast<int32_T>(perm_0) - 1)];
            }
        }

        i1 = static_cast<int32_T>(nBlocks >> 1);
        for (ib = 0; ib <= static_cast<int32_T>(i1 - 1); ib++) {
            blockOffset = static_cast<int32_T>(wOffset + ib);
            i2 = idx->data[blockOffset];
            b_iwork_tmp = static_cast<int32_T>(n - ib);
            idx->data[blockOffset] = idx->data[b_iwork_tmp];
            idx->data[b_iwork_tmp] = i2;
            i2 = static_cast<int32_T>(wOffset + ib);
            blockOffset = static_cast<int32_T>(n - ib);
            b_x->data[i2] = xwork->data[blockOffset];
            b_x->data[blockOffset] = xwork->data[i2];
        }

        if (static_cast<uint32_T>(static_cast<uint32_T>(nBlocks) & 1U) != 0U) {
            i2 = static_cast<int32_T>(wOffset + i1);
            b_x->data[i2] = xwork->data[i2];
        }

        n = x->size[1];
        b_iwork_tmp = iwork->size[0];
        iwork->size[0] = x->size[1];
        FlightMissionMode_emxEnsureCapacity_int32_T_c(iwork, b_iwork_tmp);
        for (ib = 0; ib <= static_cast<int32_T>(n - 1); ib++) {
            iwork->data[ib] = 0;
        }

        n = static_cast<int32_T>(x->size[1] - nBlocks);
        wOffset = 2;
        if (n > 1) {
            if (x->size[1] >= 256) {
                nBlocks = static_cast<int32_T>(n >> 8);
                if (nBlocks > 0) {
                    for (wOffset = 0; wOffset <= static_cast<int32_T>(nBlocks -
                            1); wOffset++) {
                        i2 = static_cast<int32_T>(static_cast<int32_T>(wOffset <<
                            8) - 1);
                        for (ib = 0; ib < 6; ib++) {
                            int32_T d;
                            i3 = static_cast<int32_T>(1 << static_cast<int32_T>
                                (ib + 2));
                            i4 = static_cast<int32_T>(i3 << 1);
                            d = static_cast<int32_T>(256 >> static_cast<int32_T>
                                (ib + 3));
                            for (i1 = 0; i1 <= static_cast<int32_T>(d - 1); i1++)
                            {
                                int32_T p;
                                int32_T q;
                                blockOffset = static_cast<int32_T>
                                    (static_cast<int32_T>(i1 * i4) + i2);
                                for (p = 0; p <= static_cast<int32_T>(i4 - 1); p
                                        ++) {
                                    b_iwork_tmp = static_cast<int32_T>(
                                        static_cast<int32_T>(blockOffset + p) +
                                        1);
                                    b_iwork[p] = idx->data[b_iwork_tmp];
                                    b_xwork[p] = b_x->data[b_iwork_tmp];
                                }

                                p = 0;
                                q = i3;
                                int32_T exitg1;
                                do {
                                    exitg1 = 0;
                                    blockOffset = static_cast<int32_T>
                                        (blockOffset + 1);
                                    if (b_xwork[p] <= b_xwork[q]) {
                                        idx->data[blockOffset] = b_iwork[p];
                                        b_x->data[blockOffset] = b_xwork[p];
                                        if (static_cast<int32_T>(p + 1) < i3) {
                                            p = static_cast<int32_T>(p + 1);
                                        } else {
                                            exitg1 = 1;
                                        }
                                    } else {
                                        idx->data[blockOffset] = b_iwork[q];
                                        b_x->data[blockOffset] = b_xwork[q];
                                        if (static_cast<int32_T>(q + 1) < i4) {
                                            q = static_cast<int32_T>(q + 1);
                                        } else {
                                            q = static_cast<int32_T>(blockOffset
                                                - p);
                                            for (blockOffset =
                                                    static_cast<int32_T>(p + 1);
                                                 blockOffset <= i3; blockOffset
                                                    ++) {
                                                b_iwork_tmp =
                                                    static_cast<int32_T>(q +
                                                    blockOffset);
                                                idx->data[b_iwork_tmp] =
                                                    b_iwork[static_cast<int32_T>
                                                    (blockOffset - 1)];
                                                b_x->data[b_iwork_tmp] =
                                                    b_xwork[static_cast<int32_T>
                                                    (blockOffset - 1)];
                                            }

                                            exitg1 = 1;
                                        }
                                    }
                                } while (exitg1 == 0);
                            }
                        }
                    }

                    nBlocks = static_cast<int32_T>(nBlocks << 8);
                    wOffset = static_cast<int32_T>(n - nBlocks);
                    if (wOffset > 0) {
                        FlightMissionMode_merge_block_o(idx, b_x, nBlocks,
                            wOffset, 2, iwork, xwork);
                    }

                    wOffset = 8;
                }
            }

            FlightMissionMode_merge_block_o(idx, b_x, 0, n, wOffset, iwork,
                xwork);
        }

        FlightMissionMode_emxFree_real_T_c(&xwork);
        FlightMissionMode_emxFree_int32_T_k(&iwork);
        FlightMissionMode_emxFree_int32_T_k(&idx);
    }

    b_iwork_tmp = static_cast<int32_T>(x->size[0] * x->size[1]);
    x->size[0] = 1;
    x->size[1] = b_x->size[1];
    FlightMissionMode_emxEnsureCapacity_real_T_a(x, b_iwork_tmp);
    n = b_x->size[1];
    for (ib = 0; ib <= static_cast<int32_T>(n - 1); ib++) {
        x->data[ib] = b_x->data[ib];
    }

    FlightMissionMode_emxFree_real_T_c(&b_x);
}

static void FlightMissionMode_emxInit_boolean_T_k
    (emxArray_boolean_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions)
{
    emxArray_boolean_T_FlightMissionMode_T *emxArray;
    *pEmxArray = static_cast<emxArray_boolean_T_FlightMissionMode_T *>(std::
        malloc(sizeof(emxArray_boolean_T_FlightMissionMode_T)));
    emxArray = *pEmxArray;
    emxArray->data = static_cast<boolean_T *>(nullptr);
    emxArray->numDimensions = numDimensions;
    emxArray->size = static_cast<int32_T *>(std::malloc(static_cast<uint32_T>
        (sizeof(int32_T) * static_cast<uint32_T>(numDimensions))));
    emxArray->allocatedSize = 0;
    emxArray->canFreeData = true;
    for (int32_T i{0}; i <= static_cast<int32_T>(numDimensions - 1); i++) {
        emxArray->size[i] = 0;
    }
}

static void FlightMissionMode_emxFree_boolean_T_d
    (emxArray_boolean_T_FlightMissionMode_T **pEmxArray)
{
    if (*pEmxArray != static_cast<emxArray_boolean_T_FlightMissionMode_T *>
            (nullptr)) {
        if (((*pEmxArray)->data != static_cast<boolean_T *>(nullptr)) &&
                (*pEmxArray)->canFreeData) {
            std::free((*pEmxArray)->data);
        }

        std::free((*pEmxArray)->size);
        std::free(*pEmxArray);
        *pEmxArray = static_cast<emxArray_boolean_T_FlightMissionMode_T *>
            (nullptr);
    }
}

static void FlightMissionMode_emxEnsureCapacity_boolean_T_p
    (emxArray_boolean_T_FlightMissionMode_T *emxArray, int32_T oldNumel)
{
    int32_T i;
    int32_T newNumel;
    void *newData;
    if (oldNumel < 0) {
        oldNumel = 0;
    }

    newNumel = 1;
    for (i = 0; i <= static_cast<int32_T>(emxArray->numDimensions - 1); i++) {
        newNumel = static_cast<int32_T>(newNumel * emxArray->size[i]);
    }

    if (newNumel > emxArray->allocatedSize) {
        i = emxArray->allocatedSize;
        if (i < 16) {
            i = 16;
        }

        while (i < newNumel) {
            if (i > 1073741823) {
                i = MAX_int32_T;
            } else {
                i = static_cast<int32_T>(i << 1);
            }
        }

        newData = std::calloc(static_cast<uint32_T>(i), sizeof(boolean_T));
        if (emxArray->data != nullptr) {
            std::memcpy(newData, emxArray->data, static_cast<uint32_T>(sizeof
                         (boolean_T) * static_cast<uint32_T>(oldNumel)));
            if (emxArray->canFreeData) {
                std::free(emxArray->data);
            }
        }

        emxArray->data = static_cast<boolean_T *>(newData);
        emxArray->allocatedSize = i;
        emxArray->canFreeData = true;
    }
}

static void FlightMissionMode_binary_expand_op_h
    (emxArray_boolean_T_FlightMissionMode_T *in1, const
     emxArray_real_T_FlightMissionMode_T *in2, const
     emxArray_real_T_FlightMissionMode_T *in3)
{
    int32_T i;
    int32_T loop_ub;
    int32_T stride_0_0;
    int32_T stride_1_0;
    i = in1->size[0];
    in1->size[0] = in3->size[0] == 1 ? in2->size[0] : in3->size[0];
    FlightMissionMode_emxEnsureCapacity_boolean_T_p(in1, i);
    stride_0_0 = (in2->size[0] != 1);
    stride_1_0 = (in3->size[0] != 1);
    loop_ub = in3->size[0] == 1 ? in2->size[0] : in3->size[0];
    for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
        in1->data[i] = static_cast<boolean_T>(static_cast<int32_T>((in2->data[
            static_cast<int32_T>(i * stride_0_0)] == 0.0) & (in3->data[
            static_cast<int32_T>(i * stride_1_0)] > 0.0)));
    }
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static void FlightMissionMode_wrapToPi_i(emxArray_real_T_FlightMissionMode_T
    *theta)
{
    emxArray_boolean_T_FlightMissionMode_T *x;
    emxArray_real_T_FlightMissionMode_T *y;
    int32_T k;
    int32_T nx;
    boolean_T b_y;
    boolean_T exitg1;
    nx = theta->size[0];
    FlightMissionMode_emxInit_real_T_i(&y, 1);
    k = y->size[0];
    y->size[0] = theta->size[0];
    FlightMissionMode_emxEnsureCapacity_real_T_a(y, k);
    for (k = 0; k <= static_cast<int32_T>(nx - 1); k++) {
        y->data[k] = std::abs(theta->data[k]);
    }

    FlightMissionMode_emxInit_boolean_T_k(&x, 1);
    k = x->size[0];
    x->size[0] = y->size[0];
    FlightMissionMode_emxEnsureCapacity_boolean_T_p(x, k);
    nx = y->size[0];
    for (k = 0; k <= static_cast<int32_T>(nx - 1); k++) {
        x->data[k] = (y->data[k] > 3.1415926535897931);
    }

    b_y = false;
    k = 1;
    exitg1 = false;
    while ((!exitg1) && (k <= x->size[0])) {
        if (x->data[static_cast<int32_T>(k - 1)]) {
            b_y = true;
            exitg1 = true;
        } else {
            k = static_cast<int32_T>(k + 1);
        }
    }

    if (b_y) {
        k = y->size[0];
        y->size[0] = theta->size[0];
        FlightMissionMode_emxEnsureCapacity_real_T_a(y, k);
        nx = theta->size[0];
        for (k = 0; k <= static_cast<int32_T>(nx - 1); k++) {
            y->data[k] = theta->data[k] + 3.1415926535897931;
        }

        k = theta->size[0];
        theta->size[0] = y->size[0];
        FlightMissionMode_emxEnsureCapacity_real_T_a(theta, k);
        nx = y->size[0];
        for (k = 0; k <= static_cast<int32_T>(nx - 1); k++) {
            theta->data[k] = mod_Cteiw4Qy(y->data[k]);
        }

        if (theta->size[0] == y->size[0]) {
            k = x->size[0];
            x->size[0] = theta->size[0];
            FlightMissionMode_emxEnsureCapacity_boolean_T_p(x, k);
            nx = theta->size[0];
            for (k = 0; k <= static_cast<int32_T>(nx - 1); k++) {
                x->data[k] = static_cast<boolean_T>(static_cast<int32_T>
                    ((theta->data[k] == 0.0) & (y->data[k] > 0.0)));
            }
        } else {
            FlightMissionMode_binary_expand_op_h(x, theta, y);
        }

        nx = x->size[0];
        for (k = 0; k <= static_cast<int32_T>(nx - 1); k++) {
            if (x->data[k]) {
                theta->data[k] = 6.2831853071795862;
            }
        }

        nx = theta->size[0];
        for (k = 0; k <= static_cast<int32_T>(nx - 1); k++) {
            theta->data[k] -= 3.1415926535897931;
        }
    }

    FlightMissionMode_emxFree_boolean_T_d(&x);
    FlightMissionMode_emxFree_real_T_c(&y);
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static void FlightMissionMode_eml_find_g(const
    emxArray_boolean_T_FlightMissionMode_T *x,
    emxArray_int32_T_FlightMissionMode_T *i)
{
    int32_T idx;
    int32_T ii;
    int32_T nx;
    boolean_T exitg1;
    nx = x->size[1];
    idx = 0;
    ii = static_cast<int32_T>(i->size[0] * i->size[1]);
    i->size[0] = 1;
    i->size[1] = x->size[1];
    FlightMissionMode_emxEnsureCapacity_int32_T_c(i, ii);
    ii = 0;
    exitg1 = false;
    while ((!exitg1) && (ii <= static_cast<int32_T>(nx - 1))) {
        if (x->data[ii]) {
            idx = static_cast<int32_T>(idx + 1);
            i->data[static_cast<int32_T>(idx - 1)] = static_cast<int32_T>(ii + 1);
            if (idx >= nx) {
                exitg1 = true;
            } else {
                ii = static_cast<int32_T>(ii + 1);
            }
        } else {
            ii = static_cast<int32_T>(ii + 1);
        }
    }

    if (x->size[1] == 1) {
        if (idx == 0) {
            i->size[0] = 1;
            i->size[1] = 0;
        }
    } else if (idx < 1) {
        i->size[1] = 0;
    } else {
        ii = static_cast<int32_T>(i->size[0] * i->size[1]);
        i->size[1] = idx;
        FlightMissionMode_emxEnsureCapacity_int32_T_c(i, ii);
    }
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static boolean_T FlightMissionMode_strcmp_coghzfkn4(const char_T a_data[], const
    int32_T a_size[2])
{
    boolean_T b_bool;
    b_bool = false;
    if ((a_size[1] == 1) && (a_data[0] == 'N')) {
        b_bool = true;
    }

    return b_bool;
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static boolean_T FlightMissionMode_strcmp_coghzfkn4y(const char_T a_data[],
    const int32_T a_size[2])
{
    static const char_T b[2]{ 'H', 'l' };

    boolean_T b_bool;
    b_bool = false;
    if (a_size[1] == 2) {
        int32_T kstr;
        kstr = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (kstr < 2) {
                if (a_data[kstr] != b[kstr]) {
                    exitg1 = 1;
                } else {
                    kstr = static_cast<int32_T>(kstr + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    return b_bool;
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static boolean_T FlightMissionMode_strcmp_coghzfkn4yb(const char_T a_data[],
    const int32_T a_size[2])
{
    static const char_T b[2]{ 'H', 'r' };

    boolean_T b_bool;
    b_bool = false;
    if (a_size[1] == 2) {
        int32_T kstr;
        kstr = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (kstr < 2) {
                if (a_data[kstr] != b[kstr]) {
                    exitg1 = 1;
                } else {
                    kstr = static_cast<int32_T>(kstr + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    return b_bool;
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static boolean_T FlightMissionMode_strcmp_coghzfkn4ybo(const char_T a_data[],
    const int32_T a_size[2])
{
    boolean_T b_bool;
    b_bool = false;
    if ((a_size[1] == 1) && (a_data[0] == 'L')) {
        b_bool = true;
    }

    return b_bool;
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static boolean_T FlightMissionMode_strcmp_coghzfkn4ybo3(const char_T a_data[],
    const int32_T a_size[2])
{
    boolean_T b_bool;
    b_bool = false;
    if ((a_size[1] == 1) && (a_data[0] == 'R')) {
        b_bool = true;
    }

    return b_bool;
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static boolean_T FlightMissionMode_strcmp_coghzfkn4ybo3s(const char_T a_data[],
    const int32_T a_size[2])
{
    boolean_T b_bool;
    b_bool = false;
    if ((a_size[1] == 1) && (a_data[0] == 'S')) {
        b_bool = true;
    }

    return b_bool;
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static void FlightMissionMode_mtimes_p(const emxArray_real_T_FlightMissionMode_T
    *A, const real_T B[4], emxArray_real_T_FlightMissionMode_T *C)
{
    int32_T j;
    int32_T m;
    m = A->size[0];
    j = static_cast<int32_T>(C->size[0] * C->size[1]);
    C->size[0] = A->size[0];
    C->size[1] = 2;
    FlightMissionMode_emxEnsureCapacity_real_T_a(C, j);
    for (j = 0; j < 2; j++) {
        int32_T boffset;
        int32_T coffset;
        coffset = static_cast<int32_T>(j * m);
        boffset = static_cast<int32_T>(j << 1);
        for (int32_T i{0}; i <= static_cast<int32_T>(m - 1); i++) {
            C->data[static_cast<int32_T>(coffset + i)] = A->data
                [static_cast<int32_T>(A->size[0] + i)] * B[static_cast<int32_T>
                (boffset + 1)] + A->data[i] * B[boffset];
        }
    }
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static void FlightMissionMode_uavDubinsPathSegment_interpolate_h(const real_T
    b_this_StartPose[4], const real_T b_this_GoalPose[4], real_T
    b_this_FlightPathAngle, real_T b_this_AirSpeed, real_T
    b_this_MinTurningRadius, real_T b_this_HelixRadius, const
    cell_wrap_11_FlightMissionMode_T b_this_MotionTypes[4], const real_T
    b_this_MotionLengths[4], real_T b_this_Length,
    emxArray_real_T_FlightMissionMode_T *samples,
    emxArray_real_T_FlightMissionMode_T *poses)
{
    emxArray_boolean_T_FlightMissionMode_T *tempSamplesIndex;
    emxArray_boolean_T_FlightMissionMode_T *tempSamplesIndex_0;
    emxArray_int32_T_FlightMissionMode_T *bb;
    emxArray_real_T_FlightMissionMode_T *S;
    emxArray_real_T_FlightMissionMode_T *S_0;
    emxArray_real_T_FlightMissionMode_T *d_x;
    emxArray_real_T_FlightMissionMode_T *ns;
    emxArray_real_T_FlightMissionMode_T *p;
    emxArray_real_T_FlightMissionMode_T *tempSamples;
    emxArray_real_T_FlightMissionMode_T *z;
    real_T state[6];
    real_T TransformMatrix[4];
    real_T tempMotionLength_data[4];
    real_T transLength_data[4];
    int32_T transLength_size[2];
    boolean_T tmp[4];
    poses->size[0] = 0;
    poses->size[1] = 6;
    if ((static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(std::
            isnan(b_this_Length)) ^ 1))) && (samples->size[1] != 0)) {
        real_T b_b_tmp;
        real_T intermediateLength;
        real_T startIndex;
        real_T tempStartPose_idx_2;
        int32_T loop_ub;
        int32_T tempMotionLength_size_idx_1;
        tempStartPose_idx_2 = -b_this_StartPose[2];
        loop_ub = static_cast<int32_T>(poses->size[0] * poses->size[1]);
        poses->size[0] = samples->size[1];
        poses->size[1] = 6;
        FlightMissionMode_emxEnsureCapacity_real_T_a(poses, loop_ub);
        loop_ub = static_cast<int32_T>(samples->size[1] * 6);
        for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                static_cast<int32_T>(loop_ub - 1); transLength_data_tmp++) {
            poses->data[transLength_data_tmp] = 0.0;
        }

        b_b_tmp = std::cos(std::abs(b_this_FlightPathAngle));
        loop_ub = static_cast<int32_T>(samples->size[0] * samples->size[1]);
        samples->size[0] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T_a(samples, loop_ub);
        loop_ub = static_cast<int32_T>(samples->size[1] - 1);
        for (int32_T transLength_data_tmp{0}; transLength_data_tmp <= loop_ub;
                transLength_data_tmp++) {
            samples->data[transLength_data_tmp] *= b_b_tmp;
        }

        TransformMatrix[0] = b_this_MotionLengths[0] * b_b_tmp;
        TransformMatrix[1] = b_this_MotionLengths[1] * b_b_tmp;
        TransformMatrix[2] = b_this_MotionLengths[2] * b_b_tmp;
        tempMotionLength_size_idx_1 = 4;
        tempMotionLength_data[0] = TransformMatrix[0];
        tempMotionLength_data[1] = TransformMatrix[1];
        tempMotionLength_data[2] = TransformMatrix[2];
        tempMotionLength_data[3] = b_this_MotionLengths[3] * b_b_tmp;
        FlightMissionMode_strcmp_coghzfkn(b_this_MotionTypes, tmp);
        if (FlightMissionMode_any_h(tmp)) {
            tempMotionLength_size_idx_1 = 3;
            tempMotionLength_data[0] = TransformMatrix[0];
            tempMotionLength_data[1] = TransformMatrix[1];
            tempMotionLength_data[2] = TransformMatrix[2];
        }

        transLength_size[0] = 1;
        transLength_size[1] = tempMotionLength_size_idx_1;
        for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                static_cast<int32_T>(tempMotionLength_size_idx_1 - 1);
                transLength_data_tmp++) {
            transLength_data[transLength_data_tmp] =
                tempMotionLength_data[transLength_data_tmp];
        }

        FlightMissionMode_useConstantDim_l(transLength_data, transLength_size);
        FlightMissionMode_sort_d(samples);
        intermediateLength = 0.0;
        startIndex = 1.0;
        state[0] = b_this_StartPose[0];
        state[1] = -b_this_StartPose[1];
        state[3] = -b_this_StartPose[3];
        FlightMissionMode_emxInit_boolean_T_k(&tempSamplesIndex, 2);
        FlightMissionMode_emxInit_real_T_i(&tempSamples, 1);
        FlightMissionMode_emxInit_real_T_i(&S, 1);
        FlightMissionMode_emxInit_real_T_i(&ns, 2);
        FlightMissionMode_emxInit_real_T_i(&z, 1);
        FlightMissionMode_emxInit_real_T_i(&p, 2);
        FlightMissionMode_emxInit_real_T_i(&d_x, 1);
        FlightMissionMode_emxInit_int32_T_j(&bb, 2);
        FlightMissionMode_emxInit_boolean_T_k(&tempSamplesIndex_0, 2);
        FlightMissionMode_emxInit_real_T_i(&S_0, 2);
        for (int32_T tempMotionLength_data_tmp{0}; tempMotionLength_data_tmp <=
                static_cast<int32_T>(tempMotionLength_size_idx_1 - 1);
                tempMotionLength_data_tmp++) {
            real_T radius;
            if (static_cast<int32_T>(tempMotionLength_data_tmp + 1) == 1) {
                loop_ub = static_cast<int32_T>(tempSamplesIndex->size[0] *
                    tempSamplesIndex->size[1]);
                tempSamplesIndex->size[0] = 1;
                tempSamplesIndex->size[1] = samples->size[1];
                FlightMissionMode_emxEnsureCapacity_boolean_T_p(tempSamplesIndex,
                    loop_ub);
                radius = (intermediateLength + tempMotionLength_data[0]) +
                    1.0E-6;
                loop_ub = samples->size[1];
                for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                        static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                        ++) {
                    tempSamplesIndex->data[transLength_data_tmp] =
                        static_cast<boolean_T>(static_cast<int32_T>
                        ((samples->data[transLength_data_tmp] >=
                          intermediateLength) & (samples->
                        data[transLength_data_tmp] <= radius)));
                }
            } else {
                loop_ub = static_cast<int32_T>(tempSamplesIndex->size[0] *
                    tempSamplesIndex->size[1]);
                tempSamplesIndex->size[0] = 1;
                tempSamplesIndex->size[1] = samples->size[1];
                FlightMissionMode_emxEnsureCapacity_boolean_T_p(tempSamplesIndex,
                    loop_ub);
                radius = (intermediateLength +
                          tempMotionLength_data[tempMotionLength_data_tmp]) +
                    1.0E-6;
                loop_ub = samples->size[1];
                for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                        static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                        ++) {
                    tempSamplesIndex->data[transLength_data_tmp] =
                        static_cast<boolean_T>(static_cast<int32_T>
                        ((samples->data[transLength_data_tmp] >
                          intermediateLength) & (samples->
                        data[transLength_data_tmp] <= radius)));
                }
            }

            loop_ub = static_cast<int32_T>(tempSamplesIndex_0->size[0] *
                tempSamplesIndex_0->size[1]);
            tempSamplesIndex_0->size[0] = 1;
            tempSamplesIndex_0->size[1] = tempSamplesIndex->size[1];
            FlightMissionMode_emxEnsureCapacity_boolean_T_p(tempSamplesIndex_0,
                loop_ub);
            loop_ub = tempSamplesIndex->size[1];
            for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                    static_cast<int32_T>(loop_ub - 1); transLength_data_tmp++) {
                tempSamplesIndex_0->data[transLength_data_tmp] =
                    tempSamplesIndex->data[transLength_data_tmp];
            }

            FlightMissionMode_eml_find_g(tempSamplesIndex_0, bb);
            if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                    (FlightMissionMode_strcmp_coghzfkn4
                     (b_this_MotionTypes[tempMotionLength_data_tmp].f1.data,
                      b_this_MotionTypes[tempMotionLength_data_tmp].f1.size)) ^
                    1))) {
                real_T TransformMatrix_tmp;
                real_T TransformMatrix_tmp_0;
                int32_T count;
                int32_T tempMotionLength_data_tmp_0;
                radius = b_this_MinTurningRadius;
                if (FlightMissionMode_strcmp_coghzfkn4y
                        (b_this_MotionTypes[tempMotionLength_data_tmp].f1.data,
                         b_this_MotionTypes[tempMotionLength_data_tmp].f1.size))
                {
                    radius = b_this_HelixRadius;
                } else if (FlightMissionMode_strcmp_coghzfkn4yb
                           (b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.data,
                            b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.size)) {
                    radius = b_this_HelixRadius;
                }

                count = 0;
                loop_ub = tempSamples->size[0];
                tempSamples->size[0] = 1;
                FlightMissionMode_emxEnsureCapacity_real_T_a(tempSamples,
                    loop_ub);
                tempSamples->data[0] = 0.0;
                if (bb->size[1] != 0) {
                    loop_ub = tempSamples->size[0];
                    tempSamples->size[0] = static_cast<int32_T>(bb->size[1] + 1);
                    FlightMissionMode_emxEnsureCapacity_real_T_a(tempSamples,
                        loop_ub);
                    loop_ub = bb->size[1];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         loop_ub; transLength_data_tmp++) {
                        tempSamples->data[transLength_data_tmp] = 0.0;
                    }

                    if (static_cast<boolean_T>(static_cast<int32_T>((
                            static_cast<real_T>(static_cast<int32_T>(bb->size[1]
                             + 1)) - 1.0 < 1.0) ^ 1))) {
                        count = bb->size[1];
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(count - 1); transLength_data_tmp++)
                    {
                        tempSamples->data[transLength_data_tmp] = samples->data[
                            static_cast<int32_T>(bb->data[transLength_data_tmp]
                            - 1)];
                    }

                    count = bb->size[1];
                    loop_ub = bb->size[1];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        samples->data[static_cast<int32_T>(bb->
                            data[transLength_data_tmp] - 1)] = -1.0;
                    }
                }

                tempSamples->data[count] =
                    transLength_data[tempMotionLength_data_tmp];
                loop_ub = S->size[0];
                S->size[0] = tempSamples->size[0];
                FlightMissionMode_emxEnsureCapacity_real_T_a(S, loop_ub);
                loop_ub = tempSamples->size[0];
                for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                        static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                        ++) {
                    S->data[transLength_data_tmp] = (tempSamples->
                        data[transLength_data_tmp] - intermediateLength) /
                        radius;
                }

                loop_ub = static_cast<int32_T>(ns->size[0] * ns->size[1]);
                ns->size[0] = S->size[0];
                ns->size[1] = 6;
                FlightMissionMode_emxEnsureCapacity_real_T_a(ns, loop_ub);
                loop_ub = static_cast<int32_T>(S->size[0] * 6);
                for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                        static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                        ++) {
                    ns->data[transLength_data_tmp] = 0.0;
                }

                loop_ub = z->size[0];
                z->size[0] = tempSamples->size[0];
                FlightMissionMode_emxEnsureCapacity_real_T_a(z, loop_ub);
                loop_ub = tempSamples->size[0];
                for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                        static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                        ++) {
                    z->data[transLength_data_tmp] = tempStartPose_idx_2 +
                        tempSamples->data[transLength_data_tmp];
                }

                TransformMatrix_tmp = std::sin(state[3]);
                TransformMatrix_tmp_0 = std::cos(state[3]);
                TransformMatrix[0] = TransformMatrix_tmp_0;
                TransformMatrix[2] = TransformMatrix_tmp;
                TransformMatrix[1] = -TransformMatrix_tmp;
                TransformMatrix[3] = TransformMatrix_tmp_0;
                if (b_this_Length != 0.0) {
                    TransformMatrix_tmp = -b_this_GoalPose[2] -
                        tempStartPose_idx_2;
                    TransformMatrix_tmp_0 = b_this_Length * b_b_tmp;
                    loop_ub = z->size[0];
                    z->size[0] = tempSamples->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T_a(z, loop_ub);
                    loop_ub = tempSamples->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        z->data[transLength_data_tmp] = tempSamples->
                            data[transLength_data_tmp] / TransformMatrix_tmp_0 *
                            TransformMatrix_tmp + tempStartPose_idx_2;
                    }
                }

                if (FlightMissionMode_strcmp_coghzfkn4y
                        (b_this_MotionTypes[tempMotionLength_data_tmp].f1.data,
                         b_this_MotionTypes[tempMotionLength_data_tmp].f1.size) ||
                    FlightMissionMode_strcmp_coghzfkn4ybo
                        (b_this_MotionTypes[tempMotionLength_data_tmp].f1.data,
                         b_this_MotionTypes[tempMotionLength_data_tmp].f1.size))
                {
                    real_T state_0;
                    real_T state_1;
                    loop_ub = tempSamples->size[0];
                    tempSamples->size[0] = S->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T_a(tempSamples,
                        loop_ub);
                    loop_ub = S->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        tempSamples->data[transLength_data_tmp] = S->
                            data[transLength_data_tmp];
                    }

                    count = S->size[0];
                    for (loop_ub = 0; loop_ub <= static_cast<int32_T>(count - 1);
                         loop_ub++) {
                        tempSamples->data[loop_ub] = std::sin(tempSamples->
                            data[loop_ub]);
                    }

                    loop_ub = d_x->size[0];
                    d_x->size[0] = S->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T_a(d_x, loop_ub);
                    loop_ub = S->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        d_x->data[transLength_data_tmp] = S->
                            data[transLength_data_tmp];
                    }

                    count = S->size[0];
                    for (loop_ub = 0; loop_ub <= static_cast<int32_T>(count - 1);
                         loop_ub++) {
                        d_x->data[loop_ub] = std::cos(d_x->data[loop_ub]);
                    }

                    loop_ub = static_cast<int32_T>(S_0->size[0] * S_0->size[1]);
                    S_0->size[0] = tempSamples->size[0];
                    S_0->size[1] = 2;
                    FlightMissionMode_emxEnsureCapacity_real_T_a(S_0, loop_ub);
                    loop_ub = tempSamples->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        S_0->data[transLength_data_tmp] = tempSamples->
                            data[transLength_data_tmp];
                    }

                    loop_ub = d_x->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        S_0->data[static_cast<int32_T>(transLength_data_tmp +
                            tempSamples->size[0])] = 1.0 - d_x->
                            data[transLength_data_tmp];
                    }

                    FlightMissionMode_mtimes_p(S_0, TransformMatrix, p);
                    TransformMatrix_tmp = rt_atan2d_snf(b_this_AirSpeed *
                        b_this_AirSpeed, 9.8 * radius);
                    TransformMatrix_tmp_0 = state[0];
                    state_0 = state[1];
                    state_1 = state[3];
                    count = S->size[0];
                    tempMotionLength_data_tmp_0 = S->size[0];
                    loop_ub = static_cast<int32_T>(ns->size[0] * ns->size[1]);
                    ns->size[0] = p->size[0];
                    ns->size[1] = 6;
                    FlightMissionMode_emxEnsureCapacity_real_T_a(ns, loop_ub);
                    loop_ub = p->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        ns->data[transLength_data_tmp] = p->
                            data[transLength_data_tmp] * radius +
                            TransformMatrix_tmp_0;
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            ns->size[0])] = p->data[static_cast<int32_T>
                            (transLength_data_tmp + p->size[0])] * radius +
                            state_0;
                    }

                    loop_ub = z->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] << 1))] = z->
                            data[transLength_data_tmp];
                    }

                    loop_ub = S->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] * 3))] = state_1 +
                            S->data[transLength_data_tmp];
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(count - 1); transLength_data_tmp++)
                    {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] << 2))] =
                            b_this_FlightPathAngle;
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(tempMotionLength_data_tmp_0 - 1);
                            transLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] * 5))] =
                            -TransformMatrix_tmp;
                    }
                } else if (FlightMissionMode_strcmp_coghzfkn4yb
                           (b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.data,
                            b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.size) || FlightMissionMode_strcmp_coghzfkn4ybo3
                           (b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.data,
                            b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.size)) {
                    real_T state_0;
                    real_T state_1;
                    loop_ub = tempSamples->size[0];
                    tempSamples->size[0] = S->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T_a(tempSamples,
                        loop_ub);
                    loop_ub = S->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        tempSamples->data[transLength_data_tmp] = S->
                            data[transLength_data_tmp];
                    }

                    count = S->size[0];
                    for (loop_ub = 0; loop_ub <= static_cast<int32_T>(count - 1);
                         loop_ub++) {
                        tempSamples->data[loop_ub] = std::sin(tempSamples->
                            data[loop_ub]);
                    }

                    loop_ub = d_x->size[0];
                    d_x->size[0] = S->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T_a(d_x, loop_ub);
                    loop_ub = S->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        d_x->data[transLength_data_tmp] = S->
                            data[transLength_data_tmp];
                    }

                    count = S->size[0];
                    for (loop_ub = 0; loop_ub <= static_cast<int32_T>(count - 1);
                         loop_ub++) {
                        d_x->data[loop_ub] = std::cos(d_x->data[loop_ub]);
                    }

                    loop_ub = static_cast<int32_T>(S_0->size[0] * S_0->size[1]);
                    S_0->size[0] = tempSamples->size[0];
                    S_0->size[1] = 2;
                    FlightMissionMode_emxEnsureCapacity_real_T_a(S_0, loop_ub);
                    loop_ub = tempSamples->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        S_0->data[transLength_data_tmp] = tempSamples->
                            data[transLength_data_tmp];
                    }

                    loop_ub = d_x->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        S_0->data[static_cast<int32_T>(transLength_data_tmp +
                            tempSamples->size[0])] = d_x->
                            data[transLength_data_tmp] - 1.0;
                    }

                    FlightMissionMode_mtimes_p(S_0, TransformMatrix, p);
                    TransformMatrix_tmp = rt_atan2d_snf(b_this_AirSpeed *
                        b_this_AirSpeed, 9.8 * radius);
                    TransformMatrix_tmp_0 = state[0];
                    state_0 = state[1];
                    state_1 = state[3];
                    count = S->size[0];
                    tempMotionLength_data_tmp_0 = S->size[0];
                    loop_ub = static_cast<int32_T>(ns->size[0] * ns->size[1]);
                    ns->size[0] = p->size[0];
                    ns->size[1] = 6;
                    FlightMissionMode_emxEnsureCapacity_real_T_a(ns, loop_ub);
                    loop_ub = p->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        ns->data[transLength_data_tmp] = p->
                            data[transLength_data_tmp] * radius +
                            TransformMatrix_tmp_0;
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            ns->size[0])] = p->data[static_cast<int32_T>
                            (transLength_data_tmp + p->size[0])] * radius +
                            state_0;
                    }

                    loop_ub = z->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] << 1))] = z->
                            data[transLength_data_tmp];
                    }

                    loop_ub = S->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] * 3))] = state_1 -
                            S->data[transLength_data_tmp];
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(count - 1); transLength_data_tmp++)
                    {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] << 2))] =
                            b_this_FlightPathAngle;
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(tempMotionLength_data_tmp_0 - 1);
                            transLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] * 5))] =
                            TransformMatrix_tmp;
                    }
                } else if (FlightMissionMode_strcmp_coghzfkn4ybo3s
                           (b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.data,
                            b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.size)) {
                    real_T state_0;
                    int32_T S_idx_0;
                    count = S->size[0];
                    loop_ub = static_cast<int32_T>(S_0->size[0] * S_0->size[1]);
                    S_0->size[0] = S->size[0];
                    S_0->size[1] = 2;
                    FlightMissionMode_emxEnsureCapacity_real_T_a(S_0, loop_ub);
                    loop_ub = S->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        S_0->data[transLength_data_tmp] = S->
                            data[transLength_data_tmp];
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(count - 1); transLength_data_tmp++)
                    {
                        S_0->data[static_cast<int32_T>(transLength_data_tmp +
                            S->size[0])] = 0.0;
                    }

                    FlightMissionMode_mtimes_p(S_0, TransformMatrix, p);
                    TransformMatrix_tmp_0 = state[0];
                    state_0 = state[1];
                    count = S->size[0];
                    tempMotionLength_data_tmp_0 = S->size[0];
                    S_idx_0 = S->size[0];
                    loop_ub = static_cast<int32_T>(ns->size[0] * ns->size[1]);
                    ns->size[0] = p->size[0];
                    ns->size[1] = 6;
                    FlightMissionMode_emxEnsureCapacity_real_T_a(ns, loop_ub);
                    loop_ub = p->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        ns->data[transLength_data_tmp] = p->
                            data[transLength_data_tmp] * radius +
                            TransformMatrix_tmp_0;
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            ns->size[0])] = p->data[static_cast<int32_T>
                            (transLength_data_tmp + p->size[0])] * radius +
                            state_0;
                    }

                    loop_ub = z->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] << 1))] = z->
                            data[transLength_data_tmp];
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(count - 1); transLength_data_tmp++)
                    {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] * 3))] = state[3];
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(tempMotionLength_data_tmp_0 - 1);
                            transLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] << 2))] =
                            b_this_FlightPathAngle;
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(S_idx_0 - 1); transLength_data_tmp
                            ++) {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] * 5))] = 0.0;
                    }
                }

                if (bb->size[1] != 0) {
                    if (startIndex > (startIndex + static_cast<real_T>(bb->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <
                         6; transLength_data_tmp++) {
                        for (tempMotionLength_data_tmp_0 = 0;
                                tempMotionLength_data_tmp_0 <= loop_ub;
                                tempMotionLength_data_tmp_0++) {
                            poses->data[static_cast<int32_T>(static_cast<int32_T>
                                (static_cast<int32_T>(count +
                                tempMotionLength_data_tmp_0) +
                                 static_cast<int32_T>(poses->size[0] *
                                transLength_data_tmp)) - 1)] = ns->data[
                                static_cast<int32_T>(static_cast<int32_T>
                                (ns->size[0] * transLength_data_tmp) +
                                tempMotionLength_data_tmp_0)];
                        }
                    }

                    if (startIndex > (startIndex + static_cast<real_T>(bb->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         loop_ub; transLength_data_tmp++) {
                        poses->data[static_cast<int32_T>(static_cast<int32_T>
                            (count + transLength_data_tmp) - 1)] = ns->
                            data[transLength_data_tmp];
                    }

                    if (startIndex > (startIndex + static_cast<real_T>(bb->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         loop_ub; transLength_data_tmp++) {
                        poses->data[static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>(count + transLength_data_tmp) +
                            poses->size[0]) - 1)] = -ns->data
                            [static_cast<int32_T>(transLength_data_tmp +
                            ns->size[0])];
                    }

                    if (startIndex > (startIndex + static_cast<real_T>(bb->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         loop_ub; transLength_data_tmp++) {
                        poses->data[static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>(count + transLength_data_tmp) +
                            static_cast<int32_T>(poses->size[0] << 1)) - 1)] =
                            -ns->data[static_cast<int32_T>(static_cast<int32_T>
                            (ns->size[0] << 1) + transLength_data_tmp)];
                    }

                    if (startIndex > (startIndex + static_cast<real_T>(bb->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         loop_ub; transLength_data_tmp++) {
                        poses->data[static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>(count + transLength_data_tmp) +
                            static_cast<int32_T>(poses->size[0] * 3)) - 1)] =
                            -ns->data[static_cast<int32_T>(static_cast<int32_T>
                            (ns->size[0] * 3) + transLength_data_tmp)];
                    }
                }

                count = ns->size[0];
                for (int32_T transLength_data_tmp{0}; transLength_data_tmp < 6;
                        transLength_data_tmp++) {
                    state[transLength_data_tmp] = ns->data[static_cast<int32_T>(
                        static_cast<int32_T>(static_cast<int32_T>(ns->size[0] *
                        transLength_data_tmp) + count) - 1)];
                }

                startIndex += static_cast<real_T>(bb->size[1]);
            }

            intermediateLength +=
                tempMotionLength_data[tempMotionLength_data_tmp];
        }

        FlightMissionMode_emxFree_real_T_c(&S_0);
        FlightMissionMode_emxFree_boolean_T_d(&tempSamplesIndex_0);
        FlightMissionMode_emxFree_int32_T_k(&bb);
        FlightMissionMode_emxFree_real_T_c(&d_x);
        FlightMissionMode_emxFree_real_T_c(&p);
        FlightMissionMode_emxFree_real_T_c(&z);
        FlightMissionMode_emxFree_real_T_c(&ns);
        FlightMissionMode_emxFree_real_T_c(&S);
        FlightMissionMode_emxFree_boolean_T_d(&tempSamplesIndex);
        loop_ub = tempSamples->size[0];
        tempSamples->size[0] = poses->size[0];
        FlightMissionMode_emxEnsureCapacity_real_T_a(tempSamples, loop_ub);
        loop_ub = poses->size[0];
        for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                static_cast<int32_T>(loop_ub - 1); transLength_data_tmp++) {
            tempSamples->data[transLength_data_tmp] = poses->data
                [static_cast<int32_T>(static_cast<int32_T>(poses->size[0] * 3) +
                transLength_data_tmp)];
        }

        FlightMissionMode_wrapToPi_i(tempSamples);
        loop_ub = tempSamples->size[0];
        for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                static_cast<int32_T>(loop_ub - 1); transLength_data_tmp++) {
            poses->data[static_cast<int32_T>(transLength_data_tmp +
                static_cast<int32_T>(poses->size[0] * 3))] = tempSamples->
                data[transLength_data_tmp];
        }

        FlightMissionMode_emxFree_real_T_c(&tempSamples);
    }
}

// Function for MATLAB Function: '<S77>/WayPointGenerator'
static void FlightMissionMode_genSegWP_g(const real_T start[4], const real_T
    ende[4], emxArray_real_T_FlightMissionMode_T *segWayPoints,
    DW_WayPointGenerator_FlightMissionMode_T *localDW)
{
    emxArray_real_T_FlightMissionMode_T *lengths;
    emxArray_real_T_FlightMissionMode_T *poses;
    uavDubinsConnection_FlightMissionMode_g_T *obj;
    uavDubinsPathSegment_FlightMissionMode_c_T pathSegObj;
    real_T a__1;
    int32_T k;
    int32_T n;
    int32_T nm1d2;
    obj = FlightMissionMode_DubinsObjSingleton_getConnector_e(localDW);
    FlightMissionMode_uavDubinsBuiltins_connect_d(obj, start, ende,
        obj->MinTurningRadius, &pathSegObj, &a__1);
    a__1 = std::fmax(2.2204460492503131E-16, pathSegObj.Length / 128.0);
    FlightMissionMode_emxInit_real_T_i(&lengths, 2);
    if (std::isnan(pathSegObj.Length)) {
        k = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        lengths->size[1] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T_a(lengths, k);
        lengths->data[0] = (rtNaN);
    } else if (pathSegObj.Length < 0.0) {
        lengths->size[0] = 1;
        lengths->size[1] = 0;
    } else if (std::isinf(pathSegObj.Length) && std::isinf(a__1)) {
        k = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        lengths->size[1] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T_a(lengths, k);
        lengths->data[0] = (rtNaN);
    } else if (std::isinf(a__1)) {
        k = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        lengths->size[1] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T_a(lengths, k);
        lengths->data[0] = 0.0;
    } else if (std::floor(a__1) == a__1) {
        k = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        nm1d2 = static_cast<int32_T>(pathSegObj.Length / a__1);
        lengths->size[1] = static_cast<int32_T>(nm1d2 + 1);
        FlightMissionMode_emxEnsureCapacity_real_T_a(lengths, k);
        for (k = 0; k <= nm1d2; k++) {
            lengths->data[k] = a__1 * static_cast<real_T>(k);
        }
    } else {
        real_T apnd;
        real_T cdiff;
        real_T ndbl;
        ndbl = std::floor(pathSegObj.Length / a__1 + 0.5);
        apnd = ndbl * a__1;
        cdiff = apnd - pathSegObj.Length;
        if (std::abs(cdiff) < 4.4408920985006262E-16 * std::fmax(0.0, std::abs
                (pathSegObj.Length))) {
            ndbl++;
            apnd = pathSegObj.Length;
        } else if (cdiff > 0.0) {
            apnd = (ndbl - 1.0) * a__1;
        } else {
            ndbl++;
        }

        if (ndbl >= 0.0) {
            n = static_cast<int32_T>(static_cast<int32_T>(ndbl) - 1);
        } else {
            n = -1;
        }

        k = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        lengths->size[1] = static_cast<int32_T>(n + 1);
        FlightMissionMode_emxEnsureCapacity_real_T_a(lengths, k);
        if (static_cast<int32_T>(n + 1) > 0) {
            lengths->data[0] = 0.0;
            if (static_cast<int32_T>(n + 1) > 1) {
                lengths->data[n] = apnd;
                nm1d2 = static_cast<int32_T>(n / 2);
                for (k = 0; k <= static_cast<int32_T>(nm1d2 - 2); k++) {
                    ndbl = (static_cast<real_T>(k) + 1.0) * a__1;
                    lengths->data[static_cast<int32_T>(k + 1)] = ndbl;
                    lengths->data[static_cast<int32_T>(static_cast<int32_T>(n -
                        k) - 1)] = apnd - ndbl;
                }

                if (static_cast<int32_T>(nm1d2 << 1) == n) {
                    lengths->data[nm1d2] = apnd / 2.0;
                } else {
                    ndbl = static_cast<real_T>(nm1d2) * a__1;
                    lengths->data[nm1d2] = ndbl;
                    lengths->data[static_cast<int32_T>(nm1d2 + 1)] = apnd - ndbl;
                }
            }
        }
    }

    FlightMissionMode_emxInit_real_T_i(&poses, 2);
    FlightMissionMode_uavDubinsPathSegment_interpolate_h(pathSegObj.StartPose,
        pathSegObj.GoalPose, pathSegObj.FlightPathAngle, pathSegObj.AirSpeed,
        pathSegObj.MinTurningRadius, pathSegObj.HelixRadius,
        pathSegObj.MotionTypes, pathSegObj.MotionLengths, pathSegObj.Length,
        lengths, poses);
    FlightMissionMode_emxFree_real_T_c(&lengths);
    k = static_cast<int32_T>(segWayPoints->size[0] * segWayPoints->size[1]);
    segWayPoints->size[0] = poses->size[0];
    segWayPoints->size[1] = 3;
    FlightMissionMode_emxEnsureCapacity_real_T_a(segWayPoints, k);
    nm1d2 = poses->size[0];
    for (k = 0; k < 3; k++) {
        for (n = 0; n <= static_cast<int32_T>(nm1d2 - 1); n++) {
            segWayPoints->data[static_cast<int32_T>(n + static_cast<int32_T>
                (segWayPoints->size[0] * k))] = poses->data[static_cast<int32_T>
                (static_cast<int32_T>(poses->size[0] * k) + n)];
        }
    }

    FlightMissionMode_emxFree_real_T_c(&poses);
}

//
// System initialize for atomic system:
//    '<S77>/WayPointGenerator'
//    '<S121>/WayPointGenerator'
//
void FlightMissionMode_WayPointGenerator_Init
    (DW_WayPointGenerator_FlightMissionMode_T *localDW)
{
    FILE* a;
    a = NULL;
    for (int32_T i{0}; i < 20; i++) {
        localDW->eml_openfiles[i] = a;
    }
}

//
// System reset for atomic system:
//    '<S77>/WayPointGenerator'
//    '<S121>/WayPointGenerator'
//
void FlightMissionMode_WayPointGenerator_Reset
    (DW_WayPointGenerator_FlightMissionMode_T *localDW)
{
    FILE* a;
    localDW->SingletonInstance_not_empty = false;
    a = NULL;
    for (int32_T i{0}; i < 20; i++) {
        localDW->eml_openfiles[i] = a;
    }
}

//
// Output and update for atomic system:
//    '<S77>/WayPointGenerator'
//    '<S121>/WayPointGenerator'
//
void FlightMissionMode_WayPointGenerator(real_T rtu_Length, real_T rty_left[384],
    real_T rty_top[384], real_T rty_right[384], real_T rty_bottom[384],
    DW_WayPointGenerator_FlightMissionMode_T *localDW)
{
    emxArray_real_T_FlightMissionMode_T *SegWP;
    real_T LDp[4];
    real_T LUp[4];
    real_T RDp[4];
    real_T RUp[4];
    real_T LDp_tmp;
    real_T outputArg;
    int32_T tmp;

    // MATLAB Function 'WayPointGenerator': '<S111>:1'
    // '<S111>:1:4'
    LUp[0] = rtu_Length / 2.0;
    LUp[1] = 0.0;
    LUp[2] = 0.0;
    LUp[3] = 0.0;

    // '<S111>:1:5'
    LDp_tmp = -rtu_Length / 2.0;
    LDp[0] = LDp_tmp;
    LDp[1] = 0.0;
    LDp[2] = 0.0;
    LDp[3] = 0.0;

    // '<S111>:1:6'
    outputArg = (FlightMissionMode_DubinsObjSingleton_getConnector_e(localDW))
        ->MinTurningRadius;
    RUp[0] = rtu_Length / 2.0;
    RUp[1] = -2.0 * outputArg;
    RUp[2] = 0.0;
    RUp[3] = 3.1415926535897931;

    // '<S111>:1:7'
    outputArg = (FlightMissionMode_DubinsObjSingleton_getConnector_e(localDW))
        ->MinTurningRadius;
    RDp[0] = LDp_tmp;
    RDp[1] = -2.0 * outputArg;
    RDp[2] = 0.0;
    RDp[3] = 3.1415926535897931;

    // '<S111>:1:13'
    FlightMissionMode_emxInit_real_T_i(&SegWP, 2);
    FlightMissionMode_genSegWP_g(LDp, LUp, SegWP, localDW);

    // '<S111>:1:14'
    tmp = 0;
    for (int32_T i_0{0}; i_0 < 3; i_0++) {
        for (int32_T i{0}; i < 128; i++) {
            rty_left[static_cast<int32_T>(i + tmp)] = SegWP->data
                [static_cast<int32_T>(static_cast<int32_T>(SegWP->size[0] * i_0)
                + i)];
        }

        tmp = static_cast<int32_T>(tmp + 128);
    }

    // '<S111>:1:17'
    FlightMissionMode_genSegWP_g(LUp, RUp, SegWP, localDW);

    // '<S111>:1:18'
    tmp = 0;
    for (int32_T i_0{0}; i_0 < 3; i_0++) {
        for (int32_T i{0}; i < 128; i++) {
            rty_top[static_cast<int32_T>(i + tmp)] = SegWP->data
                [static_cast<int32_T>(static_cast<int32_T>(SegWP->size[0] * i_0)
                + i)];
        }

        tmp = static_cast<int32_T>(tmp + 128);
    }

    // '<S111>:1:21'
    FlightMissionMode_genSegWP_g(RUp, RDp, SegWP, localDW);

    // '<S111>:1:22'
    tmp = 0;
    for (int32_T i_0{0}; i_0 < 3; i_0++) {
        for (int32_T i{0}; i < 128; i++) {
            rty_right[static_cast<int32_T>(i + tmp)] = SegWP->data
                [static_cast<int32_T>(static_cast<int32_T>(SegWP->size[0] * i_0)
                + i)];
        }

        tmp = static_cast<int32_T>(tmp + 128);
    }

    // '<S111>:1:25'
    FlightMissionMode_genSegWP_g(RDp, LDp, SegWP, localDW);

    // '<S111>:1:26'
    tmp = 0;
    for (int32_T i_0{0}; i_0 < 3; i_0++) {
        for (int32_T i{0}; i < 128; i++) {
            rty_bottom[static_cast<int32_T>(i + tmp)] = SegWP->data
                [static_cast<int32_T>(static_cast<int32_T>(SegWP->size[0] * i_0)
                + i)];
        }

        tmp = static_cast<int32_T>(tmp + 128);
    }

    FlightMissionMode_emxFree_real_T_c(&SegWP);
}

//
// Output and update for atomic system:
//    '<S77>/biasNEDstartpose'
//    '<S121>/biasNEDstartpose'
//
void FlightMissionMode_biasNEDstartpose(const real_T rtu_MissionNED[3], const
    real_T rtu_IndivRotWP[3], real_T rty_nedWayPoint[3])
{
    // MATLAB Function 'biasNED': '<S112>:1'
    // '<S112>:1:4'
    rty_nedWayPoint[0] = rtu_IndivRotWP[0] + rtu_MissionNED[0];
    rty_nedWayPoint[1] = rtu_IndivRotWP[1] + rtu_MissionNED[1];
    rty_nedWayPoint[2] = rtu_IndivRotWP[2] + rtu_MissionNED[2];
}

static void FlightMissionMode_emxInit_char_T_e
    (emxArray_char_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions)
{
    emxArray_char_T_FlightMissionMode_T *emxArray;
    *pEmxArray = static_cast<emxArray_char_T_FlightMissionMode_T *>(std::malloc
        (sizeof(emxArray_char_T_FlightMissionMode_T)));
    emxArray = *pEmxArray;
    emxArray->data = static_cast<char_T *>(nullptr);
    emxArray->numDimensions = numDimensions;
    emxArray->size = static_cast<int32_T *>(std::malloc(static_cast<uint32_T>
        (sizeof(int32_T) * static_cast<uint32_T>(numDimensions))));
    emxArray->allocatedSize = 0;
    emxArray->canFreeData = true;
    for (int32_T i{0}; i <= static_cast<int32_T>(numDimensions - 1); i++) {
        emxArray->size[i] = 0;
    }
}

// Function for MATLAB Function: '<S163>/ReadHomePoint'
static int8_T FlightMissionMode_filedata_j(DW_ReadHomePoint_FlightMissionMode_T *
    localDW)
{
    int32_T k;
    int8_T f;
    boolean_T exitg1;
    f = 0;
    k = 1;
    exitg1 = false;
    while ((!exitg1) && (static_cast<int32_T>(k - 1) < 20)) {
        if (localDW->eml_openfiles[static_cast<int32_T>(static_cast<int32_T>(
                static_cast<int8_T>(k)) - 1)] == NULL) {
            f = static_cast<int8_T>(k);
            exitg1 = true;
        } else {
            k = static_cast<int32_T>(k + 1);
        }
    }

    return f;
}

// Function for MATLAB Function: '<S163>/ReadHomePoint'
static int8_T FlightMissionMode_cfopen_f(const char_T *cfilename, const char_T
    *cpermission, DW_ReadHomePoint_FlightMissionMode_T *localDW)
{
    int8_T fileid;
    int8_T j;
    fileid = -1;
    j = FlightMissionMode_filedata_j(localDW);
    if (static_cast<int32_T>(j) >= 1) {
        FILE* filestar;
        filestar = fopen(cfilename, cpermission);
        if (filestar != NULL) {
            int32_T tmp;
            localDW->eml_openfiles[static_cast<int32_T>(static_cast<int32_T>(j)
                - 1)] = filestar;
            tmp = static_cast<int32_T>(static_cast<int32_T>(j) + 2);
            if (static_cast<int32_T>(static_cast<int32_T>(j) + 2) > 127) {
                tmp = 127;
            }

            fileid = static_cast<int8_T>(tmp);
        }
    }

    return fileid;
}

static void FlightMissionMode_emxEnsureCapacity_char_T_c
    (emxArray_char_T_FlightMissionMode_T *emxArray, int32_T oldNumel)
{
    int32_T i;
    int32_T newNumel;
    void *newData;
    if (oldNumel < 0) {
        oldNumel = 0;
    }

    newNumel = 1;
    for (i = 0; i <= static_cast<int32_T>(emxArray->numDimensions - 1); i++) {
        newNumel = static_cast<int32_T>(newNumel * emxArray->size[i]);
    }

    if (newNumel > emxArray->allocatedSize) {
        i = emxArray->allocatedSize;
        if (i < 16) {
            i = 16;
        }

        while (i < newNumel) {
            if (i > 1073741823) {
                i = MAX_int32_T;
            } else {
                i = static_cast<int32_T>(i << 1);
            }
        }

        newData = std::calloc(static_cast<uint32_T>(i), sizeof(char_T));
        if (emxArray->data != nullptr) {
            std::memcpy(newData, emxArray->data, static_cast<uint32_T>(sizeof
                         (char_T) * static_cast<uint32_T>(oldNumel)));
            if (emxArray->canFreeData) {
                std::free(emxArray->data);
            }
        }

        emxArray->data = static_cast<char_T *>(newData);
        emxArray->allocatedSize = i;
        emxArray->canFreeData = true;
    }
}

// Function for MATLAB Function: '<S163>/ReadHomePoint'
static void FlightMissionMode_fread_o(real_T fileID,
    emxArray_char_T_FlightMissionMode_T *A, DW_ReadHomePoint_FlightMissionMode_T
    *localDW)
{
    FILE* filestar;
    size_t nBytes;
    char_T tbuf[1024];
    int8_T fileid;
    nBytes = sizeof(char_T);
    fileid = static_cast<int8_T>(fileID);
    if (fileID != static_cast<real_T>(static_cast<int8_T>(fileID))) {
        fileid = -1;
    }

    if (static_cast<int32_T>(fileid) >= 3) {
        filestar = localDW->eml_openfiles[static_cast<int32_T>
            (static_cast<int32_T>(fileid) - 3)];
    } else {
        switch (static_cast<int32_T>(fileid)) {
          case 0:
            filestar = stdin;
            break;

          case 1:
            filestar = stdout;
            break;

          case 2:
            filestar = stderr;
            break;

          default:
            filestar = NULL;
            break;
        }
    }

    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
            static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
              static_cast<boolean_T>(static_cast<int32_T>((fileID != 0.0) ^ 1)))
             | static_cast<int32_T>(static_cast<boolean_T>(static_cast<int32_T>
               ((fileID != 1.0) ^ 1)))))) | static_cast<int32_T>
            (static_cast<boolean_T>(static_cast<int32_T>((fileID != 2.0) ^ 1))))))
    {
        filestar = NULL;
    }

    A->size[0] = 0;
    if (static_cast<boolean_T>(static_cast<int32_T>((filestar == NULL) ^ 1))) {
        int32_T c;
        c = 1;
        while (c > 0) {
            int32_T i;
            int32_T loop_ub;
            int32_T numRead;
            int32_T tmp;
            c = 0;
            numRead = 1;
            while (static_cast<boolean_T>(static_cast<int32_T>((c < 1024) &
                     (numRead > 0)))) {
                size_t numReadSizeT;
                numReadSizeT = fread(&tbuf[c], nBytes, (size_t)(1024 - c),
                                     filestar);
                numRead = (int32_T)numReadSizeT;
                c = static_cast<int32_T>(c + (int32_T)numReadSizeT);
            }

            numRead = A->size[0];
            if (c < 1) {
                i = -1;
                loop_ub = -1;
            } else {
                i = static_cast<int32_T>(c - 1);
                loop_ub = static_cast<int32_T>(c - 1);
            }

            tmp = A->size[0];
            A->size[0] = static_cast<int32_T>(static_cast<int32_T>(i + A->size[0])
                + 1);
            FlightMissionMode_emxEnsureCapacity_char_T_c(A, tmp);
            for (i = 0; i <= loop_ub; i++) {
                A->data[static_cast<int32_T>(numRead + i)] = tbuf[i];
            }
        }
    }
}

// Function for MATLAB Function: '<S163>/ReadHomePoint'
static void FlightMissionMode_copysign_m(emxArray_char_T_FlightMissionMode_T *s1,
    int32_T *idx, const emxArray_char_T_FlightMissionMode_T *s, int32_T *k,
    int32_T n, boolean_T *foundsign, boolean_T *success)
{
    static const boolean_T b[128]{ false, false, false, false, false, false,
        false, false, false, true, true, true, true, true, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, true, true, true, true, true, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false };

    boolean_T exitg1;
    boolean_T isneg;
    isneg = false;
    *foundsign = false;
    exitg1 = false;
    while ((!exitg1) && (*k <= n)) {
        char_T tmp;
        tmp = s->data[static_cast<int32_T>(*k - 1)];
        if (tmp == '-') {
            isneg = static_cast<boolean_T>(static_cast<int32_T>
                (static_cast<int32_T>(isneg) ^ 1));
            *foundsign = true;
            *k = static_cast<int32_T>(*k + 1);
        } else if (tmp == ',') {
            *k = static_cast<int32_T>(*k + 1);
        } else if (tmp == '+') {
            *foundsign = true;
            *k = static_cast<int32_T>(*k + 1);
        } else if (static_cast<boolean_T>(static_cast<int32_T>
                    (static_cast<int32_T>(b[static_cast<int32_T>
                      (static_cast<int32_T>(static_cast<uint8_T>(tmp)) & 127)]) ^
                     1))) {
            exitg1 = true;
        } else {
            *k = static_cast<int32_T>(*k + 1);
        }
    }

    *success = (*k <= n);
    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
            (*success) & static_cast<int32_T>(isneg)))) {
        if ((*idx >= 2) && (s1->data[static_cast<int32_T>(*idx - 2)] == '-')) {
            s1->data[static_cast<int32_T>(*idx - 2)] = ' ';
        } else {
            s1->data[static_cast<int32_T>(*idx - 1)] = '-';
            *idx = static_cast<int32_T>(*idx + 1);
        }
    }
}

// Function for MATLAB Function: '<S163>/ReadHomePoint'
static boolean_T FlightMissionMode_isUnitImag_j(const
    emxArray_char_T_FlightMissionMode_T *s, int32_T k, int32_T n)
{
    boolean_T p;
    p = false;
    if (k <= n) {
        char_T c_idx_0;
        c_idx_0 = s->data[static_cast<int32_T>(k - 1)];
        if (c_idx_0 == 'j') {
            p = true;
        } else if (c_idx_0 == 'i') {
            if (k >= static_cast<int32_T>(n - 1)) {
                p = true;
            } else {
                int32_T b_k;
                char_T c_idx_1;
                char_T c_idx_2;
                b_k = k;
                c_idx_0 = '\x00';
                while ((b_k <= n) && (s->data[static_cast<int32_T>(b_k - 1)] ==
                                      ',')) {
                    b_k = static_cast<int32_T>(b_k + 1);
                }

                if (b_k <= n) {
                    c_idx_0 = s->data[static_cast<int32_T>(b_k - 1)];
                }

                b_k = static_cast<int32_T>(b_k + 1);
                c_idx_1 = '\x00';
                while ((b_k <= n) && (s->data[static_cast<int32_T>(b_k - 1)] ==
                                      ',')) {
                    b_k = static_cast<int32_T>(b_k + 1);
                }

                if (b_k <= n) {
                    c_idx_1 = s->data[static_cast<int32_T>(b_k - 1)];
                }

                b_k = static_cast<int32_T>(b_k + 1);
                c_idx_2 = '\x00';
                while ((b_k <= n) && (s->data[static_cast<int32_T>(b_k - 1)] ==
                                      ',')) {
                    b_k = static_cast<int32_T>(b_k + 1);
                }

                if (b_k <= n) {
                    c_idx_2 = s->data[static_cast<int32_T>(b_k - 1)];
                }

                if (((c_idx_0 == 'I') || (c_idx_0 == 'i')) && ((c_idx_1 == 'N') ||
                     (c_idx_1 == 'n')) && ((c_idx_2 == 'F') || (c_idx_2 == 'f')))
                {
                } else if ((c_idx_0 == 'N') || (c_idx_0 == 'n')) {
                    if ((c_idx_1 == 'A') || (c_idx_1 == 'a')) {
                        if ((c_idx_2 != 'N') && (c_idx_2 != 'n')) {
                            p = true;
                        }
                    } else {
                        p = true;
                    }
                } else {
                    p = true;
                }
            }
        }
    }

    return p;
}

// Function for MATLAB Function: '<S163>/ReadHomePoint'
static void FlightMissionMode_readNonFinite_m(const
    emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n, boolean_T
    *b_finite, real_T *fv)
{
    int32_T ksaved;
    char_T c_idx_0;
    char_T c_idx_1;
    char_T c_idx_2;
    ksaved = *k;
    c_idx_0 = '\x00';
    while ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == ',')) {
        *k = static_cast<int32_T>(*k + 1);
    }

    if (*k <= n) {
        c_idx_0 = s->data[static_cast<int32_T>(*k - 1)];
    }

    *k = static_cast<int32_T>(*k + 1);
    c_idx_1 = '\x00';
    while ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == ',')) {
        *k = static_cast<int32_T>(*k + 1);
    }

    if (*k <= n) {
        c_idx_1 = s->data[static_cast<int32_T>(*k - 1)];
    }

    *k = static_cast<int32_T>(*k + 1);
    c_idx_2 = '\x00';
    while ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == ',')) {
        *k = static_cast<int32_T>(*k + 1);
    }

    if (*k <= n) {
        c_idx_2 = s->data[static_cast<int32_T>(*k - 1)];
    }

    *k = static_cast<int32_T>(*k + 1);
    if (((c_idx_0 == 'I') || (c_idx_0 == 'i')) && ((c_idx_1 == 'N') || (c_idx_1 ==
          'n')) && ((c_idx_2 == 'F') || (c_idx_2 == 'f'))) {
        *b_finite = false;
        *fv = (rtInf);
    } else if (((c_idx_0 == 'N') || (c_idx_0 == 'n')) && ((c_idx_1 == 'A') ||
                (c_idx_1 == 'a')) && ((c_idx_2 == 'N') || (c_idx_2 == 'n'))) {
        *b_finite = false;
        *fv = (rtNaN);
    } else {
        *b_finite = true;
        *fv = 0.0;
        *k = ksaved;
    }
}

// Function for MATLAB Function: '<S163>/ReadHomePoint'
static boolean_T FlightMissionMode_copydigits_e
    (emxArray_char_T_FlightMissionMode_T *s1, int32_T *idx, const
     emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n, boolean_T
     allowpoint)
{
    boolean_T exitg1;
    boolean_T haspoint;
    boolean_T success;
    success = (*k <= n);
    haspoint = false;
    exitg1 = false;
    while ((!exitg1) && (static_cast<boolean_T>(static_cast<int32_T>((*k <= n) &
              static_cast<int32_T>(success))))) {
        char_T tmp;
        tmp = s->data[static_cast<int32_T>(*k - 1)];
        if ((tmp >= '0') && (tmp <= '9')) {
            s1->data[static_cast<int32_T>(*idx - 1)] = tmp;
            *idx = static_cast<int32_T>(*idx + 1);
            *k = static_cast<int32_T>(*k + 1);
        } else if (tmp == '.') {
            success = static_cast<boolean_T>(static_cast<int32_T>
                (static_cast<int32_T>(static_cast<boolean_T>(static_cast<int32_T>
                (static_cast<int32_T>(haspoint) ^ 1))) & static_cast<int32_T>
                 (allowpoint)));
            if (success) {
                s1->data[static_cast<int32_T>(*idx - 1)] = '.';
                *idx = static_cast<int32_T>(*idx + 1);
                haspoint = true;
            }

            *k = static_cast<int32_T>(*k + 1);
        } else if (tmp == ',') {
            *k = static_cast<int32_T>(*k + 1);
        } else {
            exitg1 = true;
        }
    }

    return success;
}

// Function for MATLAB Function: '<S163>/ReadHomePoint'
static boolean_T FlightMissionMode_copyexponent_h
    (emxArray_char_T_FlightMissionMode_T *s1, int32_T *idx, const
     emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n)
{
    int32_T b_k;
    boolean_T success;
    success = true;
    if (*k <= n) {
        char_T tmp;
        tmp = s->data[static_cast<int32_T>(*k - 1)];
        if ((tmp == 'E') || (tmp == 'e')) {
            int32_T kexp;
            boolean_T b_success;
            s1->data[static_cast<int32_T>(*idx - 1)] = 'e';
            *idx = static_cast<int32_T>(*idx + 1);
            *k = static_cast<int32_T>(*k + 1);
            while ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == ','))
            {
                *k = static_cast<int32_T>(*k + 1);
            }

            if (*k <= n) {
                if (s->data[static_cast<int32_T>(*k - 1)] == '-') {
                    s1->data[static_cast<int32_T>(*idx - 1)] = '-';
                    *idx = static_cast<int32_T>(*idx + 1);
                    *k = static_cast<int32_T>(*k + 1);
                } else if (s->data[static_cast<int32_T>(*k - 1)] == '+') {
                    *k = static_cast<int32_T>(*k + 1);
                }
            }

            kexp = *k;
            b_k = *k;
            b_success = FlightMissionMode_copydigits_e(s1, idx, s, &b_k, n,
                false);
            *k = b_k;
            if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                    (static_cast<boolean_T>(static_cast<int32_T>
                    (static_cast<int32_T>(b_success) ^ 1))) | (b_k <= kexp)))) {
                success = false;
            }
        }
    }

    return success;
}

// Function for MATLAB Function: '<S163>/ReadHomePoint'
static void FlightMissionMode_readfloat_n(emxArray_char_T_FlightMissionMode_T
    *s1, int32_T *idx, const emxArray_char_T_FlightMissionMode_T *s, int32_T *k,
    int32_T n, boolean_T *isimag, boolean_T *b_finite, real_T *nfv, boolean_T
    *foundsign, boolean_T *success)
{
    static const boolean_T b[128]{ false, false, false, false, false, false,
        false, false, false, true, true, true, true, true, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, true, true, true, true, true, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false };

    int32_T b_idx;
    int32_T b_k;
    boolean_T a__3;
    *isimag = false;
    *b_finite = true;
    *nfv = 0.0;
    b_idx = *idx;
    b_k = *k;
    FlightMissionMode_copysign_m(s1, &b_idx, s, &b_k, n, foundsign, success);
    *idx = b_idx;
    *k = b_k;
    if (*success) {
        char_T tmp;
        boolean_T exitg1;
        if (FlightMissionMode_isUnitImag_j(s, b_k, n)) {
            *isimag = true;
            *k = static_cast<int32_T>(b_k + 1);
            exitg1 = false;
            while ((!exitg1) && (*k <= n)) {
                tmp = s->data[static_cast<int32_T>(*k - 1)];
                if (b[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(tmp)) & 127)] ||
                    (tmp == '\x00') || (tmp == ',')) {
                    *k = static_cast<int32_T>(*k + 1);
                } else {
                    exitg1 = true;
                }
            }

            if ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == '*')) {
                b_k = static_cast<int32_T>(*k + 1);
                FlightMissionMode_copysign_m(s1, &b_idx, s, &b_k, n, &a__3,
                    success);
                *idx = b_idx;
                if (*success) {
                    if (FlightMissionMode_isUnitImag_j(s, b_k, n)) {
                        *success = false;
                    } else {
                        FlightMissionMode_readNonFinite_m(s, &b_k, n, b_finite,
                            nfv);
                        if (*b_finite) {
                            *success = FlightMissionMode_copydigits_e(s1, idx, s,
                                &b_k, n, true);
                            if (*success) {
                                *success = FlightMissionMode_copyexponent_h(s1,
                                    idx, s, &b_k, n);
                            }
                        } else if ((b_idx >= 2) && (s1->data[static_cast<int32_T>
                                                    (b_idx - 2)] == '-')) {
                            *idx = static_cast<int32_T>(b_idx - 1);
                            s1->data[static_cast<int32_T>(b_idx - 2)] = ' ';
                            *nfv = -*nfv;
                        }

                        exitg1 = false;
                        while ((!exitg1) && (b_k <= n)) {
                            tmp = s->data[static_cast<int32_T>(b_k - 1)];
                            if (b[static_cast<int32_T>(static_cast<int32_T>(
                                    static_cast<uint8_T>(tmp)) & 127)] || (tmp ==
                                 '\x00') || (tmp == ',')) {
                                b_k = static_cast<int32_T>(b_k + 1);
                            } else {
                                exitg1 = true;
                            }
                        }

                        if ((b_k <= n) && (s->data[static_cast<int32_T>(b_k - 1)]
                                           == '*')) {
                            b_k = static_cast<int32_T>(b_k + 1);
                            exitg1 = false;
                            while ((!exitg1) && (b_k <= n)) {
                                tmp = s->data[static_cast<int32_T>(b_k - 1)];
                                if (b[static_cast<int32_T>(static_cast<int32_T>(
                                        static_cast<uint8_T>(tmp)) & 127)] ||
                                        (tmp == '\x00') || (tmp == ',')) {
                                    b_k = static_cast<int32_T>(b_k + 1);
                                } else {
                                    exitg1 = true;
                                }
                            }
                        }

                        if (b_k <= n) {
                            tmp = s->data[static_cast<int32_T>(b_k - 1)];
                            if ((tmp == 'i') || (tmp == 'j')) {
                                b_k = static_cast<int32_T>(b_k + 1);
                            }
                        }
                    }

                    exitg1 = false;
                    while ((!exitg1) && (b_k <= n)) {
                        tmp = s->data[static_cast<int32_T>(b_k - 1)];
                        if (b[static_cast<int32_T>(static_cast<int32_T>(
                                static_cast<uint8_T>(tmp)) & 127)] || (tmp ==
                                '\x00') || (tmp == ',')) {
                            b_k = static_cast<int32_T>(b_k + 1);
                        } else {
                            exitg1 = true;
                        }
                    }
                }

                *k = b_k;
            } else {
                s1->data[static_cast<int32_T>(b_idx - 1)] = '1';
                *idx = static_cast<int32_T>(b_idx + 1);
            }
        } else {
            FlightMissionMode_readNonFinite_m(s, &b_k, n, b_finite, nfv);
            *k = b_k;
            if (*b_finite) {
                *success = FlightMissionMode_copydigits_e(s1, idx, s, k, n, true);
                if (*success) {
                    *success = FlightMissionMode_copyexponent_h(s1, idx, s, k, n);
                }
            } else if ((b_idx >= 2) && (s1->data[static_cast<int32_T>(b_idx - 2)]
                        == '-')) {
                *idx = static_cast<int32_T>(b_idx - 1);
                s1->data[static_cast<int32_T>(b_idx - 2)] = ' ';
                *nfv = -*nfv;
            }

            exitg1 = false;
            while ((!exitg1) && (*k <= n)) {
                if (b[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(s->data[
                        static_cast<int32_T>(*k - 1)])) & 127)]) {
                    *k = static_cast<int32_T>(*k + 1);
                } else {
                    tmp = s->data[static_cast<int32_T>(*k - 1)];
                    if ((tmp == '\x00') || (tmp == ',')) {
                        *k = static_cast<int32_T>(*k + 1);
                    } else {
                        exitg1 = true;
                    }
                }
            }

            if ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == '*')) {
                *k = static_cast<int32_T>(*k + 1);
                while ((*k <= n) && (b[static_cast<int32_T>(static_cast<int32_T>
                         (static_cast<uint8_T>(s->data[static_cast<int32_T>(*k -
                            1)])) & 127)] || (s->data[static_cast<int32_T>(*k -
                          1)] == '\x00') || (s->data[static_cast<int32_T>(*k - 1)]
                         == ','))) {
                    *k = static_cast<int32_T>(*k + 1);
                }
            }

            if (*k <= n) {
                tmp = s->data[static_cast<int32_T>(*k - 1)];
                if ((tmp == 'i') || (tmp == 'j')) {
                    *k = static_cast<int32_T>(*k + 1);
                    *isimag = true;
                }
            }
        }

        exitg1 = false;
        while ((!exitg1) && (*k <= n)) {
            if (b[static_cast<int32_T>(static_cast<int32_T>(static_cast<uint8_T>
                    (s->data[static_cast<int32_T>(*k - 1)])) & 127)]) {
                *k = static_cast<int32_T>(*k + 1);
            } else {
                tmp = s->data[static_cast<int32_T>(*k - 1)];
                if ((tmp == '\x00') || (tmp == ',')) {
                    *k = static_cast<int32_T>(*k + 1);
                } else {
                    exitg1 = true;
                }
            }
        }
    }
}

static void FlightMissionMode_emxFree_char_T_f
    (emxArray_char_T_FlightMissionMode_T **pEmxArray)
{
    if (*pEmxArray != static_cast<emxArray_char_T_FlightMissionMode_T *>(nullptr))
    {
        if (((*pEmxArray)->data != static_cast<char_T *>(nullptr)) &&
                (*pEmxArray)->canFreeData) {
            std::free((*pEmxArray)->data);
        }

        std::free((*pEmxArray)->size);
        std::free(*pEmxArray);
        *pEmxArray = static_cast<emxArray_char_T_FlightMissionMode_T *>(nullptr);
    }
}

// Function for MATLAB Function: '<S163>/ReadHomePoint'
static creal_T FlightMissionMode_str2double_a(const
    emxArray_char_T_FlightMissionMode_T *s)
{
    static const boolean_T c[128]{ false, false, false, false, false, false,
        false, false, false, true, true, true, true, true, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, true, true, true, true, true, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false };

    emxArray_char_T_FlightMissionMode_T *s1;
    creal_T x;
    real_T b_scanned1;
    real_T scanned1;
    real_T scanned2;
    int32_T idx;
    int32_T k;
    boolean_T a__1;
    boolean_T c_success;
    boolean_T foundsign;
    boolean_T isfinite1;
    boolean_T isimag1;
    boolean_T success;
    x.re = (rtNaN);
    x.im = 0.0;
    if (s->size[1] >= 1) {
        int32_T i;
        int32_T ntoread;
        boolean_T exitg1;
        FlightMissionMode_emxInit_char_T_e(&s1, 2);
        ntoread = 0;
        k = 1;
        exitg1 = false;
        while ((!exitg1) && (k <= s->size[1])) {
            char_T tmp;
            tmp = s->data[static_cast<int32_T>(k - 1)];
            if (c[static_cast<int32_T>(static_cast<int32_T>(static_cast<uint8_T>
                    (tmp)) & 127)] || (tmp == '\x00')) {
                k = static_cast<int32_T>(k + 1);
            } else {
                exitg1 = true;
            }
        }

        i = static_cast<int32_T>(s1->size[0] * s1->size[1]);
        s1->size[0] = 1;
        s1->size[1] = static_cast<int32_T>(s->size[1] + 2);
        FlightMissionMode_emxEnsureCapacity_char_T_c(s1, i);
        idx = s->size[1];
        for (i = 0; i <= static_cast<int32_T>(idx + 1); i++) {
            s1->data[i] = '\x00';
        }

        idx = 1;
        FlightMissionMode_readfloat_n(s1, &idx, s, &k, s->size[1], &isimag1,
            &isfinite1, &scanned1, &a__1, &success);
        if (isfinite1) {
            ntoread = 1;
        }

        if (success) {
            if (k <= s->size[1]) {
                s1->data[static_cast<int32_T>(idx - 1)] = ' ';
                idx = static_cast<int32_T>(idx + 1);
                FlightMissionMode_readfloat_n(s1, &idx, s, &k, s->size[1], &a__1,
                    &success, &scanned2, &foundsign, &c_success);
                if (success) {
                    ntoread = static_cast<int32_T>(ntoread + 1);
                }

                success = static_cast<boolean_T>(static_cast<int32_T>(
                    static_cast<int32_T>(static_cast<boolean_T>
                    (static_cast<int32_T>(static_cast<int32_T>
                    (static_cast<boolean_T>(static_cast<int32_T>
                    (static_cast<int32_T>(static_cast<boolean_T>
                    (static_cast<int32_T>(static_cast<int32_T>(isimag1) ^
                    static_cast<int32_T>(a__1)))) & static_cast<int32_T>
                     (foundsign)))) & (k > s->size[1])))) & static_cast<int32_T>
                    (c_success)));
            } else {
                scanned2 = 0.0;
            }
        } else {
            scanned2 = 0.0;
        }

        if (success) {
            s1->data[static_cast<int32_T>(idx - 1)] = '\x00';
            switch (ntoread) {
              case 2:
                ntoread = sscanf(&s1->data[0], "%lf %lf", &scanned1, &scanned2);
                if (ntoread != 2) {
                    scanned1 = (rtNaN);
                    scanned2 = (rtNaN);
                }
                break;

              case 1:
                ntoread = sscanf(&s1->data[0], "%lf", &b_scanned1);
                if (isfinite1) {
                    if (ntoread == 1) {
                        scanned1 = b_scanned1;
                    } else {
                        scanned1 = (rtNaN);
                    }
                } else if (ntoread == 1) {
                    scanned2 = b_scanned1;
                } else {
                    scanned2 = (rtNaN);
                }
                break;
            }

            if (isimag1) {
                x.re = scanned2;
                x.im = scanned1;
            } else {
                x.re = scanned1;
                x.im = scanned2;
            }
        }

        FlightMissionMode_emxFree_char_T_f(&s1);
    }

    return x;
}

// Function for MATLAB Function: '<S163>/ReadHomePoint'
static int32_T FlightMissionMode_cfclose_i(real_T fid,
    DW_ReadHomePoint_FlightMissionMode_T *localDW)
{
    FILE* filestar;
    int32_T st;
    int8_T b_fileid;
    int8_T fileid;
    st = -1;
    fileid = static_cast<int8_T>(fid);
    if (fid != static_cast<real_T>(static_cast<int8_T>(fid))) {
        fileid = -1;
    }

    b_fileid = fileid;
    if (static_cast<int32_T>(fileid) < 0) {
        b_fileid = -1;
    }

    if (static_cast<int32_T>(b_fileid) >= 3) {
        filestar = localDW->eml_openfiles[static_cast<int32_T>
            (static_cast<int32_T>(b_fileid) - 3)];
    } else {
        switch (static_cast<int32_T>(b_fileid)) {
          case 0:
            filestar = stdin;
            break;

          case 1:
            filestar = stdout;
            break;

          case 2:
            filestar = stderr;
            break;

          default:
            filestar = NULL;
            break;
        }
    }

    if (static_cast<boolean_T>(static_cast<int32_T>((filestar != NULL) & (
            static_cast<int32_T>(fileid) >= 3)))) {
        int32_T cst;
        cst = fclose(filestar);
        if (cst == 0) {
            st = 0;
            localDW->eml_openfiles[static_cast<int32_T>(static_cast<int32_T>
                (fileid) - 3)] = NULL;
        }
    }

    return st;
}

// Function for MATLAB Function: '<S163>/ReadHomePoint'
static void FlightMissionMode_strtok_m(const emxArray_char_T_FlightMissionMode_T
    *x, emxArray_char_T_FlightMissionMode_T *token,
    emxArray_char_T_FlightMissionMode_T *remain)
{
    int32_T b;
    int32_T i;
    int32_T itoken;
    int32_T k;
    int32_T n;
    n = x->size[1];
    k = 0;
    while ((static_cast<int32_T>(k + 1) <= n) && (x->data[k] == '\x0a')) {
        k = static_cast<int32_T>(k + 1);
    }

    itoken = static_cast<int32_T>(k + 1);
    while ((static_cast<int32_T>(k + 1) <= n) && (x->data[k] != '\x0a')) {
        k = static_cast<int32_T>(k + 1);
    }

    if (static_cast<int32_T>(k + 1) > x->size[1]) {
        n = 0;
        b = 0;
    } else {
        n = k;
        b = x->size[1];
    }

    i = static_cast<int32_T>(remain->size[0] * remain->size[1]);
    remain->size[0] = 1;
    b = static_cast<int32_T>(b - n);
    remain->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T_c(remain, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        remain->data[i] = x->data[static_cast<int32_T>(n + i)];
    }

    if (itoken > k) {
        itoken = 0;
        k = 0;
    } else {
        itoken = static_cast<int32_T>(itoken - 1);
    }

    i = static_cast<int32_T>(token->size[0] * token->size[1]);
    token->size[0] = 1;
    b = static_cast<int32_T>(k - itoken);
    token->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T_c(token, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        token->data[i] = x->data[static_cast<int32_T>(itoken + i)];
    }
}

// Function for MATLAB Function: '<S163>/ReadHomePoint'
static void FlightMissionMode_strtok_mm(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token)
{
    int32_T itoken;
    int32_T k;
    int32_T n;
    n = x->size[1];
    k = 1;
    while ((k <= n) && (x->data[static_cast<int32_T>(k - 1)] == ';')) {
        k = static_cast<int32_T>(k + 1);
    }

    itoken = k;
    while ((k <= n) && (x->data[static_cast<int32_T>(k - 1)] != ';')) {
        k = static_cast<int32_T>(k + 1);
    }

    if (itoken > static_cast<int32_T>(k - 1)) {
        n = 0;
        k = 0;
    } else {
        n = static_cast<int32_T>(itoken - 1);
        k = static_cast<int32_T>(k - 1);
    }

    itoken = static_cast<int32_T>(token->size[0] * token->size[1]);
    token->size[0] = 1;
    k = static_cast<int32_T>(k - n);
    token->size[1] = k;
    FlightMissionMode_emxEnsureCapacity_char_T_c(token, itoken);
    for (itoken = 0; itoken <= static_cast<int32_T>(k - 1); itoken++) {
        token->data[itoken] = x->data[static_cast<int32_T>(n + itoken)];
    }
}

// Function for MATLAB Function: '<S163>/ReadHomePoint'
static void FlightMissionMode_strtrim_e(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    y)
{
    static const boolean_T d[128]{ false, false, false, false, false, false,
        false, false, false, true, true, true, true, true, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, true, true, true, true, true, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false };

    int32_T b_j1;
    int32_T i;
    int32_T j2;
    b_j1 = 0;
    while ((static_cast<int32_T>(b_j1 + 1) <= x->size[1]) &&
            (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(d[
               static_cast<int32_T>(static_cast<int32_T>(static_cast<uint8_T>
                 (x->data[b_j1])) & 127)]) & (x->data[b_j1] != '\x00'))))) {
        b_j1 = static_cast<int32_T>(b_j1 + 1);
    }

    j2 = static_cast<int32_T>(x->size[1] - 1);
    while ((static_cast<int32_T>(j2 + 1) > 0) && (static_cast<boolean_T>(
             static_cast<int32_T>(static_cast<int32_T>(d[static_cast<int32_T>(
                static_cast<int32_T>(static_cast<uint8_T>(x->data[j2])) & 127)])
              & (x->data[j2] != '\x00'))))) {
        j2 = static_cast<int32_T>(j2 - 1);
    }

    if (static_cast<int32_T>(b_j1 + 1) > static_cast<int32_T>(j2 + 1)) {
        b_j1 = 0;
        j2 = -1;
    }

    i = static_cast<int32_T>(y->size[0] * y->size[1]);
    y->size[0] = 1;
    j2 = static_cast<int32_T>(j2 - b_j1);
    y->size[1] = static_cast<int32_T>(j2 + 1);
    FlightMissionMode_emxEnsureCapacity_char_T_c(y, i);
    for (i = 0; i <= j2; i++) {
        y->data[i] = x->data[static_cast<int32_T>(b_j1 + i)];
    }
}

// Function for MATLAB Function: '<S163>/ReadHomePoint'
static boolean_T FlightMissionMode_strcmp_j(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[9]{ 'H', 'o', 'm', 'e', 'P', 'o', 'i', 'n', 't' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_e(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_c(aTmp, i);
        loop_ub = a->size[1];
        for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 9) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 9) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_f(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S163>/ReadHomePoint'
static boolean_T FlightMissionMode_strcmp_j3(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[3]{ 'L', 'a', 't' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_e(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_c(aTmp, i);
        loop_ub = a->size[1];
        for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 3) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 3) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_f(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S163>/ReadHomePoint'
static boolean_T FlightMissionMode_contains_p(const
    emxArray_char_T_FlightMissionMode_T *str)
{
    int32_T matchPos;
    matchPos = 0;
    int32_T exitg1;
    do {
        exitg1 = 0;
        if (matchPos <= static_cast<int32_T>(str->size[1] - 1)) {
            if (str->data[matchPos] == '=') {
                exitg1 = 1;
            } else {
                matchPos = static_cast<int32_T>(matchPos + 1);
            }
        } else {
            matchPos = -1;
            exitg1 = 1;
        }
    } while (exitg1 == 0);

    return static_cast<int32_T>(matchPos + 1) > 0;
}

// Function for MATLAB Function: '<S163>/ReadHomePoint'
static void FlightMissionMode_find_token_f(const
    emxArray_char_T_FlightMissionMode_T *x, int32_T *itoken, int32_T *iremain)
{
    int32_T n;
    n = x->size[1];
    *iremain = 1;
    while ((*iremain <= n) && (x->data[static_cast<int32_T>(*iremain - 1)] ==
                               '=')) {
        *iremain = static_cast<int32_T>(*iremain + 1);
    }

    *itoken = *iremain;
    while ((*iremain <= n) && (x->data[static_cast<int32_T>(*iremain - 1)] !=
                               '=')) {
        *iremain = static_cast<int32_T>(*iremain + 1);
    }
}

// Function for MATLAB Function: '<S163>/ReadHomePoint'
static void FlightMissionMode_strtok_mmp(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token, emxArray_char_T_FlightMissionMode_T *remain)
{
    int32_T b;
    int32_T c;
    int32_T i;
    int32_T iremain;
    int32_T itoken;
    FlightMissionMode_find_token_f(x, &itoken, &iremain);
    if (iremain > x->size[1]) {
        c = 0;
        b = 0;
    } else {
        c = static_cast<int32_T>(iremain - 1);
        b = x->size[1];
    }

    i = static_cast<int32_T>(remain->size[0] * remain->size[1]);
    remain->size[0] = 1;
    b = static_cast<int32_T>(b - c);
    remain->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T_c(remain, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        remain->data[i] = x->data[static_cast<int32_T>(c + i)];
    }

    if (itoken > static_cast<int32_T>(iremain - 1)) {
        itoken = 0;
        iremain = 0;
    } else {
        itoken = static_cast<int32_T>(itoken - 1);
        iremain = static_cast<int32_T>(iremain - 1);
    }

    i = static_cast<int32_T>(token->size[0] * token->size[1]);
    token->size[0] = 1;
    b = static_cast<int32_T>(iremain - itoken);
    token->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T_c(token, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        token->data[i] = x->data[static_cast<int32_T>(itoken + i)];
    }
}

// Function for MATLAB Function: '<S163>/ReadHomePoint'
static boolean_T FlightMissionMode_strcmp_j3x(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[3]{ 'L', 'o', 'n' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_e(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_c(aTmp, i);
        loop_ub = a->size[1];
        for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 3) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 3) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_f(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S163>/ReadHomePoint'
static boolean_T FlightMissionMode_strcmp_j3xs(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[3]{ 'A', 'l', 't' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_e(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_c(aTmp, i);
        loop_ub = a->size[1];
        for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 3) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 3) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_f(&aTmp);
    return b_bool;
}

//
// System initialize for atomic system:
//    '<S163>/ReadHomePoint'
//    '<S166>/ReadHomePoint'
//
void FlightMissionMode_ReadHomePoint_Init(DW_ReadHomePoint_FlightMissionMode_T
    *localDW)
{
    FILE* a;
    a = NULL;
    for (int32_T i{0}; i < 20; i++) {
        localDW->eml_openfiles[i] = a;
    }
}

//
// System reset for atomic system:
//    '<S163>/ReadHomePoint'
//    '<S166>/ReadHomePoint'
//
void FlightMissionMode_ReadHomePoint_Reset(DW_ReadHomePoint_FlightMissionMode_T *
    localDW)
{
    FILE* a;
    localDW->HomePoint_not_empty = false;
    a = NULL;
    for (int32_T i{0}; i < 20; i++) {
        localDW->eml_openfiles[i] = a;
    }
}

//
// Output and update for atomic system:
//    '<S163>/ReadHomePoint'
//    '<S166>/ReadHomePoint'
//
void FlightMissionMode_ReadHomePoint(real_T rty_LLA0[3],
    DW_ReadHomePoint_FlightMissionMode_T *localDW)
{
    emxArray_char_T_FlightMissionMode_T *curKey;
    emxArray_char_T_FlightMissionMode_T *curLine;
    emxArray_char_T_FlightMissionMode_T *curSection;
    emxArray_char_T_FlightMissionMode_T *curVal;
    emxArray_char_T_FlightMissionMode_T *data;
    emxArray_char_T_FlightMissionMode_T *data_0;
    emxArray_char_T_FlightMissionMode_T *data_1;
    emxArray_char_T_FlightMissionMode_T *data_2;
    emxArray_char_T_FlightMissionMode_T *q;
    emxArray_char_T_FlightMissionMode_T *ret;
    emxArray_char_T_FlightMissionMode_T *tmp_2;
    emxArray_char_T_FlightMissionMode_T *tmp_3;
    emxArray_char_T_FlightMissionMode_T *tmp_4;
    emxArray_char_T_FlightMissionMode_T *x;
    int32_T iremain;
    int32_T itoken;
    boolean_T b_x[3];

    // MATLAB Function 'Mode55_FrmnWayPoint/Mode55_Variant/Mode55/Location2XeHdg/ReadHomePoint': '<S168>:1' 
    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
            (localDW->HomePoint_not_empty) ^ 1))) {
        creal_T tmp;
        creal_T tmp_0;
        creal_T tmp_1;
        int32_T i;
        int32_T loop_ub;
        int8_T fileid;
        boolean_T b_bool;
        boolean_T exitg1;
        boolean_T guard1{ false };

        // '<S168>:1:5'
        // '<S168>:1:6'
        FlightMissionMode_emxInit_char_T_e(&ret, 2);
        ret->size[0] = 1;
        ret->size[1] = 0;
        fileid = FlightMissionMode_cfopen_f("config.ini", "rb", localDW);
        FlightMissionMode_emxInit_char_T_e(&data, 2);
        FlightMissionMode_emxInit_char_T_e(&curSection, 2);
        FlightMissionMode_emxInit_char_T_e(&curKey, 2);
        FlightMissionMode_emxInit_char_T_e(&curVal, 2);
        FlightMissionMode_emxInit_char_T_e(&curLine, 2);
        FlightMissionMode_emxInit_char_T_e(&x, 2);
        FlightMissionMode_emxInit_char_T_e(&q, 1);
        if (static_cast<int32_T>(fileid) < 0) {
            printf("INI-file \"%s\" was not found or could not be read.\n",
                   "config.ini");
            fflush(stdout);
        } else {
            FlightMissionMode_fread_o(static_cast<real_T>(fileid), q, localDW);
            i = static_cast<int32_T>(data->size[0] * data->size[1]);
            data->size[0] = 1;
            data->size[1] = q->size[0];
            FlightMissionMode_emxEnsureCapacity_char_T_c(data, i);
            loop_ub = q->size[0];
            for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
                data->data[i] = q->data[i];
            }

            FlightMissionMode_cfclose_i(static_cast<real_T>(fileid), localDW);
            curSection->size[0] = 1;
            curSection->size[1] = 0;
            curKey->size[0] = 1;
            curKey->size[1] = 0;
            curVal->size[0] = 1;
            curVal->size[1] = 0;
            FlightMissionMode_emxInit_char_T_e(&tmp_4, 2);
            FlightMissionMode_emxInit_char_T_e(&data_2, 2);
            exitg1 = false;
            while ((!exitg1) && (data->size[1] != 0)) {
                i = static_cast<int32_T>(data_2->size[0] * data_2->size[1]);
                data_2->size[0] = 1;
                data_2->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_c(data_2, i);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (i = 0; i <= loop_ub; i++) {
                    data_2->data[i] = data->data[i];
                }

                FlightMissionMode_strtok_m(data_2, curLine, data);
                FlightMissionMode_strtok_mm(curLine, tmp_4);
                FlightMissionMode_strtrim_e(tmp_4, curLine);
                if (curLine->size[1] >= 2) {
                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                iremain = 0;
                                itoken = 0;
                            } else {
                                iremain = 1;
                                itoken = static_cast<int32_T>(curLine->size[1] -
                                    1);
                            }

                            i = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(itoken - iremain);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_c
                                (curSection, i);
                            for (i = 0; i <= static_cast<int32_T>(loop_ub - 1);
                                    i++) {
                                curSection->data[i] = curLine->data[static_cast<
                                    int32_T>(iremain + i)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains_p(curLine)) {
                            FlightMissionMode_strtok_mmp(curLine, curVal, x);
                            FlightMissionMode_find_token_f(x, &itoken, &iremain);
                            if (itoken > static_cast<int32_T>(iremain - 1)) {
                                itoken = 0;
                                iremain = 0;
                            } else {
                                itoken = static_cast<int32_T>(itoken - 1);
                                iremain = static_cast<int32_T>(iremain - 1);
                            }

                            FlightMissionMode_strtrim_e(curVal, curKey);
                            i = static_cast<int32_T>(curLine->size[0] *
                                curLine->size[1]);
                            curLine->size[0] = 1;
                            loop_ub = static_cast<int32_T>(iremain - itoken);
                            curLine->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_c(curLine,
                                i);
                            for (i = 0; i <= static_cast<int32_T>(loop_ub - 1);
                                    i++) {
                                curLine->data[i] = x->data[static_cast<int32_T>
                                    (itoken + i)];
                            }

                            FlightMissionMode_strtrim_e(curLine, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp_j(curSection) &&
                        FlightMissionMode_strcmp_j3(curKey)) {
                    i = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                    ret->size[0] = 1;
                    ret->size[1] = curVal->size[1];
                    FlightMissionMode_emxEnsureCapacity_char_T_c(ret, i);
                    loop_ub = curVal->size[1];
                    for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
                        ret->data[i] = curVal->data[i];
                    }

                    exitg1 = true;
                }
            }

            FlightMissionMode_emxFree_char_T_f(&data_2);
            FlightMissionMode_emxFree_char_T_f(&tmp_4);
        }

        tmp = FlightMissionMode_str2double_a(ret);
        printf("Set Home Point Latitude:\t%f\n", tmp.re);
        fflush(stdout);
        ret->size[0] = 1;
        ret->size[1] = 0;
        fileid = FlightMissionMode_cfopen_f("config.ini", "rb", localDW);
        if (static_cast<int32_T>(fileid) < 0) {
            printf("INI-file \"%s\" was not found or could not be read.\n",
                   "config.ini");
            fflush(stdout);
        } else {
            FlightMissionMode_fread_o(static_cast<real_T>(fileid), q, localDW);
            i = static_cast<int32_T>(data->size[0] * data->size[1]);
            data->size[0] = 1;
            data->size[1] = q->size[0];
            FlightMissionMode_emxEnsureCapacity_char_T_c(data, i);
            loop_ub = q->size[0];
            for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
                data->data[i] = q->data[i];
            }

            FlightMissionMode_cfclose_i(static_cast<real_T>(fileid), localDW);
            curSection->size[0] = 1;
            curSection->size[1] = 0;
            curKey->size[0] = 1;
            curKey->size[1] = 0;
            curVal->size[0] = 1;
            curVal->size[1] = 0;
            FlightMissionMode_emxInit_char_T_e(&tmp_3, 2);
            FlightMissionMode_emxInit_char_T_e(&data_1, 2);
            exitg1 = false;
            while ((!exitg1) && (data->size[1] != 0)) {
                i = static_cast<int32_T>(data_1->size[0] * data_1->size[1]);
                data_1->size[0] = 1;
                data_1->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_c(data_1, i);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (i = 0; i <= loop_ub; i++) {
                    data_1->data[i] = data->data[i];
                }

                FlightMissionMode_strtok_m(data_1, curLine, data);
                FlightMissionMode_strtok_mm(curLine, tmp_3);
                FlightMissionMode_strtrim_e(tmp_3, curLine);
                if (curLine->size[1] >= 2) {
                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                iremain = 0;
                                itoken = 0;
                            } else {
                                iremain = 1;
                                itoken = static_cast<int32_T>(curLine->size[1] -
                                    1);
                            }

                            i = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(itoken - iremain);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_c
                                (curSection, i);
                            for (i = 0; i <= static_cast<int32_T>(loop_ub - 1);
                                    i++) {
                                curSection->data[i] = curLine->data[static_cast<
                                    int32_T>(iremain + i)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains_p(curLine)) {
                            FlightMissionMode_strtok_mmp(curLine, curVal, x);
                            FlightMissionMode_find_token_f(x, &itoken, &iremain);
                            if (itoken > static_cast<int32_T>(iremain - 1)) {
                                itoken = 0;
                                iremain = 0;
                            } else {
                                itoken = static_cast<int32_T>(itoken - 1);
                                iremain = static_cast<int32_T>(iremain - 1);
                            }

                            FlightMissionMode_strtrim_e(curVal, curKey);
                            i = static_cast<int32_T>(curLine->size[0] *
                                curLine->size[1]);
                            curLine->size[0] = 1;
                            loop_ub = static_cast<int32_T>(iremain - itoken);
                            curLine->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_c(curLine,
                                i);
                            for (i = 0; i <= static_cast<int32_T>(loop_ub - 1);
                                    i++) {
                                curLine->data[i] = x->data[static_cast<int32_T>
                                    (itoken + i)];
                            }

                            FlightMissionMode_strtrim_e(curLine, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp_j(curSection) &&
                        FlightMissionMode_strcmp_j3x(curKey)) {
                    i = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                    ret->size[0] = 1;
                    ret->size[1] = curVal->size[1];
                    FlightMissionMode_emxEnsureCapacity_char_T_c(ret, i);
                    loop_ub = curVal->size[1];
                    for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
                        ret->data[i] = curVal->data[i];
                    }

                    exitg1 = true;
                }
            }

            FlightMissionMode_emxFree_char_T_f(&data_1);
            FlightMissionMode_emxFree_char_T_f(&tmp_3);
        }

        tmp_0 = FlightMissionMode_str2double_a(ret);
        printf("Set Home Point Longitude:\t%f\n", tmp_0.re);
        fflush(stdout);
        ret->size[0] = 1;
        ret->size[1] = 0;
        fileid = FlightMissionMode_cfopen_f("config.ini", "rb", localDW);
        if (static_cast<int32_T>(fileid) < 0) {
            printf("INI-file \"%s\" was not found or could not be read.\n",
                   "config.ini");
            fflush(stdout);
        } else {
            FlightMissionMode_fread_o(static_cast<real_T>(fileid), q, localDW);
            i = static_cast<int32_T>(data->size[0] * data->size[1]);
            data->size[0] = 1;
            data->size[1] = q->size[0];
            FlightMissionMode_emxEnsureCapacity_char_T_c(data, i);
            loop_ub = q->size[0];
            for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
                data->data[i] = q->data[i];
            }

            FlightMissionMode_cfclose_i(static_cast<real_T>(fileid), localDW);
            curSection->size[0] = 1;
            curSection->size[1] = 0;
            curKey->size[0] = 1;
            curKey->size[1] = 0;
            curVal->size[0] = 1;
            curVal->size[1] = 0;
            FlightMissionMode_emxInit_char_T_e(&tmp_2, 2);
            FlightMissionMode_emxInit_char_T_e(&data_0, 2);
            exitg1 = false;
            while ((!exitg1) && (data->size[1] != 0)) {
                i = static_cast<int32_T>(data_0->size[0] * data_0->size[1]);
                data_0->size[0] = 1;
                data_0->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_c(data_0, i);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (i = 0; i <= loop_ub; i++) {
                    data_0->data[i] = data->data[i];
                }

                FlightMissionMode_strtok_m(data_0, curLine, data);
                FlightMissionMode_strtok_mm(curLine, tmp_2);
                FlightMissionMode_strtrim_e(tmp_2, curLine);
                if (curLine->size[1] >= 2) {
                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                iremain = 0;
                                itoken = 0;
                            } else {
                                iremain = 1;
                                itoken = static_cast<int32_T>(curLine->size[1] -
                                    1);
                            }

                            i = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(itoken - iremain);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_c
                                (curSection, i);
                            for (i = 0; i <= static_cast<int32_T>(loop_ub - 1);
                                    i++) {
                                curSection->data[i] = curLine->data[static_cast<
                                    int32_T>(iremain + i)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains_p(curLine)) {
                            FlightMissionMode_strtok_mmp(curLine, curVal, x);
                            FlightMissionMode_find_token_f(x, &itoken, &iremain);
                            if (itoken > static_cast<int32_T>(iremain - 1)) {
                                itoken = 0;
                                iremain = 0;
                            } else {
                                itoken = static_cast<int32_T>(itoken - 1);
                                iremain = static_cast<int32_T>(iremain - 1);
                            }

                            FlightMissionMode_strtrim_e(curVal, curKey);
                            i = static_cast<int32_T>(curLine->size[0] *
                                curLine->size[1]);
                            curLine->size[0] = 1;
                            loop_ub = static_cast<int32_T>(iremain - itoken);
                            curLine->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_c(curLine,
                                i);
                            for (i = 0; i <= static_cast<int32_T>(loop_ub - 1);
                                    i++) {
                                curLine->data[i] = x->data[static_cast<int32_T>
                                    (itoken + i)];
                            }

                            FlightMissionMode_strtrim_e(curLine, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp_j(curSection) &&
                        FlightMissionMode_strcmp_j3xs(curKey)) {
                    i = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                    ret->size[0] = 1;
                    ret->size[1] = curVal->size[1];
                    FlightMissionMode_emxEnsureCapacity_char_T_c(ret, i);
                    loop_ub = curVal->size[1];
                    for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
                        ret->data[i] = curVal->data[i];
                    }

                    exitg1 = true;
                }
            }

            FlightMissionMode_emxFree_char_T_f(&data_0);
            FlightMissionMode_emxFree_char_T_f(&tmp_2);
        }

        FlightMissionMode_emxFree_char_T_f(&q);
        FlightMissionMode_emxFree_char_T_f(&x);
        FlightMissionMode_emxFree_char_T_f(&curLine);
        FlightMissionMode_emxFree_char_T_f(&curVal);
        FlightMissionMode_emxFree_char_T_f(&curKey);
        FlightMissionMode_emxFree_char_T_f(&curSection);
        FlightMissionMode_emxFree_char_T_f(&data);
        tmp_1 = FlightMissionMode_str2double_a(ret);
        FlightMissionMode_emxFree_char_T_f(&ret);
        printf("Set Home Point Altitude:\t%f\n", tmp_1.re);
        fflush(stdout);
        localDW->HomePoint[0] = tmp.re;
        localDW->HomePoint[1] = tmp_0.re;
        localDW->HomePoint[2] = tmp_1.re;
        localDW->HomePoint_not_empty = true;
        b_x[0] = std::isnan(localDW->HomePoint[0]);
        b_x[1] = std::isnan(localDW->HomePoint[1]);
        b_x[2] = std::isnan(localDW->HomePoint[2]);
        b_bool = false;
        iremain = 0;
        exitg1 = false;
        while ((!exitg1) && (iremain < 3)) {
            if (b_x[iremain]) {
                b_bool = true;
                exitg1 = true;
            } else {
                iremain = static_cast<int32_T>(iremain + 1);
            }
        }

        if (b_bool) {
            // '<S168>:1:7'
            // '<S168>:1:8'
            localDW->HomePoint[0] = 35.8617;
            localDW->HomePoint[1] = 104.1954;
            localDW->HomePoint[2] = 0.0;
        }
    }

    // '<S168>:1:12'
    rty_LLA0[0] = localDW->HomePoint[0];
    rty_LLA0[1] = localDW->HomePoint[1];
    rty_LLA0[2] = localDW->HomePoint[2];
}

static void FlightMissionMode_emxInit_char_T_ey
    (emxArray_char_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions)
{
    emxArray_char_T_FlightMissionMode_T *emxArray;
    *pEmxArray = static_cast<emxArray_char_T_FlightMissionMode_T *>(std::malloc
        (sizeof(emxArray_char_T_FlightMissionMode_T)));
    emxArray = *pEmxArray;
    emxArray->data = static_cast<char_T *>(nullptr);
    emxArray->numDimensions = numDimensions;
    emxArray->size = static_cast<int32_T *>(std::malloc(static_cast<uint32_T>
        (sizeof(int32_T) * static_cast<uint32_T>(numDimensions))));
    emxArray->allocatedSize = 0;
    emxArray->canFreeData = true;
    for (int32_T i{0}; i <= static_cast<int32_T>(numDimensions - 1); i++) {
        emxArray->size[i] = 0;
    }
}

static void FlightMissionMode_emxInit_real_T_h
    (emxArray_real_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions)
{
    emxArray_real_T_FlightMissionMode_T *emxArray;
    *pEmxArray = static_cast<emxArray_real_T_FlightMissionMode_T *>(std::malloc
        (sizeof(emxArray_real_T_FlightMissionMode_T)));
    emxArray = *pEmxArray;
    emxArray->data = static_cast<real_T *>(nullptr);
    emxArray->numDimensions = numDimensions;
    emxArray->size = static_cast<int32_T *>(std::malloc(static_cast<uint32_T>
        (sizeof(int32_T) * static_cast<uint32_T>(numDimensions))));
    emxArray->allocatedSize = 0;
    emxArray->canFreeData = true;
    for (int32_T i{0}; i <= static_cast<int32_T>(numDimensions - 1); i++) {
        emxArray->size[i] = 0;
    }
}

static void FlightMissionMode_emxFree_real_T_n
    (emxArray_real_T_FlightMissionMode_T **pEmxArray)
{
    if (*pEmxArray != static_cast<emxArray_real_T_FlightMissionMode_T *>(nullptr))
    {
        if (((*pEmxArray)->data != static_cast<real_T *>(nullptr)) &&
                (*pEmxArray)->canFreeData) {
            std::free((*pEmxArray)->data);
        }

        std::free((*pEmxArray)->size);
        std::free(*pEmxArray);
        *pEmxArray = static_cast<emxArray_real_T_FlightMissionMode_T *>(nullptr);
    }
}

static void FlightMissionMode_emxFree_char_T_o
    (emxArray_char_T_FlightMissionMode_T **pEmxArray)
{
    if (*pEmxArray != static_cast<emxArray_char_T_FlightMissionMode_T *>(nullptr))
    {
        if (((*pEmxArray)->data != static_cast<char_T *>(nullptr)) &&
                (*pEmxArray)->canFreeData) {
            std::free((*pEmxArray)->data);
        }

        std::free((*pEmxArray)->size);
        std::free(*pEmxArray);
        *pEmxArray = static_cast<emxArray_char_T_FlightMissionMode_T *>(nullptr);
    }
}

// Function for MATLAB Function: '<S10>/ReadHomePoint'
static int8_T FlightMissionMode_filedata_o(DW_FlightMissionMode_f_T *localDW)
{
    int32_T k;
    int8_T f;
    boolean_T exitg1;
    f = 0;
    k = 1;
    exitg1 = false;
    while ((!exitg1) && (static_cast<int32_T>(k - 1) < 20)) {
        if (localDW->eml_openfiles[static_cast<int32_T>(static_cast<int32_T>(
                static_cast<int8_T>(k)) - 1)] == NULL) {
            f = static_cast<int8_T>(k);
            exitg1 = true;
        } else {
            k = static_cast<int32_T>(k + 1);
        }
    }

    return f;
}

// Function for MATLAB Function: '<S10>/ReadHomePoint'
static int8_T FlightMissionMode_cfopen_e(const char_T *cfilename, const char_T
    *cpermission, DW_FlightMissionMode_f_T *localDW)
{
    int8_T fileid;
    int8_T j;
    fileid = -1;
    j = FlightMissionMode_filedata_o(localDW);
    if (static_cast<int32_T>(j) >= 1) {
        FILE* filestar;
        filestar = fopen(cfilename, cpermission);
        if (filestar != NULL) {
            int32_T tmp;
            localDW->eml_openfiles[static_cast<int32_T>(static_cast<int32_T>(j)
                - 1)] = filestar;
            tmp = static_cast<int32_T>(static_cast<int32_T>(j) + 2);
            if (static_cast<int32_T>(static_cast<int32_T>(j) + 2) > 127) {
                tmp = 127;
            }

            fileid = static_cast<int8_T>(tmp);
        }
    }

    return fileid;
}

// Function for MATLAB Function: '<S75>/ReadHomePoint'
static int8_T FlightMissionMode_filedata_m(DW_FlightMissionMode_f_T *localDW)
{
    int32_T k;
    int8_T f;
    boolean_T exitg1;
    f = 0;
    k = 1;
    exitg1 = false;
    while ((!exitg1) && (static_cast<int32_T>(k - 1) < 20)) {
        if (localDW->eml_openfiles_d[static_cast<int32_T>(static_cast<int32_T>(
                static_cast<int8_T>(k)) - 1)] == NULL) {
            f = static_cast<int8_T>(k);
            exitg1 = true;
        } else {
            k = static_cast<int32_T>(k + 1);
        }
    }

    return f;
}

// Function for MATLAB Function: '<S75>/ReadHomePoint'
static int8_T FlightMissionMode_cfopen_d(const char_T *cfilename, const char_T
    *cpermission, DW_FlightMissionMode_f_T *localDW)
{
    int8_T fileid;
    int8_T j;
    fileid = -1;
    j = FlightMissionMode_filedata_m(localDW);
    if (static_cast<int32_T>(j) >= 1) {
        FILE* filestar;
        filestar = fopen(cfilename, cpermission);
        if (filestar != NULL) {
            int32_T tmp;
            localDW->eml_openfiles_d[static_cast<int32_T>(static_cast<int32_T>(j)
                - 1)] = filestar;
            tmp = static_cast<int32_T>(static_cast<int32_T>(j) + 2);
            if (static_cast<int32_T>(static_cast<int32_T>(j) + 2) > 127) {
                tmp = 127;
            }

            fileid = static_cast<int8_T>(tmp);
        }
    }

    return fileid;
}

// Function for MATLAB Function: '<S118>/ReadHomePoint'
static int8_T FlightMissionMode_filedata_d(DW_FlightMissionMode_f_T *localDW)
{
    int32_T k;
    int8_T f;
    boolean_T exitg1;
    f = 0;
    k = 1;
    exitg1 = false;
    while ((!exitg1) && (static_cast<int32_T>(k - 1) < 20)) {
        if (localDW->eml_openfiles_bx[static_cast<int32_T>(static_cast<int32_T>(
                static_cast<int8_T>(k)) - 1)] == NULL) {
            f = static_cast<int8_T>(k);
            exitg1 = true;
        } else {
            k = static_cast<int32_T>(k + 1);
        }
    }

    return f;
}

// Function for MATLAB Function: '<S118>/ReadHomePoint'
static int8_T FlightMissionMode_cfopen_du(const char_T *cfilename, const char_T *
    cpermission, DW_FlightMissionMode_f_T *localDW)
{
    int8_T fileid;
    int8_T j;
    fileid = -1;
    j = FlightMissionMode_filedata_d(localDW);
    if (static_cast<int32_T>(j) >= 1) {
        FILE* filestar;
        filestar = fopen(cfilename, cpermission);
        if (filestar != NULL) {
            int32_T tmp;
            localDW->eml_openfiles_bx[static_cast<int32_T>(static_cast<int32_T>
                (j) - 1)] = filestar;
            tmp = static_cast<int32_T>(static_cast<int32_T>(j) + 2);
            if (static_cast<int32_T>(static_cast<int32_T>(j) + 2) > 127) {
                tmp = 127;
            }

            fileid = static_cast<int8_T>(tmp);
        }
    }

    return fileid;
}

// Function for MATLAB Function: '<S166>/WayPointGenerator'
static void FlightMissionMode_string_string(real_T val, char_T obj_Value_data[],
    int32_T obj_Value_size[2])
{
    int32_T str_size_idx_1;
    char_T st[24];
    char_T str_data[23];
    if (val == 0.0) {
        str_size_idx_1 = 1;
        str_data[0] = '0';
    } else if (std::isinf(val)) {
        if (val > 0.0) {
            str_size_idx_1 = 3;
            str_data[0] = 'I';
            str_data[1] = 'n';
            str_data[2] = 'f';
        } else {
            str_size_idx_1 = 4;
            str_data[0] = '-';
            str_data[1] = 'I';
            str_data[2] = 'n';
            str_data[3] = 'f';
        }
    } else if (std::isnan(val)) {
        str_size_idx_1 = 3;
        str_data[0] = 'N';
        str_data[1] = 'a';
        str_data[2] = 'N';
    } else {
        int32_T resCount;
        resCount = sprintf(&st[0], "%.16g", val);
        str_size_idx_1 = resCount;
        resCount = static_cast<int32_T>(static_cast<uint8_T>(resCount));
        for (int32_T k{0}; k <= static_cast<int32_T>(resCount - 1); k++) {
            str_data[k] = st[k];
        }
    }

    obj_Value_size[0] = 1;
    obj_Value_size[1] = str_size_idx_1;
    for (int32_T k{0}; k <= static_cast<int32_T>(str_size_idx_1 - 1); k++) {
        obj_Value_data[k] = str_data[k];
    }
}

static void FlightMissionMode_emxEnsureCapacity_char_T_g
    (emxArray_char_T_FlightMissionMode_T *emxArray, int32_T oldNumel)
{
    int32_T i;
    int32_T newNumel;
    void *newData;
    if (oldNumel < 0) {
        oldNumel = 0;
    }

    newNumel = 1;
    for (i = 0; i <= static_cast<int32_T>(emxArray->numDimensions - 1); i++) {
        newNumel = static_cast<int32_T>(newNumel * emxArray->size[i]);
    }

    if (newNumel > emxArray->allocatedSize) {
        i = emxArray->allocatedSize;
        if (i < 16) {
            i = 16;
        }

        while (i < newNumel) {
            if (i > 1073741823) {
                i = MAX_int32_T;
            } else {
                i = static_cast<int32_T>(i << 1);
            }
        }

        newData = std::calloc(static_cast<uint32_T>(i), sizeof(char_T));
        if (emxArray->data != nullptr) {
            std::memcpy(newData, emxArray->data, static_cast<uint32_T>(sizeof
                         (char_T) * static_cast<uint32_T>(oldNumel)));
            if (emxArray->canFreeData) {
                std::free(emxArray->data);
            }
        }

        emxArray->data = static_cast<char_T *>(newData);
        emxArray->allocatedSize = i;
        emxArray->canFreeData = true;
    }
}

// Function for MATLAB Function: '<S10>/ReadHomePoint'
static void FlightMissionMode_fread_h(real_T fileID,
    emxArray_char_T_FlightMissionMode_T *A, DW_FlightMissionMode_f_T *localDW)
{
    FILE* filestar;
    size_t nBytes;
    char_T tbuf[1024];
    int8_T fileid;
    nBytes = sizeof(char_T);
    fileid = static_cast<int8_T>(fileID);
    if (fileID != static_cast<real_T>(static_cast<int8_T>(fileID))) {
        fileid = -1;
    }

    if (static_cast<int32_T>(fileid) >= 3) {
        filestar = localDW->eml_openfiles[static_cast<int32_T>
            (static_cast<int32_T>(fileid) - 3)];
    } else {
        switch (static_cast<int32_T>(fileid)) {
          case 0:
            filestar = stdin;
            break;

          case 1:
            filestar = stdout;
            break;

          case 2:
            filestar = stderr;
            break;

          default:
            filestar = NULL;
            break;
        }
    }

    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
            static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
              static_cast<boolean_T>(static_cast<int32_T>((fileID != 0.0) ^ 1)))
             | static_cast<int32_T>(static_cast<boolean_T>(static_cast<int32_T>
               ((fileID != 1.0) ^ 1)))))) | static_cast<int32_T>
            (static_cast<boolean_T>(static_cast<int32_T>((fileID != 2.0) ^ 1))))))
    {
        filestar = NULL;
    }

    A->size[0] = 0;
    if (static_cast<boolean_T>(static_cast<int32_T>((filestar == NULL) ^ 1))) {
        int32_T c;
        c = 1;
        while (c > 0) {
            int32_T i;
            int32_T loop_ub;
            int32_T numRead;
            int32_T tmp;
            c = 0;
            numRead = 1;
            while (static_cast<boolean_T>(static_cast<int32_T>((c < 1024) &
                     (numRead > 0)))) {
                size_t numReadSizeT;
                numReadSizeT = fread(&tbuf[c], nBytes, (size_t)(1024 - c),
                                     filestar);
                numRead = (int32_T)numReadSizeT;
                c = static_cast<int32_T>(c + (int32_T)numReadSizeT);
            }

            numRead = A->size[0];
            if (c < 1) {
                i = -1;
                loop_ub = -1;
            } else {
                i = static_cast<int32_T>(c - 1);
                loop_ub = static_cast<int32_T>(c - 1);
            }

            tmp = A->size[0];
            A->size[0] = static_cast<int32_T>(static_cast<int32_T>(i + A->size[0])
                + 1);
            FlightMissionMode_emxEnsureCapacity_char_T_g(A, tmp);
            for (i = 0; i <= loop_ub; i++) {
                A->data[static_cast<int32_T>(numRead + i)] = tbuf[i];
            }
        }
    }
}

// Function for MATLAB Function: '<S75>/ReadHomePoint'
static void FlightMissionMode_fread_ow(real_T fileID,
    emxArray_char_T_FlightMissionMode_T *A, DW_FlightMissionMode_f_T *localDW)
{
    FILE* filestar;
    size_t nBytes;
    char_T tbuf[1024];
    int8_T fileid;
    nBytes = sizeof(char_T);
    fileid = static_cast<int8_T>(fileID);
    if (fileID != static_cast<real_T>(static_cast<int8_T>(fileID))) {
        fileid = -1;
    }

    if (static_cast<int32_T>(fileid) >= 3) {
        filestar = localDW->eml_openfiles_d[static_cast<int32_T>
            (static_cast<int32_T>(fileid) - 3)];
    } else {
        switch (static_cast<int32_T>(fileid)) {
          case 0:
            filestar = stdin;
            break;

          case 1:
            filestar = stdout;
            break;

          case 2:
            filestar = stderr;
            break;

          default:
            filestar = NULL;
            break;
        }
    }

    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
            static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
              static_cast<boolean_T>(static_cast<int32_T>((fileID != 0.0) ^ 1)))
             | static_cast<int32_T>(static_cast<boolean_T>(static_cast<int32_T>
               ((fileID != 1.0) ^ 1)))))) | static_cast<int32_T>
            (static_cast<boolean_T>(static_cast<int32_T>((fileID != 2.0) ^ 1))))))
    {
        filestar = NULL;
    }

    A->size[0] = 0;
    if (static_cast<boolean_T>(static_cast<int32_T>((filestar == NULL) ^ 1))) {
        int32_T c;
        c = 1;
        while (c > 0) {
            int32_T i;
            int32_T loop_ub;
            int32_T numRead;
            int32_T tmp;
            c = 0;
            numRead = 1;
            while (static_cast<boolean_T>(static_cast<int32_T>((c < 1024) &
                     (numRead > 0)))) {
                size_t numReadSizeT;
                numReadSizeT = fread(&tbuf[c], nBytes, (size_t)(1024 - c),
                                     filestar);
                numRead = (int32_T)numReadSizeT;
                c = static_cast<int32_T>(c + (int32_T)numReadSizeT);
            }

            numRead = A->size[0];
            if (c < 1) {
                i = -1;
                loop_ub = -1;
            } else {
                i = static_cast<int32_T>(c - 1);
                loop_ub = static_cast<int32_T>(c - 1);
            }

            tmp = A->size[0];
            A->size[0] = static_cast<int32_T>(static_cast<int32_T>(i + A->size[0])
                + 1);
            FlightMissionMode_emxEnsureCapacity_char_T_g(A, tmp);
            for (i = 0; i <= loop_ub; i++) {
                A->data[static_cast<int32_T>(numRead + i)] = tbuf[i];
            }
        }
    }
}

// Function for MATLAB Function: '<S118>/ReadHomePoint'
static void FlightMissionMode_fread_j(real_T fileID,
    emxArray_char_T_FlightMissionMode_T *A, DW_FlightMissionMode_f_T *localDW)
{
    FILE* filestar;
    size_t nBytes;
    char_T tbuf[1024];
    int8_T fileid;
    nBytes = sizeof(char_T);
    fileid = static_cast<int8_T>(fileID);
    if (fileID != static_cast<real_T>(static_cast<int8_T>(fileID))) {
        fileid = -1;
    }

    if (static_cast<int32_T>(fileid) >= 3) {
        filestar = localDW->eml_openfiles_bx[static_cast<int32_T>
            (static_cast<int32_T>(fileid) - 3)];
    } else {
        switch (static_cast<int32_T>(fileid)) {
          case 0:
            filestar = stdin;
            break;

          case 1:
            filestar = stdout;
            break;

          case 2:
            filestar = stderr;
            break;

          default:
            filestar = NULL;
            break;
        }
    }

    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
            static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
              static_cast<boolean_T>(static_cast<int32_T>((fileID != 0.0) ^ 1)))
             | static_cast<int32_T>(static_cast<boolean_T>(static_cast<int32_T>
               ((fileID != 1.0) ^ 1)))))) | static_cast<int32_T>
            (static_cast<boolean_T>(static_cast<int32_T>((fileID != 2.0) ^ 1))))))
    {
        filestar = NULL;
    }

    A->size[0] = 0;
    if (static_cast<boolean_T>(static_cast<int32_T>((filestar == NULL) ^ 1))) {
        int32_T c;
        c = 1;
        while (c > 0) {
            int32_T i;
            int32_T loop_ub;
            int32_T numRead;
            int32_T tmp;
            c = 0;
            numRead = 1;
            while (static_cast<boolean_T>(static_cast<int32_T>((c < 1024) &
                     (numRead > 0)))) {
                size_t numReadSizeT;
                numReadSizeT = fread(&tbuf[c], nBytes, (size_t)(1024 - c),
                                     filestar);
                numRead = (int32_T)numReadSizeT;
                c = static_cast<int32_T>(c + (int32_T)numReadSizeT);
            }

            numRead = A->size[0];
            if (c < 1) {
                i = -1;
                loop_ub = -1;
            } else {
                i = static_cast<int32_T>(c - 1);
                loop_ub = static_cast<int32_T>(c - 1);
            }

            tmp = A->size[0];
            A->size[0] = static_cast<int32_T>(static_cast<int32_T>(i + A->size[0])
                + 1);
            FlightMissionMode_emxEnsureCapacity_char_T_g(A, tmp);
            for (i = 0; i <= loop_ub; i++) {
                A->data[static_cast<int32_T>(numRead + i)] = tbuf[i];
            }
        }
    }
}

// Function for MATLAB Function: '<S10>/ReadHomePoint'
static void FlightMissionMode_copysign_j(emxArray_char_T_FlightMissionMode_T *s1,
    int32_T *idx, const emxArray_char_T_FlightMissionMode_T *s, int32_T *k,
    int32_T n, boolean_T *foundsign, boolean_T *success)
{
    static const boolean_T b[128]{ false, false, false, false, false, false,
        false, false, false, true, true, true, true, true, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, true, true, true, true, true, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false };

    boolean_T exitg1;
    boolean_T isneg;
    isneg = false;
    *foundsign = false;
    exitg1 = false;
    while ((!exitg1) && (*k <= n)) {
        char_T tmp;
        tmp = s->data[static_cast<int32_T>(*k - 1)];
        if (tmp == '-') {
            isneg = static_cast<boolean_T>(static_cast<int32_T>
                (static_cast<int32_T>(isneg) ^ 1));
            *foundsign = true;
            *k = static_cast<int32_T>(*k + 1);
        } else if (tmp == ',') {
            *k = static_cast<int32_T>(*k + 1);
        } else if (tmp == '+') {
            *foundsign = true;
            *k = static_cast<int32_T>(*k + 1);
        } else if (static_cast<boolean_T>(static_cast<int32_T>
                    (static_cast<int32_T>(b[static_cast<int32_T>
                      (static_cast<int32_T>(static_cast<uint8_T>(tmp)) & 127)]) ^
                     1))) {
            exitg1 = true;
        } else {
            *k = static_cast<int32_T>(*k + 1);
        }
    }

    *success = (*k <= n);
    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
            (*success) & static_cast<int32_T>(isneg)))) {
        if ((*idx >= 2) && (s1->data[static_cast<int32_T>(*idx - 2)] == '-')) {
            s1->data[static_cast<int32_T>(*idx - 2)] = ' ';
        } else {
            s1->data[static_cast<int32_T>(*idx - 1)] = '-';
            *idx = static_cast<int32_T>(*idx + 1);
        }
    }
}

// Function for MATLAB Function: '<S10>/ReadHomePoint'
static boolean_T FlightMissionMode_isUnitImag_l(const
    emxArray_char_T_FlightMissionMode_T *s, int32_T k, int32_T n)
{
    boolean_T p;
    p = false;
    if (k <= n) {
        char_T c_idx_0;
        c_idx_0 = s->data[static_cast<int32_T>(k - 1)];
        if (c_idx_0 == 'j') {
            p = true;
        } else if (c_idx_0 == 'i') {
            if (k >= static_cast<int32_T>(n - 1)) {
                p = true;
            } else {
                int32_T b_k;
                char_T c_idx_1;
                char_T c_idx_2;
                b_k = k;
                c_idx_0 = '\x00';
                while ((b_k <= n) && (s->data[static_cast<int32_T>(b_k - 1)] ==
                                      ',')) {
                    b_k = static_cast<int32_T>(b_k + 1);
                }

                if (b_k <= n) {
                    c_idx_0 = s->data[static_cast<int32_T>(b_k - 1)];
                }

                b_k = static_cast<int32_T>(b_k + 1);
                c_idx_1 = '\x00';
                while ((b_k <= n) && (s->data[static_cast<int32_T>(b_k - 1)] ==
                                      ',')) {
                    b_k = static_cast<int32_T>(b_k + 1);
                }

                if (b_k <= n) {
                    c_idx_1 = s->data[static_cast<int32_T>(b_k - 1)];
                }

                b_k = static_cast<int32_T>(b_k + 1);
                c_idx_2 = '\x00';
                while ((b_k <= n) && (s->data[static_cast<int32_T>(b_k - 1)] ==
                                      ',')) {
                    b_k = static_cast<int32_T>(b_k + 1);
                }

                if (b_k <= n) {
                    c_idx_2 = s->data[static_cast<int32_T>(b_k - 1)];
                }

                if (((c_idx_0 == 'I') || (c_idx_0 == 'i')) && ((c_idx_1 == 'N') ||
                     (c_idx_1 == 'n')) && ((c_idx_2 == 'F') || (c_idx_2 == 'f')))
                {
                } else if ((c_idx_0 == 'N') || (c_idx_0 == 'n')) {
                    if ((c_idx_1 == 'A') || (c_idx_1 == 'a')) {
                        if ((c_idx_2 != 'N') && (c_idx_2 != 'n')) {
                            p = true;
                        }
                    } else {
                        p = true;
                    }
                } else {
                    p = true;
                }
            }
        }
    }

    return p;
}

// Function for MATLAB Function: '<S10>/ReadHomePoint'
static void FlightMissionMode_readNonFinite_b(const
    emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n, boolean_T
    *b_finite, real_T *fv)
{
    int32_T ksaved;
    char_T c_idx_0;
    char_T c_idx_1;
    char_T c_idx_2;
    ksaved = *k;
    c_idx_0 = '\x00';
    while ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == ',')) {
        *k = static_cast<int32_T>(*k + 1);
    }

    if (*k <= n) {
        c_idx_0 = s->data[static_cast<int32_T>(*k - 1)];
    }

    *k = static_cast<int32_T>(*k + 1);
    c_idx_1 = '\x00';
    while ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == ',')) {
        *k = static_cast<int32_T>(*k + 1);
    }

    if (*k <= n) {
        c_idx_1 = s->data[static_cast<int32_T>(*k - 1)];
    }

    *k = static_cast<int32_T>(*k + 1);
    c_idx_2 = '\x00';
    while ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == ',')) {
        *k = static_cast<int32_T>(*k + 1);
    }

    if (*k <= n) {
        c_idx_2 = s->data[static_cast<int32_T>(*k - 1)];
    }

    *k = static_cast<int32_T>(*k + 1);
    if (((c_idx_0 == 'I') || (c_idx_0 == 'i')) && ((c_idx_1 == 'N') || (c_idx_1 ==
          'n')) && ((c_idx_2 == 'F') || (c_idx_2 == 'f'))) {
        *b_finite = false;
        *fv = (rtInf);
    } else if (((c_idx_0 == 'N') || (c_idx_0 == 'n')) && ((c_idx_1 == 'A') ||
                (c_idx_1 == 'a')) && ((c_idx_2 == 'N') || (c_idx_2 == 'n'))) {
        *b_finite = false;
        *fv = (rtNaN);
    } else {
        *b_finite = true;
        *fv = 0.0;
        *k = ksaved;
    }
}

// Function for MATLAB Function: '<S10>/ReadHomePoint'
static boolean_T FlightMissionMode_copydigits_h
    (emxArray_char_T_FlightMissionMode_T *s1, int32_T *idx, const
     emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n, boolean_T
     allowpoint)
{
    boolean_T exitg1;
    boolean_T haspoint;
    boolean_T success;
    success = (*k <= n);
    haspoint = false;
    exitg1 = false;
    while ((!exitg1) && (static_cast<boolean_T>(static_cast<int32_T>((*k <= n) &
              static_cast<int32_T>(success))))) {
        char_T tmp;
        tmp = s->data[static_cast<int32_T>(*k - 1)];
        if ((tmp >= '0') && (tmp <= '9')) {
            s1->data[static_cast<int32_T>(*idx - 1)] = tmp;
            *idx = static_cast<int32_T>(*idx + 1);
            *k = static_cast<int32_T>(*k + 1);
        } else if (tmp == '.') {
            success = static_cast<boolean_T>(static_cast<int32_T>
                (static_cast<int32_T>(static_cast<boolean_T>(static_cast<int32_T>
                (static_cast<int32_T>(haspoint) ^ 1))) & static_cast<int32_T>
                 (allowpoint)));
            if (success) {
                s1->data[static_cast<int32_T>(*idx - 1)] = '.';
                *idx = static_cast<int32_T>(*idx + 1);
                haspoint = true;
            }

            *k = static_cast<int32_T>(*k + 1);
        } else if (tmp == ',') {
            *k = static_cast<int32_T>(*k + 1);
        } else {
            exitg1 = true;
        }
    }

    return success;
}

// Function for MATLAB Function: '<S10>/ReadHomePoint'
static boolean_T FlightMissionMode_copyexponent_f
    (emxArray_char_T_FlightMissionMode_T *s1, int32_T *idx, const
     emxArray_char_T_FlightMissionMode_T *s, int32_T *k, int32_T n)
{
    int32_T b_k;
    boolean_T success;
    success = true;
    if (*k <= n) {
        char_T tmp;
        tmp = s->data[static_cast<int32_T>(*k - 1)];
        if ((tmp == 'E') || (tmp == 'e')) {
            int32_T kexp;
            boolean_T b_success;
            s1->data[static_cast<int32_T>(*idx - 1)] = 'e';
            *idx = static_cast<int32_T>(*idx + 1);
            *k = static_cast<int32_T>(*k + 1);
            while ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == ','))
            {
                *k = static_cast<int32_T>(*k + 1);
            }

            if (*k <= n) {
                if (s->data[static_cast<int32_T>(*k - 1)] == '-') {
                    s1->data[static_cast<int32_T>(*idx - 1)] = '-';
                    *idx = static_cast<int32_T>(*idx + 1);
                    *k = static_cast<int32_T>(*k + 1);
                } else if (s->data[static_cast<int32_T>(*k - 1)] == '+') {
                    *k = static_cast<int32_T>(*k + 1);
                }
            }

            kexp = *k;
            b_k = *k;
            b_success = FlightMissionMode_copydigits_h(s1, idx, s, &b_k, n,
                false);
            *k = b_k;
            if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                    (static_cast<boolean_T>(static_cast<int32_T>
                    (static_cast<int32_T>(b_success) ^ 1))) | (b_k <= kexp)))) {
                success = false;
            }
        }
    }

    return success;
}

// Function for MATLAB Function: '<S10>/ReadHomePoint'
static void FlightMissionMode_readfloat_n0(emxArray_char_T_FlightMissionMode_T
    *s1, int32_T *idx, const emxArray_char_T_FlightMissionMode_T *s, int32_T *k,
    int32_T n, boolean_T *isimag, boolean_T *b_finite, real_T *nfv, boolean_T
    *foundsign, boolean_T *success)
{
    static const boolean_T b[128]{ false, false, false, false, false, false,
        false, false, false, true, true, true, true, true, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, true, true, true, true, true, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false };

    int32_T b_idx;
    int32_T b_k;
    boolean_T a__3;
    *isimag = false;
    *b_finite = true;
    *nfv = 0.0;
    b_idx = *idx;
    b_k = *k;
    FlightMissionMode_copysign_j(s1, &b_idx, s, &b_k, n, foundsign, success);
    *idx = b_idx;
    *k = b_k;
    if (*success) {
        char_T tmp;
        boolean_T exitg1;
        if (FlightMissionMode_isUnitImag_l(s, b_k, n)) {
            *isimag = true;
            *k = static_cast<int32_T>(b_k + 1);
            exitg1 = false;
            while ((!exitg1) && (*k <= n)) {
                tmp = s->data[static_cast<int32_T>(*k - 1)];
                if (b[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(tmp)) & 127)] ||
                    (tmp == '\x00') || (tmp == ',')) {
                    *k = static_cast<int32_T>(*k + 1);
                } else {
                    exitg1 = true;
                }
            }

            if ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == '*')) {
                b_k = static_cast<int32_T>(*k + 1);
                FlightMissionMode_copysign_j(s1, &b_idx, s, &b_k, n, &a__3,
                    success);
                *idx = b_idx;
                if (*success) {
                    if (FlightMissionMode_isUnitImag_l(s, b_k, n)) {
                        *success = false;
                    } else {
                        FlightMissionMode_readNonFinite_b(s, &b_k, n, b_finite,
                            nfv);
                        if (*b_finite) {
                            *success = FlightMissionMode_copydigits_h(s1, idx, s,
                                &b_k, n, true);
                            if (*success) {
                                *success = FlightMissionMode_copyexponent_f(s1,
                                    idx, s, &b_k, n);
                            }
                        } else if ((b_idx >= 2) && (s1->data[static_cast<int32_T>
                                                    (b_idx - 2)] == '-')) {
                            *idx = static_cast<int32_T>(b_idx - 1);
                            s1->data[static_cast<int32_T>(b_idx - 2)] = ' ';
                            *nfv = -*nfv;
                        }

                        exitg1 = false;
                        while ((!exitg1) && (b_k <= n)) {
                            tmp = s->data[static_cast<int32_T>(b_k - 1)];
                            if (b[static_cast<int32_T>(static_cast<int32_T>(
                                    static_cast<uint8_T>(tmp)) & 127)] || (tmp ==
                                 '\x00') || (tmp == ',')) {
                                b_k = static_cast<int32_T>(b_k + 1);
                            } else {
                                exitg1 = true;
                            }
                        }

                        if ((b_k <= n) && (s->data[static_cast<int32_T>(b_k - 1)]
                                           == '*')) {
                            b_k = static_cast<int32_T>(b_k + 1);
                            exitg1 = false;
                            while ((!exitg1) && (b_k <= n)) {
                                tmp = s->data[static_cast<int32_T>(b_k - 1)];
                                if (b[static_cast<int32_T>(static_cast<int32_T>(
                                        static_cast<uint8_T>(tmp)) & 127)] ||
                                        (tmp == '\x00') || (tmp == ',')) {
                                    b_k = static_cast<int32_T>(b_k + 1);
                                } else {
                                    exitg1 = true;
                                }
                            }
                        }

                        if (b_k <= n) {
                            tmp = s->data[static_cast<int32_T>(b_k - 1)];
                            if ((tmp == 'i') || (tmp == 'j')) {
                                b_k = static_cast<int32_T>(b_k + 1);
                            }
                        }
                    }

                    exitg1 = false;
                    while ((!exitg1) && (b_k <= n)) {
                        tmp = s->data[static_cast<int32_T>(b_k - 1)];
                        if (b[static_cast<int32_T>(static_cast<int32_T>(
                                static_cast<uint8_T>(tmp)) & 127)] || (tmp ==
                                '\x00') || (tmp == ',')) {
                            b_k = static_cast<int32_T>(b_k + 1);
                        } else {
                            exitg1 = true;
                        }
                    }
                }

                *k = b_k;
            } else {
                s1->data[static_cast<int32_T>(b_idx - 1)] = '1';
                *idx = static_cast<int32_T>(b_idx + 1);
            }
        } else {
            FlightMissionMode_readNonFinite_b(s, &b_k, n, b_finite, nfv);
            *k = b_k;
            if (*b_finite) {
                *success = FlightMissionMode_copydigits_h(s1, idx, s, k, n, true);
                if (*success) {
                    *success = FlightMissionMode_copyexponent_f(s1, idx, s, k, n);
                }
            } else if ((b_idx >= 2) && (s1->data[static_cast<int32_T>(b_idx - 2)]
                        == '-')) {
                *idx = static_cast<int32_T>(b_idx - 1);
                s1->data[static_cast<int32_T>(b_idx - 2)] = ' ';
                *nfv = -*nfv;
            }

            exitg1 = false;
            while ((!exitg1) && (*k <= n)) {
                if (b[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(s->data[
                        static_cast<int32_T>(*k - 1)])) & 127)]) {
                    *k = static_cast<int32_T>(*k + 1);
                } else {
                    tmp = s->data[static_cast<int32_T>(*k - 1)];
                    if ((tmp == '\x00') || (tmp == ',')) {
                        *k = static_cast<int32_T>(*k + 1);
                    } else {
                        exitg1 = true;
                    }
                }
            }

            if ((*k <= n) && (s->data[static_cast<int32_T>(*k - 1)] == '*')) {
                *k = static_cast<int32_T>(*k + 1);
                while ((*k <= n) && (b[static_cast<int32_T>(static_cast<int32_T>
                         (static_cast<uint8_T>(s->data[static_cast<int32_T>(*k -
                            1)])) & 127)] || (s->data[static_cast<int32_T>(*k -
                          1)] == '\x00') || (s->data[static_cast<int32_T>(*k - 1)]
                         == ','))) {
                    *k = static_cast<int32_T>(*k + 1);
                }
            }

            if (*k <= n) {
                tmp = s->data[static_cast<int32_T>(*k - 1)];
                if ((tmp == 'i') || (tmp == 'j')) {
                    *k = static_cast<int32_T>(*k + 1);
                    *isimag = true;
                }
            }
        }

        exitg1 = false;
        while ((!exitg1) && (*k <= n)) {
            if (b[static_cast<int32_T>(static_cast<int32_T>(static_cast<uint8_T>
                    (s->data[static_cast<int32_T>(*k - 1)])) & 127)]) {
                *k = static_cast<int32_T>(*k + 1);
            } else {
                tmp = s->data[static_cast<int32_T>(*k - 1)];
                if ((tmp == '\x00') || (tmp == ',')) {
                    *k = static_cast<int32_T>(*k + 1);
                } else {
                    exitg1 = true;
                }
            }
        }
    }
}

// Function for MATLAB Function: '<S10>/ReadHomePoint'
static creal_T FlightMissionMode_str2double_k(const
    emxArray_char_T_FlightMissionMode_T *s)
{
    static const boolean_T c[128]{ false, false, false, false, false, false,
        false, false, false, true, true, true, true, true, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, true, true, true, true, true, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false };

    emxArray_char_T_FlightMissionMode_T *s1;
    creal_T x;
    real_T b_scanned1;
    real_T scanned1;
    real_T scanned2;
    int32_T idx;
    int32_T k;
    boolean_T a__1;
    boolean_T c_success;
    boolean_T foundsign;
    boolean_T isfinite1;
    boolean_T isimag1;
    boolean_T success;
    x.re = (rtNaN);
    x.im = 0.0;
    if (s->size[1] >= 1) {
        int32_T i;
        int32_T ntoread;
        boolean_T exitg1;
        FlightMissionMode_emxInit_char_T_ey(&s1, 2);
        ntoread = 0;
        k = 1;
        exitg1 = false;
        while ((!exitg1) && (k <= s->size[1])) {
            char_T tmp;
            tmp = s->data[static_cast<int32_T>(k - 1)];
            if (c[static_cast<int32_T>(static_cast<int32_T>(static_cast<uint8_T>
                    (tmp)) & 127)] || (tmp == '\x00')) {
                k = static_cast<int32_T>(k + 1);
            } else {
                exitg1 = true;
            }
        }

        i = static_cast<int32_T>(s1->size[0] * s1->size[1]);
        s1->size[0] = 1;
        s1->size[1] = static_cast<int32_T>(s->size[1] + 2);
        FlightMissionMode_emxEnsureCapacity_char_T_g(s1, i);
        idx = s->size[1];
        for (i = 0; i <= static_cast<int32_T>(idx + 1); i++) {
            s1->data[i] = '\x00';
        }

        idx = 1;
        FlightMissionMode_readfloat_n0(s1, &idx, s, &k, s->size[1], &isimag1,
            &isfinite1, &scanned1, &a__1, &success);
        if (isfinite1) {
            ntoread = 1;
        }

        if (success) {
            if (k <= s->size[1]) {
                s1->data[static_cast<int32_T>(idx - 1)] = ' ';
                idx = static_cast<int32_T>(idx + 1);
                FlightMissionMode_readfloat_n0(s1, &idx, s, &k, s->size[1],
                    &a__1, &success, &scanned2, &foundsign, &c_success);
                if (success) {
                    ntoread = static_cast<int32_T>(ntoread + 1);
                }

                success = static_cast<boolean_T>(static_cast<int32_T>(
                    static_cast<int32_T>(static_cast<boolean_T>
                    (static_cast<int32_T>(static_cast<int32_T>
                    (static_cast<boolean_T>(static_cast<int32_T>
                    (static_cast<int32_T>(static_cast<boolean_T>
                    (static_cast<int32_T>(static_cast<int32_T>(isimag1) ^
                    static_cast<int32_T>(a__1)))) & static_cast<int32_T>
                     (foundsign)))) & (k > s->size[1])))) & static_cast<int32_T>
                    (c_success)));
            } else {
                scanned2 = 0.0;
            }
        } else {
            scanned2 = 0.0;
        }

        if (success) {
            s1->data[static_cast<int32_T>(idx - 1)] = '\x00';
            switch (ntoread) {
              case 2:
                ntoread = sscanf(&s1->data[0], "%lf %lf", &scanned1, &scanned2);
                if (ntoread != 2) {
                    scanned1 = (rtNaN);
                    scanned2 = (rtNaN);
                }
                break;

              case 1:
                ntoread = sscanf(&s1->data[0], "%lf", &b_scanned1);
                if (isfinite1) {
                    if (ntoread == 1) {
                        scanned1 = b_scanned1;
                    } else {
                        scanned1 = (rtNaN);
                    }
                } else if (ntoread == 1) {
                    scanned2 = b_scanned1;
                } else {
                    scanned2 = (rtNaN);
                }
                break;
            }

            if (isimag1) {
                x.re = scanned2;
                x.im = scanned1;
            } else {
                x.re = scanned1;
                x.im = scanned2;
            }
        }

        FlightMissionMode_emxFree_char_T_o(&s1);
    }

    return x;
}

// Function for MATLAB Function: '<S10>/ReadHomePoint'
static int32_T FlightMissionMode_cfclose_n(real_T fid, DW_FlightMissionMode_f_T *
    localDW)
{
    FILE* filestar;
    int32_T st;
    int8_T b_fileid;
    int8_T fileid;
    st = -1;
    fileid = static_cast<int8_T>(fid);
    if (fid != static_cast<real_T>(static_cast<int8_T>(fid))) {
        fileid = -1;
    }

    b_fileid = fileid;
    if (static_cast<int32_T>(fileid) < 0) {
        b_fileid = -1;
    }

    if (static_cast<int32_T>(b_fileid) >= 3) {
        filestar = localDW->eml_openfiles[static_cast<int32_T>
            (static_cast<int32_T>(b_fileid) - 3)];
    } else {
        switch (static_cast<int32_T>(b_fileid)) {
          case 0:
            filestar = stdin;
            break;

          case 1:
            filestar = stdout;
            break;

          case 2:
            filestar = stderr;
            break;

          default:
            filestar = NULL;
            break;
        }
    }

    if (static_cast<boolean_T>(static_cast<int32_T>((filestar != NULL) & (
            static_cast<int32_T>(fileid) >= 3)))) {
        int32_T cst;
        cst = fclose(filestar);
        if (cst == 0) {
            st = 0;
            localDW->eml_openfiles[static_cast<int32_T>(static_cast<int32_T>
                (fileid) - 3)] = NULL;
        }
    }

    return st;
}

// Function for MATLAB Function: '<S75>/ReadHomePoint'
static int32_T FlightMissionMode_cfclose_a(real_T fid, DW_FlightMissionMode_f_T *
    localDW)
{
    FILE* filestar;
    int32_T st;
    int8_T b_fileid;
    int8_T fileid;
    st = -1;
    fileid = static_cast<int8_T>(fid);
    if (fid != static_cast<real_T>(static_cast<int8_T>(fid))) {
        fileid = -1;
    }

    b_fileid = fileid;
    if (static_cast<int32_T>(fileid) < 0) {
        b_fileid = -1;
    }

    if (static_cast<int32_T>(b_fileid) >= 3) {
        filestar = localDW->eml_openfiles_d[static_cast<int32_T>
            (static_cast<int32_T>(b_fileid) - 3)];
    } else {
        switch (static_cast<int32_T>(b_fileid)) {
          case 0:
            filestar = stdin;
            break;

          case 1:
            filestar = stdout;
            break;

          case 2:
            filestar = stderr;
            break;

          default:
            filestar = NULL;
            break;
        }
    }

    if (static_cast<boolean_T>(static_cast<int32_T>((filestar != NULL) & (
            static_cast<int32_T>(fileid) >= 3)))) {
        int32_T cst;
        cst = fclose(filestar);
        if (cst == 0) {
            st = 0;
            localDW->eml_openfiles_d[static_cast<int32_T>(static_cast<int32_T>
                (fileid) - 3)] = NULL;
        }
    }

    return st;
}

// Function for MATLAB Function: '<S118>/ReadHomePoint'
static int32_T FlightMissionMode_cfclose_d(real_T fid, DW_FlightMissionMode_f_T *
    localDW)
{
    FILE* filestar;
    int32_T st;
    int8_T b_fileid;
    int8_T fileid;
    st = -1;
    fileid = static_cast<int8_T>(fid);
    if (fid != static_cast<real_T>(static_cast<int8_T>(fid))) {
        fileid = -1;
    }

    b_fileid = fileid;
    if (static_cast<int32_T>(fileid) < 0) {
        b_fileid = -1;
    }

    if (static_cast<int32_T>(b_fileid) >= 3) {
        filestar = localDW->eml_openfiles_bx[static_cast<int32_T>
            (static_cast<int32_T>(b_fileid) - 3)];
    } else {
        switch (static_cast<int32_T>(b_fileid)) {
          case 0:
            filestar = stdin;
            break;

          case 1:
            filestar = stdout;
            break;

          case 2:
            filestar = stderr;
            break;

          default:
            filestar = NULL;
            break;
        }
    }

    if (static_cast<boolean_T>(static_cast<int32_T>((filestar != NULL) & (
            static_cast<int32_T>(fileid) >= 3)))) {
        int32_T cst;
        cst = fclose(filestar);
        if (cst == 0) {
            st = 0;
            localDW->eml_openfiles_bx[static_cast<int32_T>(static_cast<int32_T>
                (fileid) - 3)] = NULL;
        }
    }

    return st;
}

// Function for MATLAB Function: '<S166>/WayPointGenerator'
static int8_T FlightMissionMode_filedata_i(DW_FlightMissionMode_f_T *localDW)
{
    int32_T k;
    int8_T f;
    boolean_T exitg1;
    f = 0;
    k = 1;
    exitg1 = false;
    while ((!exitg1) && (static_cast<int32_T>(k - 1) < 20)) {
        if (localDW->eml_openfiles_i[static_cast<int32_T>(static_cast<int32_T>(
                static_cast<int8_T>(k)) - 1)] == NULL) {
            f = static_cast<int8_T>(k);
            exitg1 = true;
        } else {
            k = static_cast<int32_T>(k + 1);
        }
    }

    return f;
}

// Function for MATLAB Function: '<S166>/WayPointGenerator'
static int8_T FlightMissionMode_cfopen_h(const char_T cfilename_data[], const
    int32_T cfilename_size[2], const char_T *cpermission,
    DW_FlightMissionMode_f_T *localDW)
{
    char_T ccfilename_data[38];
    int8_T fileid;
    int8_T j;
    fileid = -1;
    j = FlightMissionMode_filedata_i(localDW);
    if (static_cast<int32_T>(j) >= 1) {
        FILE* filestar;
        int32_T ccfilename_data_tmp;
        int32_T loop_ub;
        loop_ub = cfilename_size[1];
        for (ccfilename_data_tmp = 0; ccfilename_data_tmp <= static_cast<int32_T>
                (loop_ub - 1); ccfilename_data_tmp++) {
            ccfilename_data[ccfilename_data_tmp] =
                cfilename_data[ccfilename_data_tmp];
        }

        ccfilename_data[cfilename_size[1]] = '\x00';
        filestar = fopen(&ccfilename_data[0], cpermission);
        if (filestar != NULL) {
            localDW->eml_openfiles_i[static_cast<int32_T>(static_cast<int32_T>(j)
                - 1)] = filestar;
            ccfilename_data_tmp = static_cast<int32_T>(static_cast<int32_T>(j) +
                2);
            if (static_cast<int32_T>(static_cast<int32_T>(j) + 2) > 127) {
                ccfilename_data_tmp = 127;
            }

            fileid = static_cast<int8_T>(ccfilename_data_tmp);
        }
    }

    return fileid;
}

// Function for MATLAB Function: '<S37>/ReadHomePoint'
static int8_T FlightMissionMode_filedata_g(DW_FlightMissionMode_f_T *localDW)
{
    int32_T k;
    int8_T f;
    boolean_T exitg1;
    f = 0;
    k = 1;
    exitg1 = false;
    while ((!exitg1) && (static_cast<int32_T>(k - 1) < 20)) {
        if (localDW->eml_openfiles_b[static_cast<int32_T>(static_cast<int32_T>(
                static_cast<int8_T>(k)) - 1)] == NULL) {
            f = static_cast<int8_T>(k);
            exitg1 = true;
        } else {
            k = static_cast<int32_T>(k + 1);
        }
    }

    return f;
}

// Function for MATLAB Function: '<S37>/ReadHomePoint'
static int8_T FlightMissionMode_cfopen_c(const char_T *cfilename, const char_T
    *cpermission, DW_FlightMissionMode_f_T *localDW)
{
    int8_T fileid;
    int8_T j;
    fileid = -1;
    j = FlightMissionMode_filedata_g(localDW);
    if (static_cast<int32_T>(j) >= 1) {
        FILE* filestar;
        filestar = fopen(cfilename, cpermission);
        if (filestar != NULL) {
            int32_T tmp;
            localDW->eml_openfiles_b[static_cast<int32_T>(static_cast<int32_T>(j)
                - 1)] = filestar;
            tmp = static_cast<int32_T>(static_cast<int32_T>(j) + 2);
            if (static_cast<int32_T>(static_cast<int32_T>(j) + 2) > 127) {
                tmp = 127;
            }

            fileid = static_cast<int8_T>(tmp);
        }
    }

    return fileid;
}

// Function for MATLAB Function: '<S37>/ReadHomePoint'
static void FlightMissionMode_fread_hc(real_T fileID,
    emxArray_char_T_FlightMissionMode_T *A, DW_FlightMissionMode_f_T *localDW)
{
    FILE* filestar;
    size_t nBytes;
    char_T tbuf[1024];
    int8_T fileid;
    nBytes = sizeof(char_T);
    fileid = static_cast<int8_T>(fileID);
    if (fileID != static_cast<real_T>(static_cast<int8_T>(fileID))) {
        fileid = -1;
    }

    if (static_cast<int32_T>(fileid) >= 3) {
        filestar = localDW->eml_openfiles_b[static_cast<int32_T>
            (static_cast<int32_T>(fileid) - 3)];
    } else {
        switch (static_cast<int32_T>(fileid)) {
          case 0:
            filestar = stdin;
            break;

          case 1:
            filestar = stdout;
            break;

          case 2:
            filestar = stderr;
            break;

          default:
            filestar = NULL;
            break;
        }
    }

    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
            static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
              static_cast<boolean_T>(static_cast<int32_T>((fileID != 0.0) ^ 1)))
             | static_cast<int32_T>(static_cast<boolean_T>(static_cast<int32_T>
               ((fileID != 1.0) ^ 1)))))) | static_cast<int32_T>
            (static_cast<boolean_T>(static_cast<int32_T>((fileID != 2.0) ^ 1))))))
    {
        filestar = NULL;
    }

    A->size[0] = 0;
    if (static_cast<boolean_T>(static_cast<int32_T>((filestar == NULL) ^ 1))) {
        int32_T c;
        c = 1;
        while (c > 0) {
            int32_T i;
            int32_T loop_ub;
            int32_T numRead;
            int32_T tmp;
            c = 0;
            numRead = 1;
            while (static_cast<boolean_T>(static_cast<int32_T>((c < 1024) &
                     (numRead > 0)))) {
                size_t numReadSizeT;
                numReadSizeT = fread(&tbuf[c], nBytes, (size_t)(1024 - c),
                                     filestar);
                numRead = (int32_T)numReadSizeT;
                c = static_cast<int32_T>(c + (int32_T)numReadSizeT);
            }

            numRead = A->size[0];
            if (c < 1) {
                i = -1;
                loop_ub = -1;
            } else {
                i = static_cast<int32_T>(c - 1);
                loop_ub = static_cast<int32_T>(c - 1);
            }

            tmp = A->size[0];
            A->size[0] = static_cast<int32_T>(static_cast<int32_T>(i + A->size[0])
                + 1);
            FlightMissionMode_emxEnsureCapacity_char_T_g(A, tmp);
            for (i = 0; i <= loop_ub; i++) {
                A->data[static_cast<int32_T>(numRead + i)] = tbuf[i];
            }
        }
    }
}

// Function for MATLAB Function: '<S166>/WayPointGenerator'
static int32_T FlightMissionMode_cfclose_k(real_T fid, DW_FlightMissionMode_f_T *
    localDW)
{
    FILE* filestar;
    int32_T st;
    int8_T b_fileid;
    int8_T fileid;
    st = -1;
    fileid = static_cast<int8_T>(fid);
    if (static_cast<boolean_T>(static_cast<int32_T>((static_cast<int32_T>(
            static_cast<int8_T>(fid)) < 0) | (fid != static_cast<real_T>(
            static_cast<int8_T>(fid)))))) {
        fileid = -1;
    }

    b_fileid = fileid;
    if (static_cast<int32_T>(fileid) < 0) {
        b_fileid = -1;
    }

    if (static_cast<int32_T>(b_fileid) >= 3) {
        filestar = localDW->eml_openfiles_i[static_cast<int32_T>
            (static_cast<int32_T>(b_fileid) - 3)];
    } else {
        switch (static_cast<int32_T>(b_fileid)) {
          case 0:
            filestar = stdin;
            break;

          case 1:
            filestar = stdout;
            break;

          case 2:
            filestar = stderr;
            break;

          default:
            filestar = NULL;
            break;
        }
    }

    if (static_cast<boolean_T>(static_cast<int32_T>((filestar != NULL) & (
            static_cast<int32_T>(fileid) >= 3)))) {
        int32_T cst;
        cst = fclose(filestar);
        if (cst == 0) {
            st = 0;
            localDW->eml_openfiles_i[static_cast<int32_T>(static_cast<int32_T>
                (fileid) - 3)] = NULL;
        }
    }

    return st;
}

// Function for MATLAB Function: '<S37>/ReadHomePoint'
static int32_T FlightMissionMode_cfclose_h5(real_T fid, DW_FlightMissionMode_f_T
    *localDW)
{
    FILE* filestar;
    int32_T st;
    int8_T b_fileid;
    int8_T fileid;
    st = -1;
    fileid = static_cast<int8_T>(fid);
    if (fid != static_cast<real_T>(static_cast<int8_T>(fid))) {
        fileid = -1;
    }

    b_fileid = fileid;
    if (static_cast<int32_T>(fileid) < 0) {
        b_fileid = -1;
    }

    if (static_cast<int32_T>(b_fileid) >= 3) {
        filestar = localDW->eml_openfiles_b[static_cast<int32_T>
            (static_cast<int32_T>(b_fileid) - 3)];
    } else {
        switch (static_cast<int32_T>(b_fileid)) {
          case 0:
            filestar = stdin;
            break;

          case 1:
            filestar = stdout;
            break;

          case 2:
            filestar = stderr;
            break;

          default:
            filestar = NULL;
            break;
        }
    }

    if (static_cast<boolean_T>(static_cast<int32_T>((filestar != NULL) & (
            static_cast<int32_T>(fileid) >= 3)))) {
        int32_T cst;
        cst = fclose(filestar);
        if (cst == 0) {
            st = 0;
            localDW->eml_openfiles_b[static_cast<int32_T>(static_cast<int32_T>
                (fileid) - 3)] = NULL;
        }
    }

    return st;
}

static void FlightMissionMode_emxEnsureCapacity_real_T_c
    (emxArray_real_T_FlightMissionMode_T *emxArray, int32_T oldNumel)
{
    int32_T i;
    int32_T newNumel;
    void *newData;
    if (oldNumel < 0) {
        oldNumel = 0;
    }

    newNumel = 1;
    for (i = 0; i <= static_cast<int32_T>(emxArray->numDimensions - 1); i++) {
        newNumel = static_cast<int32_T>(newNumel * emxArray->size[i]);
    }

    if (newNumel > emxArray->allocatedSize) {
        i = emxArray->allocatedSize;
        if (i < 16) {
            i = 16;
        }

        while (i < newNumel) {
            if (i > 1073741823) {
                i = MAX_int32_T;
            } else {
                i = static_cast<int32_T>(i << 1);
            }
        }

        newData = std::calloc(static_cast<uint32_T>(i), sizeof(real_T));
        if (emxArray->data != nullptr) {
            std::memcpy(newData, emxArray->data, static_cast<uint32_T>(sizeof
                         (real_T) * static_cast<uint32_T>(oldNumel)));
            if (emxArray->canFreeData) {
                std::free(emxArray->data);
            }
        }

        emxArray->data = static_cast<real_T *>(newData);
        emxArray->allocatedSize = i;
        emxArray->canFreeData = true;
    }
}

// Function for MATLAB Function: '<S10>/ReadHomePoint'
static void FlightMissionMode_strtok_d(const emxArray_char_T_FlightMissionMode_T
    *x, emxArray_char_T_FlightMissionMode_T *token,
    emxArray_char_T_FlightMissionMode_T *remain)
{
    int32_T b;
    int32_T i;
    int32_T itoken;
    int32_T k;
    int32_T n;
    n = x->size[1];
    k = 0;
    while ((static_cast<int32_T>(k + 1) <= n) && (x->data[k] == '\x0a')) {
        k = static_cast<int32_T>(k + 1);
    }

    itoken = static_cast<int32_T>(k + 1);
    while ((static_cast<int32_T>(k + 1) <= n) && (x->data[k] != '\x0a')) {
        k = static_cast<int32_T>(k + 1);
    }

    if (static_cast<int32_T>(k + 1) > x->size[1]) {
        n = 0;
        b = 0;
    } else {
        n = k;
        b = x->size[1];
    }

    i = static_cast<int32_T>(remain->size[0] * remain->size[1]);
    remain->size[0] = 1;
    b = static_cast<int32_T>(b - n);
    remain->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T_g(remain, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        remain->data[i] = x->data[static_cast<int32_T>(n + i)];
    }

    if (itoken > k) {
        itoken = 0;
        k = 0;
    } else {
        itoken = static_cast<int32_T>(itoken - 1);
    }

    i = static_cast<int32_T>(token->size[0] * token->size[1]);
    token->size[0] = 1;
    b = static_cast<int32_T>(k - itoken);
    token->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T_g(token, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        token->data[i] = x->data[static_cast<int32_T>(itoken + i)];
    }
}

// Function for MATLAB Function: '<S10>/ReadHomePoint'
static void FlightMissionMode_strtok_dq(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token)
{
    int32_T itoken;
    int32_T k;
    int32_T n;
    n = x->size[1];
    k = 1;
    while ((k <= n) && (x->data[static_cast<int32_T>(k - 1)] == ';')) {
        k = static_cast<int32_T>(k + 1);
    }

    itoken = k;
    while ((k <= n) && (x->data[static_cast<int32_T>(k - 1)] != ';')) {
        k = static_cast<int32_T>(k + 1);
    }

    if (itoken > static_cast<int32_T>(k - 1)) {
        n = 0;
        k = 0;
    } else {
        n = static_cast<int32_T>(itoken - 1);
        k = static_cast<int32_T>(k - 1);
    }

    itoken = static_cast<int32_T>(token->size[0] * token->size[1]);
    token->size[0] = 1;
    k = static_cast<int32_T>(k - n);
    token->size[1] = k;
    FlightMissionMode_emxEnsureCapacity_char_T_g(token, itoken);
    for (itoken = 0; itoken <= static_cast<int32_T>(k - 1); itoken++) {
        token->data[itoken] = x->data[static_cast<int32_T>(n + itoken)];
    }
}

// Function for MATLAB Function: '<S166>/WayPointGenerator'
static FILE* FlightMissionMode_fileManager_b(real_T varargin_1,
    DW_FlightMissionMode_f_T *localDW)
{
    FILE* f;
    int8_T fileid;
    fileid = static_cast<int8_T>(varargin_1);
    if (static_cast<boolean_T>(static_cast<int32_T>((static_cast<int32_T>(
            static_cast<int8_T>(varargin_1)) < 0) | (varargin_1 !=
            static_cast<real_T>(static_cast<int8_T>(varargin_1)))))) {
        fileid = -1;
    }

    if (static_cast<int32_T>(fileid) >= 3) {
        f = localDW->eml_openfiles_i[static_cast<int32_T>(static_cast<int32_T>
            (fileid) - 3)];
    } else {
        switch (static_cast<int32_T>(fileid)) {
          case 0:
            f = stdin;
            break;

          case 1:
            f = stdout;
            break;

          case 2:
            f = stderr;
            break;

          default:
            f = NULL;
            break;
        }
    }

    return f;
}

// Function for MATLAB Function: '<S166>/WayPointGenerator'
static void FlightMissionMode_fgetl(real_T fileID,
    emxArray_char_T_FlightMissionMode_T *out, DW_FlightMissionMode_f_T *localDW)
{
    FILE* filestar;
    emxArray_char_T_FlightMissionMode_T *outBuff;
    int32_T i;
    int32_T reachedEndOfFile;
    char_T ReadBuff[1024];
    uint8_T buf;
    filestar = FlightMissionMode_fileManager_b(fileID, localDW);
    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
            static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
              static_cast<boolean_T>(static_cast<int32_T>((fileID != 0.0) ^ 1)))
             | static_cast<int32_T>(static_cast<boolean_T>(static_cast<int32_T>
               ((fileID != 1.0) ^ 1)))))) | static_cast<int32_T>
            (static_cast<boolean_T>(static_cast<int32_T>((fileID != 2.0) ^ 1))))))
    {
        filestar = NULL;
    }

    FlightMissionMode_emxInit_char_T_ey(&outBuff, 2);
    outBuff->size[0] = 1;
    outBuff->size[1] = 0;
    if (static_cast<boolean_T>(static_cast<int32_T>((filestar == NULL) ^ 1))) {
        FILE* b_NULL;
        FILE* b_filestar;
        char* cOut;
        int b_wherefrom;
        int st;
        int32_T exitg1;
        boolean_T readNewline;
        do {
            exitg1 = 0;
            cOut = fgets(&ReadBuff[0], 1024, filestar);
            readNewline = false;
            b_NULL = NULL;
            b_filestar = FlightMissionMode_fileManager_b(fileID, localDW);
            if (b_filestar == b_NULL) {
                reachedEndOfFile = 0;
            } else {
                st = feof(b_filestar);
                reachedEndOfFile = ((int32_T)st != 0);
            }

            if (cOut == NULL) {
                exitg1 = 1;
            } else {
                int32_T b_i;
                int32_T carriageReturnAt;
                int32_T idx;
                boolean_T fileEndAfterCarriageReturn;
                boolean_T newLineAfterCarriageReturn;
                idx = 1;
                carriageReturnAt = 0;
                if (reachedEndOfFile != 0) {
                    boolean_T exitg2;
                    b_i = 0;
                    exitg2 = false;
                    while ((!exitg2) && (b_i < 1024)) {
                        if (ReadBuff[b_i] == '\x00') {
                            idx = static_cast<int32_T>(b_i + 1);
                            exitg2 = true;
                        } else {
                            if ((carriageReturnAt == 0) && (ReadBuff[b_i] ==
                                    '\x0d')) {
                                carriageReturnAt = static_cast<int32_T>(b_i + 1);
                            }

                            b_i = static_cast<int32_T>(b_i + 1);
                        }
                    }

                    if (ReadBuff[static_cast<int32_T>(idx - 1)] == '\x00') {
                        idx = static_cast<int32_T>(idx - 1);
                    }
                } else {
                    boolean_T exitg2;
                    b_i = 0;
                    exitg2 = false;
                    while ((!exitg2) && (b_i < 1025)) {
                        if (static_cast<int32_T>(b_i + 1) > 1024) {
                            idx = 1023;
                            exitg2 = true;
                        } else if (ReadBuff[b_i] == '\x0a') {
                            idx = static_cast<int32_T>(b_i + 1);
                            exitg2 = true;
                        } else {
                            if ((carriageReturnAt == 0) && (ReadBuff[b_i] ==
                                    '\x0d')) {
                                carriageReturnAt = static_cast<int32_T>(b_i + 1);
                            }

                            b_i = static_cast<int32_T>(b_i + 1);
                        }
                    }

                    readNewline = (ReadBuff[static_cast<int32_T>(idx - 1)] ==
                                   '\x0a');
                }

                if (static_cast<boolean_T>(static_cast<int32_T>
                                           ((carriageReturnAt > 0) &
                                            (carriageReturnAt < 1024)))) {
                    newLineAfterCarriageReturn = (ReadBuff[carriageReturnAt] ==
                        '\x0a');
                    if (reachedEndOfFile != 0) {
                        fileEndAfterCarriageReturn = (ReadBuff[carriageReturnAt]
                            == '\x00');
                    } else {
                        fileEndAfterCarriageReturn = false;
                    }
                } else {
                    newLineAfterCarriageReturn = false;
                    fileEndAfterCarriageReturn = false;
                }

                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>
                                            (static_cast<boolean_T>
                        (static_cast<int32_T>((carriageReturnAt == 0) |
                         static_cast<int32_T>(newLineAfterCarriageReturn)))) |
                                            static_cast<int32_T>
                                            (fileEndAfterCarriageReturn)))) {
                    int32_T tmp;
                    if (idx < 1) {
                        i = -1;
                        idx = -1;
                    } else {
                        i = static_cast<int32_T>(idx - 1);
                        idx = static_cast<int32_T>(idx - 1);
                    }

                    b_i = static_cast<int32_T>(i + 1);
                    i = outBuff->size[1];
                    tmp = static_cast<int32_T>(outBuff->size[0] * outBuff->size
                        [1]);
                    outBuff->size[1] = static_cast<int32_T>(static_cast<int32_T>
                        (idx + outBuff->size[1]) + 1);
                    FlightMissionMode_emxEnsureCapacity_char_T_g(outBuff, tmp);
                    for (idx = 0; idx <= static_cast<int32_T>(b_i - 1); idx++) {
                        outBuff->data[static_cast<int32_T>(i + idx)] =
                            ReadBuff[idx];
                    }
                } else {
                    b_i = outBuff->size[1];
                    i = static_cast<int32_T>(outBuff->size[0] * outBuff->size[1]);
                    outBuff->size[1] = static_cast<int32_T>(outBuff->size[1] +
                        carriageReturnAt);
                    FlightMissionMode_emxEnsureCapacity_char_T_g(outBuff, i);
                    for (i = 0; i <= static_cast<int32_T>(carriageReturnAt - 1);
                         i++) {
                        outBuff->data[static_cast<int32_T>(b_i + i)] =
                            ReadBuff[i];
                    }

                    b_wherefrom = SEEK_CUR;
                    b_NULL = FlightMissionMode_fileManager_b(fileID, localDW);
                    if (static_cast<boolean_T>(static_cast<int32_T>
                                               (static_cast<int32_T>(
                            static_cast<boolean_T>(static_cast<int32_T>(
                             static_cast<int32_T>(static_cast<boolean_T>(
                               static_cast<int32_T>((fileID != 0.0) ^ 1))) |
                             static_cast<int32_T>(static_cast<boolean_T>(
                               static_cast<int32_T>((fileID != 1.0) ^ 1)))))) |
                                                static_cast<int32_T>(
                            static_cast<boolean_T>(static_cast<int32_T>((fileID
                              != 2.0) ^ 1)))))) {
                        b_NULL = NULL;
                    }

                    if (static_cast<boolean_T>(static_cast<int32_T>((b_NULL ==
                            NULL) ^ 1))) {
                        fseek(b_NULL, (long int)(carriageReturnAt - idx),
                              b_wherefrom);
                    }
                }

                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>
                                            (static_cast<boolean_T>(static_cast<
                        int32_T>((reachedEndOfFile != 0) | static_cast<int32_T>
                                 (readNewline)))) | (carriageReturnAt > 0)))) {
                    exitg1 = 1;
                }
            }
        } while (exitg1 == 0);

        filestar = NULL;
        b_NULL = FlightMissionMode_fileManager_b(fileID, localDW);
        if (b_NULL == filestar) {
            reachedEndOfFile = 0;
        } else {
            st = feof(b_NULL);
            reachedEndOfFile = ((int32_T)st != 0);
        }

        if (reachedEndOfFile == 0) {
            filestar = FlightMissionMode_fileManager_b(fileID, localDW);
            if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                    (static_cast<boolean_T>(static_cast<int32_T>
                    (static_cast<int32_T>(static_cast<boolean_T>
                      (static_cast<int32_T>((fileID != 0.0) ^ 1))) |
                     static_cast<int32_T>(static_cast<boolean_T>
                      (static_cast<int32_T>((fileID != 1.0) ^ 1)))))) |
                    static_cast<int32_T>(static_cast<boolean_T>
                    (static_cast<int32_T>((fileID != 2.0) ^ 1)))))) {
                filestar = NULL;
            }

            if (static_cast<boolean_T>(static_cast<int32_T>((filestar == NULL) ^
                  1))) {
                fread(&buf, sizeof(uint8_T), (size_t)1, filestar);
            }

            filestar = NULL;
            b_NULL = FlightMissionMode_fileManager_b(fileID, localDW);
            if (static_cast<boolean_T>(static_cast<int32_T>((b_NULL == filestar)
                  ^ 1))) {
                st = feof(b_NULL);
                reachedEndOfFile = ((int32_T)st != 0);
            }

            if (reachedEndOfFile == 0) {
                b_wherefrom = SEEK_CUR;
                filestar = FlightMissionMode_fileManager_b(fileID, localDW);
                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>(static_cast<
                        boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
                          static_cast<boolean_T>(static_cast<int32_T>((fileID !=
                             0.0) ^ 1))) | static_cast<int32_T>
                         (static_cast<boolean_T>(static_cast<int32_T>((fileID !=
                             1.0) ^ 1)))))) | static_cast<int32_T>
                                            (static_cast<boolean_T>
                        (static_cast<int32_T>((fileID != 2.0) ^ 1)))))) {
                    filestar = NULL;
                }

                if (static_cast<boolean_T>(static_cast<int32_T>((filestar ==
                        NULL) ^ 1))) {
                    fseek(filestar, (long int)-1.0, b_wherefrom);
                }
            }
        }
    }

    if (outBuff->size[1] == 0) {
        out->size[0] = 1;
        out->size[1] = 0;
    } else if (outBuff->data[static_cast<int32_T>(outBuff->size[1] - 1)] ==
               '\x0a') {
        if ((outBuff->size[1] > 1) && (outBuff->data[static_cast<int32_T>
                (outBuff->size[1] - 2)] == '\x0d')) {
            if (static_cast<int32_T>(outBuff->size[1] - 2) < 1) {
                reachedEndOfFile = -1;
            } else {
                reachedEndOfFile = static_cast<int32_T>(outBuff->size[1] - 3);
            }

            i = static_cast<int32_T>(out->size[0] * out->size[1]);
            out->size[0] = 1;
            out->size[1] = static_cast<int32_T>(reachedEndOfFile + 1);
            FlightMissionMode_emxEnsureCapacity_char_T_g(out, i);
            for (i = 0; i <= reachedEndOfFile; i++) {
                out->data[i] = outBuff->data[i];
            }
        } else {
            if (static_cast<int32_T>(outBuff->size[1] - 1) < 1) {
                reachedEndOfFile = -1;
            } else {
                reachedEndOfFile = static_cast<int32_T>(outBuff->size[1] - 2);
            }

            i = static_cast<int32_T>(out->size[0] * out->size[1]);
            out->size[0] = 1;
            out->size[1] = static_cast<int32_T>(reachedEndOfFile + 1);
            FlightMissionMode_emxEnsureCapacity_char_T_g(out, i);
            for (i = 0; i <= reachedEndOfFile; i++) {
                out->data[i] = outBuff->data[i];
            }
        }
    } else if (outBuff->data[static_cast<int32_T>(outBuff->size[1] - 1)] ==
               '\x0d') {
        if (static_cast<int32_T>(outBuff->size[1] - 1) < 1) {
            reachedEndOfFile = -1;
        } else {
            reachedEndOfFile = static_cast<int32_T>(outBuff->size[1] - 2);
        }

        i = static_cast<int32_T>(out->size[0] * out->size[1]);
        out->size[0] = 1;
        out->size[1] = static_cast<int32_T>(reachedEndOfFile + 1);
        FlightMissionMode_emxEnsureCapacity_char_T_g(out, i);
        for (i = 0; i <= reachedEndOfFile; i++) {
            out->data[i] = outBuff->data[i];
        }
    } else {
        i = static_cast<int32_T>(out->size[0] * out->size[1]);
        out->size[0] = 1;
        out->size[1] = outBuff->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_g(out, i);
        reachedEndOfFile = outBuff->size[1];
        for (i = 0; i <= static_cast<int32_T>(reachedEndOfFile - 1); i++) {
            out->data[i] = outBuff->data[i];
        }
    }

    FlightMissionMode_emxFree_char_T_o(&outBuff);
}

// Function for MATLAB Function: '<S10>/ReadHomePoint'
static void FlightMissionMode_strtrim_f(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    y)
{
    static const boolean_T d[128]{ false, false, false, false, false, false,
        false, false, false, true, true, true, true, true, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, true, true, true, true, true, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false };

    int32_T b_j1;
    int32_T i;
    int32_T j2;
    b_j1 = 0;
    while ((static_cast<int32_T>(b_j1 + 1) <= x->size[1]) &&
            (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(d[
               static_cast<int32_T>(static_cast<int32_T>(static_cast<uint8_T>
                 (x->data[b_j1])) & 127)]) & (x->data[b_j1] != '\x00'))))) {
        b_j1 = static_cast<int32_T>(b_j1 + 1);
    }

    j2 = static_cast<int32_T>(x->size[1] - 1);
    while ((static_cast<int32_T>(j2 + 1) > 0) && (static_cast<boolean_T>(
             static_cast<int32_T>(static_cast<int32_T>(d[static_cast<int32_T>(
                static_cast<int32_T>(static_cast<uint8_T>(x->data[j2])) & 127)])
              & (x->data[j2] != '\x00'))))) {
        j2 = static_cast<int32_T>(j2 - 1);
    }

    if (static_cast<int32_T>(b_j1 + 1) > static_cast<int32_T>(j2 + 1)) {
        b_j1 = 0;
        j2 = -1;
    }

    i = static_cast<int32_T>(y->size[0] * y->size[1]);
    y->size[0] = 1;
    j2 = static_cast<int32_T>(j2 - b_j1);
    y->size[1] = static_cast<int32_T>(j2 + 1);
    FlightMissionMode_emxEnsureCapacity_char_T_g(y, i);
    for (i = 0; i <= j2; i++) {
        y->data[i] = x->data[static_cast<int32_T>(b_j1 + i)];
    }
}

// Function for MATLAB Function: '<S10>/ReadHomePoint'
static boolean_T FlightMissionMode_strcmp_b(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[9]{ 'H', 'o', 'm', 'e', 'P', 'o', 'i', 'n', 't' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_ey(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_g(aTmp, i);
        loop_ub = a->size[1];
        for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 9) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 9) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_o(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S10>/ReadHomePoint'
static boolean_T FlightMissionMode_strcmp_bx(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[3]{ 'L', 'a', 't' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_ey(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_g(aTmp, i);
        loop_ub = a->size[1];
        for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 3) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 3) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_o(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S10>/ReadHomePoint'
static boolean_T FlightMissionMode_contains_d(const
    emxArray_char_T_FlightMissionMode_T *str)
{
    int32_T matchPos;
    matchPos = 0;
    int32_T exitg1;
    do {
        exitg1 = 0;
        if (matchPos <= static_cast<int32_T>(str->size[1] - 1)) {
            if (str->data[matchPos] == '=') {
                exitg1 = 1;
            } else {
                matchPos = static_cast<int32_T>(matchPos + 1);
            }
        } else {
            matchPos = -1;
            exitg1 = 1;
        }
    } while (exitg1 == 0);

    return static_cast<int32_T>(matchPos + 1) > 0;
}

// Function for MATLAB Function: '<S10>/ReadHomePoint'
static void FlightMissionMode_find_token_m(const
    emxArray_char_T_FlightMissionMode_T *x, int32_T *itoken, int32_T *iremain)
{
    int32_T n;
    n = x->size[1];
    *iremain = 1;
    while ((*iremain <= n) && (x->data[static_cast<int32_T>(*iremain - 1)] ==
                               '=')) {
        *iremain = static_cast<int32_T>(*iremain + 1);
    }

    *itoken = *iremain;
    while ((*iremain <= n) && (x->data[static_cast<int32_T>(*iremain - 1)] !=
                               '=')) {
        *iremain = static_cast<int32_T>(*iremain + 1);
    }
}

// Function for MATLAB Function: '<S10>/ReadHomePoint'
static void FlightMissionMode_strtok_dq4(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token, emxArray_char_T_FlightMissionMode_T *remain)
{
    int32_T b;
    int32_T c;
    int32_T i;
    int32_T iremain;
    int32_T itoken;
    FlightMissionMode_find_token_m(x, &itoken, &iremain);
    if (iremain > x->size[1]) {
        c = 0;
        b = 0;
    } else {
        c = static_cast<int32_T>(iremain - 1);
        b = x->size[1];
    }

    i = static_cast<int32_T>(remain->size[0] * remain->size[1]);
    remain->size[0] = 1;
    b = static_cast<int32_T>(b - c);
    remain->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T_g(remain, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        remain->data[i] = x->data[static_cast<int32_T>(c + i)];
    }

    if (itoken > static_cast<int32_T>(iremain - 1)) {
        itoken = 0;
        iremain = 0;
    } else {
        itoken = static_cast<int32_T>(itoken - 1);
        iremain = static_cast<int32_T>(iremain - 1);
    }

    i = static_cast<int32_T>(token->size[0] * token->size[1]);
    token->size[0] = 1;
    b = static_cast<int32_T>(iremain - itoken);
    token->size[1] = b;
    FlightMissionMode_emxEnsureCapacity_char_T_g(token, i);
    for (i = 0; i <= static_cast<int32_T>(b - 1); i++) {
        token->data[i] = x->data[static_cast<int32_T>(itoken + i)];
    }
}

// Function for MATLAB Function: '<S10>/ReadHomePoint'
static boolean_T FlightMissionMode_strcmp_bxk(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[3]{ 'L', 'o', 'n' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_ey(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_g(aTmp, i);
        loop_ub = a->size[1];
        for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 3) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 3) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_o(&aTmp);
    return b_bool;
}

static real_T FlightMissionMode_norm_p(const real_T x[2])
{
    real_T absxk;
    real_T scale;
    real_T t;
    real_T y;
    scale = 3.3121686421112381E-170;
    absxk = std::abs(x[0]);
    if (absxk > 3.3121686421112381E-170) {
        y = 1.0;
        scale = absxk;
    } else {
        t = absxk / 3.3121686421112381E-170;
        y = t * t;
    }

    absxk = std::abs(x[1]);
    if (absxk > scale) {
        t = scale / absxk;
        y = y * t * t + 1.0;
        scale = absxk;
    } else {
        t = absxk / scale;
        y += t * t;
    }

    return scale * std::sqrt(y);
}

// Function for MATLAB Function: '<S166>/WayPointGenerator'
static void FlightMissionMode_circshift(real_T a_data[], const int32_T a_size[2],
    real_T p)
{
    real_T a__1_data[512];
    int32_T dim;
    dim = (a_size[0] == 1);
    if (a_size[0] != 0) {
        int32_T a__1_size_idx_1_tmp;
        int32_T c;
        int32_T npages;
        int32_T ns;
        int32_T nv;
        int32_T stride;
        boolean_T shiftright;
        if (p < 0.0) {
            ns = static_cast<int32_T>(-static_cast<int32_T>(p));
            shiftright = false;
        } else {
            ns = static_cast<int32_T>(p);
            shiftright = true;
        }

        if (a_size[dim] <= 1) {
            ns = 0;
        } else {
            if (ns > a_size[dim]) {
                npages = a_size[dim];
                if (npages == 0) {
                    ns = 0;
                } else {
                    ns = static_cast<int32_T>(ns - static_cast<int32_T>(npages *
                        div_s32(ns, npages)));
                }
            }

            if (ns > static_cast<int32_T>(a_size[dim] >> 1)) {
                ns = static_cast<int32_T>(a_size[dim] - ns);
                shiftright = static_cast<boolean_T>(static_cast<int32_T>(
                    static_cast<int32_T>(shiftright) ^ 1));
            }
        }

        if (a_size[0] == 0) {
            npages = 0;
        } else if (a_size[0] >= 3) {
            npages = a_size[0];
        } else {
            npages = 3;
        }

        a__1_size_idx_1_tmp = static_cast<int32_T>(static_cast<int16_T>(
            static_cast<int32_T>(npages / 2)));
        for (npages = 0; npages <= static_cast<int32_T>(a__1_size_idx_1_tmp - 1);
             npages++) {
            a__1_data[npages] = 0.0;
        }

        c = a_size[dim];
        nv = a_size[dim];
        stride = 1;
        for (npages = 0; npages <= static_cast<int32_T>(dim - 1); npages++) {
            stride = static_cast<int32_T>(stride * a_size[0]);
        }

        npages = 1;
        for (a__1_size_idx_1_tmp = static_cast<int32_T>(dim + 2);
                a__1_size_idx_1_tmp < 3; a__1_size_idx_1_tmp++) {
            npages = static_cast<int32_T>(npages * 3);
        }

        a__1_size_idx_1_tmp = static_cast<int32_T>(stride * a_size[dim]);
        if ((a_size[dim] > 1) && (ns > 0)) {
            for (dim = 0; dim <= static_cast<int32_T>(npages - 1); dim++) {
                int32_T pageroot;
                pageroot = static_cast<int32_T>(dim * a__1_size_idx_1_tmp);
                for (int32_T j{0}; j <= static_cast<int32_T>(stride - 1); j++) {
                    int32_T i1;
                    i1 = static_cast<int32_T>(pageroot + j);
                    if (shiftright) {
                        for (int32_T f_k{0}; f_k <= static_cast<int32_T>(ns - 1);
                             f_k++) {
                            a__1_data[f_k] = a_data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>(
                                static_cast<int32_T>(f_k + c) - ns) * stride) +
                                i1)];
                        }

                        for (int32_T f_k{nv}; f_k >= static_cast<int32_T>(ns + 1);
                             f_k--) {
                            a_data[static_cast<int32_T>(i1 + static_cast<int32_T>
                                (static_cast<int32_T>(f_k - 1) * stride))] =
                                a_data[static_cast<int32_T>(static_cast<int32_T>
                                (static_cast<int32_T>(static_cast<int32_T>(f_k -
                                ns) - 1) * stride) + i1)];
                        }

                        for (int32_T f_k{0}; f_k <= static_cast<int32_T>(ns - 1);
                             f_k++) {
                            a_data[static_cast<int32_T>(i1 + static_cast<int32_T>
                                (f_k * stride))] = a__1_data[f_k];
                        }
                    } else {
                        int32_T g;
                        for (int32_T f_k{0}; f_k <= static_cast<int32_T>(ns - 1);
                             f_k++) {
                            a__1_data[f_k] = a_data[static_cast<int32_T>(
                                static_cast<int32_T>(f_k * stride) + i1)];
                        }

                        g = static_cast<int32_T>(static_cast<int32_T>(c - ns) -
                            1);
                        for (int32_T f_k{0}; f_k <= g; f_k++) {
                            a_data[static_cast<int32_T>(i1 + static_cast<int32_T>
                                (f_k * stride))] = a_data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>(f_k +
                                ns) * stride) + i1)];
                        }

                        for (int32_T f_k{0}; f_k <= static_cast<int32_T>(ns - 1);
                             f_k++) {
                            a_data[static_cast<int32_T>(i1 + static_cast<int32_T>
                                (static_cast<int32_T>(static_cast<int32_T>(f_k +
                                c) - ns) * stride))] = a__1_data[f_k];
                        }
                    }
                }
            }
        }
    }
}

// Function for MATLAB Function: '<S10>/ReadHomePoint'
static boolean_T FlightMissionMode_strcmp_bxki(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[3]{ 'A', 'l', 't' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_ey(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_g(aTmp, i);
        loop_ub = a->size[1];
        for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 3) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 3) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_o(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S166>/WayPointGenerator'
static void FlightMissionMode_sind(real_T x_data[], const int32_T *x_size)
{
    int32_T b;
    b = *x_size;
    for (int32_T k{0}; k <= static_cast<int32_T>(b - 1); k++) {
        if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(std::
                isinf(x_data[k])) | static_cast<int32_T>(std::isnan(x_data[k])))))
        {
            x_data[k] = (rtNaN);
        } else {
            real_T absx;
            real_T b_x;
            int8_T n;
            b_x = rt_remd_snf(x_data[k], 360.0);
            absx = std::abs(b_x);
            if (absx > 180.0) {
                if (b_x > 0.0) {
                    b_x -= 360.0;
                } else {
                    b_x += 360.0;
                }

                absx = std::abs(b_x);
            }

            if (absx <= 45.0) {
                b_x *= 0.017453292519943295;
                n = 0;
            } else if (absx <= 135.0) {
                if (b_x > 0.0) {
                    b_x = (b_x - 90.0) * 0.017453292519943295;
                    n = 1;
                } else {
                    b_x = (b_x + 90.0) * 0.017453292519943295;
                    n = -1;
                }
            } else if (b_x > 0.0) {
                b_x = (b_x - 180.0) * 0.017453292519943295;
                n = 2;
            } else {
                b_x = (b_x + 180.0) * 0.017453292519943295;
                n = -2;
            }

            switch (static_cast<int32_T>(n)) {
              case 0:
                x_data[k] = std::sin(b_x);
                break;

              case 1:
                x_data[k] = std::cos(b_x);
                break;

              case -1:
                x_data[k] = -std::cos(b_x);
                break;

              default:
                x_data[k] = -std::sin(b_x);
                break;
            }
        }
    }
}

// Function for MATLAB Function: '<S166>/WayPointGenerator'
static void FlightMissionMode_cosd(real_T x_data[], const int32_T *x_size)
{
    int32_T b;
    b = *x_size;
    for (int32_T k{0}; k <= static_cast<int32_T>(b - 1); k++) {
        if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(std::
                isinf(x_data[k])) | static_cast<int32_T>(std::isnan(x_data[k])))))
        {
            x_data[k] = (rtNaN);
        } else {
            real_T absx;
            real_T b_x;
            int8_T n;
            b_x = rt_remd_snf(x_data[k], 360.0);
            absx = std::abs(b_x);
            if (absx > 180.0) {
                if (b_x > 0.0) {
                    b_x -= 360.0;
                } else {
                    b_x += 360.0;
                }

                absx = std::abs(b_x);
            }

            if (absx <= 45.0) {
                b_x *= 0.017453292519943295;
                n = 0;
            } else if (absx <= 135.0) {
                if (b_x > 0.0) {
                    b_x = (b_x - 90.0) * 0.017453292519943295;
                    n = 1;
                } else {
                    b_x = (b_x + 90.0) * 0.017453292519943295;
                    n = -1;
                }
            } else if (b_x > 0.0) {
                b_x = (b_x - 180.0) * 0.017453292519943295;
                n = 2;
            } else {
                b_x = (b_x + 180.0) * 0.017453292519943295;
                n = -2;
            }

            switch (static_cast<int32_T>(n)) {
              case 0:
                x_data[k] = std::cos(b_x);
                break;

              case 1:
                x_data[k] = -std::sin(b_x);
                break;

              case -1:
                x_data[k] = std::sin(b_x);
                break;

              default:
                x_data[k] = -std::cos(b_x);
                break;
            }
        }
    }
}

static void FlightMissionMode_binary_expand_op_puhaq(real_T in1_data[], int32_T *
    in1_size, const real_T in2_data[], const int32_T *in2_size, const real_T
    in3_data[], const int32_T in3_size[2], DW_FlightMissionMode_f_T *localDW)
{
    int32_T in2_size_idx_0;
    int32_T loop_ub;
    int32_T stride_0_0;
    int32_T stride_1_0;
    int32_T stride_2_0;
    in2_size_idx_0 = *in1_size == 1 ? in3_size[0] == 1 ? *in2_size : in3_size[0]
        : *in1_size;
    stride_0_0 = (*in2_size != 1);
    stride_1_0 = (in3_size[0] != 1);
    stride_2_0 = (*in1_size != 1);
    loop_ub = *in1_size == 1 ? in3_size[0] == 1 ? *in2_size : in3_size[0] :
        *in1_size;
    for (int32_T i{0}; i <= static_cast<int32_T>(loop_ub - 1); i++) {
        localDW->in2_data_cv[i] = (in3_data[static_cast<int32_T>
            (static_cast<int32_T>(i * stride_1_0) + static_cast<int32_T>
             (in3_size[0] << 1))] + in2_data[static_cast<int32_T>(i * stride_0_0)])
            * in1_data[static_cast<int32_T>(i * stride_2_0)];
    }

    *in1_size = in2_size_idx_0;
    for (int32_T i{0}; i <= static_cast<int32_T>(in2_size_idx_0 - 1); i++) {
        in1_data[i] = localDW->in2_data_cv[i];
    }
}

static void FlightMissionMode_binary_expand_op_puha(real_T in1_data[], int32_T
    in1_size[2], const real_T in2_data[], const int32_T *in2_size, const real_T
    in3_data[], const int32_T *in3_size, const real_T in4_data[], const int32_T *
    in4_size, const real_T in5_data[], const int32_T *in5_size, const real_T
    in6_data[], const int32_T in6_size[2], const real_T in7_data[], const
    int32_T *in7_size, DW_FlightMissionMode_f_T *localDW)
{
    int32_T in2_size_idx_0;
    int32_T in2_size_idx_0_0;
    int32_T in5_size_idx_0;
    int32_T loop_ub;
    int32_T stride_0_0;
    int32_T stride_1_0;
    int32_T stride_2_0;
    in2_size_idx_0 = *in3_size == 1 ? *in2_size : *in3_size;
    stride_0_0 = (*in2_size != 1);
    stride_1_0 = (*in3_size != 1);
    loop_ub = *in3_size == 1 ? *in2_size : *in3_size;
    for (int32_T i{0}; i <= static_cast<int32_T>(loop_ub - 1); i++) {
        localDW->in2_data_c[i] = in2_data[static_cast<int32_T>(i * stride_0_0)] *
            in3_data[static_cast<int32_T>(i * stride_1_0)];
    }

    in2_size_idx_0_0 = *in4_size == 1 ? *in2_size : *in4_size;
    stride_0_0 = (*in2_size != 1);
    stride_1_0 = (*in4_size != 1);
    loop_ub = *in4_size == 1 ? *in2_size : *in4_size;
    for (int32_T i{0}; i <= static_cast<int32_T>(loop_ub - 1); i++) {
        localDW->in2_data_b[i] = in2_data[static_cast<int32_T>(i * stride_0_0)] *
            in4_data[static_cast<int32_T>(i * stride_1_0)];
    }

    in5_size_idx_0 = *in7_size == 1 ? in6_size[0] == 1 ? *in5_size : in6_size[0]
        : *in7_size;
    stride_0_0 = (*in5_size != 1);
    stride_1_0 = (in6_size[0] != 1);
    stride_2_0 = (*in7_size != 1);
    loop_ub = *in7_size == 1 ? in6_size[0] == 1 ? *in5_size : in6_size[0] :
        *in7_size;
    for (int32_T i{0}; i <= static_cast<int32_T>(loop_ub - 1); i++) {
        localDW->in5_data_p[i] = (in5_data[static_cast<int32_T>(i * stride_0_0)]
            * 0.99330562000985867 + in6_data[static_cast<int32_T>
            (static_cast<int32_T>(i * stride_1_0) + static_cast<int32_T>
             (in6_size[0] << 1))]) * in7_data[static_cast<int32_T>(i *
            stride_2_0)];
    }

    in1_size[0] = in2_size_idx_0;
    in1_size[1] = 3;
    for (int32_T i{0}; i <= static_cast<int32_T>(in2_size_idx_0 - 1); i++) {
        in1_data[i] = localDW->in2_data_c[i];
    }

    for (int32_T i{0}; i <= static_cast<int32_T>(in2_size_idx_0_0 - 1); i++) {
        in1_data[static_cast<int32_T>(i + in1_size[0])] = localDW->in2_data_b[i];
    }

    for (int32_T i{0}; i <= static_cast<int32_T>(in5_size_idx_0 - 1); i++) {
        in1_data[static_cast<int32_T>(i + static_cast<int32_T>(in1_size[0] << 1))]
            = localDW->in5_data_p[i];
    }
}

// Function for MATLAB Function: '<S166>/WayPointGenerator'
static void FlightMissionMode_lla2ecef(const real_T llaPos_data[], const int32_T
    llaPos_size[2], real_T ecefPos_data[], int32_T ecefPos_size[2],
    DW_FlightMissionMode_f_T *localDW)
{
    int32_T c_size;
    int32_T lambda_size;
    int32_T loop_ub;
    int32_T phi_size;
    int32_T sinphi_size;
    phi_size = llaPos_size[0];
    loop_ub = llaPos_size[0];
    for (int32_T k{0}; k <= static_cast<int32_T>(loop_ub - 1); k++) {
        localDW->phi_data_k[k] = llaPos_data[k];
    }

    lambda_size = llaPos_size[0];
    loop_ub = llaPos_size[0];
    for (int32_T k{0}; k <= static_cast<int32_T>(loop_ub - 1); k++) {
        localDW->lambda_data_c[k] = llaPos_data[static_cast<int32_T>(k +
            llaPos_size[0])];
    }

    sinphi_size = llaPos_size[0];
    loop_ub = llaPos_size[0];
    for (int32_T k{0}; k <= static_cast<int32_T>(loop_ub - 1); k++) {
        localDW->sinphi_data[k] = llaPos_data[k];
    }

    FlightMissionMode_sind(localDW->sinphi_data, &sinphi_size);
    for (int32_T k{0}; k <= static_cast<int32_T>(sinphi_size - 1); k++) {
        real_T varargin_1;
        varargin_1 = localDW->sinphi_data[k];
        localDW->N_data[k] = 1.0 - varargin_1 * varargin_1 *
            0.0066943799901413165;
    }

    for (int32_T k{0}; k <= static_cast<int32_T>(sinphi_size - 1); k++) {
        localDW->N_data[k] = std::sqrt(localDW->N_data[k]);
    }

    for (int32_T k{0}; k <= static_cast<int32_T>(sinphi_size - 1); k++) {
        localDW->N_data[k] = 6.378137E+6 / localDW->N_data[k];
    }

    FlightMissionMode_cosd(localDW->phi_data_k, &phi_size);
    if (static_cast<boolean_T>(static_cast<int32_T>(((sinphi_size == 1 ?
            llaPos_size[0] : sinphi_size) == phi_size) & (sinphi_size ==
            llaPos_size[0])))) {
        phi_size = sinphi_size;
        for (int32_T k{0}; k <= static_cast<int32_T>(sinphi_size - 1); k++) {
            localDW->phi_data_k[k] *= llaPos_data[static_cast<int32_T>(
                static_cast<int32_T>(llaPos_size[0] << 1) + k)] +
                localDW->N_data[k];
        }
    } else {
        FlightMissionMode_binary_expand_op_puhaq(localDW->phi_data_k, &phi_size,
            localDW->N_data, &sinphi_size, llaPos_data, llaPos_size, localDW);
    }

    c_size = llaPos_size[0];
    loop_ub = llaPos_size[0];
    for (int32_T k{0}; k <= static_cast<int32_T>(loop_ub - 1); k++) {
        localDW->c_data[k] = llaPos_data[static_cast<int32_T>(k + llaPos_size[0])];
    }

    FlightMissionMode_cosd(localDW->c_data, &c_size);
    FlightMissionMode_sind(localDW->lambda_data_c, &lambda_size);
    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
            static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
              static_cast<boolean_T>(static_cast<int32_T>((phi_size == c_size) &
                (phi_size == lambda_size)))) & (sinphi_size == llaPos_size[0]))))
          & ((sinphi_size == 1 ? llaPos_size[0] : sinphi_size) == sinphi_size))))
    {
        ecefPos_size[0] = phi_size;
        ecefPos_size[1] = 3;
        for (int32_T k{0}; k <= static_cast<int32_T>(phi_size - 1); k++) {
            ecefPos_data[k] = localDW->phi_data_k[k] * localDW->c_data[k];
        }

        for (int32_T k{0}; k <= static_cast<int32_T>(phi_size - 1); k++) {
            ecefPos_data[static_cast<int32_T>(k + ecefPos_size[0])] =
                localDW->phi_data_k[k] * localDW->lambda_data_c[k];
        }

        for (int32_T k{0}; k <= static_cast<int32_T>(sinphi_size - 1); k++) {
            ecefPos_data[static_cast<int32_T>(k + static_cast<int32_T>
                (ecefPos_size[0] << 1))] = (llaPos_data[static_cast<int32_T>(
                static_cast<int32_T>(llaPos_size[0] << 1) + k)] +
                localDW->N_data[k] * 0.99330562000985867) * localDW->
                sinphi_data[k];
        }
    } else {
        FlightMissionMode_binary_expand_op_puha(ecefPos_data, ecefPos_size,
            localDW->phi_data_k, &phi_size, localDW->c_data, &c_size,
            localDW->lambda_data_c, &lambda_size, localDW->N_data, &sinphi_size,
            llaPos_data, llaPos_size, localDW->sinphi_data, &sinphi_size,
            localDW);
    }
}

static void FlightMissionMode_minus_l(real_T in1_data[], int32_T in1_size[2],
    const real_T in2_data[], const int32_T in2_size[2], DW_FlightMissionMode_f_T
    *localDW)
{
    int32_T in1_size_idx_0;
    int32_T loop_ub;
    int32_T stride_0_0;
    int32_T stride_1_0;
    in1_size_idx_0 = in2_size[0] == 1 ? in1_size[0] : in2_size[0];
    stride_0_0 = (in1_size[0] != 1);
    stride_1_0 = (in2_size[0] != 1);
    loop_ub = in2_size[0] == 1 ? in1_size[0] : in2_size[0];
    for (int32_T i_0{0}; i_0 < 3; i_0++) {
        for (int32_T i{0}; i <= static_cast<int32_T>(loop_ub - 1); i++) {
            localDW->in1_data[static_cast<int32_T>(i + static_cast<int32_T>
                (in1_size_idx_0 * i_0))] = in1_data[static_cast<int32_T>(
                static_cast<int32_T>(i * stride_0_0) + static_cast<int32_T>
                (in1_size[0] * i_0))] - in2_data[static_cast<int32_T>(
                static_cast<int32_T>(i * stride_1_0) + static_cast<int32_T>
                (in2_size[0] * i_0))];
        }
    }

    in1_size[0] = in1_size_idx_0;
    in1_size[1] = 3;
    for (int32_T i_0{0}; i_0 < 3; i_0++) {
        for (int32_T i{0}; i <= static_cast<int32_T>(in1_size_idx_0 - 1); i++) {
            in1_data[static_cast<int32_T>(i + static_cast<int32_T>(in1_size[0] *
                i_0))] = localDW->in1_data[static_cast<int32_T>
                (static_cast<int32_T>(in1_size_idx_0 * i_0) + i)];
        }
    }
}

static void FlightMissionMode_binary_expand_op_puh(real_T in1_data[], int32_T
    *in1_size, const real_T in2_data[], const int32_T *in2_size, const real_T
    in3_data[], const int32_T in3_size[2], const real_T in4_data[], const
    int32_T *in4_size)
{
    int32_T loop_ub;
    int32_T stride_0_0;
    int32_T stride_1_0;
    int32_T stride_2_0;
    int32_T stride_3_0;
    *in1_size = (in3_size[0] == 1 ? *in4_size : in3_size[0]) == 1 ? in3_size[0] ==
        1 ? *in2_size : in3_size[0] : in3_size[0] == 1 ? *in4_size : in3_size[0];
    stride_0_0 = (*in2_size != 1);
    stride_1_0 = (in3_size[0] != 1);
    stride_2_0 = (*in4_size != 1);
    stride_3_0 = (in3_size[0] != 1);
    loop_ub = (in3_size[0] == 1 ? *in4_size : in3_size[0]) == 1 ? in3_size[0] ==
        1 ? *in2_size : in3_size[0] : in3_size[0] == 1 ? *in4_size : in3_size[0];
    for (int32_T i{0}; i <= static_cast<int32_T>(loop_ub - 1); i++) {
        in1_data[i] = in3_data[static_cast<int32_T>(static_cast<int32_T>(i *
            stride_3_0) + in3_size[0])] * in4_data[static_cast<int32_T>(i *
            stride_2_0)] + in2_data[static_cast<int32_T>(i * stride_0_0)] *
            in3_data[static_cast<int32_T>(i * stride_1_0)];
    }
}

static void FlightMissionMode_binary_expand_op_pu(real_T in1_data[], int32_T
    in1_size[2], const real_T in2_data[], const int32_T *in2_size, const real_T
    in3_data[], const int32_T in3_size[2], const real_T in4_data[], const
    int32_T *in4_size, const real_T in5_data[], const int32_T *in5_size, const
    real_T in6_data[], const int32_T *in6_size, const real_T in7_data[], const
    int32_T *in7_size, DW_FlightMissionMode_f_T *localDW)
{
    int32_T in2_size_idx_0;
    int32_T in5_size_idx_0;
    int32_T in7_size_idx_0;
    int32_T loop_ub;
    int32_T stride_0_0;
    int32_T stride_1_0;
    int32_T stride_2_0;
    int32_T stride_3_0;
    in2_size_idx_0 = (in3_size[0] == 1 ? *in4_size : in3_size[0]) == 1 ?
        in3_size[0] == 1 ? *in2_size : in3_size[0] : in3_size[0] == 1 ?
        *in4_size : in3_size[0];
    stride_0_0 = (*in2_size != 1);
    stride_1_0 = (in3_size[0] != 1);
    stride_2_0 = (*in4_size != 1);
    stride_3_0 = (in3_size[0] != 1);
    loop_ub = (in3_size[0] == 1 ? *in4_size : in3_size[0]) == 1 ? in3_size[0] ==
        1 ? *in2_size : in3_size[0] : in3_size[0] == 1 ? *in4_size : in3_size[0];
    for (int32_T i{0}; i <= static_cast<int32_T>(loop_ub - 1); i++) {
        localDW->in2_data[i] = in3_data[static_cast<int32_T>(static_cast<int32_T>
            (i * stride_3_0) + in3_size[0])] * in4_data[static_cast<int32_T>(i *
            stride_2_0)] + -in2_data[static_cast<int32_T>(i * stride_0_0)] *
            in3_data[static_cast<int32_T>(i * stride_1_0)];
    }

    in5_size_idx_0 = (in3_size[0] == 1 ? *in7_size : in3_size[0]) == 1 ?
        *in6_size == 1 ? *in5_size : *in6_size : in3_size[0] == 1 ? *in7_size :
        in3_size[0];
    stride_0_0 = (*in5_size != 1);
    stride_1_0 = (*in6_size != 1);
    stride_2_0 = (*in7_size != 1);
    stride_3_0 = (in3_size[0] != 1);
    loop_ub = (in3_size[0] == 1 ? *in7_size : in3_size[0]) == 1 ? *in6_size == 1
        ? *in5_size : *in6_size : in3_size[0] == 1 ? *in7_size : in3_size[0];
    for (int32_T i{0}; i <= static_cast<int32_T>(loop_ub - 1); i++) {
        localDW->in5_data[i] = in3_data[static_cast<int32_T>(static_cast<int32_T>
            (i * stride_3_0) + static_cast<int32_T>(in3_size[0] << 1))] *
            in7_data[static_cast<int32_T>(i * stride_2_0)] + -in5_data[
            static_cast<int32_T>(i * stride_0_0)] * in6_data[static_cast<int32_T>
            (i * stride_1_0)];
    }

    in7_size_idx_0 = (in3_size[0] == 1 ? *in5_size : in3_size[0]) == 1 ?
        *in6_size == 1 ? *in7_size : *in6_size : in3_size[0] == 1 ? *in5_size :
        in3_size[0];
    stride_0_0 = (*in7_size != 1);
    stride_1_0 = (*in6_size != 1);
    stride_2_0 = (*in5_size != 1);
    stride_3_0 = (in3_size[0] != 1);
    loop_ub = (in3_size[0] == 1 ? *in5_size : in3_size[0]) == 1 ? *in6_size == 1
        ? *in7_size : *in6_size : in3_size[0] == 1 ? *in5_size : in3_size[0];
    for (int32_T i{0}; i <= static_cast<int32_T>(loop_ub - 1); i++) {
        localDW->in7_data[i] = in3_data[static_cast<int32_T>(static_cast<int32_T>
            (i * stride_3_0) + static_cast<int32_T>(in3_size[0] << 1))] *
            in5_data[static_cast<int32_T>(i * stride_2_0)] + in7_data[
            static_cast<int32_T>(i * stride_0_0)] * in6_data[static_cast<int32_T>
            (i * stride_1_0)];
    }

    in1_size[0] = in2_size_idx_0;
    in1_size[1] = 3;
    for (int32_T i{0}; i <= static_cast<int32_T>(in2_size_idx_0 - 1); i++) {
        in1_data[i] = localDW->in2_data[i];
    }

    for (int32_T i{0}; i <= static_cast<int32_T>(in5_size_idx_0 - 1); i++) {
        in1_data[static_cast<int32_T>(i + in1_size[0])] = localDW->in5_data[i];
    }

    for (int32_T i{0}; i <= static_cast<int32_T>(in7_size_idx_0 - 1); i++) {
        in1_data[static_cast<int32_T>(i + static_cast<int32_T>(in1_size[0] << 1))]
            = localDW->in7_data[i];
    }
}

// Function for MATLAB Function: '<S166>/WayPointGenerator'
static void FlightMissionMode_lla2ned(const real_T lla_data[], const int32_T
    lla_size[2], const real_T lla0[3], real_T xyzNED_data[], int32_T
    xyzNED_size[2], DW_FlightMissionMode_f_T *localDW)
{
    int32_T ecefPosWithENUOrigin_size[2];
    int32_T lla0tmp_size[2];
    int32_T llatmp_size[2];
    int32_T coslambda_size;
    int32_T cosphi_size;
    int32_T iacol;
    int32_T idx;
    int32_T k;
    int32_T llatmp_data_tmp;
    int32_T nrows;
    if (static_cast<int32_T>(static_cast<int16_T>(lla_size[0])) > 1) {
        nrows = 1;
        idx = 2;
    } else {
        nrows = static_cast<int32_T>(static_cast<int16_T>(lla_size[0]));
        idx = 1;
    }

    if (((nrows != 1) && (lla_size[0] != 1)) || (!(lla_size[0] == 1))) {
    } else {
        idx = 0;
    }

    switch (idx) {
      case 1:
        llatmp_size[0] = static_cast<int32_T>(static_cast<int16_T>(lla_size[0]));
        llatmp_size[1] = 3;
        nrows = lla_size[0];
        lla0tmp_size[0] = 1;
        lla0tmp_size[1] = 3;
        for (idx = 0; idx < 3; idx++) {
            iacol = static_cast<int32_T>(idx * nrows);
            for (k = 0; k <= static_cast<int32_T>(nrows - 1); k++) {
                llatmp_data_tmp = static_cast<int32_T>(iacol + k);
                localDW->llatmp_data[llatmp_data_tmp] = lla_data[llatmp_data_tmp];
            }

            localDW->lla0tmp_data[idx] = lla0[idx];
        }
        break;

      case 2:
        lla0tmp_size[0] = static_cast<int32_T>(static_cast<int16_T>(lla_size[0]));
        lla0tmp_size[1] = 3;
        nrows = lla_size[0];
        for (idx = 0; idx < 3; idx++) {
            iacol = static_cast<int32_T>(idx * nrows);
            for (k = 0; k <= static_cast<int32_T>(nrows - 1); k++) {
                localDW->lla0tmp_data[static_cast<int32_T>(iacol + k)] =
                    lla0[idx];
            }
        }

        llatmp_size[0] = lla_size[0];
        llatmp_size[1] = 3;
        nrows = static_cast<int32_T>(lla_size[0] * 3);
        for (idx = 0; idx <= static_cast<int32_T>(nrows - 1); idx++) {
            localDW->llatmp_data[idx] = lla_data[idx];
        }
        break;

      default:
        llatmp_size[0] = lla_size[0];
        llatmp_size[1] = 3;
        nrows = static_cast<int32_T>(lla_size[0] * 3);
        for (idx = 0; idx <= static_cast<int32_T>(nrows - 1); idx++) {
            localDW->llatmp_data[idx] = lla_data[idx];
        }

        lla0tmp_size[0] = 1;
        lla0tmp_size[1] = 3;
        localDW->lla0tmp_data[0] = lla0[0];
        localDW->lla0tmp_data[1] = lla0[1];
        localDW->lla0tmp_data[2] = lla0[2];
        break;
    }

    FlightMissionMode_lla2ecef(localDW->llatmp_data, llatmp_size,
        localDW->ecefPosWithENUOrigin_data, ecefPosWithENUOrigin_size, localDW);
    iacol = lla0tmp_size[0];
    nrows = lla0tmp_size[0];
    for (idx = 0; idx <= static_cast<int32_T>(nrows - 1); idx++) {
        localDW->phi_data[idx] = localDW->lla0tmp_data[idx];
    }

    llatmp_data_tmp = lla0tmp_size[0];
    nrows = lla0tmp_size[0];
    for (idx = 0; idx <= static_cast<int32_T>(nrows - 1); idx++) {
        localDW->lambda_data[idx] = localDW->lla0tmp_data[static_cast<int32_T>
            (idx + lla0tmp_size[0])];
    }

    cosphi_size = lla0tmp_size[0];
    nrows = lla0tmp_size[0];
    for (idx = 0; idx <= static_cast<int32_T>(nrows - 1); idx++) {
        localDW->cosphi_data[idx] = localDW->lla0tmp_data[idx];
    }

    FlightMissionMode_cosd(localDW->cosphi_data, &cosphi_size);
    FlightMissionMode_sind(localDW->phi_data, &iacol);
    coslambda_size = lla0tmp_size[0];
    nrows = lla0tmp_size[0];
    for (idx = 0; idx <= static_cast<int32_T>(nrows - 1); idx++) {
        localDW->coslambda_data[idx] = localDW->lla0tmp_data[static_cast<int32_T>
            (idx + lla0tmp_size[0])];
    }

    FlightMissionMode_cosd(localDW->coslambda_data, &coslambda_size);
    FlightMissionMode_sind(localDW->lambda_data, &llatmp_data_tmp);
    FlightMissionMode_lla2ecef(localDW->lla0tmp_data, lla0tmp_size,
        localDW->llatmp_data, llatmp_size, localDW);
    if (ecefPosWithENUOrigin_size[0] == llatmp_size[0]) {
        nrows = static_cast<int32_T>(ecefPosWithENUOrigin_size[0] * 3);
        ecefPosWithENUOrigin_size[1] = 3;
        for (k = 0; k <= static_cast<int32_T>(nrows - 1); k++) {
            localDW->ecefPosWithENUOrigin_data[k] -= localDW->llatmp_data[k];
        }
    } else {
        FlightMissionMode_minus_l(localDW->ecefPosWithENUOrigin_data,
            ecefPosWithENUOrigin_size, localDW->llatmp_data, llatmp_size,
            localDW);
    }

    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
            static_cast<boolean_T>(static_cast<int32_T>((coslambda_size ==
              ecefPosWithENUOrigin_size[0]) & (llatmp_data_tmp ==
              ecefPosWithENUOrigin_size[0])))) & ((coslambda_size == 1 ?
            ecefPosWithENUOrigin_size[0] : coslambda_size) == (llatmp_data_tmp ==
            1 ? ecefPosWithENUOrigin_size[0] : llatmp_data_tmp))))) {
        k = coslambda_size;
        for (idx = 0; idx <= static_cast<int32_T>(coslambda_size - 1); idx++) {
            localDW->tmp_data[idx] = localDW->ecefPosWithENUOrigin_data[
                static_cast<int32_T>(idx + ecefPosWithENUOrigin_size[0])] *
                localDW->lambda_data[idx] + localDW->coslambda_data[idx] *
                localDW->ecefPosWithENUOrigin_data[idx];
        }
    } else {
        FlightMissionMode_binary_expand_op_puh(localDW->tmp_data, &k,
            localDW->coslambda_data, &coslambda_size,
            localDW->ecefPosWithENUOrigin_data, ecefPosWithENUOrigin_size,
            localDW->lambda_data, &llatmp_data_tmp);
    }

    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
            static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
              static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
                 static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                   (static_cast<boolean_T>(static_cast<int32_T>
                     (static_cast<int32_T>(static_cast<boolean_T>
                       (static_cast<int32_T>(static_cast<int32_T>
                         (static_cast<boolean_T>(static_cast<int32_T>(
            static_cast<int32_T>(static_cast<boolean_T>(static_cast<int32_T>
            ((llatmp_data_tmp == ecefPosWithENUOrigin_size[0]) & (coslambda_size
        == ecefPosWithENUOrigin_size[0])))) & ((llatmp_data_tmp == 1 ?
            ecefPosWithENUOrigin_size[0] : llatmp_data_tmp) == (coslambda_size ==
        1 ? ecefPosWithENUOrigin_size[0] : coslambda_size))))) & (iacol == k))))
                      & (cosphi_size == ecefPosWithENUOrigin_size[0])))) &
                   ((iacol == 1 ? k : iacol) == (cosphi_size == 1 ?
                     ecefPosWithENUOrigin_size[0] : cosphi_size))))) &
                (cosphi_size == k)))) & (iacol == ecefPosWithENUOrigin_size[0]))))
          & ((cosphi_size == 1 ? k : cosphi_size) == (iacol == 1 ?
            ecefPosWithENUOrigin_size[0] : iacol))))) {
        llatmp_size[0] = llatmp_data_tmp;
        for (idx = 0; idx <= static_cast<int32_T>(llatmp_data_tmp - 1); idx++) {
            localDW->llatmp_data[idx] = localDW->ecefPosWithENUOrigin_data[
                static_cast<int32_T>(idx + ecefPosWithENUOrigin_size[0])] *
                localDW->coslambda_data[idx] + -localDW->lambda_data[idx] *
                localDW->ecefPosWithENUOrigin_data[idx];
        }

        for (idx = 0; idx <= static_cast<int32_T>(iacol - 1); idx++) {
            localDW->llatmp_data[static_cast<int32_T>(idx + llatmp_size[0])] =
                localDW->ecefPosWithENUOrigin_data[static_cast<int32_T>(
                static_cast<int32_T>(ecefPosWithENUOrigin_size[0] << 1) + idx)] *
                localDW->cosphi_data[idx] + -localDW->phi_data[idx] *
                localDW->tmp_data[idx];
        }

        for (idx = 0; idx <= static_cast<int32_T>(cosphi_size - 1); idx++) {
            localDW->llatmp_data[static_cast<int32_T>(idx + static_cast<int32_T>
                (llatmp_size[0] << 1))] = localDW->ecefPosWithENUOrigin_data[
                static_cast<int32_T>(static_cast<int32_T>
                (ecefPosWithENUOrigin_size[0] << 1) + idx)] * localDW->
                phi_data[idx] + localDW->cosphi_data[idx] * localDW->
                tmp_data[idx];
        }
    } else {
        FlightMissionMode_binary_expand_op_pu(localDW->llatmp_data, llatmp_size,
            localDW->lambda_data, &llatmp_data_tmp,
            localDW->ecefPosWithENUOrigin_data, ecefPosWithENUOrigin_size,
            localDW->coslambda_data, &coslambda_size, localDW->phi_data, &iacol,
            localDW->tmp_data, &k, localDW->cosphi_data, &cosphi_size, localDW);
    }

    xyzNED_size[0] = static_cast<int32_T>(static_cast<int16_T>(llatmp_size[0]));
    xyzNED_size[1] = 3;
    nrows = static_cast<int32_T>(static_cast<int32_T>(static_cast<int16_T>
        (llatmp_size[0])) * 3);
    for (idx = 0; idx <= static_cast<int32_T>(nrows - 1); idx++) {
        xyzNED_data[idx] = 0.0;
    }

    nrows = llatmp_size[0];
    for (idx = 0; idx <= static_cast<int32_T>(nrows - 1); idx++) {
        xyzNED_data[idx] = localDW->llatmp_data[static_cast<int32_T>(idx +
            llatmp_size[0])];
    }

    nrows = llatmp_size[0];
    for (idx = 0; idx <= static_cast<int32_T>(nrows - 1); idx++) {
        xyzNED_data[static_cast<int32_T>(idx + xyzNED_size[0])] =
            localDW->llatmp_data[idx];
    }

    nrows = llatmp_size[0];
    for (idx = 0; idx <= static_cast<int32_T>(nrows - 1); idx++) {
        xyzNED_data[static_cast<int32_T>(idx + static_cast<int32_T>(xyzNED_size
            [0] << 1))] = -localDW->llatmp_data[static_cast<int32_T>(
            static_cast<int32_T>(llatmp_size[0] << 1) + idx)];
    }
}

static real_T FlightMissionMode_norm_pv(const real_T x[3])
{
    real_T absxk;
    real_T scale;
    real_T t;
    real_T y;
    scale = 3.3121686421112381E-170;
    absxk = std::abs(x[0]);
    if (absxk > 3.3121686421112381E-170) {
        y = 1.0;
        scale = absxk;
    } else {
        t = absxk / 3.3121686421112381E-170;
        y = t * t;
    }

    absxk = std::abs(x[1]);
    if (absxk > scale) {
        t = scale / absxk;
        y = y * t * t + 1.0;
        scale = absxk;
    } else {
        t = absxk / scale;
        y += t * t;
    }

    absxk = std::abs(x[2]);
    if (absxk > scale) {
        t = scale / absxk;
        y = y * t * t + 1.0;
        scale = absxk;
    } else {
        t = absxk / scale;
        y += t * t;
    }

    return scale * std::sqrt(y);
}

static void FlightMissionMode_WaypointFollowerBase_searchClosestPath
    (uav_sluav_internal_system_WaypointFollower_FlightMissionMode_cc_T *obj,
     const emxArray_real_T_FlightMissionMode_T *waypoints, const real_T
     currentPose[4])
{
    emxArray_real_T_FlightMissionMode_T *d;
    real_T currentPose_0[3];
    real_T lambda;
    real_T lambda_tmp_tmp;
    int32_T b_idx;
    int32_T b_k;
    int32_T last;
    FlightMissionMode_emxInit_real_T_h(&d, 2);
    b_k = static_cast<int32_T>(d->size[0] * d->size[1]);
    d->size[0] = 1;
    last = static_cast<int32_T>(obj->NumWaypoints - 1.0);
    d->size[1] = static_cast<int32_T>(obj->NumWaypoints - 1.0);
    FlightMissionMode_emxEnsureCapacity_real_T_c(d, b_k);
    for (b_k = 0; b_k <= static_cast<int32_T>(last - 1); b_k++) {
        d->data[b_k] = 0.0;
    }

    last = static_cast<int32_T>(static_cast<int32_T>(obj->NumWaypoints - 1.0) -
        1);
    for (b_k = 0; b_k <= last; b_k++) {
        real_T lambda_tmp;
        real_T lambda_tmp_0;
        real_T lambda_tmp_tmp_0;
        real_T lambda_tmp_tmp_tmp;
        real_T waypoints_tmp;
        lambda_tmp_tmp = waypoints->data[static_cast<int32_T>
            (static_cast<int32_T>((static_cast<real_T>(b_k) + 1.0) + 1.0) - 1)]
            - waypoints->data[b_k];
        lambda_tmp = waypoints->data[static_cast<int32_T>(static_cast<int32_T>(
            static_cast<int32_T>((static_cast<real_T>(b_k) + 1.0) + 1.0) +
            waypoints->size[0]) - 1)] - waypoints->data[static_cast<int32_T>(b_k
            + waypoints->size[0])];
        waypoints_tmp = waypoints->data[static_cast<int32_T>(static_cast<int32_T>
            (static_cast<int32_T>((static_cast<real_T>(b_k) + 1.0) + 1.0) +
             waypoints->size[0]) - 1)];
        lambda_tmp_tmp_tmp = waypoints->data[static_cast<int32_T>
            (static_cast<int32_T>(static_cast<int32_T>((static_cast<real_T>(b_k)
                + 1.0) + 1.0) + static_cast<int32_T>(waypoints->size[0] << 1)) -
             1)];
        lambda_tmp_tmp_0 = lambda_tmp_tmp_tmp - waypoints->data
            [static_cast<int32_T>(static_cast<int32_T>(waypoints->size[0] << 1)
            + b_k)];
        lambda_tmp_0 = currentPose[2] - waypoints->data[static_cast<int32_T>(
            static_cast<int32_T>(waypoints->size[0] << 1) + b_k)];
        lambda = (((currentPose[1] - waypoints->data[static_cast<int32_T>(b_k +
                     waypoints->size[0])]) * lambda_tmp + (currentPose[0] -
                    waypoints->data[b_k]) * lambda_tmp_tmp) + lambda_tmp_0 *
                  lambda_tmp_tmp_0) / (((waypoints_tmp - waypoints->data[
            static_cast<int32_T>(b_k + waypoints->size[0])]) * lambda_tmp +
            lambda_tmp_tmp * lambda_tmp_tmp) + lambda_tmp_tmp_0 *
            lambda_tmp_tmp_0);
        if (lambda < 0.0) {
            currentPose_0[0] = currentPose[0] - waypoints->data[b_k];
            currentPose_0[1] = currentPose[1] - waypoints->data[static_cast<
                int32_T>(b_k + waypoints->size[0])];
            currentPose_0[2] = lambda_tmp_0;
            d->data[b_k] = FlightMissionMode_norm_pv(currentPose_0);
        } else if (lambda > 1.0) {
            currentPose_0[0] = currentPose[0] - waypoints->data
                [static_cast<int32_T>(static_cast<int32_T>((static_cast<real_T>
                (b_k) + 1.0) + 1.0) - 1)];
            currentPose_0[1] = currentPose[1] - waypoints_tmp;
            currentPose_0[2] = currentPose[2] - lambda_tmp_tmp_tmp;
            d->data[b_k] = FlightMissionMode_norm_pv(currentPose_0);
        } else {
            currentPose_0[0] = currentPose[0] - (lambda * lambda_tmp_tmp +
                waypoints->data[b_k]);
            currentPose_0[1] = currentPose[1] - (lambda * lambda_tmp +
                waypoints->data[static_cast<int32_T>(b_k + waypoints->size[0])]);
            currentPose_0[2] = currentPose[2] - (waypoints->data
                [static_cast<int32_T>(static_cast<int32_T>(waypoints->size[0] <<
                1) + b_k)] + lambda * lambda_tmp_tmp_0);
            d->data[b_k] = FlightMissionMode_norm_pv(currentPose_0);
        }
    }

    last = d->size[1];
    if (d->size[1] <= 2) {
        if (d->size[1] == 1) {
            b_idx = 1;
        } else if ((d->data[0] > d->data[static_cast<int32_T>(d->size[1] - 1)]) ||
                   (std::isnan(d->data[0]) && (static_cast<boolean_T>(
                      static_cast<int32_T>(static_cast<int32_T>(std::isnan
                        (d->data[static_cast<int32_T>(d->size[1] - 1)])) ^ 1)))))
        {
            b_idx = d->size[1];
        } else {
            b_idx = 1;
        }
    } else {
        if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(std::
                isnan(d->data[0])) ^ 1))) {
            b_idx = 1;
        } else {
            boolean_T exitg1;
            b_idx = 0;
            b_k = 2;
            exitg1 = false;
            while ((!exitg1) && (b_k <= last)) {
                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>(std::isnan
                        (d->data[static_cast<int32_T>(b_k - 1)])) ^ 1))) {
                    b_idx = b_k;
                    exitg1 = true;
                } else {
                    b_k = static_cast<int32_T>(b_k + 1);
                }
            }
        }

        if (b_idx == 0) {
            b_idx = 1;
        } else {
            int32_T b;
            lambda = d->data[static_cast<int32_T>(b_idx - 1)];
            b = b_idx;
            for (b_k = static_cast<int32_T>(b + 1); b_k <= last; b_k++) {
                lambda_tmp_tmp = d->data[static_cast<int32_T>(b_k - 1)];
                if (lambda > lambda_tmp_tmp) {
                    lambda = lambda_tmp_tmp;
                    b_idx = b_k;
                }
            }
        }
    }

    FlightMissionMode_emxFree_real_T_n(&d);
    obj->WaypointIndex = static_cast<real_T>(b_idx);
    obj->SearchFlag = false;
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static int8_T FlightMissionMode_filedata_ei(DW_FlightMissionMode_f_T *localDW)
{
    int32_T k;
    int8_T f;
    boolean_T exitg1;
    f = 0;
    k = 1;
    exitg1 = false;
    while ((!exitg1) && (static_cast<int32_T>(k - 1) < 20)) {
        if (localDW->eml_openfiles_k[static_cast<int32_T>(static_cast<int32_T>(
                static_cast<int8_T>(k)) - 1)] == NULL) {
            f = static_cast<int8_T>(k);
            exitg1 = true;
        } else {
            k = static_cast<int32_T>(k + 1);
        }
    }

    return f;
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static int8_T FlightMissionMode_cfopen_j0(const char_T *cfilename, const char_T *
    cpermission, DW_FlightMissionMode_f_T *localDW)
{
    int8_T fileid;
    int8_T j;
    fileid = -1;
    j = FlightMissionMode_filedata_ei(localDW);
    if (static_cast<int32_T>(j) >= 1) {
        FILE* filestar;
        filestar = fopen(cfilename, cpermission);
        if (filestar != NULL) {
            int32_T tmp;
            localDW->eml_openfiles_k[static_cast<int32_T>(static_cast<int32_T>(j)
                - 1)] = filestar;
            tmp = static_cast<int32_T>(static_cast<int32_T>(j) + 2);
            if (static_cast<int32_T>(static_cast<int32_T>(j) + 2) > 127) {
                tmp = 127;
            }

            fileid = static_cast<int8_T>(tmp);
        }
    }

    return fileid;
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static real_T FlightMissionMode_fileManager_f(DW_FlightMissionMode_f_T *localDW)
{
    real_T f;
    int8_T fileid;
    fileid = FlightMissionMode_cfopen_j0("config.ini", "rb", localDW);
    f = static_cast<real_T>(fileid);
    return f;
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static void FlightMissionMode_fread_n(real_T fileID,
    emxArray_char_T_FlightMissionMode_T *A, DW_FlightMissionMode_f_T *localDW)
{
    FILE* filestar;
    size_t nBytes;
    char_T tbuf[1024];
    int8_T fileid;
    nBytes = sizeof(char_T);
    fileid = static_cast<int8_T>(fileID);
    if (fileID != static_cast<real_T>(static_cast<int8_T>(fileID))) {
        fileid = -1;
    }

    if (static_cast<int32_T>(fileid) >= 3) {
        filestar = localDW->eml_openfiles_k[static_cast<int32_T>
            (static_cast<int32_T>(fileid) - 3)];
    } else {
        switch (static_cast<int32_T>(fileid)) {
          case 0:
            filestar = stdin;
            break;

          case 1:
            filestar = stdout;
            break;

          case 2:
            filestar = stderr;
            break;

          default:
            filestar = NULL;
            break;
        }
    }

    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
            static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
              static_cast<boolean_T>(static_cast<int32_T>((fileID != 0.0) ^ 1)))
             | static_cast<int32_T>(static_cast<boolean_T>(static_cast<int32_T>
               ((fileID != 1.0) ^ 1)))))) | static_cast<int32_T>
            (static_cast<boolean_T>(static_cast<int32_T>((fileID != 2.0) ^ 1))))))
    {
        filestar = NULL;
    }

    A->size[0] = 0;
    if (static_cast<boolean_T>(static_cast<int32_T>((filestar == NULL) ^ 1))) {
        int32_T c;
        c = 1;
        while (c > 0) {
            int32_T i;
            int32_T loop_ub;
            int32_T numRead;
            int32_T tmp;
            c = 0;
            numRead = 1;
            while (static_cast<boolean_T>(static_cast<int32_T>((c < 1024) &
                     (numRead > 0)))) {
                size_t numReadSizeT;
                numReadSizeT = fread(&tbuf[c], nBytes, (size_t)(1024 - c),
                                     filestar);
                numRead = (int32_T)numReadSizeT;
                c = static_cast<int32_T>(c + (int32_T)numReadSizeT);
            }

            numRead = A->size[0];
            if (c < 1) {
                i = -1;
                loop_ub = -1;
            } else {
                i = static_cast<int32_T>(c - 1);
                loop_ub = static_cast<int32_T>(c - 1);
            }

            tmp = A->size[0];
            A->size[0] = static_cast<int32_T>(static_cast<int32_T>(i + A->size[0])
                + 1);
            FlightMissionMode_emxEnsureCapacity_char_T_g(A, tmp);
            for (i = 0; i <= loop_ub; i++) {
                A->data[static_cast<int32_T>(numRead + i)] = tbuf[i];
            }
        }
    }
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static int32_T FlightMissionMode_cfclose_p(real_T fid, DW_FlightMissionMode_f_T *
    localDW)
{
    FILE* filestar;
    int32_T st;
    int8_T b_fileid;
    int8_T fileid;
    st = -1;
    fileid = static_cast<int8_T>(fid);
    if (fid != static_cast<real_T>(static_cast<int8_T>(fid))) {
        fileid = -1;
    }

    b_fileid = fileid;
    if (static_cast<int32_T>(fileid) < 0) {
        b_fileid = -1;
    }

    if (static_cast<int32_T>(b_fileid) >= 3) {
        filestar = localDW->eml_openfiles_k[static_cast<int32_T>
            (static_cast<int32_T>(b_fileid) - 3)];
    } else {
        switch (static_cast<int32_T>(b_fileid)) {
          case 0:
            filestar = stdin;
            break;

          case 1:
            filestar = stdout;
            break;

          case 2:
            filestar = stderr;
            break;

          default:
            filestar = NULL;
            break;
        }
    }

    if (static_cast<boolean_T>(static_cast<int32_T>((filestar != NULL) & (
            static_cast<int32_T>(fileid) >= 3)))) {
        int32_T cst;
        cst = fclose(filestar);
        if (cst == 0) {
            st = 0;
            localDW->eml_openfiles_k[static_cast<int32_T>(static_cast<int32_T>
                (fileid) - 3)] = NULL;
        }
    }

    return st;
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static boolean_T FlightMissionMode_strcmp_h(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[3]{ 'U', 'A', 'V' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_ey(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_g(aTmp, i);
        loop_ub = a->size[1];
        for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 3) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 3) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_o(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static boolean_T FlightMissionMode_strcmp_hb(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[10]{ 'N', 'o', 'r', 'm', 'A', 'i', 'r', 'S', 'p', 'd'
    };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_ey(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_g(aTmp, i);
        loop_ub = a->size[1];
        for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 10) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 10) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_o(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static void FlightMissionMode_strtok_otld(const
    emxArray_char_T_FlightMissionMode_T *x, emxArray_char_T_FlightMissionMode_T *
    token)
{
    int32_T i;
    int32_T iremain;
    int32_T itoken;
    FlightMissionMode_find_token_m(x, &itoken, &iremain);
    if (itoken > static_cast<int32_T>(iremain - 1)) {
        itoken = 0;
        iremain = 0;
    } else {
        itoken = static_cast<int32_T>(itoken - 1);
        iremain = static_cast<int32_T>(iremain - 1);
    }

    i = static_cast<int32_T>(token->size[0] * token->size[1]);
    token->size[0] = 1;
    iremain = static_cast<int32_T>(iremain - itoken);
    token->size[1] = iremain;
    FlightMissionMode_emxEnsureCapacity_char_T_g(token, i);
    for (i = 0; i <= static_cast<int32_T>(iremain - 1); i++) {
        token->data[i] = x->data[static_cast<int32_T>(itoken + i)];
    }
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static boolean_T FlightMissionMode_strcmp_hbq(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[9]{ 'M', 'a', 'x', 'A', 'i', 'r', 'S', 'p', 'd' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_ey(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_g(aTmp, i);
        loop_ub = a->size[1];
        for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 9) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 9) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_o(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static void FlightMissionMode_readINI_e(emxArray_char_T_FlightMissionMode_T *ret,
    DW_FlightMissionMode_f_T *localDW)
{
    static const char_T h[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T i[15]{ 'C', 'l', 'i', 'm', 'b', 'A', 'n', 'g', 'l', 'e',
        'L', 'i', 'm', 'i', 't' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    emxArray_char_T_FlightMissionMode_T *curKey;
    emxArray_char_T_FlightMissionMode_T *curLine;
    emxArray_char_T_FlightMissionMode_T *curSection;
    emxArray_char_T_FlightMissionMode_T *curVal;
    emxArray_char_T_FlightMissionMode_T *data;
    emxArray_char_T_FlightMissionMode_T *data_0;
    emxArray_char_T_FlightMissionMode_T *j;
    emxArray_char_T_FlightMissionMode_T *tmp;
    int32_T iremain;
    int32_T itoken;
    int8_T fileid;
    ret->size[0] = 1;
    ret->size[1] = 0;
    fileid = FlightMissionMode_cfopen_j0("config.ini", "rb", localDW);
    if (static_cast<int32_T>(fileid) < 0) {
        printf("INI-file \"%s\" was not found or could not be read.\n",
               "config.ini");
        fflush(stdout);
    } else {
        int32_T i_0;
        int32_T loop_ub;
        FlightMissionMode_emxInit_char_T_ey(&j, 1);
        FlightMissionMode_fread_n(static_cast<real_T>(fileid), j, localDW);
        FlightMissionMode_emxInit_char_T_ey(&data, 2);
        i_0 = static_cast<int32_T>(data->size[0] * data->size[1]);
        data->size[0] = 1;
        data->size[1] = j->size[0];
        FlightMissionMode_emxEnsureCapacity_char_T_g(data, i_0);
        loop_ub = j->size[0];
        for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub - 1); i_0++) {
            data->data[i_0] = j->data[i_0];
        }

        FlightMissionMode_emxFree_char_T_o(&j);
        FlightMissionMode_cfclose_p(static_cast<real_T>(fileid), localDW);
        FlightMissionMode_emxInit_char_T_ey(&curSection, 2);
        curSection->size[0] = 1;
        curSection->size[1] = 0;
        FlightMissionMode_emxInit_char_T_ey(&curKey, 2);
        curKey->size[0] = 1;
        curKey->size[1] = 0;
        FlightMissionMode_emxInit_char_T_ey(&curVal, 2);
        curVal->size[0] = 1;
        curVal->size[1] = 0;
        FlightMissionMode_emxInit_char_T_ey(&curLine, 2);
        FlightMissionMode_emxInit_char_T_ey(&aTmp, 2);
        FlightMissionMode_emxInit_char_T_ey(&tmp, 2);
        FlightMissionMode_emxInit_char_T_ey(&data_0, 2);
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (data->size[1] != 0) {
                boolean_T b_bool;
                i_0 = static_cast<int32_T>(data_0->size[0] * data_0->size[1]);
                data_0->size[0] = 1;
                data_0->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_g(data_0, i_0);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (i_0 = 0; i_0 <= loop_ub; i_0++) {
                    data_0->data[i_0] = data->data[i_0];
                }

                FlightMissionMode_strtok_d(data_0, curLine, data);
                FlightMissionMode_strtok_dq(curLine, tmp);
                FlightMissionMode_strtrim_f(tmp, curLine);
                if (curLine->size[1] >= 2) {
                    boolean_T guard1{ false };

                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                iremain = 0;
                                itoken = 0;
                            } else {
                                iremain = 1;
                                itoken = static_cast<int32_T>(curLine->size[1] -
                                    1);
                            }

                            i_0 = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(itoken - iremain);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_g
                                (curSection, i_0);
                            for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub -
                                    1); i_0++) {
                                curSection->data[i_0] = curLine->data[
                                    static_cast<int32_T>(iremain + i_0)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains_d(curLine)) {
                            FlightMissionMode_strtok_dq4(curLine, aTmp, curVal);
                            FlightMissionMode_find_token_m(curVal, &itoken,
                                &iremain);
                            if (itoken > static_cast<int32_T>(iremain - 1)) {
                                itoken = 0;
                                iremain = 0;
                            } else {
                                itoken = static_cast<int32_T>(itoken - 1);
                                iremain = static_cast<int32_T>(iremain - 1);
                            }

                            FlightMissionMode_strtrim_f(aTmp, curKey);
                            i_0 = static_cast<int32_T>(curLine->size[0] *
                                curLine->size[1]);
                            curLine->size[0] = 1;
                            loop_ub = static_cast<int32_T>(iremain - itoken);
                            curLine->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_g(curLine,
                                i_0);
                            for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub -
                                    1); i_0++) {
                                curLine->data[i_0] = curVal->data
                                    [static_cast<int32_T>(itoken + i_0)];
                            }

                            FlightMissionMode_strtrim_f(curLine, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp_h(curSection)) {
                    if (curKey->size[1] == 0) {
                        aTmp->size[0] = 1;
                        aTmp->size[1] = 0;
                    } else {
                        i_0 = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
                        aTmp->size[0] = 1;
                        aTmp->size[1] = curKey->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_g(aTmp, i_0);
                        loop_ub = curKey->size[1];
                        for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub - 1);
                                i_0++) {
                            aTmp->data[i_0] = curKey->data[i_0];
                        }
                    }

                    b_bool = false;
                    if (aTmp->size[1] == 15) {
                        iremain = 0;
                        int32_T exitg2;
                        do {
                            exitg2 = 0;
                            if (iremain < 15) {
                                if (h[static_cast<int32_T>(static_cast<int32_T>(
                                        static_cast<uint8_T>(aTmp->data[iremain]))
                                     & 127)] != h[static_cast<int32_T>(i[iremain])])
                                {
                                    exitg2 = 1;
                                } else {
                                    iremain = static_cast<int32_T>(iremain + 1);
                                }
                            } else {
                                b_bool = true;
                                exitg2 = 1;
                            }
                        } while (exitg2 == 0);
                    }

                    if (b_bool) {
                        i_0 = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                        ret->size[0] = 1;
                        ret->size[1] = curVal->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_g(ret, i_0);
                        loop_ub = curVal->size[1];
                        for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub - 1);
                                i_0++) {
                            ret->data[i_0] = curVal->data[i_0];
                        }

                        exitg1 = 1;
                    }
                }
            } else {
                exitg1 = 1;
            }
        } while (exitg1 == 0);

        FlightMissionMode_emxFree_char_T_o(&data_0);
        FlightMissionMode_emxFree_char_T_o(&tmp);
        FlightMissionMode_emxFree_char_T_o(&aTmp);
        FlightMissionMode_emxFree_char_T_o(&curLine);
        FlightMissionMode_emxFree_char_T_o(&curVal);
        FlightMissionMode_emxFree_char_T_o(&curKey);
        FlightMissionMode_emxFree_char_T_o(&curSection);
        FlightMissionMode_emxFree_char_T_o(&data);
    }
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static void FlightMissionMode_readINI_ew(emxArray_char_T_FlightMissionMode_T
    *ret, DW_FlightMissionMode_f_T *localDW)
{
    static const char_T h[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T i[14]{ 'D', 'i', 'v', 'e', 'A', 'n', 'g', 'l', 'e', 'L',
        'i', 'm', 'i', 't' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    emxArray_char_T_FlightMissionMode_T *curKey;
    emxArray_char_T_FlightMissionMode_T *curLine;
    emxArray_char_T_FlightMissionMode_T *curSection;
    emxArray_char_T_FlightMissionMode_T *curVal;
    emxArray_char_T_FlightMissionMode_T *data;
    emxArray_char_T_FlightMissionMode_T *data_0;
    emxArray_char_T_FlightMissionMode_T *j;
    emxArray_char_T_FlightMissionMode_T *tmp;
    int32_T iremain;
    int32_T itoken;
    int8_T fileid;
    ret->size[0] = 1;
    ret->size[1] = 0;
    fileid = FlightMissionMode_cfopen_j0("config.ini", "rb", localDW);
    if (static_cast<int32_T>(fileid) < 0) {
        printf("INI-file \"%s\" was not found or could not be read.\n",
               "config.ini");
        fflush(stdout);
    } else {
        int32_T i_0;
        int32_T loop_ub;
        FlightMissionMode_emxInit_char_T_ey(&j, 1);
        FlightMissionMode_fread_n(static_cast<real_T>(fileid), j, localDW);
        FlightMissionMode_emxInit_char_T_ey(&data, 2);
        i_0 = static_cast<int32_T>(data->size[0] * data->size[1]);
        data->size[0] = 1;
        data->size[1] = j->size[0];
        FlightMissionMode_emxEnsureCapacity_char_T_g(data, i_0);
        loop_ub = j->size[0];
        for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub - 1); i_0++) {
            data->data[i_0] = j->data[i_0];
        }

        FlightMissionMode_emxFree_char_T_o(&j);
        FlightMissionMode_cfclose_p(static_cast<real_T>(fileid), localDW);
        FlightMissionMode_emxInit_char_T_ey(&curSection, 2);
        curSection->size[0] = 1;
        curSection->size[1] = 0;
        FlightMissionMode_emxInit_char_T_ey(&curKey, 2);
        curKey->size[0] = 1;
        curKey->size[1] = 0;
        FlightMissionMode_emxInit_char_T_ey(&curVal, 2);
        curVal->size[0] = 1;
        curVal->size[1] = 0;
        FlightMissionMode_emxInit_char_T_ey(&curLine, 2);
        FlightMissionMode_emxInit_char_T_ey(&aTmp, 2);
        FlightMissionMode_emxInit_char_T_ey(&tmp, 2);
        FlightMissionMode_emxInit_char_T_ey(&data_0, 2);
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (data->size[1] != 0) {
                boolean_T b_bool;
                i_0 = static_cast<int32_T>(data_0->size[0] * data_0->size[1]);
                data_0->size[0] = 1;
                data_0->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_g(data_0, i_0);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (i_0 = 0; i_0 <= loop_ub; i_0++) {
                    data_0->data[i_0] = data->data[i_0];
                }

                FlightMissionMode_strtok_d(data_0, curLine, data);
                FlightMissionMode_strtok_dq(curLine, tmp);
                FlightMissionMode_strtrim_f(tmp, curLine);
                if (curLine->size[1] >= 2) {
                    boolean_T guard1{ false };

                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                iremain = 0;
                                itoken = 0;
                            } else {
                                iremain = 1;
                                itoken = static_cast<int32_T>(curLine->size[1] -
                                    1);
                            }

                            i_0 = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(itoken - iremain);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_g
                                (curSection, i_0);
                            for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub -
                                    1); i_0++) {
                                curSection->data[i_0] = curLine->data[
                                    static_cast<int32_T>(iremain + i_0)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains_d(curLine)) {
                            FlightMissionMode_strtok_dq4(curLine, aTmp, curVal);
                            FlightMissionMode_find_token_m(curVal, &itoken,
                                &iremain);
                            if (itoken > static_cast<int32_T>(iremain - 1)) {
                                itoken = 0;
                                iremain = 0;
                            } else {
                                itoken = static_cast<int32_T>(itoken - 1);
                                iremain = static_cast<int32_T>(iremain - 1);
                            }

                            FlightMissionMode_strtrim_f(aTmp, curKey);
                            i_0 = static_cast<int32_T>(curLine->size[0] *
                                curLine->size[1]);
                            curLine->size[0] = 1;
                            loop_ub = static_cast<int32_T>(iremain - itoken);
                            curLine->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_g(curLine,
                                i_0);
                            for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub -
                                    1); i_0++) {
                                curLine->data[i_0] = curVal->data
                                    [static_cast<int32_T>(itoken + i_0)];
                            }

                            FlightMissionMode_strtrim_f(curLine, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp_h(curSection)) {
                    if (curKey->size[1] == 0) {
                        aTmp->size[0] = 1;
                        aTmp->size[1] = 0;
                    } else {
                        i_0 = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
                        aTmp->size[0] = 1;
                        aTmp->size[1] = curKey->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_g(aTmp, i_0);
                        loop_ub = curKey->size[1];
                        for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub - 1);
                                i_0++) {
                            aTmp->data[i_0] = curKey->data[i_0];
                        }
                    }

                    b_bool = false;
                    if (aTmp->size[1] == 14) {
                        iremain = 0;
                        int32_T exitg2;
                        do {
                            exitg2 = 0;
                            if (iremain < 14) {
                                if (h[static_cast<int32_T>(static_cast<int32_T>(
                                        static_cast<uint8_T>(aTmp->data[iremain]))
                                     & 127)] != h[static_cast<int32_T>(i[iremain])])
                                {
                                    exitg2 = 1;
                                } else {
                                    iremain = static_cast<int32_T>(iremain + 1);
                                }
                            } else {
                                b_bool = true;
                                exitg2 = 1;
                            }
                        } while (exitg2 == 0);
                    }

                    if (b_bool) {
                        i_0 = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                        ret->size[0] = 1;
                        ret->size[1] = curVal->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_g(ret, i_0);
                        loop_ub = curVal->size[1];
                        for (i_0 = 0; i_0 <= static_cast<int32_T>(loop_ub - 1);
                                i_0++) {
                            ret->data[i_0] = curVal->data[i_0];
                        }

                        exitg1 = 1;
                    }
                }
            } else {
                exitg1 = 1;
            }
        } while (exitg1 == 0);

        FlightMissionMode_emxFree_char_T_o(&data_0);
        FlightMissionMode_emxFree_char_T_o(&tmp);
        FlightMissionMode_emxFree_char_T_o(&aTmp);
        FlightMissionMode_emxFree_char_T_o(&curLine);
        FlightMissionMode_emxFree_char_T_o(&curVal);
        FlightMissionMode_emxFree_char_T_o(&curKey);
        FlightMissionMode_emxFree_char_T_o(&curSection);
        FlightMissionMode_emxFree_char_T_o(&data);
    }
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static boolean_T FlightMissionMode_strcmp_hbqn(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[9]{ 'M', 'i', 'n', 'A', 'i', 'r', 'S', 'p', 'd' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_ey(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_g(aTmp, i);
        loop_ub = a->size[1];
        for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 9) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 9) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_o(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static boolean_T FlightMissionMode_strcmp_hbqnf(const
    emxArray_char_T_FlightMissionMode_T *a)
{
    static const char_T c[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T d[12]{ 'M', 'a', 'x', 'R', 'o', 'l', 'l', 'A', 'n', 'g',
        'l', 'e' };

    emxArray_char_T_FlightMissionMode_T *aTmp;
    int32_T loop_ub;
    boolean_T b_bool;
    FlightMissionMode_emxInit_char_T_ey(&aTmp, 2);
    if (a->size[1] == 0) {
        aTmp->size[0] = 1;
        aTmp->size[1] = 0;
    } else {
        int32_T i;
        i = static_cast<int32_T>(aTmp->size[0] * aTmp->size[1]);
        aTmp->size[0] = 1;
        aTmp->size[1] = a->size[1];
        FlightMissionMode_emxEnsureCapacity_char_T_g(aTmp, i);
        loop_ub = a->size[1];
        for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
            aTmp->data[i] = a->data[i];
        }
    }

    b_bool = false;
    if (aTmp->size[1] == 12) {
        loop_ub = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (loop_ub < 12) {
                if (c[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(aTmp->
                        data[loop_ub])) & 127)] != c[static_cast<int32_T>
                        (d[loop_ub])]) {
                    exitg1 = 1;
                } else {
                    loop_ub = static_cast<int32_T>(loop_ub + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    FlightMissionMode_emxFree_char_T_o(&aTmp);
    return b_bool;
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static uavDubinsConnection_FlightMissionMode_T
    *FlightMissionMode_uavDubinsConnection_uavDubinsConnection_lg
    (uavDubinsConnection_FlightMissionMode_T *b_this, real_T varargin_2, real_T
     varargin_4, const real_T varargin_6[2])
{
    uavDubinsConnection_FlightMissionMode_T *c_this;
    real_T b_x;
    c_this = b_this;
    b_this->AirSpeed = 10.0;
    b_this->FlightPathAngleLimit[0] = varargin_6[0];
    b_this->FlightPathAngleLimit[1] = varargin_6[1];
    b_this->MaxRollAngle = varargin_4;
    b_x = b_this->MaxRollAngle;
    b_this->MinTurningRadius = b_this->AirSpeed * b_this->AirSpeed / (9.8 * std::
        tan(b_x));
    b_this->AirSpeed = varargin_2;
    b_x = b_this->MaxRollAngle;
    b_this->MinTurningRadius = b_this->AirSpeed * b_this->AirSpeed / (9.8 * std::
        tan(b_x));
    b_x = b_this->MaxRollAngle;
    b_this->MinTurningRadius = b_this->AirSpeed * b_this->AirSpeed / (9.8 * std::
        tan(b_x));
    return c_this;
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static uavDubinsConnection_FlightMissionMode_T
    *FlightMissionMode_DubinsObjSingleton_getConnector_p
    (DW_FlightMissionMode_f_T *localDW)
{
    emxArray_char_T_FlightMissionMode_T *b_remainder;
    emxArray_char_T_FlightMissionMode_T *curKey;
    emxArray_char_T_FlightMissionMode_T *curLine;
    emxArray_char_T_FlightMissionMode_T *curSection;
    emxArray_char_T_FlightMissionMode_T *curVal;
    emxArray_char_T_FlightMissionMode_T *data;
    emxArray_char_T_FlightMissionMode_T *data_0;
    emxArray_char_T_FlightMissionMode_T *data_1;
    emxArray_char_T_FlightMissionMode_T *data_2;
    emxArray_char_T_FlightMissionMode_T *data_3;
    emxArray_char_T_FlightMissionMode_T *k;
    emxArray_char_T_FlightMissionMode_T *ret;
    emxArray_char_T_FlightMissionMode_T *tmp_1;
    emxArray_char_T_FlightMissionMode_T *tmp_2;
    emxArray_char_T_FlightMissionMode_T *tmp_3;
    emxArray_char_T_FlightMissionMode_T *tmp_4;
    emxArray_char_T_FlightMissionMode_T *tmp_5;
    emxArray_char_T_FlightMissionMode_T *tmp_6;
    emxArray_char_T_FlightMissionMode_T *tmp_7;
    emxArray_char_T_FlightMissionMode_T *tmp_8;
    uavDubinsConnection_FlightMissionMode_T *outputArg;
    real_T tmp_9[2];
    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
            (localDW->SingletonInstance_not_empty) ^ 1))) {
        creal_T tmp;
        creal_T tmp_0;
        real_T ClimbAngleLimit;
        real_T DiveAngleLimit;
        real_T fid;
        int32_T b;
        int32_T c;
        int32_T i;
        int32_T loop_ub;
        boolean_T b_bool;
        boolean_T exitg1;
        boolean_T guard1{ false };

        localDW->SingletonInstance.AirSpeed = 35.0;
        localDW->SingletonInstance.MaxRollAngle = 0.3490658503988659;
        localDW->SingletonInstance.FlightPathAngleLimit[0] = -0.175;
        localDW->SingletonInstance.FlightPathAngleLimit[1] = 0.175;
        FlightMissionMode_emxInit_char_T_ey(&ret, 2);
        ret->size[0] = 1;
        ret->size[1] = 0;
        fid = FlightMissionMode_fileManager_f(localDW);
        FlightMissionMode_emxInit_char_T_ey(&data, 2);
        FlightMissionMode_emxInit_char_T_ey(&curSection, 2);
        FlightMissionMode_emxInit_char_T_ey(&curKey, 2);
        FlightMissionMode_emxInit_char_T_ey(&curVal, 2);
        FlightMissionMode_emxInit_char_T_ey(&curLine, 2);
        FlightMissionMode_emxInit_char_T_ey(&b_remainder, 2);
        FlightMissionMode_emxInit_char_T_ey(&k, 1);
        if (fid < 0.0) {
            printf("INI-file \"%s\" was not found or could not be read.\n",
                   "config.ini");
            fflush(stdout);
        } else {
            FlightMissionMode_fread_n(fid, k, localDW);
            i = static_cast<int32_T>(data->size[0] * data->size[1]);
            data->size[0] = 1;
            data->size[1] = k->size[0];
            FlightMissionMode_emxEnsureCapacity_char_T_g(data, i);
            loop_ub = k->size[0];
            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                data->data[b] = k->data[b];
            }

            FlightMissionMode_cfclose_p(fid, localDW);
            curSection->size[0] = 1;
            curSection->size[1] = 0;
            curKey->size[0] = 1;
            curKey->size[1] = 0;
            curVal->size[0] = 1;
            curVal->size[1] = 0;
            FlightMissionMode_emxInit_char_T_ey(&tmp_7, 2);
            FlightMissionMode_emxInit_char_T_ey(&tmp_8, 2);
            FlightMissionMode_emxInit_char_T_ey(&data_3, 2);
            exitg1 = false;
            while ((!exitg1) && (data->size[1] != 0)) {
                i = static_cast<int32_T>(data_3->size[0] * data_3->size[1]);
                data_3->size[0] = 1;
                data_3->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_g(data_3, i);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (i = 0; i <= loop_ub; i++) {
                    data_3->data[i] = data->data[i];
                }

                FlightMissionMode_strtok_d(data_3, curLine, data);
                FlightMissionMode_strtok_dq(curLine, tmp_8);
                FlightMissionMode_strtrim_f(tmp_8, curLine);
                if (curLine->size[1] >= 2) {
                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                c = 0;
                                b = 0;
                            } else {
                                c = 1;
                                b = static_cast<int32_T>(curLine->size[1] - 1);
                            }

                            i = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(b - c);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_g
                                (curSection, i);
                            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1);
                                    b++) {
                                curSection->data[b] = curLine->data[static_cast<
                                    int32_T>(c + b)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains_d(curLine)) {
                            FlightMissionMode_strtok_dq4(curLine, curVal,
                                b_remainder);
                            FlightMissionMode_strtrim_f(curVal, curKey);
                            FlightMissionMode_strtok_otld(b_remainder, tmp_7);
                            FlightMissionMode_strtrim_f(tmp_7, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp_h(curSection) &&
                        FlightMissionMode_strcmp_hb(curKey)) {
                    i = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                    ret->size[0] = 1;
                    ret->size[1] = curVal->size[1];
                    FlightMissionMode_emxEnsureCapacity_char_T_g(ret, i);
                    loop_ub = curVal->size[1];
                    for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                        ret->data[b] = curVal->data[b];
                    }

                    exitg1 = true;
                }
            }

            FlightMissionMode_emxFree_char_T_o(&data_3);
            FlightMissionMode_emxFree_char_T_o(&tmp_8);
            FlightMissionMode_emxFree_char_T_o(&tmp_7);
        }

        tmp = FlightMissionMode_str2double_k(ret);
        printf("Set UAV NormAirSpeed:\t\t%f\n", tmp.re);
        fflush(stdout);
        ret->size[0] = 1;
        ret->size[1] = 0;
        fid = FlightMissionMode_fileManager_f(localDW);
        if (fid < 0.0) {
            printf("INI-file \"%s\" was not found or could not be read.\n",
                   "config.ini");
            fflush(stdout);
        } else {
            FlightMissionMode_fread_n(fid, k, localDW);
            i = static_cast<int32_T>(data->size[0] * data->size[1]);
            data->size[0] = 1;
            data->size[1] = k->size[0];
            FlightMissionMode_emxEnsureCapacity_char_T_g(data, i);
            loop_ub = k->size[0];
            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                data->data[b] = k->data[b];
            }

            FlightMissionMode_cfclose_p(fid, localDW);
            curSection->size[0] = 1;
            curSection->size[1] = 0;
            curKey->size[0] = 1;
            curKey->size[1] = 0;
            curVal->size[0] = 1;
            curVal->size[1] = 0;
            FlightMissionMode_emxInit_char_T_ey(&tmp_5, 2);
            FlightMissionMode_emxInit_char_T_ey(&tmp_6, 2);
            FlightMissionMode_emxInit_char_T_ey(&data_2, 2);
            exitg1 = false;
            while ((!exitg1) && (data->size[1] != 0)) {
                i = static_cast<int32_T>(data_2->size[0] * data_2->size[1]);
                data_2->size[0] = 1;
                data_2->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_g(data_2, i);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (i = 0; i <= loop_ub; i++) {
                    data_2->data[i] = data->data[i];
                }

                FlightMissionMode_strtok_d(data_2, curLine, data);
                FlightMissionMode_strtok_dq(curLine, tmp_6);
                FlightMissionMode_strtrim_f(tmp_6, curLine);
                if (curLine->size[1] >= 2) {
                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                c = 0;
                                b = 0;
                            } else {
                                c = 1;
                                b = static_cast<int32_T>(curLine->size[1] - 1);
                            }

                            i = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(b - c);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_g
                                (curSection, i);
                            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1);
                                    b++) {
                                curSection->data[b] = curLine->data[static_cast<
                                    int32_T>(c + b)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains_d(curLine)) {
                            FlightMissionMode_strtok_dq4(curLine, curVal,
                                b_remainder);
                            FlightMissionMode_strtrim_f(curVal, curKey);
                            FlightMissionMode_strtok_otld(b_remainder, tmp_5);
                            FlightMissionMode_strtrim_f(tmp_5, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp_h(curSection) &&
                        FlightMissionMode_strcmp_hbq(curKey)) {
                    i = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                    ret->size[0] = 1;
                    ret->size[1] = curVal->size[1];
                    FlightMissionMode_emxEnsureCapacity_char_T_g(ret, i);
                    loop_ub = curVal->size[1];
                    for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                        ret->data[b] = curVal->data[b];
                    }

                    exitg1 = true;
                }
            }

            FlightMissionMode_emxFree_char_T_o(&data_2);
            FlightMissionMode_emxFree_char_T_o(&tmp_6);
            FlightMissionMode_emxFree_char_T_o(&tmp_5);
        }

        tmp_0 = FlightMissionMode_str2double_k(ret);
        printf("Set UAV MaxAirSpeed:\t\t%f\n", tmp_0.re);
        fflush(stdout);
        ret->size[0] = 1;
        ret->size[1] = 0;
        fid = FlightMissionMode_fileManager_f(localDW);
        if (fid < 0.0) {
            printf("INI-file \"%s\" was not found or could not be read.\n",
                   "config.ini");
            fflush(stdout);
        } else {
            FlightMissionMode_fread_n(fid, k, localDW);
            i = static_cast<int32_T>(data->size[0] * data->size[1]);
            data->size[0] = 1;
            data->size[1] = k->size[0];
            FlightMissionMode_emxEnsureCapacity_char_T_g(data, i);
            loop_ub = k->size[0];
            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                data->data[b] = k->data[b];
            }

            FlightMissionMode_cfclose_p(fid, localDW);
            curSection->size[0] = 1;
            curSection->size[1] = 0;
            curKey->size[0] = 1;
            curKey->size[1] = 0;
            curVal->size[0] = 1;
            curVal->size[1] = 0;
            FlightMissionMode_emxInit_char_T_ey(&tmp_3, 2);
            FlightMissionMode_emxInit_char_T_ey(&tmp_4, 2);
            FlightMissionMode_emxInit_char_T_ey(&data_1, 2);
            exitg1 = false;
            while ((!exitg1) && (data->size[1] != 0)) {
                i = static_cast<int32_T>(data_1->size[0] * data_1->size[1]);
                data_1->size[0] = 1;
                data_1->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_g(data_1, i);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (i = 0; i <= loop_ub; i++) {
                    data_1->data[i] = data->data[i];
                }

                FlightMissionMode_strtok_d(data_1, curLine, data);
                FlightMissionMode_strtok_dq(curLine, tmp_4);
                FlightMissionMode_strtrim_f(tmp_4, curLine);
                if (curLine->size[1] >= 2) {
                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                c = 0;
                                b = 0;
                            } else {
                                c = 1;
                                b = static_cast<int32_T>(curLine->size[1] - 1);
                            }

                            i = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(b - c);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_g
                                (curSection, i);
                            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1);
                                    b++) {
                                curSection->data[b] = curLine->data[static_cast<
                                    int32_T>(c + b)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains_d(curLine)) {
                            FlightMissionMode_strtok_dq4(curLine, curVal,
                                b_remainder);
                            FlightMissionMode_strtrim_f(curVal, curKey);
                            FlightMissionMode_strtok_otld(b_remainder, tmp_3);
                            FlightMissionMode_strtrim_f(tmp_3, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp_h(curSection) &&
                        FlightMissionMode_strcmp_hbqn(curKey)) {
                    i = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                    ret->size[0] = 1;
                    ret->size[1] = curVal->size[1];
                    FlightMissionMode_emxEnsureCapacity_char_T_g(ret, i);
                    loop_ub = curVal->size[1];
                    for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                        ret->data[b] = curVal->data[b];
                    }

                    exitg1 = true;
                }
            }

            FlightMissionMode_emxFree_char_T_o(&data_1);
            FlightMissionMode_emxFree_char_T_o(&tmp_4);
            FlightMissionMode_emxFree_char_T_o(&tmp_3);
        }

        tmp_0 = FlightMissionMode_str2double_k(ret);
        printf("Set UAV MinAirSpeed:\t\t%f\n", tmp_0.re);
        fflush(stdout);
        ret->size[0] = 1;
        ret->size[1] = 0;
        fid = FlightMissionMode_fileManager_f(localDW);
        if (fid < 0.0) {
            printf("INI-file \"%s\" was not found or could not be read.\n",
                   "config.ini");
            fflush(stdout);
        } else {
            FlightMissionMode_fread_n(fid, k, localDW);
            i = static_cast<int32_T>(data->size[0] * data->size[1]);
            data->size[0] = 1;
            data->size[1] = k->size[0];
            FlightMissionMode_emxEnsureCapacity_char_T_g(data, i);
            loop_ub = k->size[0];
            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                data->data[b] = k->data[b];
            }

            FlightMissionMode_cfclose_p(fid, localDW);
            curSection->size[0] = 1;
            curSection->size[1] = 0;
            curKey->size[0] = 1;
            curKey->size[1] = 0;
            curVal->size[0] = 1;
            curVal->size[1] = 0;
            FlightMissionMode_emxInit_char_T_ey(&tmp_1, 2);
            FlightMissionMode_emxInit_char_T_ey(&tmp_2, 2);
            FlightMissionMode_emxInit_char_T_ey(&data_0, 2);
            exitg1 = false;
            while ((!exitg1) && (data->size[1] != 0)) {
                i = static_cast<int32_T>(data_0->size[0] * data_0->size[1]);
                data_0->size[0] = 1;
                data_0->size[1] = data->size[1];
                FlightMissionMode_emxEnsureCapacity_char_T_g(data_0, i);
                loop_ub = static_cast<int32_T>(static_cast<int32_T>(data->size[0]
                    * data->size[1]) - 1);
                for (i = 0; i <= loop_ub; i++) {
                    data_0->data[i] = data->data[i];
                }

                FlightMissionMode_strtok_d(data_0, curLine, data);
                FlightMissionMode_strtok_dq(curLine, tmp_2);
                FlightMissionMode_strtrim_f(tmp_2, curLine);
                if (curLine->size[1] >= 2) {
                    b_bool = false;
                    if (curLine->data[0] == '[') {
                        b_bool = true;
                    }

                    guard1 = false;
                    if (b_bool) {
                        b_bool = false;
                        if (curLine->data[static_cast<int32_T>(curLine->size[1]
                                - 1)] == ']') {
                            b_bool = true;
                        }

                        if (b_bool) {
                            if (static_cast<int32_T>(curLine->size[1] - 1) < 2)
                            {
                                c = 0;
                                b = 0;
                            } else {
                                c = 1;
                                b = static_cast<int32_T>(curLine->size[1] - 1);
                            }

                            i = static_cast<int32_T>(curSection->size[0] *
                                curSection->size[1]);
                            curSection->size[0] = 1;
                            loop_ub = static_cast<int32_T>(b - c);
                            curSection->size[1] = loop_ub;
                            FlightMissionMode_emxEnsureCapacity_char_T_g
                                (curSection, i);
                            for (b = 0; b <= static_cast<int32_T>(loop_ub - 1);
                                    b++) {
                                curSection->data[b] = curLine->data[static_cast<
                                    int32_T>(c + b)];
                            }

                            curKey->size[0] = 1;
                            curKey->size[1] = 0;
                        } else {
                            guard1 = true;
                        }
                    } else {
                        guard1 = true;
                    }

                    if (guard1) {
                        if (curLine->data[0] == ';') {
                            b_bool = true;
                        }

                        if ((static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(b_bool) ^ 1))) &&
                                FlightMissionMode_contains_d(curLine)) {
                            FlightMissionMode_strtok_dq4(curLine, curVal,
                                b_remainder);
                            FlightMissionMode_strtrim_f(curVal, curKey);
                            FlightMissionMode_strtok_otld(b_remainder, tmp_1);
                            FlightMissionMode_strtrim_f(tmp_1, curVal);
                        }
                    }
                }

                if (FlightMissionMode_strcmp_h(curSection) &&
                        FlightMissionMode_strcmp_hbqnf(curKey)) {
                    i = static_cast<int32_T>(ret->size[0] * ret->size[1]);
                    ret->size[0] = 1;
                    ret->size[1] = curVal->size[1];
                    FlightMissionMode_emxEnsureCapacity_char_T_g(ret, i);
                    loop_ub = curVal->size[1];
                    for (b = 0; b <= static_cast<int32_T>(loop_ub - 1); b++) {
                        ret->data[b] = curVal->data[b];
                    }

                    exitg1 = true;
                }
            }

            FlightMissionMode_emxFree_char_T_o(&data_0);
            FlightMissionMode_emxFree_char_T_o(&tmp_2);
            FlightMissionMode_emxFree_char_T_o(&tmp_1);
        }

        FlightMissionMode_emxFree_char_T_o(&k);
        FlightMissionMode_emxFree_char_T_o(&b_remainder);
        FlightMissionMode_emxFree_char_T_o(&curLine);
        FlightMissionMode_emxFree_char_T_o(&curVal);
        FlightMissionMode_emxFree_char_T_o(&curKey);
        FlightMissionMode_emxFree_char_T_o(&curSection);
        FlightMissionMode_emxFree_char_T_o(&data);
        tmp_0 = FlightMissionMode_str2double_k(ret);
        fid = 0.017453292519943295 * tmp_0.re;
        printf("Set UAV MaxRollAngle:\t\t%f\n", fid);
        fflush(stdout);
        FlightMissionMode_readINI_e(ret, localDW);
        tmp_0 = FlightMissionMode_str2double_k(ret);
        ClimbAngleLimit = 0.017453292519943295 * tmp_0.re;
        printf("Set UAV ClimbAngleLimit:\t%f\n", ClimbAngleLimit);
        fflush(stdout);
        FlightMissionMode_readINI_ew(ret, localDW);
        tmp_0 = FlightMissionMode_str2double_k(ret);
        FlightMissionMode_emxFree_char_T_o(&ret);
        DiveAngleLimit = 0.017453292519943295 * tmp_0.re;
        printf("Set UAV DiveAngleLimit:\t\t%f\n", DiveAngleLimit);
        fflush(stdout);
        if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(std::
                isnan(tmp.re)) ^ 1))) {
            localDW->SingletonInstance.AirSpeed = tmp.re;
        }

        if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(std::
                isnan(fid)) ^ 1))) {
            localDW->SingletonInstance.MaxRollAngle = fid;
        }

        if ((static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                (std::isnan(ClimbAngleLimit)) ^ 1))) && (static_cast<boolean_T>(
                static_cast<int32_T>(static_cast<int32_T>(std::isnan
                (DiveAngleLimit)) ^ 1)))) {
            localDW->SingletonInstance.FlightPathAngleLimit[0] = DiveAngleLimit;
            localDW->SingletonInstance.FlightPathAngleLimit[1] = ClimbAngleLimit;
        }

        for (i = 0; i < 2; i++) {
            tmp_9[i] = localDW->SingletonInstance.FlightPathAngleLimit[i];
        }

        FlightMissionMode_uavDubinsConnection_uavDubinsConnection_lg
            (&localDW->SingletonInstance.Connector,
             localDW->SingletonInstance.AirSpeed,
             localDW->SingletonInstance.MaxRollAngle, tmp_9);
        localDW->SingletonInstance_not_empty = true;
    }

    outputArg = &localDW->SingletonInstance.Connector;
    return outputArg;
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static void* FlightMissionMode_uavDubinsBuildable_uavDubinsBuildable_j(real_T
    airSpeed, real_T maxRollAngle, const real_T flightPathAngle[2])
{
    real_T b_flightPathAngle[2];
    b_flightPathAngle[0] = flightPathAngle[0];
    b_flightPathAngle[1] = flightPathAngle[1];
    return uavDubinsConnectionObj(airSpeed, maxRollAngle, &b_flightPathAngle[0],
        nullptr, 0U);
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static boolean_T FlightMissionMode_strcmp_hbqnfp(const char_T a_data[], const
    int32_T a_size[2])
{
    static const char_T b[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T c[2]{ 'H', 'L' };

    boolean_T b_bool;
    b_bool = false;
    if (a_size[1] == 2) {
        int32_T kstr;
        kstr = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (kstr < 2) {
                if (b[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(a_data[kstr]))
                                           & 127)] != b[static_cast<int32_T>
                        (c[kstr])]) {
                    exitg1 = 1;
                } else {
                    kstr = static_cast<int32_T>(kstr + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    return b_bool;
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static boolean_T FlightMissionMode_strcmp_hbqnfps(const char_T a_data[], const
    int32_T a_size[2])
{
    static const char_T b[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
        'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
        'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
        'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
        'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

    static const char_T c[2]{ 'H', 'R' };

    boolean_T b_bool;
    b_bool = false;
    if (a_size[1] == 2) {
        int32_T kstr;
        kstr = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (kstr < 2) {
                if (b[static_cast<int32_T>(static_cast<int32_T>
                                           (static_cast<uint8_T>(a_data[kstr]))
                                           & 127)] != b[static_cast<int32_T>
                        (c[kstr])]) {
                    exitg1 = 1;
                } else {
                    kstr = static_cast<int32_T>(kstr + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    return b_bool;
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static void FlightMissionMode_uavDubinsPathSegment_uavDubinsPathSegment_hw(const
    real_T varargin_1[4], const real_T varargin_2[4], real_T varargin_3, real_T
    varargin_4, real_T varargin_5, real_T varargin_6, const
    cell_wrap_0_FlightMissionMode_T varargin_7[4], const real_T varargin_8[4],
    uavDubinsPathSegment_FlightMissionMode_T *b_this)
{
    static const char_T h[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
        '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e',
        '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
        '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!',
        '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=',
        '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K',
        'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',
        'Z', '[', '\\', ']', '^', '_', '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
        'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',
        'V', 'W', 'X', 'Y', 'Z', '{', '|', '}', '~', '\x7f' };

    real_T thetaWrap;
    int32_T f;
    b_this->MinTurningRadius = varargin_5;
    b_this->StartPose[0] = varargin_1[0];
    b_this->StartPose[1] = varargin_1[1];
    b_this->StartPose[2] = varargin_1[2];
    thetaWrap = mod_Cteiw4Qy(varargin_1[3]);
    b_this->StartPose[3] = thetaWrap;
    if (static_cast<boolean_T>(static_cast<int32_T>((thetaWrap == 0.0) &
            (varargin_1[3] > 0.0)))) {
        b_this->StartPose[3] = 6.2831853071795862;
    }

    wrapToPi_8g8Yma1S(&b_this->StartPose[3]);
    b_this->GoalPose[0] = varargin_2[0];
    b_this->GoalPose[1] = varargin_2[1];
    b_this->GoalPose[2] = varargin_2[2];
    thetaWrap = mod_Cteiw4Qy(varargin_2[3]);
    b_this->GoalPose[3] = thetaWrap;
    if (static_cast<boolean_T>(static_cast<int32_T>((thetaWrap == 0.0) &
            (varargin_2[3] > 0.0)))) {
        b_this->GoalPose[3] = 6.2831853071795862;
    }

    wrapToPi_8g8Yma1S(&b_this->GoalPose[3]);
    b_this->AirSpeed = varargin_4;
    b_this->HelixRadius = varargin_6;
    b_this->FlightPathAngle = varargin_3;
    b_this->MotionLengths[0] = varargin_8[0];
    b_this->MotionTypes[0] = varargin_7[0];
    b_this->MotionLengths[1] = varargin_8[1];
    b_this->MotionTypes[1] = varargin_7[1];
    b_this->MotionLengths[2] = varargin_8[2];
    b_this->MotionTypes[2] = varargin_7[2];
    b_this->MotionLengths[3] = varargin_8[3];
    b_this->MotionTypes[3] = varargin_7[3];
    b_this->MotionTypes[0].f1.size[0] = 1;
    b_this->MotionTypes[0].f1.size[1] = varargin_7[0].f1.size[1];
    f = varargin_7[0].f1.size[1];
    for (int32_T k{0}; k <= static_cast<int32_T>(f - 1); k++) {
        b_this->MotionTypes[0].f1.data[k] = h[static_cast<int32_T>(varargin_7[0]
            .f1.data[k])];
    }

    b_this->MotionTypes[1].f1.size[0] = 1;
    b_this->MotionTypes[1].f1.size[1] = 1;
    b_this->MotionTypes[1].f1.data[0] = h[static_cast<int32_T>
        (static_cast<int32_T>(static_cast<uint8_T>(varargin_7[1].f1.data[0])) &
         127)];
    b_this->MotionTypes[2].f1.size[0] = 1;
    b_this->MotionTypes[2].f1.size[1] = 1;
    b_this->MotionTypes[2].f1.data[0] = h[static_cast<int32_T>
        (static_cast<int32_T>(static_cast<uint8_T>(varargin_7[2].f1.data[0])) &
         127)];
    b_this->MotionTypes[3].f1.size[0] = 1;
    b_this->MotionTypes[3].f1.size[1] = varargin_7[3].f1.size[1];
    f = varargin_7[3].f1.size[1];
    for (int32_T k{0}; k <= static_cast<int32_T>(f - 1); k++) {
        b_this->MotionTypes[3].f1.data[k] = h[static_cast<int32_T>(varargin_7[3]
            .f1.data[k])];
    }

    if (FlightMissionMode_strcmp_hbqnfp(b_this->MotionTypes[0].f1.data,
            b_this->MotionTypes[0].f1.size)) {
        b_this->MotionTypes[0].f1.size[0] = 1;
        b_this->MotionTypes[0].f1.size[1] = 2;
        b_this->MotionTypes[0].f1.data[0] = 'H';
        b_this->MotionTypes[0].f1.data[1] = 'l';
    } else if (FlightMissionMode_strcmp_hbqnfps(b_this->MotionTypes[0].f1.data,
                b_this->MotionTypes[0].f1.size)) {
        b_this->MotionTypes[0].f1.size[0] = 1;
        b_this->MotionTypes[0].f1.size[1] = 2;
        b_this->MotionTypes[0].f1.data[0] = 'H';
        b_this->MotionTypes[0].f1.data[1] = 'r';
    } else if (FlightMissionMode_strcmp_hbqnfps(b_this->MotionTypes[3].f1.data,
                b_this->MotionTypes[3].f1.size)) {
        b_this->MotionTypes[3].f1.size[0] = 1;
        b_this->MotionTypes[3].f1.size[1] = 2;
        b_this->MotionTypes[3].f1.data[0] = 'H';
        b_this->MotionTypes[3].f1.data[1] = 'r';
    } else if (FlightMissionMode_strcmp_hbqnfp(b_this->MotionTypes[3].f1.data,
                b_this->MotionTypes[3].f1.size)) {
        b_this->MotionTypes[3].f1.size[0] = 1;
        b_this->MotionTypes[3].f1.size[1] = 2;
        b_this->MotionTypes[3].f1.data[0] = 'H';
        b_this->MotionTypes[3].f1.data[1] = 'l';
    }

    b_this->Length = ((varargin_8[0] + varargin_8[1]) + varargin_8[2]) +
        varargin_8[3];
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static void FlightMissionMode_uavDubinsBuiltins_connect_g(const
    uavDubinsConnection_FlightMissionMode_T *obj, const real_T startPose[4],
    const real_T goalPose[4], real_T turningRadius,
    uavDubinsPathSegment_FlightMissionMode_T *pathSegObjs, real_T *pathCosts)
{
    void* b_obj_UAVDubinsBuildableObj;
    cell_wrap_0_FlightMissionMode_T ac;
    cell_wrap_0_FlightMissionMode_T ad;
    cell_wrap_0_FlightMissionMode_T ae;
    cell_wrap_0_FlightMissionMode_T af;
    cell_wrap_0_FlightMissionMode_T bc;
    cell_wrap_0_FlightMissionMode_T bd;
    cell_wrap_0_FlightMissionMode_T be;
    cell_wrap_0_FlightMissionMode_T bf;
    cell_wrap_0_FlightMissionMode_T cc;
    cell_wrap_0_FlightMissionMode_T cd;
    cell_wrap_0_FlightMissionMode_T ce;
    cell_wrap_0_FlightMissionMode_T cf;
    cell_wrap_0_FlightMissionMode_T dc;
    cell_wrap_0_FlightMissionMode_T dd;
    cell_wrap_0_FlightMissionMode_T de;
    cell_wrap_0_FlightMissionMode_T df;
    cell_wrap_0_FlightMissionMode_T ec;
    cell_wrap_0_FlightMissionMode_T ed;
    cell_wrap_0_FlightMissionMode_T ee;
    cell_wrap_0_FlightMissionMode_T ef;
    cell_wrap_0_FlightMissionMode_T fc;
    cell_wrap_0_FlightMissionMode_T fd;
    cell_wrap_0_FlightMissionMode_T fe;
    cell_wrap_0_FlightMissionMode_T ff;
    cell_wrap_0_FlightMissionMode_T gc;
    cell_wrap_0_FlightMissionMode_T gd;
    cell_wrap_0_FlightMissionMode_T ge;
    cell_wrap_0_FlightMissionMode_T gf;
    cell_wrap_0_FlightMissionMode_T hc;
    cell_wrap_0_FlightMissionMode_T hd;
    cell_wrap_0_FlightMissionMode_T he;
    cell_wrap_0_FlightMissionMode_T hf;
    cell_wrap_0_FlightMissionMode_T ib;
    cell_wrap_0_FlightMissionMode_T ic;
    cell_wrap_0_FlightMissionMode_T id;
    cell_wrap_0_FlightMissionMode_T ie;
    cell_wrap_0_FlightMissionMode_T jb;
    cell_wrap_0_FlightMissionMode_T jc;
    cell_wrap_0_FlightMissionMode_T jd;
    cell_wrap_0_FlightMissionMode_T je;
    cell_wrap_0_FlightMissionMode_T jf;
    cell_wrap_0_FlightMissionMode_T kb;
    cell_wrap_0_FlightMissionMode_T kc;
    cell_wrap_0_FlightMissionMode_T kd;
    cell_wrap_0_FlightMissionMode_T ke;
    cell_wrap_0_FlightMissionMode_T kf;
    cell_wrap_0_FlightMissionMode_T lb;
    cell_wrap_0_FlightMissionMode_T lc;
    cell_wrap_0_FlightMissionMode_T ld;
    cell_wrap_0_FlightMissionMode_T le;
    cell_wrap_0_FlightMissionMode_T lf;
    cell_wrap_0_FlightMissionMode_T mb;
    cell_wrap_0_FlightMissionMode_T mc;
    cell_wrap_0_FlightMissionMode_T md;
    cell_wrap_0_FlightMissionMode_T me;
    cell_wrap_0_FlightMissionMode_T mf;
    cell_wrap_0_FlightMissionMode_T nb;
    cell_wrap_0_FlightMissionMode_T nc;
    cell_wrap_0_FlightMissionMode_T nd;
    cell_wrap_0_FlightMissionMode_T ne;
    cell_wrap_0_FlightMissionMode_T nf;
    cell_wrap_0_FlightMissionMode_T ob;
    cell_wrap_0_FlightMissionMode_T oc;
    cell_wrap_0_FlightMissionMode_T od;
    cell_wrap_0_FlightMissionMode_T oe;
    cell_wrap_0_FlightMissionMode_T of;
    cell_wrap_0_FlightMissionMode_T pb;
    cell_wrap_0_FlightMissionMode_T pc;
    cell_wrap_0_FlightMissionMode_T pd;
    cell_wrap_0_FlightMissionMode_T pe;
    cell_wrap_0_FlightMissionMode_T pf;
    cell_wrap_0_FlightMissionMode_T qb;
    cell_wrap_0_FlightMissionMode_T qc;
    cell_wrap_0_FlightMissionMode_T qd;
    cell_wrap_0_FlightMissionMode_T qe;
    cell_wrap_0_FlightMissionMode_T qf;
    cell_wrap_0_FlightMissionMode_T rb;
    cell_wrap_0_FlightMissionMode_T rc;
    cell_wrap_0_FlightMissionMode_T rd;
    cell_wrap_0_FlightMissionMode_T re;
    cell_wrap_0_FlightMissionMode_T rf;
    cell_wrap_0_FlightMissionMode_T sb;
    cell_wrap_0_FlightMissionMode_T sc;
    cell_wrap_0_FlightMissionMode_T sd;
    cell_wrap_0_FlightMissionMode_T se;
    cell_wrap_0_FlightMissionMode_T sf;
    cell_wrap_0_FlightMissionMode_T tb;
    cell_wrap_0_FlightMissionMode_T tc;
    cell_wrap_0_FlightMissionMode_T td;
    cell_wrap_0_FlightMissionMode_T te;
    cell_wrap_0_FlightMissionMode_T tf;
    cell_wrap_0_FlightMissionMode_T ub;
    cell_wrap_0_FlightMissionMode_T uc;
    cell_wrap_0_FlightMissionMode_T ud;
    cell_wrap_0_FlightMissionMode_T ue;
    cell_wrap_0_FlightMissionMode_T uf;
    cell_wrap_0_FlightMissionMode_T vb;
    cell_wrap_0_FlightMissionMode_T vc;
    cell_wrap_0_FlightMissionMode_T vd;
    cell_wrap_0_FlightMissionMode_T ve;
    cell_wrap_0_FlightMissionMode_T wb;
    cell_wrap_0_FlightMissionMode_T wc;
    cell_wrap_0_FlightMissionMode_T wd;
    cell_wrap_0_FlightMissionMode_T we;
    cell_wrap_0_FlightMissionMode_T xb;
    cell_wrap_0_FlightMissionMode_T xc;
    cell_wrap_0_FlightMissionMode_T xd;
    cell_wrap_0_FlightMissionMode_T xe;
    cell_wrap_0_FlightMissionMode_T yb;
    cell_wrap_0_FlightMissionMode_T yc;
    cell_wrap_0_FlightMissionMode_T yd;
    cell_wrap_0_FlightMissionMode_T ye;
    cell_wrap_22_FlightMissionMode_T motionTypes[28];
    cell_wrap_22_FlightMissionMode_T b;
    real_T g[16];
    real_T ml[16];
    real_T ml1[16];
    real_T s[16];
    real_T b_goalPose[4];
    real_T b_startPose[4];
    real_T ml1_0[4];
    real_T b_a;
    real_T b_fpa;
    real_T h;
    real_T mt;
    real_T mtr;
    int32_T tmp;
    ib.f1.size[0] = 1;
    ib.f1.size[1] = 1;
    ib.f1.data[0] = 'L';
    jb.f1.size[0] = 1;
    jb.f1.size[1] = 1;
    jb.f1.data[0] = 'S';
    kb.f1.size[0] = 1;
    kb.f1.size[1] = 1;
    kb.f1.data[0] = 'L';
    lb.f1.size[0] = 1;
    lb.f1.size[1] = 1;
    lb.f1.data[0] = 'N';
    b.f1[0] = ib;
    b.f1[1] = jb;
    b.f1[2] = kb;
    b.f1[3] = lb;
    mb.f1.size[0] = 1;
    mb.f1.size[1] = 1;
    mb.f1.data[0] = 'L';
    nb.f1.size[0] = 1;
    nb.f1.size[1] = 1;
    nb.f1.data[0] = 'S';
    ob.f1.size[0] = 1;
    ob.f1.size[1] = 1;
    ob.f1.data[0] = 'R';
    pb.f1.size[0] = 1;
    pb.f1.size[1] = 1;
    pb.f1.data[0] = 'N';
    qb.f1.size[0] = 1;
    qb.f1.size[1] = 1;
    qb.f1.data[0] = 'R';
    rb.f1.size[0] = 1;
    rb.f1.size[1] = 1;
    rb.f1.data[0] = 'S';
    sb.f1.size[0] = 1;
    sb.f1.size[1] = 1;
    sb.f1.data[0] = 'L';
    tb.f1.size[0] = 1;
    tb.f1.size[1] = 1;
    tb.f1.data[0] = 'N';
    ub.f1.size[0] = 1;
    ub.f1.size[1] = 1;
    ub.f1.data[0] = 'R';
    vb.f1.size[0] = 1;
    vb.f1.size[1] = 1;
    vb.f1.data[0] = 'S';
    wb.f1.size[0] = 1;
    wb.f1.size[1] = 1;
    wb.f1.data[0] = 'R';
    xb.f1.size[0] = 1;
    xb.f1.size[1] = 1;
    xb.f1.data[0] = 'N';
    yb.f1.size[0] = 1;
    yb.f1.size[1] = 1;
    yb.f1.data[0] = 'R';
    ac.f1.size[0] = 1;
    ac.f1.size[1] = 1;
    ac.f1.data[0] = 'L';
    bc.f1.size[0] = 1;
    bc.f1.size[1] = 1;
    bc.f1.data[0] = 'R';
    cc.f1.size[0] = 1;
    cc.f1.size[1] = 1;
    cc.f1.data[0] = 'N';
    dc.f1.size[0] = 1;
    dc.f1.size[1] = 1;
    dc.f1.data[0] = 'L';
    ec.f1.size[0] = 1;
    ec.f1.size[1] = 1;
    ec.f1.data[0] = 'R';
    fc.f1.size[0] = 1;
    fc.f1.size[1] = 1;
    fc.f1.data[0] = 'L';
    gc.f1.size[0] = 1;
    gc.f1.size[1] = 1;
    gc.f1.data[0] = 'N';
    hc.f1.size[0] = 1;
    hc.f1.size[1] = 2;
    ic.f1.size[0] = 1;
    ic.f1.size[1] = 1;
    ic.f1.data[0] = 'L';
    jc.f1.size[0] = 1;
    jc.f1.size[1] = 1;
    jc.f1.data[0] = 'S';
    kc.f1.size[0] = 1;
    kc.f1.size[1] = 1;
    kc.f1.data[0] = 'L';
    lc.f1.size[0] = 1;
    lc.f1.size[1] = 2;
    mc.f1.size[0] = 1;
    mc.f1.size[1] = 1;
    mc.f1.data[0] = 'L';
    nc.f1.size[0] = 1;
    nc.f1.size[1] = 1;
    nc.f1.data[0] = 'S';
    oc.f1.size[0] = 1;
    oc.f1.size[1] = 1;
    oc.f1.data[0] = 'R';
    pc.f1.size[0] = 1;
    pc.f1.size[1] = 2;
    qc.f1.size[0] = 1;
    qc.f1.size[1] = 1;
    qc.f1.data[0] = 'R';
    rc.f1.size[0] = 1;
    rc.f1.size[1] = 1;
    rc.f1.data[0] = 'S';
    sc.f1.size[0] = 1;
    sc.f1.size[1] = 1;
    sc.f1.data[0] = 'L';
    tc.f1.size[0] = 1;
    tc.f1.size[1] = 2;
    uc.f1.size[0] = 1;
    uc.f1.size[1] = 1;
    uc.f1.data[0] = 'R';
    vc.f1.size[0] = 1;
    vc.f1.size[1] = 1;
    vc.f1.data[0] = 'S';
    wc.f1.size[0] = 1;
    wc.f1.size[1] = 1;
    wc.f1.data[0] = 'R';
    xc.f1.size[0] = 1;
    xc.f1.size[1] = 2;
    yc.f1.size[0] = 1;
    yc.f1.size[1] = 1;
    yc.f1.data[0] = 'R';
    ad.f1.size[0] = 1;
    ad.f1.size[1] = 1;
    ad.f1.data[0] = 'L';
    bd.f1.size[0] = 1;
    bd.f1.size[1] = 1;
    bd.f1.data[0] = 'R';
    cd.f1.size[0] = 1;
    cd.f1.size[1] = 2;
    dd.f1.size[0] = 1;
    dd.f1.size[1] = 1;
    dd.f1.data[0] = 'L';
    ed.f1.size[0] = 1;
    ed.f1.size[1] = 1;
    ed.f1.data[0] = 'R';
    fd.f1.size[0] = 1;
    fd.f1.size[1] = 1;
    fd.f1.data[0] = 'L';
    gd.f1.size[0] = 1;
    gd.f1.size[1] = 1;
    gd.f1.data[0] = 'L';
    hd.f1.size[0] = 1;
    hd.f1.size[1] = 1;
    hd.f1.data[0] = 'S';
    id.f1.size[0] = 1;
    id.f1.size[1] = 1;
    id.f1.data[0] = 'L';
    jd.f1.size[0] = 1;
    jd.f1.size[1] = 2;
    kd.f1.size[0] = 1;
    kd.f1.size[1] = 1;
    kd.f1.data[0] = 'L';
    ld.f1.size[0] = 1;
    ld.f1.size[1] = 1;
    ld.f1.data[0] = 'S';
    md.f1.size[0] = 1;
    md.f1.size[1] = 1;
    md.f1.data[0] = 'R';
    nd.f1.size[0] = 1;
    nd.f1.size[1] = 2;
    od.f1.size[0] = 1;
    od.f1.size[1] = 1;
    od.f1.data[0] = 'R';
    pd.f1.size[0] = 1;
    pd.f1.size[1] = 1;
    pd.f1.data[0] = 'S';
    qd.f1.size[0] = 1;
    qd.f1.size[1] = 1;
    qd.f1.data[0] = 'L';
    rd.f1.size[0] = 1;
    rd.f1.size[1] = 2;
    sd.f1.size[0] = 1;
    sd.f1.size[1] = 1;
    sd.f1.data[0] = 'R';
    td.f1.size[0] = 1;
    td.f1.size[1] = 1;
    td.f1.data[0] = 'S';
    ud.f1.size[0] = 1;
    ud.f1.size[1] = 1;
    ud.f1.data[0] = 'R';
    vd.f1.size[0] = 1;
    vd.f1.size[1] = 2;
    wd.f1.size[0] = 1;
    wd.f1.size[1] = 1;
    wd.f1.data[0] = 'R';
    xd.f1.size[0] = 1;
    xd.f1.size[1] = 1;
    xd.f1.data[0] = 'L';
    yd.f1.size[0] = 1;
    yd.f1.size[1] = 1;
    yd.f1.data[0] = 'R';
    ae.f1.size[0] = 1;
    ae.f1.size[1] = 2;
    be.f1.size[0] = 1;
    be.f1.size[1] = 1;
    be.f1.data[0] = 'L';
    ce.f1.size[0] = 1;
    ce.f1.size[1] = 1;
    ce.f1.data[0] = 'R';
    de.f1.size[0] = 1;
    de.f1.size[1] = 1;
    de.f1.data[0] = 'L';
    ee.f1.size[0] = 1;
    ee.f1.size[1] = 2;
    hc.f1.data[0] = 'H';
    lc.f1.data[0] = 'H';
    pc.f1.data[0] = 'H';
    tc.f1.data[0] = 'H';
    xc.f1.data[0] = 'H';
    cd.f1.data[0] = 'H';
    jd.f1.data[0] = 'H';
    nd.f1.data[0] = 'H';
    rd.f1.data[0] = 'H';
    vd.f1.data[0] = 'H';
    ae.f1.data[0] = 'H';
    ee.f1.data[0] = 'H';
    hc.f1.data[1] = 'l';
    lc.f1.data[1] = 'l';
    pc.f1.data[1] = 'r';
    tc.f1.data[1] = 'r';
    xc.f1.data[1] = 'r';
    cd.f1.data[1] = 'l';
    jd.f1.data[1] = 'l';
    nd.f1.data[1] = 'r';
    rd.f1.data[1] = 'l';
    vd.f1.data[1] = 'r';
    ae.f1.data[1] = 'r';
    ee.f1.data[1] = 'l';
    fe.f1.size[0] = 1;
    fe.f1.size[1] = 1;
    fe.f1.data[0] = 'L';
    ge.f1.size[0] = 1;
    ge.f1.size[1] = 1;
    ge.f1.data[0] = 'R';
    he.f1.size[0] = 1;
    he.f1.size[1] = 1;
    he.f1.data[0] = 'S';
    ie.f1.size[0] = 1;
    ie.f1.size[1] = 1;
    ie.f1.data[0] = 'L';
    je.f1.size[0] = 1;
    je.f1.size[1] = 1;
    je.f1.data[0] = 'L';
    ke.f1.size[0] = 1;
    ke.f1.size[1] = 1;
    ke.f1.data[0] = 'R';
    le.f1.size[0] = 1;
    le.f1.size[1] = 1;
    le.f1.data[0] = 'S';
    me.f1.size[0] = 1;
    me.f1.size[1] = 1;
    me.f1.data[0] = 'R';
    ne.f1.size[0] = 1;
    ne.f1.size[1] = 1;
    ne.f1.data[0] = 'L';
    oe.f1.size[0] = 1;
    oe.f1.size[1] = 1;
    oe.f1.data[0] = 'R';
    pe.f1.size[0] = 1;
    pe.f1.size[1] = 1;
    pe.f1.data[0] = 'L';
    qe.f1.size[0] = 1;
    qe.f1.size[1] = 1;
    qe.f1.data[0] = 'R';
    re.f1.size[0] = 1;
    re.f1.size[1] = 1;
    re.f1.data[0] = 'R';
    se.f1.size[0] = 1;
    se.f1.size[1] = 1;
    se.f1.data[0] = 'L';
    te.f1.size[0] = 1;
    te.f1.size[1] = 1;
    te.f1.data[0] = 'S';
    ue.f1.size[0] = 1;
    ue.f1.size[1] = 1;
    ue.f1.data[0] = 'R';
    ve.f1.size[0] = 1;
    ve.f1.size[1] = 1;
    ve.f1.data[0] = 'R';
    we.f1.size[0] = 1;
    we.f1.size[1] = 1;
    we.f1.data[0] = 'L';
    xe.f1.size[0] = 1;
    xe.f1.size[1] = 1;
    xe.f1.data[0] = 'R';
    ye.f1.size[0] = 1;
    ye.f1.size[1] = 1;
    ye.f1.data[0] = 'L';
    af.f1.size[0] = 1;
    af.f1.size[1] = 1;
    af.f1.data[0] = 'R';
    bf.f1.size[0] = 1;
    bf.f1.size[1] = 1;
    bf.f1.data[0] = 'L';
    cf.f1.size[0] = 1;
    cf.f1.size[1] = 1;
    cf.f1.data[0] = 'S';
    df.f1.size[0] = 1;
    df.f1.size[1] = 1;
    df.f1.data[0] = 'L';
    ef.f1.size[0] = 1;
    ef.f1.size[1] = 1;
    ef.f1.data[0] = 'L';
    ff.f1.size[0] = 1;
    ff.f1.size[1] = 1;
    ff.f1.data[0] = 'S';
    gf.f1.size[0] = 1;
    gf.f1.size[1] = 1;
    gf.f1.data[0] = 'R';
    hf.f1.size[0] = 1;
    hf.f1.size[1] = 1;
    hf.f1.data[0] = 'L';
    jf.f1.size[0] = 1;
    jf.f1.size[1] = 1;
    jf.f1.data[0] = 'R';
    kf.f1.size[0] = 1;
    kf.f1.size[1] = 1;
    kf.f1.data[0] = 'S';
    lf.f1.size[0] = 1;
    lf.f1.size[1] = 1;
    lf.f1.data[0] = 'R';
    mf.f1.size[0] = 1;
    mf.f1.size[1] = 1;
    mf.f1.data[0] = 'L';
    nf.f1.size[0] = 1;
    nf.f1.size[1] = 1;
    nf.f1.data[0] = 'L';
    of.f1.size[0] = 1;
    of.f1.size[1] = 1;
    of.f1.data[0] = 'S';
    pf.f1.size[0] = 1;
    pf.f1.size[1] = 1;
    pf.f1.data[0] = 'L';
    qf.f1.size[0] = 1;
    qf.f1.size[1] = 1;
    qf.f1.data[0] = 'R';
    rf.f1.size[0] = 1;
    rf.f1.size[1] = 1;
    rf.f1.data[0] = 'R';
    sf.f1.size[0] = 1;
    sf.f1.size[1] = 1;
    sf.f1.data[0] = 'S';
    tf.f1.size[0] = 1;
    tf.f1.size[1] = 1;
    tf.f1.data[0] = 'L';
    uf.f1.size[0] = 1;
    uf.f1.size[1] = 1;
    uf.f1.data[0] = 'R';
    motionTypes[0] = b;
    b_obj_UAVDubinsBuildableObj =
        FlightMissionMode_uavDubinsBuildable_uavDubinsBuildable_j(obj->AirSpeed,
        obj->MaxRollAngle, obj->FlightPathAngleLimit);
    b_startPose[0] = startPose[0];
    b_goalPose[0] = goalPose[0];
    b_startPose[1] = startPose[1];
    b_goalPose[1] = goalPose[1];
    b_startPose[2] = startPose[2];
    b_goalPose[2] = goalPose[2];
    b_startPose[3] = startPose[3];
    b_goalPose[3] = goalPose[3];
    uavDubinsDistanceCodegen_real64(b_obj_UAVDubinsBuildableObj, &b_startPose[0],
        1U, &b_goalPose[0], 1U, true, turningRadius, &s[0], &g[0], &b_fpa, &b_a,
        &mtr, &h, &mt, &ml[0]);
    tmp = 0;
    for (int32_T i{0}; i < 4; i++) {
        ml1[tmp] = ml[i];
        ml1[static_cast<int32_T>(tmp + 1)] = ml[static_cast<int32_T>(i + 4)];
        ml1[static_cast<int32_T>(tmp + 2)] = ml[static_cast<int32_T>(i + 8)];
        ml1[static_cast<int32_T>(tmp + 3)] = ml[static_cast<int32_T>(i + 12)];
        tmp = static_cast<int32_T>(tmp + 4);
    }

    if (mt + 1.0 == 2.0) {
        motionTypes[0].f1[0] = mb;
        motionTypes[0].f1[1] = nb;
        motionTypes[0].f1[2] = ob;
        motionTypes[0].f1[3] = pb;
    }

    if (mt + 1.0 == 3.0) {
        motionTypes[0].f1[0] = qb;
        motionTypes[0].f1[1] = rb;
        motionTypes[0].f1[2] = sb;
        motionTypes[0].f1[3] = tb;
    }

    if (mt + 1.0 == 4.0) {
        motionTypes[0].f1[0] = ub;
        motionTypes[0].f1[1] = vb;
        motionTypes[0].f1[2] = wb;
        motionTypes[0].f1[3] = xb;
    }

    if (mt + 1.0 == 5.0) {
        motionTypes[0].f1[0] = yb;
        motionTypes[0].f1[1] = ac;
        motionTypes[0].f1[2] = bc;
        motionTypes[0].f1[3] = cc;
    }

    if (mt + 1.0 == 6.0) {
        motionTypes[0].f1[0] = dc;
        motionTypes[0].f1[1] = ec;
        motionTypes[0].f1[2] = fc;
        motionTypes[0].f1[3] = gc;
    }

    if (mt + 1.0 == 7.0) {
        motionTypes[0].f1[0] = hc;
        motionTypes[0].f1[1] = ic;
        motionTypes[0].f1[2] = jc;
        motionTypes[0].f1[3] = kc;
    }

    if (mt + 1.0 == 8.0) {
        motionTypes[0].f1[0] = lc;
        motionTypes[0].f1[1] = mc;
        motionTypes[0].f1[2] = nc;
        motionTypes[0].f1[3] = oc;
    }

    if (mt + 1.0 == 9.0) {
        motionTypes[0].f1[0] = pc;
        motionTypes[0].f1[1] = qc;
        motionTypes[0].f1[2] = rc;
        motionTypes[0].f1[3] = sc;
    }

    if (mt + 1.0 == 10.0) {
        motionTypes[0].f1[0] = tc;
        motionTypes[0].f1[1] = uc;
        motionTypes[0].f1[2] = vc;
        motionTypes[0].f1[3] = wc;
    }

    if (mt + 1.0 == 11.0) {
        motionTypes[0].f1[0] = xc;
        motionTypes[0].f1[1] = yc;
        motionTypes[0].f1[2] = ad;
        motionTypes[0].f1[3] = bd;
    }

    if (mt + 1.0 == 12.0) {
        motionTypes[0].f1[0] = cd;
        motionTypes[0].f1[1] = dd;
        motionTypes[0].f1[2] = ed;
        motionTypes[0].f1[3] = fd;
    }

    if (mt + 1.0 == 13.0) {
        motionTypes[0].f1[0] = gd;
        motionTypes[0].f1[1] = hd;
        motionTypes[0].f1[2] = id;
        motionTypes[0].f1[3] = jd;
    }

    if (mt + 1.0 == 14.0) {
        motionTypes[0].f1[0] = kd;
        motionTypes[0].f1[1] = ld;
        motionTypes[0].f1[2] = md;
        motionTypes[0].f1[3] = nd;
    }

    if (mt + 1.0 == 15.0) {
        motionTypes[0].f1[0] = od;
        motionTypes[0].f1[1] = pd;
        motionTypes[0].f1[2] = qd;
        motionTypes[0].f1[3] = rd;
    }

    if (mt + 1.0 == 16.0) {
        motionTypes[0].f1[0] = sd;
        motionTypes[0].f1[1] = td;
        motionTypes[0].f1[2] = ud;
        motionTypes[0].f1[3] = vd;
    }

    if (mt + 1.0 == 17.0) {
        motionTypes[0].f1[0] = wd;
        motionTypes[0].f1[1] = xd;
        motionTypes[0].f1[2] = yd;
        motionTypes[0].f1[3] = ae;
    }

    if (mt + 1.0 == 18.0) {
        motionTypes[0].f1[0] = be;
        motionTypes[0].f1[1] = ce;
        motionTypes[0].f1[2] = de;
        motionTypes[0].f1[3] = ee;
    }

    if (mt + 1.0 == 19.0) {
        motionTypes[0].f1[0] = fe;
        motionTypes[0].f1[1] = ge;
        motionTypes[0].f1[2] = he;
        motionTypes[0].f1[3] = ie;
    }

    if (mt + 1.0 == 20.0) {
        motionTypes[0].f1[0] = je;
        motionTypes[0].f1[1] = ke;
        motionTypes[0].f1[2] = le;
        motionTypes[0].f1[3] = me;
    }

    if (mt + 1.0 == 21.0) {
        motionTypes[0].f1[0] = ne;
        motionTypes[0].f1[1] = oe;
        motionTypes[0].f1[2] = pe;
        motionTypes[0].f1[3] = qe;
    }

    if (mt + 1.0 == 22.0) {
        motionTypes[0].f1[0] = re;
        motionTypes[0].f1[1] = se;
        motionTypes[0].f1[2] = te;
        motionTypes[0].f1[3] = ue;
    }

    if (mt + 1.0 == 23.0) {
        motionTypes[0].f1[0] = ve;
        motionTypes[0].f1[1] = we;
        motionTypes[0].f1[2] = xe;
        motionTypes[0].f1[3] = ye;
    }

    if (mt + 1.0 == 24.0) {
        motionTypes[0].f1[0] = af;
        motionTypes[0].f1[1] = bf;
        motionTypes[0].f1[2] = cf;
        motionTypes[0].f1[3] = df;
    }

    if (mt + 1.0 == 25.0) {
        motionTypes[0].f1[0] = ef;
        motionTypes[0].f1[1] = ff;
        motionTypes[0].f1[2] = gf;
        motionTypes[0].f1[3] = hf;
    }

    if (mt + 1.0 == 26.0) {
        motionTypes[0].f1[0] = jf;
        motionTypes[0].f1[1] = kf;
        motionTypes[0].f1[2] = lf;
        motionTypes[0].f1[3] = mf;
    }

    if (mt + 1.0 == 27.0) {
        motionTypes[0].f1[0] = nf;
        motionTypes[0].f1[1] = of;
        motionTypes[0].f1[2] = pf;
        motionTypes[0].f1[3] = qf;
    }

    if (mt + 1.0 == 28.0) {
        motionTypes[0].f1[0] = rf;
        motionTypes[0].f1[1] = sf;
        motionTypes[0].f1[2] = tf;
        motionTypes[0].f1[3] = uf;
    }

    b_startPose[0] = s[0];
    b_goalPose[0] = g[0];
    ml1_0[0] = ml1[0];
    b_startPose[1] = s[1];
    b_goalPose[1] = g[1];
    ml1_0[1] = ml1[4];
    b_startPose[2] = s[2];
    b_goalPose[2] = g[2];
    ml1_0[2] = ml1[8];
    b_startPose[3] = s[3];
    b_goalPose[3] = g[3];
    ml1_0[3] = ml1[12];
    FlightMissionMode_uavDubinsPathSegment_uavDubinsPathSegment_hw(b_startPose,
        b_goalPose, b_fpa, b_a, mtr, h, motionTypes[0].f1, ml1_0, pathSegObjs);
    ml1_0[0] = ml1[0];
    ml1_0[1] = ml1[4];
    ml1_0[2] = ml1[8];
    ml1_0[3] = ml1[12];
    *pathCosts = sum_ftQQGuCy(ml1_0);
}

static real_T FlightMissionMode_angdiff(real_T x, real_T y)
{
    real_T delta;
    delta = y - x;
    if (std::abs(delta) > 3.1415926535897931) {
        real_T thetaWrap;
        if (std::isnan(delta + 3.1415926535897931) || std::isinf(delta +
                3.1415926535897931)) {
            thetaWrap = (rtNaN);
        } else if (delta + 3.1415926535897931 == 0.0) {
            thetaWrap = 0.0;
        } else {
            boolean_T rEQ0;
            thetaWrap = std::fmod(delta + 3.1415926535897931, 6.2831853071795862);
            rEQ0 = (thetaWrap == 0.0);
            if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                    (rEQ0) ^ 1))) {
                real_T q;
                q = std::abs((delta + 3.1415926535897931) / 6.2831853071795862);
                rEQ0 = static_cast<boolean_T>(static_cast<int32_T>((std::abs(q -
                    std::floor(q + 0.5)) > 2.2204460492503131E-16 * q) ^ 1));
            }

            if (rEQ0) {
                thetaWrap = 0.0;
            } else if (delta + 3.1415926535897931 < 0.0) {
                thetaWrap += 6.2831853071795862;
            }
        }

        if (static_cast<boolean_T>(static_cast<int32_T>((delta +
                3.1415926535897931 > 0.0) & (thetaWrap == 0.0)))) {
            thetaWrap = 6.2831853071795862;
        }

        delta = thetaWrap - 3.1415926535897931;
    }

    return delta;
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static void FlightMissionMode_eml_float_colon(real_T d, real_T b,
    emxArray_real_T_FlightMissionMode_T *y)
{
    real_T apnd;
    real_T cdiff;
    real_T ndbl;
    int32_T k;
    int32_T n;
    ndbl = std::floor(b / d + 0.5);
    apnd = ndbl * d;
    cdiff = apnd - b;
    if (std::abs(cdiff) < 4.4408920985006262E-16 * std::fmax(0.0, std::abs(b)))
    {
        ndbl++;
        apnd = b;
    } else if (cdiff > 0.0) {
        apnd = (ndbl - 1.0) * d;
    } else {
        ndbl++;
    }

    if (ndbl >= 0.0) {
        n = static_cast<int32_T>(static_cast<int32_T>(ndbl) - 1);
    } else {
        n = -1;
    }

    k = static_cast<int32_T>(y->size[0] * y->size[1]);
    y->size[0] = 1;
    y->size[1] = static_cast<int32_T>(n + 1);
    FlightMissionMode_emxEnsureCapacity_real_T_c(y, k);
    if (static_cast<int32_T>(n + 1) > 0) {
        y->data[0] = 0.0;
        if (static_cast<int32_T>(n + 1) > 1) {
            int32_T nm1d2;
            y->data[n] = apnd;
            nm1d2 = static_cast<int32_T>(n / 2);
            for (k = 0; k <= static_cast<int32_T>(nm1d2 - 2); k++) {
                ndbl = (static_cast<real_T>(k) + 1.0) * d;
                y->data[static_cast<int32_T>(k + 1)] = ndbl;
                y->data[static_cast<int32_T>(static_cast<int32_T>(n - k) - 1)] =
                    apnd - ndbl;
            }

            if (static_cast<int32_T>(nm1d2 << 1) == n) {
                y->data[nm1d2] = apnd / 2.0;
            } else {
                ndbl = static_cast<real_T>(nm1d2) * d;
                y->data[nm1d2] = ndbl;
                y->data[static_cast<int32_T>(nm1d2 + 1)] = apnd - ndbl;
            }
        }
    }
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static void FlightMissionMode_strcmp_hbqnfpsg(const
    cell_wrap_0_FlightMissionMode_T a[4], boolean_T b_bool[4])
{
    b_bool[0] = false;
    if ((a[0].f1.size[1] == 1) && (a[0].f1.data[0] == 'N')) {
        b_bool[0] = true;
    }

    b_bool[1] = false;
    if ((a[1].f1.size[1] == 1) && (a[1].f1.data[0] == 'N')) {
        b_bool[1] = true;
    }

    b_bool[2] = false;
    if ((a[2].f1.size[1] == 1) && (a[2].f1.data[0] == 'N')) {
        b_bool[2] = true;
    }

    b_bool[3] = false;
    if ((a[3].f1.size[1] == 1) && (a[3].f1.data[0] == 'N')) {
        b_bool[3] = true;
    }
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static boolean_T FlightMissionMode_any_i(const boolean_T x[4])
{
    int32_T k;
    boolean_T exitg1;
    boolean_T y;
    y = false;
    k = 0;
    exitg1 = false;
    while ((!exitg1) && (k < 4)) {
        if (x[k]) {
            y = true;
            exitg1 = true;
        } else {
            k = static_cast<int32_T>(k + 1);
        }
    }

    return y;
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static void FlightMissionMode_useConstantDim_i(real_T varargin_2_data[], const
    int32_T varargin_2_size[2])
{
    int32_T b;
    b = static_cast<int32_T>(static_cast<uint8_T>(static_cast<int32_T>
        (varargin_2_size[1] - 1)));
    for (int32_T k{0}; k <= static_cast<int32_T>(b - 1); k++) {
        varargin_2_data[static_cast<int32_T>(k + 1)] += varargin_2_data[k];
    }
}

static void FlightMissionMode_emxInit_int32_T_k
    (emxArray_int32_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions)
{
    emxArray_int32_T_FlightMissionMode_T *emxArray;
    *pEmxArray = static_cast<emxArray_int32_T_FlightMissionMode_T *>(std::malloc
        (sizeof(emxArray_int32_T_FlightMissionMode_T)));
    emxArray = *pEmxArray;
    emxArray->data = static_cast<int32_T *>(nullptr);
    emxArray->numDimensions = numDimensions;
    emxArray->size = static_cast<int32_T *>(std::malloc(static_cast<uint32_T>
        (sizeof(int32_T) * static_cast<uint32_T>(numDimensions))));
    emxArray->allocatedSize = 0;
    emxArray->canFreeData = true;
    for (int32_T i{0}; i <= static_cast<int32_T>(numDimensions - 1); i++) {
        emxArray->size[i] = 0;
    }
}

static void FlightMissionMode_emxEnsureCapacity_int32_T_j
    (emxArray_int32_T_FlightMissionMode_T *emxArray, int32_T oldNumel)
{
    int32_T i;
    int32_T newNumel;
    void *newData;
    if (oldNumel < 0) {
        oldNumel = 0;
    }

    newNumel = 1;
    for (i = 0; i <= static_cast<int32_T>(emxArray->numDimensions - 1); i++) {
        newNumel = static_cast<int32_T>(newNumel * emxArray->size[i]);
    }

    if (newNumel > emxArray->allocatedSize) {
        i = emxArray->allocatedSize;
        if (i < 16) {
            i = 16;
        }

        while (i < newNumel) {
            if (i > 1073741823) {
                i = MAX_int32_T;
            } else {
                i = static_cast<int32_T>(i << 1);
            }
        }

        newData = std::calloc(static_cast<uint32_T>(i), sizeof(int32_T));
        if (emxArray->data != nullptr) {
            std::memcpy(newData, emxArray->data, static_cast<uint32_T>(sizeof
                         (int32_T) * static_cast<uint32_T>(oldNumel)));
            if (emxArray->canFreeData) {
                std::free(emxArray->data);
            }
        }

        emxArray->data = static_cast<int32_T *>(newData);
        emxArray->allocatedSize = i;
        emxArray->canFreeData = true;
    }
}

static void FlightMissionMode_emxFree_int32_T_a
    (emxArray_int32_T_FlightMissionMode_T **pEmxArray)
{
    if (*pEmxArray != static_cast<emxArray_int32_T_FlightMissionMode_T *>
            (nullptr)) {
        if (((*pEmxArray)->data != static_cast<int32_T *>(nullptr)) &&
                (*pEmxArray)->canFreeData) {
            std::free((*pEmxArray)->data);
        }

        std::free((*pEmxArray)->size);
        std::free(*pEmxArray);
        *pEmxArray = static_cast<emxArray_int32_T_FlightMissionMode_T *>(nullptr);
    }
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static void FlightMissionMode_merge_h(emxArray_int32_T_FlightMissionMode_T *idx,
    emxArray_real_T_FlightMissionMode_T *x, int32_T offset, int32_T np, int32_T
    nq, emxArray_int32_T_FlightMissionMode_T *iwork,
    emxArray_real_T_FlightMissionMode_T *xwork)
{
    if (nq != 0) {
        int32_T iout;
        int32_T n;
        int32_T q;
        int32_T qend;
        qend = static_cast<int32_T>(np + nq);
        for (q = 0; q <= static_cast<int32_T>(qend - 1); q++) {
            iwork->data[q] = idx->data[static_cast<int32_T>(offset + q)];
            xwork->data[q] = x->data[static_cast<int32_T>(offset + q)];
        }

        n = 0;
        q = np;
        iout = static_cast<int32_T>(offset - 1);
        int32_T exitg1;
        do {
            exitg1 = 0;
            iout = static_cast<int32_T>(iout + 1);
            if (xwork->data[n] <= xwork->data[q]) {
                idx->data[iout] = iwork->data[n];
                x->data[iout] = xwork->data[n];
                if (static_cast<int32_T>(n + 1) < np) {
                    n = static_cast<int32_T>(n + 1);
                } else {
                    exitg1 = 1;
                }
            } else {
                idx->data[iout] = iwork->data[q];
                x->data[iout] = xwork->data[q];
                if (static_cast<int32_T>(q + 1) < qend) {
                    q = static_cast<int32_T>(q + 1);
                } else {
                    qend = static_cast<int32_T>(iout - n);
                    for (q = static_cast<int32_T>(n + 1); q <= np; q++) {
                        iout = static_cast<int32_T>(qend + q);
                        idx->data[iout] = iwork->data[static_cast<int32_T>(q - 1)];
                        x->data[iout] = xwork->data[static_cast<int32_T>(q - 1)];
                    }

                    exitg1 = 1;
                }
            }
        } while (exitg1 == 0);
    }
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static void FlightMissionMode_merge_block_d(emxArray_int32_T_FlightMissionMode_T
    *idx, emxArray_real_T_FlightMissionMode_T *x, int32_T offset, int32_T n,
    int32_T preSortLevel, emxArray_int32_T_FlightMissionMode_T *iwork,
    emxArray_real_T_FlightMissionMode_T *xwork)
{
    int32_T bLen;
    int32_T nPairs;
    nPairs = static_cast<int32_T>(n >> preSortLevel);
    bLen = static_cast<int32_T>(1 << preSortLevel);
    while (nPairs > 1) {
        int32_T nTail;
        int32_T tailOffset;
        if (static_cast<uint32_T>(static_cast<uint32_T>(nPairs) & 1U) != 0U) {
            nPairs = static_cast<int32_T>(nPairs - 1);
            tailOffset = static_cast<int32_T>(bLen * nPairs);
            nTail = static_cast<int32_T>(n - tailOffset);
            if (nTail > bLen) {
                FlightMissionMode_merge_h(idx, x, static_cast<int32_T>(offset +
                    tailOffset), bLen, static_cast<int32_T>(nTail - bLen), iwork,
                    xwork);
            }
        }

        nTail = static_cast<int32_T>(bLen << 1);
        nPairs = static_cast<int32_T>(nPairs >> 1);
        for (tailOffset = 0; tailOffset <= static_cast<int32_T>(nPairs - 1);
                tailOffset++) {
            FlightMissionMode_merge_h(idx, x, static_cast<int32_T>(offset +
                static_cast<int32_T>(tailOffset * nTail)), bLen, bLen, iwork,
                xwork);
        }

        bLen = nTail;
    }

    if (n > bLen) {
        FlightMissionMode_merge_h(idx, x, offset, bLen, static_cast<int32_T>(n -
            bLen), iwork, xwork);
    }
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static void FlightMissionMode_sort_o(emxArray_real_T_FlightMissionMode_T *x)
{
    emxArray_int32_T_FlightMissionMode_T *idx;
    emxArray_int32_T_FlightMissionMode_T *iwork;
    emxArray_real_T_FlightMissionMode_T *b_x;
    emxArray_real_T_FlightMissionMode_T *xwork;
    real_T b_xwork[256];
    real_T x4[4];
    int32_T b_iwork[256];
    int32_T idx4[4];
    int32_T b_iwork_tmp;
    int32_T ib;
    int32_T n;
    int8_T perm[4];
    FlightMissionMode_emxInit_real_T_h(&b_x, 2);
    b_iwork_tmp = static_cast<int32_T>(b_x->size[0] * b_x->size[1]);
    b_x->size[0] = 1;
    b_x->size[1] = x->size[1];
    FlightMissionMode_emxEnsureCapacity_real_T_c(b_x, b_iwork_tmp);
    n = x->size[1];
    for (ib = 0; ib <= static_cast<int32_T>(n - 1); ib++) {
        b_x->data[ib] = x->data[ib];
    }

    if (x->size[1] != 0) {
        int32_T blockOffset;
        int32_T i1;
        int32_T i2;
        int32_T i3;
        int32_T i4;
        int32_T nBlocks;
        int32_T wOffset;
        FlightMissionMode_emxInit_int32_T_k(&idx, 2);
        b_iwork_tmp = static_cast<int32_T>(idx->size[0] * idx->size[1]);
        idx->size[0] = 1;
        idx->size[1] = x->size[1];
        FlightMissionMode_emxEnsureCapacity_int32_T_j(idx, b_iwork_tmp);
        n = x->size[1];
        for (ib = 0; ib <= static_cast<int32_T>(n - 1); ib++) {
            idx->data[ib] = 0;
        }

        b_iwork_tmp = static_cast<int32_T>(b_x->size[0] * b_x->size[1]);
        b_x->size[0] = 1;
        b_x->size[1] = x->size[1];
        FlightMissionMode_emxEnsureCapacity_real_T_c(b_x, b_iwork_tmp);
        n = x->size[1];
        for (ib = 0; ib <= static_cast<int32_T>(n - 1); ib++) {
            b_x->data[ib] = x->data[ib];
        }

        n = static_cast<int32_T>(x->size[1] - 1);
        x4[0] = 0.0;
        idx4[0] = 0;
        x4[1] = 0.0;
        idx4[1] = 0;
        x4[2] = 0.0;
        idx4[2] = 0;
        x4[3] = 0.0;
        idx4[3] = 0;
        FlightMissionMode_emxInit_int32_T_k(&iwork, 1);
        FlightMissionMode_emxInit_real_T_h(&xwork, 1);
        nBlocks = x->size[1];
        b_iwork_tmp = xwork->size[0];
        xwork->size[0] = x->size[1];
        FlightMissionMode_emxEnsureCapacity_real_T_c(xwork, b_iwork_tmp);
        for (ib = 0; ib <= static_cast<int32_T>(nBlocks - 1); ib++) {
            xwork->data[ib] = 0.0;
        }

        nBlocks = 0;
        ib = -1;
        for (wOffset = 0; wOffset <= n; wOffset++) {
            if (std::isnan(b_x->data[wOffset])) {
                i1 = static_cast<int32_T>(n - nBlocks);
                idx->data[i1] = static_cast<int32_T>(wOffset + 1);
                xwork->data[i1] = b_x->data[wOffset];
                nBlocks = static_cast<int32_T>(nBlocks + 1);
            } else {
                ib = static_cast<int32_T>(ib + 1);
                idx4[ib] = static_cast<int32_T>(wOffset + 1);
                x4[ib] = b_x->data[wOffset];
                if (static_cast<int32_T>(ib + 1) == 4) {
                    real_T tmp;
                    real_T tmp_0;
                    ib = static_cast<int32_T>(wOffset - nBlocks);
                    if (x4[0] <= x4[1]) {
                        i1 = 1;
                        i2 = 2;
                    } else {
                        i1 = 2;
                        i2 = 1;
                    }

                    if (x4[2] <= x4[3]) {
                        i3 = 3;
                        i4 = 4;
                    } else {
                        i3 = 4;
                        i4 = 3;
                    }

                    tmp = x4[static_cast<int32_T>(i1 - 1)];
                    tmp_0 = x4[static_cast<int32_T>(i3 - 1)];
                    if (tmp <= tmp_0) {
                        tmp = x4[static_cast<int32_T>(i2 - 1)];
                        if (tmp <= tmp_0) {
                            perm[0] = static_cast<int8_T>(i1);
                            perm[1] = static_cast<int8_T>(i2);
                            perm[2] = static_cast<int8_T>(i3);
                            perm[3] = static_cast<int8_T>(i4);
                        } else if (tmp <= x4[static_cast<int32_T>(i4 - 1)]) {
                            perm[0] = static_cast<int8_T>(i1);
                            perm[1] = static_cast<int8_T>(i3);
                            perm[2] = static_cast<int8_T>(i2);
                            perm[3] = static_cast<int8_T>(i4);
                        } else {
                            perm[0] = static_cast<int8_T>(i1);
                            perm[1] = static_cast<int8_T>(i3);
                            perm[2] = static_cast<int8_T>(i4);
                            perm[3] = static_cast<int8_T>(i2);
                        }
                    } else {
                        tmp_0 = x4[static_cast<int32_T>(i4 - 1)];
                        if (tmp <= tmp_0) {
                            if (x4[static_cast<int32_T>(i2 - 1)] <= tmp_0) {
                                perm[0] = static_cast<int8_T>(i3);
                                perm[1] = static_cast<int8_T>(i1);
                                perm[2] = static_cast<int8_T>(i2);
                                perm[3] = static_cast<int8_T>(i4);
                            } else {
                                perm[0] = static_cast<int8_T>(i3);
                                perm[1] = static_cast<int8_T>(i1);
                                perm[2] = static_cast<int8_T>(i4);
                                perm[3] = static_cast<int8_T>(i2);
                            }
                        } else {
                            perm[0] = static_cast<int8_T>(i3);
                            perm[1] = static_cast<int8_T>(i4);
                            perm[2] = static_cast<int8_T>(i1);
                            perm[3] = static_cast<int8_T>(i2);
                        }
                    }

                    idx->data[static_cast<int32_T>(ib - 3)] = idx4
                        [static_cast<int32_T>(static_cast<int32_T>(perm[0]) - 1)];
                    idx->data[static_cast<int32_T>(ib - 2)] = idx4
                        [static_cast<int32_T>(static_cast<int32_T>(perm[1]) - 1)];
                    idx->data[static_cast<int32_T>(ib - 1)] = idx4
                        [static_cast<int32_T>(static_cast<int32_T>(perm[2]) - 1)];
                    idx->data[ib] = idx4[static_cast<int32_T>
                        (static_cast<int32_T>(perm[3]) - 1)];
                    b_x->data[static_cast<int32_T>(ib - 3)] = x4
                        [static_cast<int32_T>(static_cast<int32_T>(perm[0]) - 1)];
                    b_x->data[static_cast<int32_T>(ib - 2)] = x4
                        [static_cast<int32_T>(static_cast<int32_T>(perm[1]) - 1)];
                    b_x->data[static_cast<int32_T>(ib - 1)] = x4
                        [static_cast<int32_T>(static_cast<int32_T>(perm[2]) - 1)];
                    b_x->data[ib] = x4[static_cast<int32_T>(static_cast<int32_T>
                        (perm[3]) - 1)];
                    ib = -1;
                }
            }
        }

        wOffset = static_cast<int32_T>(x->size[1] - nBlocks);
        if (static_cast<int32_T>(ib + 1) > 0) {
            perm[1] = 0;
            perm[2] = 0;
            perm[3] = 0;
            switch (static_cast<int32_T>(ib + 1)) {
              case 1:
                perm[0] = 1;
                break;

              case 2:
                if (x4[0] <= x4[1]) {
                    perm[0] = 1;
                    perm[1] = 2;
                } else {
                    perm[0] = 2;
                    perm[1] = 1;
                }
                break;

              default:
                if (x4[0] <= x4[1]) {
                    if (x4[1] <= x4[2]) {
                        perm[0] = 1;
                        perm[1] = 2;
                        perm[2] = 3;
                    } else if (x4[0] <= x4[2]) {
                        perm[0] = 1;
                        perm[1] = 3;
                        perm[2] = 2;
                    } else {
                        perm[0] = 3;
                        perm[1] = 1;
                        perm[2] = 2;
                    }
                } else if (x4[0] <= x4[2]) {
                    perm[0] = 2;
                    perm[1] = 1;
                    perm[2] = 3;
                } else if (x4[1] <= x4[2]) {
                    perm[0] = 2;
                    perm[1] = 3;
                    perm[2] = 1;
                } else {
                    perm[0] = 3;
                    perm[1] = 2;
                    perm[2] = 1;
                }
                break;
            }

            i2 = static_cast<int32_T>(static_cast<uint8_T>(static_cast<int32_T>
                (ib + 1)));
            for (i1 = 0; i1 <= static_cast<int32_T>(i2 - 1); i1++) {
                int8_T perm_0;
                perm_0 = perm[i1];
                b_iwork_tmp = static_cast<int32_T>(static_cast<int32_T>(
                    static_cast<int32_T>(wOffset - ib) + i1) - 1);
                idx->data[b_iwork_tmp] = idx4[static_cast<int32_T>
                    (static_cast<int32_T>(perm_0) - 1)];
                b_x->data[b_iwork_tmp] = x4[static_cast<int32_T>
                    (static_cast<int32_T>(perm_0) - 1)];
            }
        }

        i1 = static_cast<int32_T>(nBlocks >> 1);
        for (ib = 0; ib <= static_cast<int32_T>(i1 - 1); ib++) {
            blockOffset = static_cast<int32_T>(wOffset + ib);
            i2 = idx->data[blockOffset];
            b_iwork_tmp = static_cast<int32_T>(n - ib);
            idx->data[blockOffset] = idx->data[b_iwork_tmp];
            idx->data[b_iwork_tmp] = i2;
            i2 = static_cast<int32_T>(wOffset + ib);
            blockOffset = static_cast<int32_T>(n - ib);
            b_x->data[i2] = xwork->data[blockOffset];
            b_x->data[blockOffset] = xwork->data[i2];
        }

        if (static_cast<uint32_T>(static_cast<uint32_T>(nBlocks) & 1U) != 0U) {
            i2 = static_cast<int32_T>(wOffset + i1);
            b_x->data[i2] = xwork->data[i2];
        }

        n = x->size[1];
        b_iwork_tmp = iwork->size[0];
        iwork->size[0] = x->size[1];
        FlightMissionMode_emxEnsureCapacity_int32_T_j(iwork, b_iwork_tmp);
        for (ib = 0; ib <= static_cast<int32_T>(n - 1); ib++) {
            iwork->data[ib] = 0;
        }

        n = static_cast<int32_T>(x->size[1] - nBlocks);
        wOffset = 2;
        if (n > 1) {
            if (x->size[1] >= 256) {
                nBlocks = static_cast<int32_T>(n >> 8);
                if (nBlocks > 0) {
                    for (wOffset = 0; wOffset <= static_cast<int32_T>(nBlocks -
                            1); wOffset++) {
                        i2 = static_cast<int32_T>(static_cast<int32_T>(wOffset <<
                            8) - 1);
                        for (ib = 0; ib < 6; ib++) {
                            int32_T d;
                            i3 = static_cast<int32_T>(1 << static_cast<int32_T>
                                (ib + 2));
                            i4 = static_cast<int32_T>(i3 << 1);
                            d = static_cast<int32_T>(256 >> static_cast<int32_T>
                                (ib + 3));
                            for (i1 = 0; i1 <= static_cast<int32_T>(d - 1); i1++)
                            {
                                int32_T p;
                                int32_T q;
                                blockOffset = static_cast<int32_T>
                                    (static_cast<int32_T>(i1 * i4) + i2);
                                for (p = 0; p <= static_cast<int32_T>(i4 - 1); p
                                        ++) {
                                    b_iwork_tmp = static_cast<int32_T>(
                                        static_cast<int32_T>(blockOffset + p) +
                                        1);
                                    b_iwork[p] = idx->data[b_iwork_tmp];
                                    b_xwork[p] = b_x->data[b_iwork_tmp];
                                }

                                p = 0;
                                q = i3;
                                int32_T exitg1;
                                do {
                                    exitg1 = 0;
                                    blockOffset = static_cast<int32_T>
                                        (blockOffset + 1);
                                    if (b_xwork[p] <= b_xwork[q]) {
                                        idx->data[blockOffset] = b_iwork[p];
                                        b_x->data[blockOffset] = b_xwork[p];
                                        if (static_cast<int32_T>(p + 1) < i3) {
                                            p = static_cast<int32_T>(p + 1);
                                        } else {
                                            exitg1 = 1;
                                        }
                                    } else {
                                        idx->data[blockOffset] = b_iwork[q];
                                        b_x->data[blockOffset] = b_xwork[q];
                                        if (static_cast<int32_T>(q + 1) < i4) {
                                            q = static_cast<int32_T>(q + 1);
                                        } else {
                                            q = static_cast<int32_T>(blockOffset
                                                - p);
                                            for (blockOffset =
                                                    static_cast<int32_T>(p + 1);
                                                 blockOffset <= i3; blockOffset
                                                    ++) {
                                                b_iwork_tmp =
                                                    static_cast<int32_T>(q +
                                                    blockOffset);
                                                idx->data[b_iwork_tmp] =
                                                    b_iwork[static_cast<int32_T>
                                                    (blockOffset - 1)];
                                                b_x->data[b_iwork_tmp] =
                                                    b_xwork[static_cast<int32_T>
                                                    (blockOffset - 1)];
                                            }

                                            exitg1 = 1;
                                        }
                                    }
                                } while (exitg1 == 0);
                            }
                        }
                    }

                    nBlocks = static_cast<int32_T>(nBlocks << 8);
                    wOffset = static_cast<int32_T>(n - nBlocks);
                    if (wOffset > 0) {
                        FlightMissionMode_merge_block_d(idx, b_x, nBlocks,
                            wOffset, 2, iwork, xwork);
                    }

                    wOffset = 8;
                }
            }

            FlightMissionMode_merge_block_d(idx, b_x, 0, n, wOffset, iwork,
                xwork);
        }

        FlightMissionMode_emxFree_real_T_n(&xwork);
        FlightMissionMode_emxFree_int32_T_a(&iwork);
        FlightMissionMode_emxFree_int32_T_a(&idx);
    }

    b_iwork_tmp = static_cast<int32_T>(x->size[0] * x->size[1]);
    x->size[0] = 1;
    x->size[1] = b_x->size[1];
    FlightMissionMode_emxEnsureCapacity_real_T_c(x, b_iwork_tmp);
    n = b_x->size[1];
    for (ib = 0; ib <= static_cast<int32_T>(n - 1); ib++) {
        x->data[ib] = b_x->data[ib];
    }

    FlightMissionMode_emxFree_real_T_n(&b_x);
}

static void FlightMissionMode_emxInit_boolean_T_c
    (emxArray_boolean_T_FlightMissionMode_T **pEmxArray, int32_T numDimensions)
{
    emxArray_boolean_T_FlightMissionMode_T *emxArray;
    *pEmxArray = static_cast<emxArray_boolean_T_FlightMissionMode_T *>(std::
        malloc(sizeof(emxArray_boolean_T_FlightMissionMode_T)));
    emxArray = *pEmxArray;
    emxArray->data = static_cast<boolean_T *>(nullptr);
    emxArray->numDimensions = numDimensions;
    emxArray->size = static_cast<int32_T *>(std::malloc(static_cast<uint32_T>
        (sizeof(int32_T) * static_cast<uint32_T>(numDimensions))));
    emxArray->allocatedSize = 0;
    emxArray->canFreeData = true;
    for (int32_T i{0}; i <= static_cast<int32_T>(numDimensions - 1); i++) {
        emxArray->size[i] = 0;
    }
}

static void FlightMissionMode_emxFree_boolean_T_n
    (emxArray_boolean_T_FlightMissionMode_T **pEmxArray)
{
    if (*pEmxArray != static_cast<emxArray_boolean_T_FlightMissionMode_T *>
            (nullptr)) {
        if (((*pEmxArray)->data != static_cast<boolean_T *>(nullptr)) &&
                (*pEmxArray)->canFreeData) {
            std::free((*pEmxArray)->data);
        }

        std::free((*pEmxArray)->size);
        std::free(*pEmxArray);
        *pEmxArray = static_cast<emxArray_boolean_T_FlightMissionMode_T *>
            (nullptr);
    }
}

static void FlightMissionMode_emxEnsureCapacity_boolean_T_f
    (emxArray_boolean_T_FlightMissionMode_T *emxArray, int32_T oldNumel)
{
    int32_T i;
    int32_T newNumel;
    void *newData;
    if (oldNumel < 0) {
        oldNumel = 0;
    }

    newNumel = 1;
    for (i = 0; i <= static_cast<int32_T>(emxArray->numDimensions - 1); i++) {
        newNumel = static_cast<int32_T>(newNumel * emxArray->size[i]);
    }

    if (newNumel > emxArray->allocatedSize) {
        i = emxArray->allocatedSize;
        if (i < 16) {
            i = 16;
        }

        while (i < newNumel) {
            if (i > 1073741823) {
                i = MAX_int32_T;
            } else {
                i = static_cast<int32_T>(i << 1);
            }
        }

        newData = std::calloc(static_cast<uint32_T>(i), sizeof(boolean_T));
        if (emxArray->data != nullptr) {
            std::memcpy(newData, emxArray->data, static_cast<uint32_T>(sizeof
                         (boolean_T) * static_cast<uint32_T>(oldNumel)));
            if (emxArray->canFreeData) {
                std::free(emxArray->data);
            }
        }

        emxArray->data = static_cast<boolean_T *>(newData);
        emxArray->allocatedSize = i;
        emxArray->canFreeData = true;
    }
}

static void FlightMissionMode_binary_expand_op_p
    (emxArray_boolean_T_FlightMissionMode_T *in1, const
     emxArray_real_T_FlightMissionMode_T *in2, const
     emxArray_real_T_FlightMissionMode_T *in3)
{
    int32_T i;
    int32_T loop_ub;
    int32_T stride_0_0;
    int32_T stride_1_0;
    i = in1->size[0];
    in1->size[0] = in3->size[0] == 1 ? in2->size[0] : in3->size[0];
    FlightMissionMode_emxEnsureCapacity_boolean_T_f(in1, i);
    stride_0_0 = (in2->size[0] != 1);
    stride_1_0 = (in3->size[0] != 1);
    loop_ub = in3->size[0] == 1 ? in2->size[0] : in3->size[0];
    for (i = 0; i <= static_cast<int32_T>(loop_ub - 1); i++) {
        in1->data[i] = static_cast<boolean_T>(static_cast<int32_T>((in2->data[
            static_cast<int32_T>(i * stride_0_0)] == 0.0) & (in3->data[
            static_cast<int32_T>(i * stride_1_0)] > 0.0)));
    }
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static void FlightMissionMode_wrapToPi_n(emxArray_real_T_FlightMissionMode_T
    *theta)
{
    emxArray_boolean_T_FlightMissionMode_T *x;
    emxArray_real_T_FlightMissionMode_T *y;
    int32_T k;
    int32_T nx;
    boolean_T b_y;
    boolean_T exitg1;
    nx = theta->size[0];
    FlightMissionMode_emxInit_real_T_h(&y, 1);
    k = y->size[0];
    y->size[0] = theta->size[0];
    FlightMissionMode_emxEnsureCapacity_real_T_c(y, k);
    for (k = 0; k <= static_cast<int32_T>(nx - 1); k++) {
        y->data[k] = std::abs(theta->data[k]);
    }

    FlightMissionMode_emxInit_boolean_T_c(&x, 1);
    k = x->size[0];
    x->size[0] = y->size[0];
    FlightMissionMode_emxEnsureCapacity_boolean_T_f(x, k);
    nx = y->size[0];
    for (k = 0; k <= static_cast<int32_T>(nx - 1); k++) {
        x->data[k] = (y->data[k] > 3.1415926535897931);
    }

    b_y = false;
    k = 1;
    exitg1 = false;
    while ((!exitg1) && (k <= x->size[0])) {
        if (x->data[static_cast<int32_T>(k - 1)]) {
            b_y = true;
            exitg1 = true;
        } else {
            k = static_cast<int32_T>(k + 1);
        }
    }

    if (b_y) {
        k = y->size[0];
        y->size[0] = theta->size[0];
        FlightMissionMode_emxEnsureCapacity_real_T_c(y, k);
        nx = theta->size[0];
        for (k = 0; k <= static_cast<int32_T>(nx - 1); k++) {
            y->data[k] = theta->data[k] + 3.1415926535897931;
        }

        k = theta->size[0];
        theta->size[0] = y->size[0];
        FlightMissionMode_emxEnsureCapacity_real_T_c(theta, k);
        nx = y->size[0];
        for (k = 0; k <= static_cast<int32_T>(nx - 1); k++) {
            theta->data[k] = mod_Cteiw4Qy(y->data[k]);
        }

        if (theta->size[0] == y->size[0]) {
            k = x->size[0];
            x->size[0] = theta->size[0];
            FlightMissionMode_emxEnsureCapacity_boolean_T_f(x, k);
            nx = theta->size[0];
            for (k = 0; k <= static_cast<int32_T>(nx - 1); k++) {
                x->data[k] = static_cast<boolean_T>(static_cast<int32_T>
                    ((theta->data[k] == 0.0) & (y->data[k] > 0.0)));
            }
        } else {
            FlightMissionMode_binary_expand_op_p(x, theta, y);
        }

        nx = x->size[0];
        for (k = 0; k <= static_cast<int32_T>(nx - 1); k++) {
            if (x->data[k]) {
                theta->data[k] = 6.2831853071795862;
            }
        }

        nx = theta->size[0];
        for (k = 0; k <= static_cast<int32_T>(nx - 1); k++) {
            theta->data[k] -= 3.1415926535897931;
        }
    }

    FlightMissionMode_emxFree_boolean_T_n(&x);
    FlightMissionMode_emxFree_real_T_n(&y);
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static void FlightMissionMode_eml_find_m(const
    emxArray_boolean_T_FlightMissionMode_T *x,
    emxArray_int32_T_FlightMissionMode_T *i)
{
    int32_T idx;
    int32_T ii;
    int32_T nx;
    boolean_T exitg1;
    nx = x->size[1];
    idx = 0;
    ii = static_cast<int32_T>(i->size[0] * i->size[1]);
    i->size[0] = 1;
    i->size[1] = x->size[1];
    FlightMissionMode_emxEnsureCapacity_int32_T_j(i, ii);
    ii = 0;
    exitg1 = false;
    while ((!exitg1) && (ii <= static_cast<int32_T>(nx - 1))) {
        if (x->data[ii]) {
            idx = static_cast<int32_T>(idx + 1);
            i->data[static_cast<int32_T>(idx - 1)] = static_cast<int32_T>(ii + 1);
            if (idx >= nx) {
                exitg1 = true;
            } else {
                ii = static_cast<int32_T>(ii + 1);
            }
        } else {
            ii = static_cast<int32_T>(ii + 1);
        }
    }

    if (x->size[1] == 1) {
        if (idx == 0) {
            i->size[0] = 1;
            i->size[1] = 0;
        }
    } else if (idx < 1) {
        i->size[1] = 0;
    } else {
        ii = static_cast<int32_T>(i->size[0] * i->size[1]);
        i->size[1] = idx;
        FlightMissionMode_emxEnsureCapacity_int32_T_j(i, ii);
    }
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static boolean_T FlightMissionMode_strcmp_hbqnfpsg1(const char_T a_data[], const
    int32_T a_size[2])
{
    boolean_T b_bool;
    b_bool = false;
    if ((a_size[1] == 1) && (a_data[0] == 'N')) {
        b_bool = true;
    }

    return b_bool;
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static boolean_T FlightMissionMode_strcmp_hbqnfpsg15(const char_T a_data[],
    const int32_T a_size[2])
{
    static const char_T b[2]{ 'H', 'l' };

    boolean_T b_bool;
    b_bool = false;
    if (a_size[1] == 2) {
        int32_T kstr;
        kstr = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (kstr < 2) {
                if (a_data[kstr] != b[kstr]) {
                    exitg1 = 1;
                } else {
                    kstr = static_cast<int32_T>(kstr + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    return b_bool;
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static boolean_T FlightMissionMode_strcmp_hbqnfpsg15d(const char_T a_data[],
    const int32_T a_size[2])
{
    static const char_T b[2]{ 'H', 'r' };

    boolean_T b_bool;
    b_bool = false;
    if (a_size[1] == 2) {
        int32_T kstr;
        kstr = 0;
        int32_T exitg1;
        do {
            exitg1 = 0;
            if (kstr < 2) {
                if (a_data[kstr] != b[kstr]) {
                    exitg1 = 1;
                } else {
                    kstr = static_cast<int32_T>(kstr + 1);
                }
            } else {
                b_bool = true;
                exitg1 = 1;
            }
        } while (exitg1 == 0);
    }

    return b_bool;
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static boolean_T FlightMissionMode_strcmp_hbqnfpsg15dl(const char_T a_data[],
    const int32_T a_size[2])
{
    boolean_T b_bool;
    b_bool = false;
    if ((a_size[1] == 1) && (a_data[0] == 'L')) {
        b_bool = true;
    }

    return b_bool;
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static boolean_T FlightMissionMode_strcmp_hbqnfpsg15dly(const char_T a_data[],
    const int32_T a_size[2])
{
    boolean_T b_bool;
    b_bool = false;
    if ((a_size[1] == 1) && (a_data[0] == 'R')) {
        b_bool = true;
    }

    return b_bool;
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static boolean_T FlightMissionMode_strcmp_hbqnfpsg15dlyq(const char_T a_data[],
    const int32_T a_size[2])
{
    boolean_T b_bool;
    b_bool = false;
    if ((a_size[1] == 1) && (a_data[0] == 'S')) {
        b_bool = true;
    }

    return b_bool;
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static void FlightMissionMode_mtimes_g(const emxArray_real_T_FlightMissionMode_T
    *A, const real_T B[4], emxArray_real_T_FlightMissionMode_T *C)
{
    int32_T j;
    int32_T m;
    m = A->size[0];
    j = static_cast<int32_T>(C->size[0] * C->size[1]);
    C->size[0] = A->size[0];
    C->size[1] = 2;
    FlightMissionMode_emxEnsureCapacity_real_T_c(C, j);
    for (j = 0; j < 2; j++) {
        int32_T boffset;
        int32_T coffset;
        coffset = static_cast<int32_T>(j * m);
        boffset = static_cast<int32_T>(j << 1);
        for (int32_T i{0}; i <= static_cast<int32_T>(m - 1); i++) {
            C->data[static_cast<int32_T>(coffset + i)] = A->data
                [static_cast<int32_T>(A->size[0] + i)] * B[static_cast<int32_T>
                (boffset + 1)] + A->data[i] * B[boffset];
        }
    }
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static void FlightMissionMode_uavDubinsPathSegment_interpolate_b(const real_T
    b_this_StartPose[4], const real_T b_this_GoalPose[4], real_T
    b_this_FlightPathAngle, real_T b_this_AirSpeed, real_T
    b_this_MinTurningRadius, real_T b_this_HelixRadius, const
    cell_wrap_0_FlightMissionMode_T b_this_MotionTypes[4], const real_T
    b_this_MotionLengths[4], real_T b_this_Length,
    emxArray_real_T_FlightMissionMode_T *samples,
    emxArray_real_T_FlightMissionMode_T *poses)
{
    emxArray_boolean_T_FlightMissionMode_T *tempSamplesIndex;
    emxArray_boolean_T_FlightMissionMode_T *tempSamplesIndex_0;
    emxArray_int32_T_FlightMissionMode_T *bb;
    emxArray_real_T_FlightMissionMode_T *S;
    emxArray_real_T_FlightMissionMode_T *S_0;
    emxArray_real_T_FlightMissionMode_T *d_x;
    emxArray_real_T_FlightMissionMode_T *ns;
    emxArray_real_T_FlightMissionMode_T *p;
    emxArray_real_T_FlightMissionMode_T *tempSamples;
    emxArray_real_T_FlightMissionMode_T *z;
    real_T state[6];
    real_T TransformMatrix[4];
    real_T tempMotionLength_data[4];
    real_T transLength_data[4];
    int32_T transLength_size[2];
    boolean_T tmp[4];
    poses->size[0] = 0;
    poses->size[1] = 6;
    if ((static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(std::
            isnan(b_this_Length)) ^ 1))) && (samples->size[1] != 0)) {
        real_T b_b_tmp;
        real_T intermediateLength;
        real_T startIndex;
        real_T tempStartPose_idx_2;
        int32_T loop_ub;
        int32_T tempMotionLength_size_idx_1;
        tempStartPose_idx_2 = -b_this_StartPose[2];
        loop_ub = static_cast<int32_T>(poses->size[0] * poses->size[1]);
        poses->size[0] = samples->size[1];
        poses->size[1] = 6;
        FlightMissionMode_emxEnsureCapacity_real_T_c(poses, loop_ub);
        loop_ub = static_cast<int32_T>(samples->size[1] * 6);
        for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                static_cast<int32_T>(loop_ub - 1); transLength_data_tmp++) {
            poses->data[transLength_data_tmp] = 0.0;
        }

        b_b_tmp = std::cos(std::abs(b_this_FlightPathAngle));
        loop_ub = static_cast<int32_T>(samples->size[0] * samples->size[1]);
        samples->size[0] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T_c(samples, loop_ub);
        loop_ub = static_cast<int32_T>(samples->size[1] - 1);
        for (int32_T transLength_data_tmp{0}; transLength_data_tmp <= loop_ub;
                transLength_data_tmp++) {
            samples->data[transLength_data_tmp] *= b_b_tmp;
        }

        TransformMatrix[0] = b_this_MotionLengths[0] * b_b_tmp;
        TransformMatrix[1] = b_this_MotionLengths[1] * b_b_tmp;
        TransformMatrix[2] = b_this_MotionLengths[2] * b_b_tmp;
        tempMotionLength_size_idx_1 = 4;
        tempMotionLength_data[0] = TransformMatrix[0];
        tempMotionLength_data[1] = TransformMatrix[1];
        tempMotionLength_data[2] = TransformMatrix[2];
        tempMotionLength_data[3] = b_this_MotionLengths[3] * b_b_tmp;
        FlightMissionMode_strcmp_hbqnfpsg(b_this_MotionTypes, tmp);
        if (FlightMissionMode_any_i(tmp)) {
            tempMotionLength_size_idx_1 = 3;
            tempMotionLength_data[0] = TransformMatrix[0];
            tempMotionLength_data[1] = TransformMatrix[1];
            tempMotionLength_data[2] = TransformMatrix[2];
        }

        transLength_size[0] = 1;
        transLength_size[1] = tempMotionLength_size_idx_1;
        for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                static_cast<int32_T>(tempMotionLength_size_idx_1 - 1);
                transLength_data_tmp++) {
            transLength_data[transLength_data_tmp] =
                tempMotionLength_data[transLength_data_tmp];
        }

        FlightMissionMode_useConstantDim_i(transLength_data, transLength_size);
        FlightMissionMode_sort_o(samples);
        intermediateLength = 0.0;
        startIndex = 1.0;
        state[0] = b_this_StartPose[0];
        state[1] = -b_this_StartPose[1];
        state[3] = -b_this_StartPose[3];
        FlightMissionMode_emxInit_boolean_T_c(&tempSamplesIndex, 2);
        FlightMissionMode_emxInit_real_T_h(&tempSamples, 1);
        FlightMissionMode_emxInit_real_T_h(&S, 1);
        FlightMissionMode_emxInit_real_T_h(&ns, 2);
        FlightMissionMode_emxInit_real_T_h(&z, 1);
        FlightMissionMode_emxInit_real_T_h(&p, 2);
        FlightMissionMode_emxInit_real_T_h(&d_x, 1);
        FlightMissionMode_emxInit_int32_T_k(&bb, 2);
        FlightMissionMode_emxInit_boolean_T_c(&tempSamplesIndex_0, 2);
        FlightMissionMode_emxInit_real_T_h(&S_0, 2);
        for (int32_T tempMotionLength_data_tmp{0}; tempMotionLength_data_tmp <=
                static_cast<int32_T>(tempMotionLength_size_idx_1 - 1);
                tempMotionLength_data_tmp++) {
            real_T radius;
            if (static_cast<int32_T>(tempMotionLength_data_tmp + 1) == 1) {
                loop_ub = static_cast<int32_T>(tempSamplesIndex->size[0] *
                    tempSamplesIndex->size[1]);
                tempSamplesIndex->size[0] = 1;
                tempSamplesIndex->size[1] = samples->size[1];
                FlightMissionMode_emxEnsureCapacity_boolean_T_f(tempSamplesIndex,
                    loop_ub);
                radius = (intermediateLength + tempMotionLength_data[0]) +
                    1.0E-6;
                loop_ub = samples->size[1];
                for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                        static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                        ++) {
                    tempSamplesIndex->data[transLength_data_tmp] =
                        static_cast<boolean_T>(static_cast<int32_T>
                        ((samples->data[transLength_data_tmp] >=
                          intermediateLength) & (samples->
                        data[transLength_data_tmp] <= radius)));
                }
            } else {
                loop_ub = static_cast<int32_T>(tempSamplesIndex->size[0] *
                    tempSamplesIndex->size[1]);
                tempSamplesIndex->size[0] = 1;
                tempSamplesIndex->size[1] = samples->size[1];
                FlightMissionMode_emxEnsureCapacity_boolean_T_f(tempSamplesIndex,
                    loop_ub);
                radius = (intermediateLength +
                          tempMotionLength_data[tempMotionLength_data_tmp]) +
                    1.0E-6;
                loop_ub = samples->size[1];
                for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                        static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                        ++) {
                    tempSamplesIndex->data[transLength_data_tmp] =
                        static_cast<boolean_T>(static_cast<int32_T>
                        ((samples->data[transLength_data_tmp] >
                          intermediateLength) & (samples->
                        data[transLength_data_tmp] <= radius)));
                }
            }

            loop_ub = static_cast<int32_T>(tempSamplesIndex_0->size[0] *
                tempSamplesIndex_0->size[1]);
            tempSamplesIndex_0->size[0] = 1;
            tempSamplesIndex_0->size[1] = tempSamplesIndex->size[1];
            FlightMissionMode_emxEnsureCapacity_boolean_T_f(tempSamplesIndex_0,
                loop_ub);
            loop_ub = tempSamplesIndex->size[1];
            for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                    static_cast<int32_T>(loop_ub - 1); transLength_data_tmp++) {
                tempSamplesIndex_0->data[transLength_data_tmp] =
                    tempSamplesIndex->data[transLength_data_tmp];
            }

            FlightMissionMode_eml_find_m(tempSamplesIndex_0, bb);
            if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                    (FlightMissionMode_strcmp_hbqnfpsg1
                     (b_this_MotionTypes[tempMotionLength_data_tmp].f1.data,
                      b_this_MotionTypes[tempMotionLength_data_tmp].f1.size)) ^
                    1))) {
                real_T TransformMatrix_tmp;
                real_T TransformMatrix_tmp_0;
                int32_T count;
                int32_T tempMotionLength_data_tmp_0;
                radius = b_this_MinTurningRadius;
                if (FlightMissionMode_strcmp_hbqnfpsg15
                        (b_this_MotionTypes[tempMotionLength_data_tmp].f1.data,
                         b_this_MotionTypes[tempMotionLength_data_tmp].f1.size))
                {
                    radius = b_this_HelixRadius;
                } else if (FlightMissionMode_strcmp_hbqnfpsg15d
                           (b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.data,
                            b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.size)) {
                    radius = b_this_HelixRadius;
                }

                count = 0;
                loop_ub = tempSamples->size[0];
                tempSamples->size[0] = 1;
                FlightMissionMode_emxEnsureCapacity_real_T_c(tempSamples,
                    loop_ub);
                tempSamples->data[0] = 0.0;
                if (bb->size[1] != 0) {
                    loop_ub = tempSamples->size[0];
                    tempSamples->size[0] = static_cast<int32_T>(bb->size[1] + 1);
                    FlightMissionMode_emxEnsureCapacity_real_T_c(tempSamples,
                        loop_ub);
                    loop_ub = bb->size[1];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         loop_ub; transLength_data_tmp++) {
                        tempSamples->data[transLength_data_tmp] = 0.0;
                    }

                    if (static_cast<boolean_T>(static_cast<int32_T>((
                            static_cast<real_T>(static_cast<int32_T>(bb->size[1]
                             + 1)) - 1.0 < 1.0) ^ 1))) {
                        count = bb->size[1];
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(count - 1); transLength_data_tmp++)
                    {
                        tempSamples->data[transLength_data_tmp] = samples->data[
                            static_cast<int32_T>(bb->data[transLength_data_tmp]
                            - 1)];
                    }

                    count = bb->size[1];
                    loop_ub = bb->size[1];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        samples->data[static_cast<int32_T>(bb->
                            data[transLength_data_tmp] - 1)] = -1.0;
                    }
                }

                tempSamples->data[count] =
                    transLength_data[tempMotionLength_data_tmp];
                loop_ub = S->size[0];
                S->size[0] = tempSamples->size[0];
                FlightMissionMode_emxEnsureCapacity_real_T_c(S, loop_ub);
                loop_ub = tempSamples->size[0];
                for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                        static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                        ++) {
                    S->data[transLength_data_tmp] = (tempSamples->
                        data[transLength_data_tmp] - intermediateLength) /
                        radius;
                }

                loop_ub = static_cast<int32_T>(ns->size[0] * ns->size[1]);
                ns->size[0] = S->size[0];
                ns->size[1] = 6;
                FlightMissionMode_emxEnsureCapacity_real_T_c(ns, loop_ub);
                loop_ub = static_cast<int32_T>(S->size[0] * 6);
                for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                        static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                        ++) {
                    ns->data[transLength_data_tmp] = 0.0;
                }

                loop_ub = z->size[0];
                z->size[0] = tempSamples->size[0];
                FlightMissionMode_emxEnsureCapacity_real_T_c(z, loop_ub);
                loop_ub = tempSamples->size[0];
                for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                        static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                        ++) {
                    z->data[transLength_data_tmp] = tempStartPose_idx_2 +
                        tempSamples->data[transLength_data_tmp];
                }

                TransformMatrix_tmp = std::sin(state[3]);
                TransformMatrix_tmp_0 = std::cos(state[3]);
                TransformMatrix[0] = TransformMatrix_tmp_0;
                TransformMatrix[2] = TransformMatrix_tmp;
                TransformMatrix[1] = -TransformMatrix_tmp;
                TransformMatrix[3] = TransformMatrix_tmp_0;
                if (b_this_Length != 0.0) {
                    TransformMatrix_tmp = -b_this_GoalPose[2] -
                        tempStartPose_idx_2;
                    TransformMatrix_tmp_0 = b_this_Length * b_b_tmp;
                    loop_ub = z->size[0];
                    z->size[0] = tempSamples->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T_c(z, loop_ub);
                    loop_ub = tempSamples->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        z->data[transLength_data_tmp] = tempSamples->
                            data[transLength_data_tmp] / TransformMatrix_tmp_0 *
                            TransformMatrix_tmp + tempStartPose_idx_2;
                    }
                }

                if (FlightMissionMode_strcmp_hbqnfpsg15
                        (b_this_MotionTypes[tempMotionLength_data_tmp].f1.data,
                         b_this_MotionTypes[tempMotionLength_data_tmp].f1.size) ||
                    FlightMissionMode_strcmp_hbqnfpsg15dl
                        (b_this_MotionTypes[tempMotionLength_data_tmp].f1.data,
                         b_this_MotionTypes[tempMotionLength_data_tmp].f1.size))
                {
                    real_T state_0;
                    real_T state_1;
                    loop_ub = tempSamples->size[0];
                    tempSamples->size[0] = S->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T_c(tempSamples,
                        loop_ub);
                    loop_ub = S->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        tempSamples->data[transLength_data_tmp] = S->
                            data[transLength_data_tmp];
                    }

                    count = S->size[0];
                    for (loop_ub = 0; loop_ub <= static_cast<int32_T>(count - 1);
                         loop_ub++) {
                        tempSamples->data[loop_ub] = std::sin(tempSamples->
                            data[loop_ub]);
                    }

                    loop_ub = d_x->size[0];
                    d_x->size[0] = S->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T_c(d_x, loop_ub);
                    loop_ub = S->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        d_x->data[transLength_data_tmp] = S->
                            data[transLength_data_tmp];
                    }

                    count = S->size[0];
                    for (loop_ub = 0; loop_ub <= static_cast<int32_T>(count - 1);
                         loop_ub++) {
                        d_x->data[loop_ub] = std::cos(d_x->data[loop_ub]);
                    }

                    loop_ub = static_cast<int32_T>(S_0->size[0] * S_0->size[1]);
                    S_0->size[0] = tempSamples->size[0];
                    S_0->size[1] = 2;
                    FlightMissionMode_emxEnsureCapacity_real_T_c(S_0, loop_ub);
                    loop_ub = tempSamples->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        S_0->data[transLength_data_tmp] = tempSamples->
                            data[transLength_data_tmp];
                    }

                    loop_ub = d_x->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        S_0->data[static_cast<int32_T>(transLength_data_tmp +
                            tempSamples->size[0])] = 1.0 - d_x->
                            data[transLength_data_tmp];
                    }

                    FlightMissionMode_mtimes_g(S_0, TransformMatrix, p);
                    TransformMatrix_tmp = rt_atan2d_snf(b_this_AirSpeed *
                        b_this_AirSpeed, 9.8 * radius);
                    TransformMatrix_tmp_0 = state[0];
                    state_0 = state[1];
                    state_1 = state[3];
                    count = S->size[0];
                    tempMotionLength_data_tmp_0 = S->size[0];
                    loop_ub = static_cast<int32_T>(ns->size[0] * ns->size[1]);
                    ns->size[0] = p->size[0];
                    ns->size[1] = 6;
                    FlightMissionMode_emxEnsureCapacity_real_T_c(ns, loop_ub);
                    loop_ub = p->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        ns->data[transLength_data_tmp] = p->
                            data[transLength_data_tmp] * radius +
                            TransformMatrix_tmp_0;
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            ns->size[0])] = p->data[static_cast<int32_T>
                            (transLength_data_tmp + p->size[0])] * radius +
                            state_0;
                    }

                    loop_ub = z->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] << 1))] = z->
                            data[transLength_data_tmp];
                    }

                    loop_ub = S->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] * 3))] = state_1 +
                            S->data[transLength_data_tmp];
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(count - 1); transLength_data_tmp++)
                    {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] << 2))] =
                            b_this_FlightPathAngle;
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(tempMotionLength_data_tmp_0 - 1);
                            transLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] * 5))] =
                            -TransformMatrix_tmp;
                    }
                } else if (FlightMissionMode_strcmp_hbqnfpsg15d
                           (b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.data,
                            b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.size) || FlightMissionMode_strcmp_hbqnfpsg15dly
                           (b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.data,
                            b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.size)) {
                    real_T state_0;
                    real_T state_1;
                    loop_ub = tempSamples->size[0];
                    tempSamples->size[0] = S->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T_c(tempSamples,
                        loop_ub);
                    loop_ub = S->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        tempSamples->data[transLength_data_tmp] = S->
                            data[transLength_data_tmp];
                    }

                    count = S->size[0];
                    for (loop_ub = 0; loop_ub <= static_cast<int32_T>(count - 1);
                         loop_ub++) {
                        tempSamples->data[loop_ub] = std::sin(tempSamples->
                            data[loop_ub]);
                    }

                    loop_ub = d_x->size[0];
                    d_x->size[0] = S->size[0];
                    FlightMissionMode_emxEnsureCapacity_real_T_c(d_x, loop_ub);
                    loop_ub = S->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        d_x->data[transLength_data_tmp] = S->
                            data[transLength_data_tmp];
                    }

                    count = S->size[0];
                    for (loop_ub = 0; loop_ub <= static_cast<int32_T>(count - 1);
                         loop_ub++) {
                        d_x->data[loop_ub] = std::cos(d_x->data[loop_ub]);
                    }

                    loop_ub = static_cast<int32_T>(S_0->size[0] * S_0->size[1]);
                    S_0->size[0] = tempSamples->size[0];
                    S_0->size[1] = 2;
                    FlightMissionMode_emxEnsureCapacity_real_T_c(S_0, loop_ub);
                    loop_ub = tempSamples->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        S_0->data[transLength_data_tmp] = tempSamples->
                            data[transLength_data_tmp];
                    }

                    loop_ub = d_x->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        S_0->data[static_cast<int32_T>(transLength_data_tmp +
                            tempSamples->size[0])] = d_x->
                            data[transLength_data_tmp] - 1.0;
                    }

                    FlightMissionMode_mtimes_g(S_0, TransformMatrix, p);
                    TransformMatrix_tmp = rt_atan2d_snf(b_this_AirSpeed *
                        b_this_AirSpeed, 9.8 * radius);
                    TransformMatrix_tmp_0 = state[0];
                    state_0 = state[1];
                    state_1 = state[3];
                    count = S->size[0];
                    tempMotionLength_data_tmp_0 = S->size[0];
                    loop_ub = static_cast<int32_T>(ns->size[0] * ns->size[1]);
                    ns->size[0] = p->size[0];
                    ns->size[1] = 6;
                    FlightMissionMode_emxEnsureCapacity_real_T_c(ns, loop_ub);
                    loop_ub = p->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        ns->data[transLength_data_tmp] = p->
                            data[transLength_data_tmp] * radius +
                            TransformMatrix_tmp_0;
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            ns->size[0])] = p->data[static_cast<int32_T>
                            (transLength_data_tmp + p->size[0])] * radius +
                            state_0;
                    }

                    loop_ub = z->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] << 1))] = z->
                            data[transLength_data_tmp];
                    }

                    loop_ub = S->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] * 3))] = state_1 -
                            S->data[transLength_data_tmp];
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(count - 1); transLength_data_tmp++)
                    {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] << 2))] =
                            b_this_FlightPathAngle;
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(tempMotionLength_data_tmp_0 - 1);
                            transLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] * 5))] =
                            TransformMatrix_tmp;
                    }
                } else if (FlightMissionMode_strcmp_hbqnfpsg15dlyq
                           (b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.data,
                            b_this_MotionTypes[tempMotionLength_data_tmp].
                            f1.size)) {
                    real_T state_0;
                    int32_T S_idx_0;
                    count = S->size[0];
                    loop_ub = static_cast<int32_T>(S_0->size[0] * S_0->size[1]);
                    S_0->size[0] = S->size[0];
                    S_0->size[1] = 2;
                    FlightMissionMode_emxEnsureCapacity_real_T_c(S_0, loop_ub);
                    loop_ub = S->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        S_0->data[transLength_data_tmp] = S->
                            data[transLength_data_tmp];
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(count - 1); transLength_data_tmp++)
                    {
                        S_0->data[static_cast<int32_T>(transLength_data_tmp +
                            S->size[0])] = 0.0;
                    }

                    FlightMissionMode_mtimes_g(S_0, TransformMatrix, p);
                    TransformMatrix_tmp_0 = state[0];
                    state_0 = state[1];
                    count = S->size[0];
                    tempMotionLength_data_tmp_0 = S->size[0];
                    S_idx_0 = S->size[0];
                    loop_ub = static_cast<int32_T>(ns->size[0] * ns->size[1]);
                    ns->size[0] = p->size[0];
                    ns->size[1] = 6;
                    FlightMissionMode_emxEnsureCapacity_real_T_c(ns, loop_ub);
                    loop_ub = p->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        ns->data[transLength_data_tmp] = p->
                            data[transLength_data_tmp] * radius +
                            TransformMatrix_tmp_0;
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            ns->size[0])] = p->data[static_cast<int32_T>
                            (transLength_data_tmp + p->size[0])] * radius +
                            state_0;
                    }

                    loop_ub = z->size[0];
                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(loop_ub - 1); transLength_data_tmp
                            ++) {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] << 1))] = z->
                            data[transLength_data_tmp];
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(count - 1); transLength_data_tmp++)
                    {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] * 3))] = state[3];
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(tempMotionLength_data_tmp_0 - 1);
                            transLength_data_tmp++) {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] << 2))] =
                            b_this_FlightPathAngle;
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         static_cast<int32_T>(S_idx_0 - 1); transLength_data_tmp
                            ++) {
                        ns->data[static_cast<int32_T>(transLength_data_tmp +
                            static_cast<int32_T>(ns->size[0] * 5))] = 0.0;
                    }
                }

                if (bb->size[1] != 0) {
                    if (startIndex > (startIndex + static_cast<real_T>(bb->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <
                         6; transLength_data_tmp++) {
                        for (tempMotionLength_data_tmp_0 = 0;
                                tempMotionLength_data_tmp_0 <= loop_ub;
                                tempMotionLength_data_tmp_0++) {
                            poses->data[static_cast<int32_T>(static_cast<int32_T>
                                (static_cast<int32_T>(count +
                                tempMotionLength_data_tmp_0) +
                                 static_cast<int32_T>(poses->size[0] *
                                transLength_data_tmp)) - 1)] = ns->data[
                                static_cast<int32_T>(static_cast<int32_T>
                                (ns->size[0] * transLength_data_tmp) +
                                tempMotionLength_data_tmp_0)];
                        }
                    }

                    if (startIndex > (startIndex + static_cast<real_T>(bb->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         loop_ub; transLength_data_tmp++) {
                        poses->data[static_cast<int32_T>(static_cast<int32_T>
                            (count + transLength_data_tmp) - 1)] = ns->
                            data[transLength_data_tmp];
                    }

                    if (startIndex > (startIndex + static_cast<real_T>(bb->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         loop_ub; transLength_data_tmp++) {
                        poses->data[static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>(count + transLength_data_tmp) +
                            poses->size[0]) - 1)] = -ns->data
                            [static_cast<int32_T>(transLength_data_tmp +
                            ns->size[0])];
                    }

                    if (startIndex > (startIndex + static_cast<real_T>(bb->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         loop_ub; transLength_data_tmp++) {
                        poses->data[static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>(count + transLength_data_tmp) +
                            static_cast<int32_T>(poses->size[0] << 1)) - 1)] =
                            -ns->data[static_cast<int32_T>(static_cast<int32_T>
                            (ns->size[0] << 1) + transLength_data_tmp)];
                    }

                    if (startIndex > (startIndex + static_cast<real_T>(bb->size
                            [1])) - 1.0) {
                        count = 1;
                    } else {
                        count = static_cast<int32_T>(startIndex);
                    }

                    if (static_cast<int32_T>(ns->size[0] - 1) < 1) {
                        loop_ub = -1;
                    } else {
                        loop_ub = static_cast<int32_T>(ns->size[0] - 2);
                    }

                    for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                         loop_ub; transLength_data_tmp++) {
                        poses->data[static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>(count + transLength_data_tmp) +
                            static_cast<int32_T>(poses->size[0] * 3)) - 1)] =
                            -ns->data[static_cast<int32_T>(static_cast<int32_T>
                            (ns->size[0] * 3) + transLength_data_tmp)];
                    }
                }

                count = ns->size[0];
                for (int32_T transLength_data_tmp{0}; transLength_data_tmp < 6;
                        transLength_data_tmp++) {
                    state[transLength_data_tmp] = ns->data[static_cast<int32_T>(
                        static_cast<int32_T>(static_cast<int32_T>(ns->size[0] *
                        transLength_data_tmp) + count) - 1)];
                }

                startIndex += static_cast<real_T>(bb->size[1]);
            }

            intermediateLength +=
                tempMotionLength_data[tempMotionLength_data_tmp];
        }

        FlightMissionMode_emxFree_real_T_n(&S_0);
        FlightMissionMode_emxFree_boolean_T_n(&tempSamplesIndex_0);
        FlightMissionMode_emxFree_int32_T_a(&bb);
        FlightMissionMode_emxFree_real_T_n(&d_x);
        FlightMissionMode_emxFree_real_T_n(&p);
        FlightMissionMode_emxFree_real_T_n(&z);
        FlightMissionMode_emxFree_real_T_n(&ns);
        FlightMissionMode_emxFree_real_T_n(&S);
        FlightMissionMode_emxFree_boolean_T_n(&tempSamplesIndex);
        loop_ub = tempSamples->size[0];
        tempSamples->size[0] = poses->size[0];
        FlightMissionMode_emxEnsureCapacity_real_T_c(tempSamples, loop_ub);
        loop_ub = poses->size[0];
        for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                static_cast<int32_T>(loop_ub - 1); transLength_data_tmp++) {
            tempSamples->data[transLength_data_tmp] = poses->data
                [static_cast<int32_T>(static_cast<int32_T>(poses->size[0] * 3) +
                transLength_data_tmp)];
        }

        FlightMissionMode_wrapToPi_n(tempSamples);
        loop_ub = tempSamples->size[0];
        for (int32_T transLength_data_tmp{0}; transLength_data_tmp <=
                static_cast<int32_T>(loop_ub - 1); transLength_data_tmp++) {
            poses->data[static_cast<int32_T>(transLength_data_tmp +
                static_cast<int32_T>(poses->size[0] * 3))] = tempSamples->
                data[transLength_data_tmp];
        }

        FlightMissionMode_emxFree_real_T_n(&tempSamples);
    }
}

// Function for MATLAB Function: '<S40>/CheckPointInterp'
static void FlightMissionMode_genSegWP_j(const real_T start[4], const real_T
    ende[4], emxArray_real_T_FlightMissionMode_T *segWayPoints,
    DW_FlightMissionMode_f_T *localDW)
{
    emxArray_real_T_FlightMissionMode_T *lengths;
    emxArray_real_T_FlightMissionMode_T *poses;
    uavDubinsConnection_FlightMissionMode_T *obj;
    uavDubinsPathSegment_FlightMissionMode_T pathSegObj;
    real_T a__1;
    int32_T i_0;
    int32_T loop_ub;
    obj = FlightMissionMode_DubinsObjSingleton_getConnector_p(localDW);
    FlightMissionMode_uavDubinsBuiltins_connect_g(obj, start, ende,
        obj->MinTurningRadius, &pathSegObj, &a__1);
    a__1 = std::fmax(2.2204460492503131E-16, pathSegObj.Length / 64.0);
    FlightMissionMode_emxInit_real_T_h(&lengths, 2);
    if (std::isnan(pathSegObj.Length)) {
        i_0 = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        lengths->size[1] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T_c(lengths, i_0);
        lengths->data[0] = (rtNaN);
    } else if (pathSegObj.Length < 0.0) {
        lengths->size[0] = 1;
        lengths->size[1] = 0;
    } else if (std::isinf(pathSegObj.Length) && std::isinf(a__1)) {
        i_0 = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        lengths->size[1] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T_c(lengths, i_0);
        lengths->data[0] = (rtNaN);
    } else if (std::isinf(a__1)) {
        i_0 = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        lengths->size[1] = 1;
        FlightMissionMode_emxEnsureCapacity_real_T_c(lengths, i_0);
        lengths->data[0] = 0.0;
    } else if (std::floor(a__1) == a__1) {
        i_0 = static_cast<int32_T>(lengths->size[0] * lengths->size[1]);
        lengths->size[0] = 1;
        loop_ub = static_cast<int32_T>(pathSegObj.Length / a__1);
        lengths->size[1] = static_cast<int32_T>(loop_ub + 1);
        FlightMissionMode_emxEnsureCapacity_real_T_c(lengths, i_0);
        for (i_0 = 0; i_0 <= loop_ub; i_0++) {
            lengths->data[i_0] = a__1 * static_cast<real_T>(i_0);
        }
    } else {
        FlightMissionMode_eml_float_colon(a__1, pathSegObj.Length, lengths);
    }

    FlightMissionMode_emxInit_real_T_h(&poses, 2);
    FlightMissionMode_uavDubinsPathSegment_interpolate_b(pathSegObj.StartPose,
        pathSegObj.GoalPose, pathSegObj.FlightPathAngle, pathSegObj.AirSpeed,
        pathSegObj.MinTurningRadius, pathSegObj.HelixRadius,
        pathSegObj.MotionTypes, pathSegObj.MotionLengths, pathSegObj.Length,
        lengths, poses);
    FlightMissionMode_emxFree_real_T_n(&lengths);
    i_0 = static_cast<int32_T>(segWayPoints->size[0] * segWayPoints->size[1]);
    segWayPoints->size[0] = poses->size[0];
    segWayPoints->size[1] = 3;
    FlightMissionMode_emxEnsureCapacity_real_T_c(segWayPoints, i_0);
    loop_ub = poses->size[0];
    for (i_0 = 0; i_0 < 3; i_0++) {
        for (int32_T i{0}; i <= static_cast<int32_T>(loop_ub - 1); i++) {
            segWayPoints->data[static_cast<int32_T>(i + static_cast<int32_T>
                (segWayPoints->size[0] * i_0))] = poses->data
                [static_cast<int32_T>(static_cast<int32_T>(poses->size[0] * i_0)
                + i)];
        }
    }

    FlightMissionMode_emxFree_real_T_n(&poses);
}

// System initialize for referenced model: 'FlightMissionMode'
void FlightMissionMode_Init(FixedWingGuidanceBus *rty_GuidanceCmds, real_T
    rty_InitialState[8], DW_FlightMissionMode_f_T *localDW)
{
    FILE* a;

    // Start for SwitchCase: '<Root>/Switch Case'
    localDW->SwitchCase_ActiveSubsystem = -1;

    // SystemInitialize for IfAction SubSystem: '<Root>/Mode1_CirclingNav'
    // SystemInitialize for MATLAB Function: '<S10>/ReadHomePoint'
    a = NULL;
    for (int32_T i{0}; i < 20; i++) {
        localDW->eml_openfiles[i] = a;
    }

    // End of SystemInitialize for MATLAB Function: '<S10>/ReadHomePoint'

    // Start for MATLABSystem: '<S9>/Orbit Follower'
    localDW->objisempty_b = true;
    localDW->obj_f.isInitialized = 1;
    localDW->obj_f.PrevResetSignal = 0.0;
    localDW->obj_f.OrbitRadiusInternal = 0.0;
    localDW->obj_f.NumCircles = 0.0;

    // InitializeConditions for MATLABSystem: '<S9>/Orbit Follower'
    localDW->obj_f.OrbitRadiusInternal *= 0.0;
    localDW->obj_f.PrevResetSignal *= 0.0;
    localDW->obj_f.NumCircles *= 0.0;

    // Start for MATLABSystem: '<S9>/Orbit Follower'
    localDW->obj_f.PrevPosition[0] = 0.0;
    localDW->obj_f.OrbitCenterInternal[0] = 0.0;

    // InitializeConditions for MATLABSystem: '<S9>/Orbit Follower'
    localDW->obj_f.OrbitCenterInternal[0] *= 0.0;
    localDW->obj_f.PrevPosition[0] *= 0.0;

    // Start for MATLABSystem: '<S9>/Orbit Follower'
    localDW->obj_f.PrevPosition[1] = 0.0;
    localDW->obj_f.OrbitCenterInternal[1] = 0.0;

    // InitializeConditions for MATLABSystem: '<S9>/Orbit Follower'
    localDW->obj_f.OrbitCenterInternal[1] *= 0.0;
    localDW->obj_f.PrevPosition[1] *= 0.0;

    // Start for MATLABSystem: '<S9>/Orbit Follower'
    localDW->obj_f.PrevPosition[2] = 0.0;
    localDW->obj_f.OrbitCenterInternal[2] = 0.0;

    // InitializeConditions for MATLABSystem: '<S9>/Orbit Follower'
    localDW->obj_f.OrbitCenterInternal[2] *= 0.0;
    localDW->obj_f.PrevPosition[2] *= 0.0;
    localDW->obj_f.StartFlag = true;
    localDW->obj_f.SelectTurnDirectionFlag = true;
    localDW->obj_f.TurnDirectionInternal = 1.0;
    localDW->obj_f.OrbitRadiusFlag = 0U;
    localDW->obj_f.LookaheadDistFlag = 0U;

    // End of SystemInitialize for SubSystem: '<Root>/Mode1_CirclingNav'

    // SystemInitialize for IfAction SubSystem: '<Root>/Mode2_HorzScanNav'
    // SystemInitialize for MATLAB Function: '<S37>/ReadHomePoint'
    a = NULL;
    for (int32_T i{0}; i < 20; i++) {
        localDW->eml_openfiles_b[i] = a;
    }

    // End of SystemInitialize for MATLAB Function: '<S37>/ReadHomePoint'

    // SystemInitialize for Enabled SubSystem: '<S36>/WayPoint'
    // SystemInitialize for MATLAB Function: '<S40>/CheckPointInterp'
    a = NULL;
    for (int32_T i{0}; i < 20; i++) {
        localDW->eml_openfiles_k[i] = a;
    }

    // End of SystemInitialize for MATLAB Function: '<S40>/CheckPointInterp'
    FlightMissionMode_RotateATMissionHdg_Init(&localDW->RotateATMissionHdg);

    // End of SystemInitialize for SubSystem: '<S36>/WayPoint'

    // Start for MATLABSystem: '<S36>/Waypoint Follower'
    localDW->obj_k.LastWaypointFlag = false;
    localDW->obj_k.StartFlag = true;
    localDW->obj_k.LookaheadFactor = 1.01;
    localDW->objisempty_n = true;
    localDW->obj_k.isInitialized = 1;
    localDW->obj_k.NumWaypoints = 0.0;

    // InitializeConditions for MATLABSystem: '<S36>/Waypoint Follower'
    localDW->obj_k.WaypointIndex = 1.0;
    for (int32_T i{0}; i < 24576; i++) {
        // Start for MATLABSystem: '<S36>/Waypoint Follower'
        localDW->obj_k.WaypointsInternal[i] = 0.0;

        // InitializeConditions for MATLABSystem: '<S36>/Waypoint Follower'
        localDW->obj_k.WaypointsInternal[i] *= 0.0;
    }

    // End of SystemInitialize for SubSystem: '<Root>/Mode2_HorzScanNav'

    // SystemInitialize for IfAction SubSystem: '<Root>/Mode3_RunWayNav'
    // SystemInitialize for MATLAB Function: '<S75>/ReadHomePoint'
    a = NULL;
    for (int32_T i{0}; i < 20; i++) {
        localDW->eml_openfiles_d[i] = a;
    }

    // End of SystemInitialize for MATLAB Function: '<S75>/ReadHomePoint'

    // SystemInitialize for Enabled SubSystem: '<S72>/WayPointGenerator'
    // SystemInitialize for MATLAB Function: '<S77>/StartPointGenerator'
    FlightMissionMode_StartPointGenerator_Init(&localDW->sf_StartPointGenerator);

    // SystemInitialize for MATLAB Function: '<S77>/WayPointGenerator'
    FlightMissionMode_WayPointGenerator_Init(&localDW->sf_WayPointGenerator);
    FlightMissionMode_RotateATMissionHdg_Init(&localDW->RotateUpward);
    FlightMissionMode_RotateATMissionHdg_Init(&localDW->RotateATRunWayHdg);
    FlightMissionMode_RotateATMissionHdg_Init(&localDW->RotateATMissionHdg_m);

    // End of SystemInitialize for SubSystem: '<S72>/WayPointGenerator'

    // SystemInitialize for Atomic SubSystem: '<S72>/SegmentSwitch'
    FlightMissionMode_SegmentSwitch_Init(localDW->MergeLookAheadP_j,
        &localDW->MergeDesiredCourse_p, &localDW->RunWayLineMode_o,
        &localDW->SegmentSwitch);

    // End of SystemInitialize for SubSystem: '<S72>/SegmentSwitch'
    // End of SystemInitialize for SubSystem: '<Root>/Mode3_RunWayNav'

    // SystemInitialize for IfAction SubSystem: '<Root>/Mode44_ProtLine'
    // SystemInitialize for MATLAB Function: '<S118>/ReadHomePoint'
    a = NULL;
    for (int32_T i{0}; i < 20; i++) {
        localDW->eml_openfiles_bx[i] = a;
    }

    // End of SystemInitialize for MATLAB Function: '<S118>/ReadHomePoint'

    // SystemInitialize for Enabled SubSystem: '<S116>/WayPointGenerator'
    // SystemInitialize for MATLAB Function: '<S121>/StartPointGenerator'
    FlightMissionMode_StartPointGenerator_Init
        (&localDW->sf_StartPointGenerator_k);

    // SystemInitialize for MATLAB Function: '<S121>/WayPointGenerator'
    FlightMissionMode_WayPointGenerator_Init(&localDW->sf_WayPointGenerator_f);
    FlightMissionMode_RotateATMissionHdg_Init(&localDW->RotateATRunWayHdg_k);
    FlightMissionMode_RotateATMissionHdg_Init(&localDW->RotateATMissionHdg_k);

    // End of SystemInitialize for SubSystem: '<S116>/WayPointGenerator'

    // SystemInitialize for Atomic SubSystem: '<S116>/SegmentSwitch'
    FlightMissionMode_SegmentSwitch_Init(localDW->MergeLookAheadP,
        &localDW->MergeDesiredCourse, &localDW->RunWayLineMode,
        &localDW->SegmentSwitch_p);

    // End of SystemInitialize for SubSystem: '<S116>/SegmentSwitch'
    // End of SystemInitialize for SubSystem: '<Root>/Mode44_ProtLine'

    // SystemInitialize for IfAction SubSystem: '<Root>/Mode55_FrmnWayPoint'
    // Start for SwitchCase: '<S161>/Switch Case'
    localDW->SwitchCase_ActiveSubsystem_c = -1;

    // SystemInitialize for Enabled SubSystem: '<S161>/WayPointGenerator'
    // SystemInitialize for MATLAB Function: '<S166>/ReadHomePoint'
    FlightMissionMode_ReadHomePoint_Init(&localDW->sf_ReadHomePoint_kc);

    // SystemInitialize for MATLAB Function: '<S166>/WayPointGenerator'
    a = NULL;
    for (int32_T i{0}; i < 20; i++) {
        localDW->eml_openfiles_i[i] = a;
    }

    // End of SystemInitialize for MATLAB Function: '<S166>/WayPointGenerator'
    // End of SystemInitialize for SubSystem: '<S161>/WayPointGenerator'

    // SystemInitialize for IfAction SubSystem: '<S161>/StartFromClosest'
    // Start for MATLABSystem: '<S164>/Waypoint Follower'
    localDW->obj_j.LastWaypointFlag = false;
    localDW->obj_j.StartFlag = true;
    localDW->obj_j.LookaheadFactor = 1.01;
    localDW->obj_j.SearchFlag = true;
    localDW->objisempty_e = true;
    localDW->obj_j.isInitialized = 1;
    localDW->obj_j.NumWaypoints = 0.0;

    // InitializeConditions for MATLABSystem: '<S164>/Waypoint Follower'
    localDW->obj_j.WaypointIndex = 1.0;

    // End of SystemInitialize for SubSystem: '<S161>/StartFromClosest'

    // SystemInitialize for IfAction SubSystem: '<S161>/StartFromFirst'
    // Start for MATLABSystem: '<S165>/Waypoint Follower'
    localDW->obj.LastWaypointFlag = false;
    localDW->obj.StartFlag = true;
    localDW->obj.LookaheadFactor = 1.01;
    localDW->objisempty = true;
    localDW->obj.isInitialized = 1;
    localDW->obj.NumWaypoints = 0.0;

    // InitializeConditions for MATLABSystem: '<S165>/Waypoint Follower'
    localDW->obj.WaypointIndex = 1.0;

    // SystemInitialize for IfAction SubSystem: '<S161>/StartFromClosest'
    for (int32_T i{0}; i < 24576; i++) {
        // Start for MATLABSystem: '<S164>/Waypoint Follower'
        localDW->obj_j.WaypointsInternal[i] = 0.0;

        // InitializeConditions for MATLABSystem: '<S164>/Waypoint Follower'
        localDW->obj_j.WaypointsInternal[i] *= 0.0;

        // Start for MATLABSystem: '<S165>/Waypoint Follower' incorporates:
        //   MATLABSystem: '<S164>/Waypoint Follower'

        localDW->obj.WaypointsInternal[i] = 0.0;

        // InitializeConditions for MATLABSystem: '<S165>/Waypoint Follower' incorporates:
        //   MATLABSystem: '<S164>/Waypoint Follower'

        localDW->obj.WaypointsInternal[i] *= 0.0;
    }

    // End of SystemInitialize for SubSystem: '<S161>/StartFromClosest'
    // End of SystemInitialize for SubSystem: '<S161>/StartFromFirst'

    // SystemInitialize for MATLAB Function: '<S163>/ReadHomePoint'
    FlightMissionMode_ReadHomePoint_Init(&localDW->sf_ReadHomePoint_l);

    // End of SystemInitialize for SubSystem: '<Root>/Mode55_FrmnWayPoint'
    std::memset(rty_GuidanceCmds, 0, sizeof(FixedWingGuidanceBus));

    // SystemInitialize for Merge: '<Root>/MergeInitialState'
    std::memset(&rty_InitialState[0], 0, static_cast<uint32_T>(sizeof(real_T) <<
                 3U));
}

// Disable for referenced model: 'FlightMissionMode'
void FlightMissionMode_Disable(DW_FlightMissionMode_f_T *localDW)
{
    // Disable for SwitchCase: '<Root>/Switch Case'
    switch (localDW->SwitchCase_ActiveSubsystem) {
      case 0:
      case 5:
        break;

      case 1:
        // Disable for Enabled SubSystem: '<S36>/WayPointGenerator'
        localDW->WayPointGenerator_MODE_h = false;

        // End of Disable for SubSystem: '<S36>/WayPointGenerator'

        // Disable for Enabled SubSystem: '<S36>/WayPoint'
        localDW->WayPoint_MODE = false;

        // End of Disable for SubSystem: '<S36>/WayPoint'
        break;

      case 2:
        // Disable for Enabled SubSystem: '<S72>/WayPointGenerator'
        localDW->WayPointGenerator_MODE_k = false;

        // End of Disable for SubSystem: '<S72>/WayPointGenerator'

        // Disable for Atomic SubSystem: '<S72>/SegmentSwitch'
        FlightMissionMode_SegmentSwitch_Disable(&localDW->SegmentSwitch);

        // End of Disable for SubSystem: '<S72>/SegmentSwitch'
        break;

      case 3:
        // Disable for Enabled SubSystem: '<S116>/WayPointGenerator'
        localDW->WayPointGenerator_MODE_m = false;

        // End of Disable for SubSystem: '<S116>/WayPointGenerator'

        // Disable for Atomic SubSystem: '<S116>/SegmentSwitch'
        FlightMissionMode_SegmentSwitch_Disable(&localDW->SegmentSwitch_p);

        // End of Disable for SubSystem: '<S116>/SegmentSwitch'
        break;

      case 4:
        // Disable for Enabled SubSystem: '<S161>/WayPointGenerator'
        localDW->WayPointGenerator_MODE = false;

        // End of Disable for SubSystem: '<S161>/WayPointGenerator'

        // Disable for SwitchCase: '<S161>/Switch Case'
        localDW->SwitchCase_ActiveSubsystem_c = -1;
        break;
    }

    localDW->SwitchCase_ActiveSubsystem = -1;

    // End of Disable for SwitchCase: '<Root>/Switch Case'
}

// Output and update for referenced model: 'FlightMissionMode'
void FlightMissionMode(const boolean_T *rtu_startFlight, const MissionModes
                       *rtu_mode, const boolean_T *rtu_Reset, const Location
                       *rtu_StartLocation, const Location *rtu_MissionLocation,
                       const Parameters *rtu_Parameters, const int32_T
                       *rtu_FormationIDX, const int32_T *rtu_MissionUAV, const
                       real_T rtu_Pose[4], real_T *rty_thisTaskStatus,
                       FixedWingGuidanceBus *rty_GuidanceCmds, real_T
                       rty_InitialState[8], DW_FlightMissionMode_f_T *localDW)
{
    // local block i/o variables
    real_T rtb_TmpSignalConversionAtRotateATRunWayHdgInport1[3];
    real_T rtb_TmpSignalConversionAtRotateATMissionHdgInport1[3];
    real_T rtb_nedWayPoint_CoreSubsysCanOut[384];
    real_T rtb_RotateRunway[384];
    real_T rtb_RotateIndivWayPoint[384];
    real_T rtb_TmpSignalConversionAtRotateUpwardInport1[3];
    real_T rtb_TmpSignalConversionAtRotateATRunWayHdgInport1_l[3];
    real_T rtb_TmpSignalConversionAtRotateATMissionHdgInport1_p[3];
    real_T rtb_ImpSel_InsertedFor_RawRunWay_at_outport_0_k[384];
    real_T rtb_nedWayPoint_CoreSubsysCanOut_b[384];
    real_T rtb_MatrixDivide_g[384];
    real_T rtb_y[384];
    real_T rtb_TmpSignalConversionAtRotateATMissionHdgInport1_i[3];
    real_T rtb_y_e[384];
    static const int16_T l[12]{ 1000, 0, -1000, 0, 0, 1000, 0, -1000, -1000,
        -1000, -1000, -1000 };

    static const char_T j[14]{ 'F', 'l', 'i', 'g', 'h', 't', 'P', 'a', 't', 'h',
        '/', 'L', 'L', 'A' };

    static const boolean_T o[128]{ false, false, false, false, false, false,
        false, false, false, true, true, true, true, true, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, true, true, true, true, true, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false,
        false, false, false, false, false, false, false, false, false, false };

    emxArray_char_T_FlightMissionMode_T *curKey;
    emxArray_char_T_FlightMissionMode_T *curLine;
    emxArray_char_T_FlightMissionMode_T *curSection;
    emxArray_char_T_FlightMissionMode_T *curVal;
    emxArray_char_T_FlightMissionMode_T *data;
    emxArray_char_T_FlightMissionMode_T *data_0;
    emxArray_char_T_FlightMissionMode_T *data_1;
    emxArray_char_T_FlightMissionMode_T *data_2;
    emxArray_char_T_FlightMissionMode_T *data_3;
    emxArray_char_T_FlightMissionMode_T *data_4;
    emxArray_char_T_FlightMissionMode_T *data_5;
    emxArray_char_T_FlightMissionMode_T *data_6;
    emxArray_char_T_FlightMissionMode_T *data_7;
    emxArray_char_T_FlightMissionMode_T *data_8;
    emxArray_char_T_FlightMissionMode_T *data_9;
    emxArray_char_T_FlightMissionMode_T *data_a;
    emxArray_char_T_FlightMissionMode_T *data_b;
    emxArray_char_T_FlightMissionMode_T *q;
    emxArray_char_T_FlightMissionMode_T *tline;
    emxArray_char_T_FlightMissionMode_T *tmp_6;
    emxArray_char_T_FlightMissionMode_T *tmp_7;
    emxArray_char_T_FlightMissionMode_T *tmp_8;
    emxArray_char_T_FlightMissionMode_T *tmp_9;
    emxArray_char_T_FlightMissionMode_T *tmp_a;
    emxArray_char_T_FlightMissionMode_T *tmp_b;
    emxArray_char_T_FlightMissionMode_T *tmp_c;
    emxArray_char_T_FlightMissionMode_T *tmp_d;
    emxArray_char_T_FlightMissionMode_T *tmp_e;
    emxArray_char_T_FlightMissionMode_T *tmp_f;
    emxArray_char_T_FlightMissionMode_T *tmp_g;
    emxArray_char_T_FlightMissionMode_T *tmp_h;
    emxArray_char_T_FlightMissionMode_T *x;
    emxArray_real_T_FlightMissionMode_T *CheckPoints;
    emxArray_real_T_FlightMissionMode_T *b_waypointsIn;
    emxArray_real_T_FlightMissionMode_T *dummyWayPoint;
    emxArray_real_T_FlightMissionMode_T *dummyWayPoint_0;
    emxArray_real_T_FlightMissionMode_T *lengths;
    emxArray_real_T_FlightMissionMode_T *pathLength;
    emxArray_real_T_FlightMissionMode_T *poses;
    emxArray_real_T_FlightMissionMode_T *segWayPoints;
    emxArray_real_T_FlightMissionMode_T *waypoints;
    uavDubinsConnection_FlightMissionMode_T *obj;
    uavDubinsPathSegment_FlightMissionMode_T a__1_0;
    real_T tmp[9];
    real_T tmp_i[9];
    real_T startPose[5];
    real_T CheckPoints_0[4];
    real_T CheckPoints_1[4];
    real_T Reshape[4];
    real_T LLA0_gw[3];
    real_T tmp_0[3];
    real_T u[3];
    real_T distToCenter_tmp[2];
    real_T rtu_Pose_0[2];
    real_T Alt;
    real_T Lon;
    real_T d;
    real_T distToCenter;
    real_T rtb_Switch_l;
    real_T turnVector_idx_2;
    real_T xyCenter_idx_1;
    int32_T NED_WP_size[2];
    int32_T j_size[2];
    int32_T obj_Value_size[2];
    int32_T q_size[2];
    int32_T b_exponent;
    int32_T i1;
    int32_T i2;
    int32_T iy;
    int32_T nread;
    int32_T rtb_Bias_mn;
    int16_T d_0[2];
    char_T j_data[37];
    char_T obj_Value_data[37];
    int8_T rtb_MatrixConcatenate[9];
    int8_T rtAction;
    int8_T rtPrevAction;
    uint8_T rtb_MergeStatus;
    boolean_T b_x[3];
    boolean_T a__1;
    boolean_T c_success;
    boolean_T foundsign;
    boolean_T isStable;
    boolean_T p;
    boolean_T success;

    // Chart: '<Root>/PreemptableMissionModeSelector'
    // Gateway: PreemptableMissionModeSelector
    nread = 0;
    do {
        isStable = true;

        // During: PreemptableMissionModeSelector
        if (static_cast<uint32_T>(localDW->is_active_c2_FlightMissionMode) == 0U)
        {
            // Entry: PreemptableMissionModeSelector
            localDW->is_active_c2_FlightMissionMode = 1U;

            // Entry Internal: PreemptableMissionModeSelector
            // Transition: '<S7>:152'
            isStable = false;
            localDW->is_c2_FlightMissionMode = FlightMissionMode_IN_WaitToStart;
            localDW->FlightMission = MissionModes::WaitToStart;

            // Entry 'WaitToStart': '<S7>:151'
        } else if (localDW->is_c2_FlightMissionMode ==
                   FlightMissionMode_IN_FlightMission) {
            // During 'FlightMission': '<S7>:275'
            if (*rtu_Reset) {
                // Transition: '<S7>:241'
                // Transition: '<S7>:255'
                if (static_cast<boolean_T>(static_cast<int32_T>((*rtu_mode ==
                        MissionModes::CircNav) | (*rtu_mode == MissionModes::
                        CircDispNav)))) {
                    // Transition: '<S7>:264'
                    // Transition: '<S7>:253'
                    // Exit Internal 'FlightMission': '<S7>:275'
                    isStable = false;
                    localDW->FlightMission = MissionModes::CircNav;

                    // Transition: '<S7>:267'
                } else if (static_cast<boolean_T>(static_cast<int32_T>
                            ((*rtu_mode == MissionModes::HorzScanNav) |
                             (*rtu_mode == MissionModes::CustomFrmnNav)))) {
                    // Transition: '<S7>:245'
                    // Transition: '<S7>:246'
                    // Exit Internal 'FlightMission': '<S7>:275'
                    isStable = false;
                    localDW->FlightMission = MissionModes::HorzScanNav;

                    // Transition: '<S7>:258'
                } else if (static_cast<boolean_T>(static_cast<int32_T>
                            ((*rtu_mode == MissionModes::RunWayNav) | (*rtu_mode
                              == MissionModes::FrmnRunWay)))) {
                    // Transition: '<S7>:256'
                    // Transition: '<S7>:244'
                    // Exit Internal 'FlightMission': '<S7>:275'
                    isStable = false;
                    localDW->FlightMission = MissionModes::RunWayNav;
                } else {
                    // Transition: '<S7>:257'
                    switch (*rtu_mode) {
                      case MissionModes::ProtLine:
                        // Transition: '<S7>:247'
                        // Transition: '<S7>:248'
                        // Exit Internal 'FlightMission': '<S7>:275'
                        isStable = false;
                        localDW->FlightMission = MissionModes::ProtLine;
                        break;

                      case MissionModes::FrmnWayPoint:
                        // Transition: '<S7>:260'
                        // Transition: '<S7>:294'
                        // Transition: '<S7>:291'
                        // Exit Internal 'FlightMission': '<S7>:275'
                        isStable = false;
                        localDW->FlightMission = MissionModes::FrmnWayPoint;
                        break;
                    }
                }
            }

            // During 'WaitToStart': '<S7>:151'
        } else if (*rtu_startFlight) {
            // Transition: '<S7>:287'
            // Transition: '<S7>:255'
            if (static_cast<boolean_T>(static_cast<int32_T>((*rtu_mode ==
                    MissionModes::CircNav) | (*rtu_mode == MissionModes::
                    CircDispNav)))) {
                // Transition: '<S7>:264'
                // Transition: '<S7>:253'
                localDW->is_c2_FlightMissionMode =
                    FlightMissionMode_IN_FlightMission;
                isStable = false;
                localDW->FlightMission = MissionModes::CircNav;

                // Transition: '<S7>:267'
            } else if (static_cast<boolean_T>(static_cast<int32_T>((*rtu_mode ==
                          MissionModes::HorzScanNav) | (*rtu_mode ==
                          MissionModes::CustomFrmnNav)))) {
                // Transition: '<S7>:245'
                // Transition: '<S7>:246'
                localDW->is_c2_FlightMissionMode =
                    FlightMissionMode_IN_FlightMission;
                isStable = false;
                localDW->FlightMission = MissionModes::HorzScanNav;

                // Transition: '<S7>:258'
            } else if (static_cast<boolean_T>(static_cast<int32_T>((*rtu_mode ==
                          MissionModes::RunWayNav) | (*rtu_mode == MissionModes::
                          FrmnRunWay)))) {
                // Transition: '<S7>:256'
                // Transition: '<S7>:244'
                localDW->is_c2_FlightMissionMode =
                    FlightMissionMode_IN_FlightMission;
                isStable = false;
                localDW->FlightMission = MissionModes::RunWayNav;
            } else {
                // Transition: '<S7>:257'
                switch (*rtu_mode) {
                  case MissionModes::ProtLine:
                    // Transition: '<S7>:247'
                    // Transition: '<S7>:248'
                    localDW->is_c2_FlightMissionMode =
                        FlightMissionMode_IN_FlightMission;
                    isStable = false;
                    localDW->FlightMission = MissionModes::ProtLine;
                    break;

                  case MissionModes::FrmnWayPoint:
                    // Transition: '<S7>:260'
                    // Transition: '<S7>:294'
                    // Transition: '<S7>:291'
                    localDW->is_c2_FlightMissionMode =
                        FlightMissionMode_IN_FlightMission;
                    isStable = false;
                    localDW->FlightMission = MissionModes::FrmnWayPoint;
                    break;
                }
            }
        }

        nread = static_cast<int32_T>(static_cast<uint32_T>(static_cast<uint32_T>
            (nread) + 1U));
    } while (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>(
                    static_cast<boolean_T>(static_cast<int32_T>
                    (static_cast<int32_T>(isStable) ^ 1))) &
                    (static_cast<uint32_T>(nread) <= 2U))));

    // SwitchCase: '<Root>/Switch Case'
    rtPrevAction = localDW->SwitchCase_ActiveSubsystem;
    switch (localDW->FlightMission) {
      case MissionModes::CircNav:
        rtAction = 0;
        break;

      case MissionModes::HorzScanNav:
        rtAction = 1;
        break;

      case MissionModes::RunWayNav:
        rtAction = 2;
        break;

      case MissionModes::ProtLine:
        rtAction = 3;
        break;

      case MissionModes::FrmnWayPoint:
        rtAction = 4;
        break;

      default:
        rtAction = 5;
        break;
    }

    localDW->SwitchCase_ActiveSubsystem = rtAction;
    if (static_cast<int32_T>(rtPrevAction) != static_cast<int32_T>(rtAction)) {
        switch (rtPrevAction) {
          case 0:
          case 5:
            break;

          case 1:
            // Disable for Enabled SubSystem: '<S36>/WayPointGenerator'
            localDW->WayPointGenerator_MODE_h = false;

            // End of Disable for SubSystem: '<S36>/WayPointGenerator'

            // Disable for Enabled SubSystem: '<S36>/WayPoint'
            localDW->WayPoint_MODE = false;

            // End of Disable for SubSystem: '<S36>/WayPoint'
            break;

          case 2:
            // Disable for Enabled SubSystem: '<S72>/WayPointGenerator'
            localDW->WayPointGenerator_MODE_k = false;

            // End of Disable for SubSystem: '<S72>/WayPointGenerator'

            // Disable for Atomic SubSystem: '<S72>/SegmentSwitch'
            FlightMissionMode_SegmentSwitch_Disable(&localDW->SegmentSwitch);

            // End of Disable for SubSystem: '<S72>/SegmentSwitch'
            break;

          case 3:
            // Disable for Enabled SubSystem: '<S116>/WayPointGenerator'
            localDW->WayPointGenerator_MODE_m = false;

            // End of Disable for SubSystem: '<S116>/WayPointGenerator'

            // Disable for Atomic SubSystem: '<S116>/SegmentSwitch'
            FlightMissionMode_SegmentSwitch_Disable(&localDW->SegmentSwitch_p);

            // End of Disable for SubSystem: '<S116>/SegmentSwitch'
            break;

          case 4:
            // Disable for Enabled SubSystem: '<S161>/WayPointGenerator'
            localDW->WayPointGenerator_MODE = false;

            // End of Disable for SubSystem: '<S161>/WayPointGenerator'

            // Disable for SwitchCase: '<S161>/Switch Case'
            localDW->SwitchCase_ActiveSubsystem_c = -1;
            break;
        }
    }

    FlightMissionMode_emxInit_char_T_ey(&tline, 2);
    FlightMissionMode_emxInit_real_T_h(&dummyWayPoint, 2);
    FlightMissionMode_emxInit_char_T_ey(&data, 2);
    FlightMissionMode_emxInit_char_T_ey(&curSection, 2);
    FlightMissionMode_emxInit_char_T_ey(&curKey, 2);
    FlightMissionMode_emxInit_char_T_ey(&curVal, 2);
    FlightMissionMode_emxInit_char_T_ey(&curLine, 2);
    FlightMissionMode_emxInit_char_T_ey(&x, 2);
    FlightMissionMode_emxInit_char_T_ey(&q, 1);
    FlightMissionMode_emxInit_real_T_h(&waypoints, 2);
    FlightMissionMode_emxInit_real_T_h(&b_waypointsIn, 2);

    // SwitchCase: '<Root>/Switch Case' incorporates:
    //   MATLAB Function: '<S166>/WayPointGenerator'
    //   MATLAB Function: '<S40>/CheckPointInterp'
    //   MATLABSystem: '<S36>/Waypoint Follower'

    switch (rtAction) {
      case 0:
        {
            real_T Lat;
            real_T rtb_Abs1_il;
            real_T rtb_Sum1_e_idx_0;
            real_T rtb_Sum1_e_idx_1;
            int32_T i;
            boolean_T exitg1;
            boolean_T guard1{ false };

            if (static_cast<int32_T>(rtAction) != static_cast<int32_T>
                    (rtPrevAction)) {
                FILE* a;

                // SystemReset for IfAction SubSystem: '<Root>/Mode1_CirclingNav' incorporates:
                //   ActionPort: '<S1>/Action Port'

                // SystemReset for SwitchCase: '<Root>/Switch Case' incorporates:
                //   MATLAB Function: '<S10>/ReadHomePoint'
                //   MATLABSystem: '<S9>/Orbit Follower'

                localDW->HomePoint_not_empty_l = false;
                a = NULL;
                for (i = 0; i < 20; i++) {
                    localDW->eml_openfiles[i] = a;
                }

                localDW->obj_f.OrbitRadiusInternal *= 0.0;
                localDW->obj_f.PrevResetSignal *= 0.0;
                localDW->obj_f.NumCircles *= 0.0;
                localDW->obj_f.OrbitCenterInternal[0] *= 0.0;
                localDW->obj_f.PrevPosition[0] *= 0.0;
                localDW->obj_f.OrbitCenterInternal[1] *= 0.0;
                localDW->obj_f.PrevPosition[1] *= 0.0;
                localDW->obj_f.OrbitCenterInternal[2] *= 0.0;
                localDW->obj_f.PrevPosition[2] *= 0.0;
                localDW->obj_f.StartFlag = true;
                localDW->obj_f.SelectTurnDirectionFlag = true;
                localDW->obj_f.TurnDirectionInternal = 1.0;

                // End of SystemReset for SubSystem: '<Root>/Mode1_CirclingNav'
            }

            // Outputs for IfAction SubSystem: '<Root>/Mode1_CirclingNav' incorporates:
            //   ActionPort: '<S1>/Action Port'

            // MATLAB Function: '<S10>/ReadHomePoint'
            // MATLAB Function 'Mode1_CirclingNav/Mode1_Variant/Mode1/Location2XeHdg1/ReadHomePoint': '<S12>:1' 
            if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                    (localDW->HomePoint_not_empty_l) ^ 1))) {
                creal_T tmp_1;
                creal_T tmp_2;
                creal_T tmp_3;
                int32_T nv;
                int32_T stride;

                // '<S12>:1:5'
                // '<S12>:1:6'
                tline->size[0] = 1;
                tline->size[1] = 0;
                rtPrevAction = FlightMissionMode_cfopen_e("config.ini", "rb",
                    localDW);
                if (static_cast<int32_T>(rtPrevAction) < 0) {
                    printf("INI-file \"%s\" was not found or could not be read.\n",
                           "config.ini");
                    fflush(stdout);
                } else {
                    FlightMissionMode_fread_h(static_cast<real_T>(rtPrevAction),
                        q, localDW);
                    stride = static_cast<int32_T>(data->size[0] * data->size[1]);
                    data->size[0] = 1;
                    data->size[1] = q->size[0];
                    FlightMissionMode_emxEnsureCapacity_char_T_g(data, stride);
                    nv = q->size[0];
                    for (i = 0; i <= static_cast<int32_T>(nv - 1); i++) {
                        data->data[i] = q->data[i];
                    }

                    FlightMissionMode_cfclose_n(static_cast<real_T>(rtPrevAction),
                        localDW);
                    curSection->size[0] = 1;
                    curSection->size[1] = 0;
                    curKey->size[0] = 1;
                    curKey->size[1] = 0;
                    curVal->size[0] = 1;
                    curVal->size[1] = 0;
                    FlightMissionMode_emxInit_char_T_ey(&tmp_8, 2);
                    FlightMissionMode_emxInit_char_T_ey(&data_2, 2);
                    exitg1 = false;
                    while ((!exitg1) && (data->size[1] != 0)) {
                        stride = static_cast<int32_T>(data_2->size[0] *
                            data_2->size[1]);
                        data_2->size[0] = 1;
                        data_2->size[1] = data->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_g(data_2,
                            stride);
                        i = static_cast<int32_T>(static_cast<int32_T>(data->
                            size[0] * data->size[1]) - 1);
                        for (stride = 0; stride <= i; stride++) {
                            data_2->data[stride] = data->data[stride];
                        }

                        FlightMissionMode_strtok_d(data_2, curLine, data);
                        FlightMissionMode_strtok_dq(curLine, tmp_8);
                        FlightMissionMode_strtrim_f(tmp_8, curLine);
                        if (curLine->size[1] >= 2) {
                            isStable = false;
                            if (curLine->data[0] == '[') {
                                isStable = true;
                            }

                            guard1 = false;
                            if (isStable) {
                                isStable = false;
                                if (curLine->data[static_cast<int32_T>
                                        (curLine->size[1] - 1)] == ']') {
                                    isStable = true;
                                }

                                if (isStable) {
                                    if (static_cast<int32_T>(curLine->size[1] -
                                            1) < 2) {
                                        iy = 0;
                                        nread = 0;
                                    } else {
                                        iy = 1;
                                        nread = static_cast<int32_T>
                                            (curLine->size[1] - 1);
                                    }

                                    stride = static_cast<int32_T>
                                        (curSection->size[0] * curSection->size
                                         [1]);
                                    curSection->size[0] = 1;
                                    nv = static_cast<int32_T>(nread - iy);
                                    curSection->size[1] = nv;
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (curSection, stride);
                                    for (i = 0; i <= static_cast<int32_T>(nv - 1);
                                         i++) {
                                        curSection->data[i] = curLine->data[
                                            static_cast<int32_T>(iy + i)];
                                    }

                                    curKey->size[0] = 1;
                                    curKey->size[1] = 0;
                                } else {
                                    guard1 = true;
                                }
                            } else {
                                guard1 = true;
                            }

                            if (guard1) {
                                if (curLine->data[0] == ';') {
                                    isStable = true;
                                }

                                if ((static_cast<boolean_T>(static_cast<int32_T>
                                                            (static_cast<int32_T>
                                        (isStable) ^ 1))) &&
                                        FlightMissionMode_contains_d(curLine)) {
                                    FlightMissionMode_strtok_dq4(curLine, curVal,
                                        x);
                                    FlightMissionMode_find_token_m(x, &i1,
                                        &nread);
                                    if (i1 > static_cast<int32_T>(nread - 1)) {
                                        iy = 0;
                                        i1 = 0;
                                    } else {
                                        iy = static_cast<int32_T>(i1 - 1);
                                        i1 = static_cast<int32_T>(nread - 1);
                                    }

                                    FlightMissionMode_strtrim_f(curVal, curKey);
                                    stride = static_cast<int32_T>(curLine->size
                                        [0] * curLine->size[1]);
                                    curLine->size[0] = 1;
                                    nv = static_cast<int32_T>(i1 - iy);
                                    curLine->size[1] = nv;
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (curLine, stride);
                                    for (i = 0; i <= static_cast<int32_T>(nv - 1);
                                         i++) {
                                        curLine->data[i] = x->data
                                            [static_cast<int32_T>(iy + i)];
                                    }

                                    FlightMissionMode_strtrim_f(curLine, curVal);
                                }
                            }
                        }

                        if (FlightMissionMode_strcmp_b(curSection) &&
                                FlightMissionMode_strcmp_bx(curKey)) {
                            stride = static_cast<int32_T>(tline->size[0] *
                                tline->size[1]);
                            tline->size[0] = 1;
                            tline->size[1] = curVal->size[1];
                            FlightMissionMode_emxEnsureCapacity_char_T_g(tline,
                                stride);
                            nv = curVal->size[1];
                            for (i = 0; i <= static_cast<int32_T>(nv - 1); i++)
                            {
                                tline->data[i] = curVal->data[i];
                            }

                            exitg1 = true;
                        }
                    }

                    FlightMissionMode_emxFree_char_T_o(&data_2);
                    FlightMissionMode_emxFree_char_T_o(&tmp_8);
                }

                tmp_1 = FlightMissionMode_str2double_k(tline);
                printf("Set Home Point Latitude:\t%f\n", tmp_1.re);
                fflush(stdout);
                tline->size[0] = 1;
                tline->size[1] = 0;
                rtPrevAction = FlightMissionMode_cfopen_e("config.ini", "rb",
                    localDW);
                if (static_cast<int32_T>(rtPrevAction) < 0) {
                    printf("INI-file \"%s\" was not found or could not be read.\n",
                           "config.ini");
                    fflush(stdout);
                } else {
                    FlightMissionMode_fread_h(static_cast<real_T>(rtPrevAction),
                        q, localDW);
                    stride = static_cast<int32_T>(data->size[0] * data->size[1]);
                    data->size[0] = 1;
                    data->size[1] = q->size[0];
                    FlightMissionMode_emxEnsureCapacity_char_T_g(data, stride);
                    nv = q->size[0];
                    for (i = 0; i <= static_cast<int32_T>(nv - 1); i++) {
                        data->data[i] = q->data[i];
                    }

                    FlightMissionMode_cfclose_n(static_cast<real_T>(rtPrevAction),
                        localDW);
                    curSection->size[0] = 1;
                    curSection->size[1] = 0;
                    curKey->size[0] = 1;
                    curKey->size[1] = 0;
                    curVal->size[0] = 1;
                    curVal->size[1] = 0;
                    FlightMissionMode_emxInit_char_T_ey(&tmp_7, 2);
                    FlightMissionMode_emxInit_char_T_ey(&data_1, 2);
                    exitg1 = false;
                    while ((!exitg1) && (data->size[1] != 0)) {
                        stride = static_cast<int32_T>(data_1->size[0] *
                            data_1->size[1]);
                        data_1->size[0] = 1;
                        data_1->size[1] = data->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_g(data_1,
                            stride);
                        i = static_cast<int32_T>(static_cast<int32_T>(data->
                            size[0] * data->size[1]) - 1);
                        for (stride = 0; stride <= i; stride++) {
                            data_1->data[stride] = data->data[stride];
                        }

                        FlightMissionMode_strtok_d(data_1, curLine, data);
                        FlightMissionMode_strtok_dq(curLine, tmp_7);
                        FlightMissionMode_strtrim_f(tmp_7, curLine);
                        if (curLine->size[1] >= 2) {
                            isStable = false;
                            if (curLine->data[0] == '[') {
                                isStable = true;
                            }

                            guard1 = false;
                            if (isStable) {
                                isStable = false;
                                if (curLine->data[static_cast<int32_T>
                                        (curLine->size[1] - 1)] == ']') {
                                    isStable = true;
                                }

                                if (isStable) {
                                    int32_T ntoread;
                                    if (static_cast<int32_T>(curLine->size[1] -
                                            1) < 2) {
                                        i1 = 0;
                                        ntoread = 0;
                                    } else {
                                        i1 = 1;
                                        ntoread = static_cast<int32_T>
                                            (curLine->size[1] - 1);
                                    }

                                    stride = static_cast<int32_T>
                                        (curSection->size[0] * curSection->size
                                         [1]);
                                    curSection->size[0] = 1;
                                    nv = static_cast<int32_T>(ntoread - i1);
                                    curSection->size[1] = nv;
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (curSection, stride);
                                    for (i = 0; i <= static_cast<int32_T>(nv - 1);
                                         i++) {
                                        curSection->data[i] = curLine->data[
                                            static_cast<int32_T>(i1 + i)];
                                    }

                                    curKey->size[0] = 1;
                                    curKey->size[1] = 0;
                                } else {
                                    guard1 = true;
                                }
                            } else {
                                guard1 = true;
                            }

                            if (guard1) {
                                if (curLine->data[0] == ';') {
                                    isStable = true;
                                }

                                if ((static_cast<boolean_T>(static_cast<int32_T>
                                                            (static_cast<int32_T>
                                        (isStable) ^ 1))) &&
                                        FlightMissionMode_contains_d(curLine)) {
                                    FlightMissionMode_strtok_dq4(curLine, curVal,
                                        x);
                                    FlightMissionMode_find_token_m(x, &iy,
                                        &nread);
                                    if (iy > static_cast<int32_T>(nread - 1)) {
                                        iy = 0;
                                        nread = 0;
                                    } else {
                                        iy = static_cast<int32_T>(iy - 1);
                                        nread = static_cast<int32_T>(nread - 1);
                                    }

                                    FlightMissionMode_strtrim_f(curVal, curKey);
                                    stride = static_cast<int32_T>(curLine->size
                                        [0] * curLine->size[1]);
                                    curLine->size[0] = 1;
                                    nv = static_cast<int32_T>(nread - iy);
                                    curLine->size[1] = nv;
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (curLine, stride);
                                    for (i = 0; i <= static_cast<int32_T>(nv - 1);
                                         i++) {
                                        curLine->data[i] = x->data
                                            [static_cast<int32_T>(iy + i)];
                                    }

                                    FlightMissionMode_strtrim_f(curLine, curVal);
                                }
                            }
                        }

                        if (FlightMissionMode_strcmp_b(curSection) &&
                                FlightMissionMode_strcmp_bxk(curKey)) {
                            stride = static_cast<int32_T>(tline->size[0] *
                                tline->size[1]);
                            tline->size[0] = 1;
                            tline->size[1] = curVal->size[1];
                            FlightMissionMode_emxEnsureCapacity_char_T_g(tline,
                                stride);
                            nv = curVal->size[1];
                            for (i = 0; i <= static_cast<int32_T>(nv - 1); i++)
                            {
                                tline->data[i] = curVal->data[i];
                            }

                            exitg1 = true;
                        }
                    }

                    FlightMissionMode_emxFree_char_T_o(&data_1);
                    FlightMissionMode_emxFree_char_T_o(&tmp_7);
                }

                tmp_2 = FlightMissionMode_str2double_k(tline);
                printf("Set Home Point Longitude:\t%f\n", tmp_2.re);
                fflush(stdout);
                tline->size[0] = 1;
                tline->size[1] = 0;
                rtPrevAction = FlightMissionMode_cfopen_e("config.ini", "rb",
                    localDW);
                if (static_cast<int32_T>(rtPrevAction) < 0) {
                    printf("INI-file \"%s\" was not found or could not be read.\n",
                           "config.ini");
                    fflush(stdout);
                } else {
                    FlightMissionMode_fread_h(static_cast<real_T>(rtPrevAction),
                        q, localDW);
                    stride = static_cast<int32_T>(data->size[0] * data->size[1]);
                    data->size[0] = 1;
                    data->size[1] = q->size[0];
                    FlightMissionMode_emxEnsureCapacity_char_T_g(data, stride);
                    nv = q->size[0];
                    for (i = 0; i <= static_cast<int32_T>(nv - 1); i++) {
                        data->data[i] = q->data[i];
                    }

                    FlightMissionMode_cfclose_n(static_cast<real_T>(rtPrevAction),
                        localDW);
                    curSection->size[0] = 1;
                    curSection->size[1] = 0;
                    curKey->size[0] = 1;
                    curKey->size[1] = 0;
                    curVal->size[0] = 1;
                    curVal->size[1] = 0;
                    FlightMissionMode_emxInit_char_T_ey(&tmp_6, 2);
                    FlightMissionMode_emxInit_char_T_ey(&data_0, 2);
                    exitg1 = false;
                    while ((!exitg1) && (data->size[1] != 0)) {
                        stride = static_cast<int32_T>(data_0->size[0] *
                            data_0->size[1]);
                        data_0->size[0] = 1;
                        data_0->size[1] = data->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_g(data_0,
                            stride);
                        i = static_cast<int32_T>(static_cast<int32_T>(data->
                            size[0] * data->size[1]) - 1);
                        for (stride = 0; stride <= i; stride++) {
                            data_0->data[stride] = data->data[stride];
                        }

                        FlightMissionMode_strtok_d(data_0, curLine, data);
                        FlightMissionMode_strtok_dq(curLine, tmp_6);
                        FlightMissionMode_strtrim_f(tmp_6, curLine);
                        if (curLine->size[1] >= 2) {
                            isStable = false;
                            if (curLine->data[0] == '[') {
                                isStable = true;
                            }

                            guard1 = false;
                            if (isStable) {
                                isStable = false;
                                if (curLine->data[static_cast<int32_T>
                                        (curLine->size[1] - 1)] == ']') {
                                    isStable = true;
                                }

                                if (isStable) {
                                    if (static_cast<int32_T>(curLine->size[1] -
                                            1) < 2) {
                                        iy = 0;
                                        i2 = 0;
                                    } else {
                                        iy = 1;
                                        i2 = static_cast<int32_T>(curLine->size
                                            [1] - 1);
                                    }

                                    stride = static_cast<int32_T>
                                        (curSection->size[0] * curSection->size
                                         [1]);
                                    curSection->size[0] = 1;
                                    nv = static_cast<int32_T>(i2 - iy);
                                    curSection->size[1] = nv;
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (curSection, stride);
                                    for (i = 0; i <= static_cast<int32_T>(nv - 1);
                                         i++) {
                                        curSection->data[i] = curLine->data[
                                            static_cast<int32_T>(iy + i)];
                                    }

                                    curKey->size[0] = 1;
                                    curKey->size[1] = 0;
                                } else {
                                    guard1 = true;
                                }
                            } else {
                                guard1 = true;
                            }

                            if (guard1) {
                                if (curLine->data[0] == ';') {
                                    isStable = true;
                                }

                                if ((static_cast<boolean_T>(static_cast<int32_T>
                                                            (static_cast<int32_T>
                                        (isStable) ^ 1))) &&
                                        FlightMissionMode_contains_d(curLine)) {
                                    int32_T n;
                                    FlightMissionMode_strtok_dq4(curLine, curVal,
                                        x);
                                    FlightMissionMode_find_token_m(x, &iy,
                                        &nread);
                                    if (iy > static_cast<int32_T>(nread - 1)) {
                                        n = 0;
                                        i = 0;
                                    } else {
                                        n = static_cast<int32_T>(iy - 1);
                                        i = static_cast<int32_T>(nread - 1);
                                    }

                                    FlightMissionMode_strtrim_f(curVal, curKey);
                                    stride = static_cast<int32_T>(curLine->size
                                        [0] * curLine->size[1]);
                                    curLine->size[0] = 1;
                                    nv = static_cast<int32_T>(i - n);
                                    curLine->size[1] = nv;
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (curLine, stride);
                                    for (i = 0; i <= static_cast<int32_T>(nv - 1);
                                         i++) {
                                        curLine->data[i] = x->data
                                            [static_cast<int32_T>(n + i)];
                                    }

                                    FlightMissionMode_strtrim_f(curLine, curVal);
                                }
                            }
                        }

                        if (FlightMissionMode_strcmp_b(curSection) &&
                                FlightMissionMode_strcmp_bxki(curKey)) {
                            stride = static_cast<int32_T>(tline->size[0] *
                                tline->size[1]);
                            tline->size[0] = 1;
                            tline->size[1] = curVal->size[1];
                            FlightMissionMode_emxEnsureCapacity_char_T_g(tline,
                                stride);
                            nv = curVal->size[1];
                            for (i = 0; i <= static_cast<int32_T>(nv - 1); i++)
                            {
                                tline->data[i] = curVal->data[i];
                            }

                            exitg1 = true;
                        }
                    }

                    FlightMissionMode_emxFree_char_T_o(&data_0);
                    FlightMissionMode_emxFree_char_T_o(&tmp_6);
                }

                tmp_3 = FlightMissionMode_str2double_k(tline);
                printf("Set Home Point Altitude:\t%f\n", tmp_3.re);
                fflush(stdout);
                localDW->HomePoint_p[0] = tmp_1.re;
                localDW->HomePoint_p[1] = tmp_2.re;
                localDW->HomePoint_p[2] = tmp_3.re;
                localDW->HomePoint_not_empty_l = true;
                b_x[0] = std::isnan(localDW->HomePoint_p[0]);
                b_x[1] = std::isnan(localDW->HomePoint_p[1]);
                b_x[2] = std::isnan(localDW->HomePoint_p[2]);
                isStable = false;
                nread = 0;
                exitg1 = false;
                while ((!exitg1) && (nread < 3)) {
                    if (b_x[nread]) {
                        isStable = true;
                        exitg1 = true;
                    } else {
                        nread = static_cast<int32_T>(nread + 1);
                    }
                }

                if (isStable) {
                    // '<S12>:1:7'
                    // '<S12>:1:8'
                    localDW->HomePoint_p[0] = 35.8617;
                    localDW->HomePoint_p[1] = 104.1954;
                    localDW->HomePoint_p[2] = 0.0;
                }
            }

            // Switch: '<S26>/Switch' incorporates:
            //   Abs: '<S26>/Abs'
            //   Bias: '<S26>/Bias'
            //   Bias: '<S26>/Bias1'
            //   Constant: '<S26>/Constant2'
            //   Constant: '<S27>/Constant'
            //   MATLAB Function: '<S10>/ReadHomePoint'
            //   Math: '<S26>/Math Function1'
            //   RelationalOperator: '<S27>/Compare'

            // '<S12>:1:12'
            if (std::abs(localDW->HomePoint_p[0]) > 180.0) {
                rtb_Switch_l = rt_modd_snf(localDW->HomePoint_p[0] + 180.0,
                    360.0) - 180.0;
            } else {
                rtb_Switch_l = localDW->HomePoint_p[0];
            }

            // End of Switch: '<S26>/Switch'

            // Abs: '<S23>/Abs1'
            rtb_Abs1_il = std::abs(rtb_Switch_l);

            // Switch: '<S23>/Switch' incorporates:
            //   Bias: '<S23>/Bias'
            //   Bias: '<S23>/Bias1'
            //   Constant: '<S14>/Constant'
            //   Constant: '<S14>/Constant1'
            //   Constant: '<S25>/Constant'
            //   Gain: '<S23>/Gain'
            //   Product: '<S23>/Divide1'
            //   RelationalOperator: '<S25>/Compare'
            //   Signum: '<S23>/Sign1'
            //   Switch: '<S14>/Switch1'

            if (rtb_Abs1_il > 90.0) {
                // Signum: '<S23>/Sign1'
                if (std::isnan(rtb_Switch_l)) {
                    rtb_Sum1_e_idx_0 = (rtNaN);
                } else if (rtb_Switch_l < 0.0) {
                    rtb_Sum1_e_idx_0 = -1.0;
                } else {
                    rtb_Sum1_e_idx_0 = static_cast<real_T>(rtb_Switch_l > 0.0);
                }

                rtb_Switch_l = (-(rtb_Abs1_il - 90.0) + 90.0) * rtb_Sum1_e_idx_0;
                i = 180;
            } else {
                i = 0;
            }

            // End of Switch: '<S23>/Switch'

            // Sum: '<S14>/Sum' incorporates:
            //   MATLAB Function: '<S10>/ReadHomePoint'
            //   Switch: '<S14>/Switch1'

            Alt = static_cast<real_T>(i) + localDW->HomePoint_p[1];

            // Switch: '<S24>/Switch' incorporates:
            //   Abs: '<S24>/Abs'
            //   Bias: '<S24>/Bias'
            //   Bias: '<S24>/Bias1'
            //   Constant: '<S24>/Constant2'
            //   Constant: '<S28>/Constant'
            //   Math: '<S24>/Math Function1'
            //   RelationalOperator: '<S28>/Compare'

            if (std::abs(Alt) > 180.0) {
                Alt = rt_modd_snf(Alt + 180.0, 360.0) - 180.0;
            }

            // End of Switch: '<S24>/Switch'

            // Sum: '<S11>/Sum1'
            rtb_Sum1_e_idx_0 = rtu_MissionLocation->Lat - rtb_Switch_l;
            rtb_Sum1_e_idx_1 = rtu_MissionLocation->Lon - Alt;

            // Switch: '<S20>/Switch' incorporates:
            //   Abs: '<S20>/Abs'
            //   Bias: '<S20>/Bias'
            //   Bias: '<S20>/Bias1'
            //   Constant: '<S20>/Constant2'
            //   Constant: '<S21>/Constant'
            //   Math: '<S20>/Math Function1'
            //   RelationalOperator: '<S21>/Compare'

            if (std::abs(rtb_Sum1_e_idx_0) > 180.0) {
                Alt = rt_modd_snf(rtb_Sum1_e_idx_0 + 180.0, 360.0) - 180.0;
            } else {
                Alt = rtb_Sum1_e_idx_0;
            }

            // End of Switch: '<S20>/Switch'

            // Abs: '<S17>/Abs1'
            rtb_Abs1_il = std::abs(Alt);

            // Switch: '<S17>/Switch' incorporates:
            //   Bias: '<S17>/Bias'
            //   Bias: '<S17>/Bias1'
            //   Constant: '<S13>/Constant'
            //   Constant: '<S13>/Constant1'
            //   Constant: '<S19>/Constant'
            //   Gain: '<S17>/Gain'
            //   Product: '<S17>/Divide1'
            //   RelationalOperator: '<S19>/Compare'
            //   Signum: '<S17>/Sign1'
            //   Switch: '<S13>/Switch1'

            if (rtb_Abs1_il > 90.0) {
                // Signum: '<S17>/Sign1'
                if (std::isnan(Alt)) {
                    rtb_Sum1_e_idx_0 = (rtNaN);
                } else if (Alt < 0.0) {
                    rtb_Sum1_e_idx_0 = -1.0;
                } else {
                    rtb_Sum1_e_idx_0 = static_cast<real_T>(Alt > 0.0);
                }

                Alt = (-(rtb_Abs1_il - 90.0) + 90.0) * rtb_Sum1_e_idx_0;
                i = 180;
            } else {
                i = 0;
            }

            // End of Switch: '<S17>/Switch'

            // Sum: '<S13>/Sum' incorporates:
            //   Switch: '<S13>/Switch1'

            Lon = static_cast<real_T>(i) + rtb_Sum1_e_idx_1;

            // Switch: '<S18>/Switch' incorporates:
            //   Abs: '<S18>/Abs'
            //   Bias: '<S18>/Bias'
            //   Bias: '<S18>/Bias1'
            //   Constant: '<S18>/Constant2'
            //   Constant: '<S22>/Constant'
            //   Math: '<S18>/Math Function1'
            //   RelationalOperator: '<S22>/Compare'

            if (std::abs(Lon) > 180.0) {
                Lon = rt_modd_snf(Lon + 180.0, 360.0) - 180.0;
            }

            // End of Switch: '<S18>/Switch'

            // UnitConversion: '<S16>/Unit Conversion'
            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            rtb_Sum1_e_idx_0 = 0.017453292519943295 * Alt;
            rtb_Sum1_e_idx_1 = 0.017453292519943295 * Lon;

            // UnitConversion: '<S31>/Unit Conversion'
            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            rtb_Switch_l *= 0.017453292519943295;

            // Trigonometry: '<S32>/Trigonometric Function1'
            Lon = std::sin(rtb_Switch_l);

            // Sum: '<S32>/Sum1' incorporates:
            //   Constant: '<S32>/Constant'
            //   Product: '<S32>/Product1'

            Lon = 1.0 - 0.0066943799901413295 * Lon * Lon;

            // Product: '<S30>/Product1' incorporates:
            //   Constant: '<S30>/Constant1'
            //   Sqrt: '<S30>/sqrt'

            Alt = 6.378137E+6 / std::sqrt(Lon);

            // Product: '<S15>/dNorth' incorporates:
            //   Constant: '<S30>/Constant2'
            //   Product: '<S30>/Product3'
            //   Trigonometry: '<S30>/Trigonometric Function1'

            Lon = rtb_Sum1_e_idx_0 / rt_atan2d_snf(1.0, Alt *
                0.99330562000985867 / Lon);

            // Product: '<S15>/dEast' incorporates:
            //   Constant: '<S30>/Constant3'
            //   Product: '<S30>/Product4'
            //   Trigonometry: '<S30>/Trigonometric Function'
            //   Trigonometry: '<S30>/Trigonometric Function2'

            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            Alt = 1.0 / rt_atan2d_snf(1.0, Alt * std::cos(rtb_Switch_l)) *
                rtb_Sum1_e_idx_1;

            // Sum: '<S15>/Sum2' incorporates:
            //   Product: '<S15>/x*cos'
            //   Product: '<S15>/y*sin'

            rtb_Switch_l = Alt * 0.0 + Lon;

            // Sum: '<S15>/Sum3' incorporates:
            //   Product: '<S15>/x*sin'
            //   Product: '<S15>/y*cos'

            rtb_Abs1_il = Alt - Lon * 0.0;

            // Sum: '<S11>/Sum' incorporates:
            //   MATLAB Function: '<S10>/ReadHomePoint'

            Lat = rtu_MissionLocation->Alt - localDW->HomePoint_p[2];

            // SignalConversion generated from: '<S9>/Orbit Follower' incorporates:
            //   UnaryMinus: '<S11>/Ze2height'

            LLA0_gw[0] = rtb_Switch_l;
            LLA0_gw[1] = rtb_Abs1_il;
            LLA0_gw[2] = -Lat;

            // MATLABSystem: '<S9>/Orbit Follower' incorporates:
            //   DataTypeConversion: '<S9>/Param1'
            //   DataTypeConversion: '<S9>/Param2'
            //   SignalConversion generated from: '<S9>/Orbit Follower'
            //   UnaryMinus: '<S11>/Ze2height'

            Alt = static_cast<real_T>(rtu_Parameters->Param1);
            localDW->obj_f.OrbitRadiusFlag = 0U;
            if (rtu_Parameters->Param1 <= 220.0F) {
                Alt = 220.0;
                localDW->obj_f.OrbitRadiusFlag = 1U;
            }

            localDW->obj_f.LookaheadDistFlag = 1U;
            rtu_Pose_0[0] = rtu_Pose[0] - rtb_Switch_l;
            rtu_Pose_0[1] = rtu_Pose[1] - rtb_Abs1_il;
            if (FlightMissionMode_norm_p(rtu_Pose_0) < 2.47032822920623E-323) {
                u[2] = -Lat;
                Lon = rtu_Pose[3];
                *rty_thisTaskStatus = localDW->obj_f.NumCircles;
            } else {
                isStable = false;
                p = true;
                nread = 0;
                exitg1 = false;
                while ((!exitg1) && (nread < 3)) {
                    if (static_cast<boolean_T>(static_cast<int32_T>
                                               ((localDW->obj_f.OrbitCenterInternal
                            [nread] == LLA0_gw[nread]) ^ 1))) {
                        p = false;
                        exitg1 = true;
                    } else {
                        nread = static_cast<int32_T>(nread + 1);
                    }
                }

                if (p) {
                    isStable = true;
                }

                guard1 = false;
                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>(isStable) ^ 1)))
                {
                    guard1 = true;
                } else {
                    isStable = false;
                    if (localDW->obj_f.OrbitRadiusInternal == Alt) {
                        isStable = true;
                    }

                    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<
                            int32_T>(isStable) ^ 1))) {
                        guard1 = true;
                    }
                }

                if (guard1) {
                    localDW->obj_f.NumCircles = 0.0;
                    localDW->obj_f.OrbitCenterInternal[0] = rtb_Switch_l;
                    localDW->obj_f.OrbitCenterInternal[1] = rtb_Abs1_il;
                    localDW->obj_f.OrbitCenterInternal[2] = -Lat;
                    localDW->obj_f.OrbitRadiusInternal = Alt;
                    localDW->obj_f.SelectTurnDirectionFlag = true;
                }

                if (Alt <= 35.0) {
                    localDW->obj_f.LookaheadDistance = 0.9 * Alt;
                } else {
                    localDW->obj_f.LookaheadDistance = 35.0;
                }

                rtb_Sum1_e_idx_1 = rtu_Pose[0] - rtb_Switch_l;
                distToCenter_tmp[0] = rtb_Sum1_e_idx_1;
                turnVector_idx_2 = rtu_Pose[1] - rtb_Abs1_il;
                distToCenter_tmp[1] = turnVector_idx_2;
                distToCenter = std::sqrt(turnVector_idx_2 * turnVector_idx_2 +
                    rtb_Sum1_e_idx_1 * rtb_Sum1_e_idx_1);
                rtb_Sum1_e_idx_0 = Alt + localDW->obj_f.LookaheadDistance;
                d = std::abs(rtb_Sum1_e_idx_0);
                isStable = std::isinf(d);
                p = std::isnan(d);
                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>(isStable) |
                                            static_cast<int32_T>(p)))) {
                    Lon = (rtNaN);
                } else if (d < 4.4501477170144028E-308) {
                    Lon = 4.94065645841247E-324;
                } else {
                    std::frexp(d, &rtb_Bias_mn);
                    Lon = std::ldexp(1.0, static_cast<int32_T>(rtb_Bias_mn - 53));
                }

                guard1 = false;
                if (distToCenter >= rtb_Sum1_e_idx_0 - 5.0 * Lon) {
                    guard1 = true;
                } else {
                    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<
                            int32_T>(isStable) | static_cast<int32_T>(p)))) {
                        Lon = (rtNaN);
                    } else if (d < 4.4501477170144028E-308) {
                        Lon = 4.94065645841247E-324;
                    } else {
                        std::frexp(d, &b_exponent);
                        Lon = std::ldexp(1.0, static_cast<int32_T>(b_exponent -
                                          53));
                    }

                    if (distToCenter <= (Alt - localDW->obj_f.LookaheadDistance)
                        + 5.0 * Lon) {
                        guard1 = true;
                    } else {
                        real_T distToCenter_tmp_0;
                        if (localDW->obj_f.StartFlag) {
                            localDW->obj_f.PrevPosition[0] = rtu_Pose[0];
                            localDW->obj_f.PrevPosition[1] = rtu_Pose[1];
                            localDW->obj_f.StartFlag = false;
                        }

                        rtu_Pose_0[0] = rtb_Sum1_e_idx_1;
                        rtu_Pose_0[1] = rtu_Pose[1] - rtb_Abs1_il;
                        d = FlightMissionMode_norm_p(rtu_Pose_0);
                        turnVector_idx_2 = localDW->obj_f.LookaheadDistance *
                            localDW->obj_f.LookaheadDistance;
                        Lon = ((turnVector_idx_2 - Alt * Alt) + d * d) / (2.0 *
                            d);
                        rtb_Sum1_e_idx_0 = rtb_Switch_l - rtu_Pose[0];
                        Alt = rtb_Sum1_e_idx_0 * Lon / d + rtu_Pose[0];
                        distToCenter_tmp_0 = rtb_Abs1_il - rtu_Pose[1];
                        distToCenter = distToCenter_tmp_0 * Lon / d + rtu_Pose[1];
                        Lon = std::sqrt(turnVector_idx_2 - Lon * Lon);
                        turnVector_idx_2 = distToCenter_tmp_0 * Lon / d;
                        distToCenter_tmp[0] = Alt - turnVector_idx_2;
                        distToCenter_tmp[1] = turnVector_idx_2 + Alt;
                        Lon = rtb_Sum1_e_idx_0 * Lon / d;
                        turnVector_idx_2 = Lon + distToCenter;
                        xyCenter_idx_1 = distToCenter - Lon;
                        if ((rtu_Parameters->Param2 == 0.0F) &&
                                (static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>
                                (localDW->obj_f.SelectTurnDirectionFlag) ^ 1))))
                        {
                            Lon = localDW->obj_f.TurnDirectionInternal;
                        } else {
                            Lon = static_cast<real_T>(rtu_Parameters->Param2);
                        }

                        distToCenter = localDW->obj_f.PrevPosition[0] -
                            rtb_Switch_l;
                        Alt = localDW->obj_f.PrevPosition[1] - rtb_Abs1_il;
                        u[0] = distToCenter;
                        u[1] = Alt;
                        u[2] = 0.0;
                        LLA0_gw[0] = rtb_Sum1_e_idx_1;
                        LLA0_gw[1] = rtu_Pose[1] - rtb_Abs1_il;
                        LLA0_gw[2] = 0.0;
                        if (Lon < 0.0) {
                            u[0] = rtb_Sum1_e_idx_1;
                            LLA0_gw[0] = distToCenter;
                            u[1] = LLA0_gw[1];
                            LLA0_gw[1] = Alt;
                            u[2] = 0.0;
                            LLA0_gw[2] = 0.0;
                        }

                        rtb_Sum1_e_idx_0 = FlightMissionMode_norm_pv(u);
                        distToCenter_tmp_0 = FlightMissionMode_norm_pv(LLA0_gw);
                        distToCenter = u[0] / rtb_Sum1_e_idx_0;
                        Alt = LLA0_gw[0] / distToCenter_tmp_0;
                        d = u[1] / rtb_Sum1_e_idx_0;
                        rtb_Sum1_e_idx_1 = LLA0_gw[1] / distToCenter_tmp_0;
                        localDW->obj_f.PrevPosition[0] = rtu_Pose[0];
                        localDW->obj_f.PrevPosition[1] = rtu_Pose[1];
                        localDW->obj_f.PrevPosition[2] = rtu_Pose[2];
                        localDW->obj_f.NumCircles += rt_atan2d_snf(distToCenter *
                            rtb_Sum1_e_idx_1 - Alt * d, (distToCenter * Alt + d *
                            rtb_Sum1_e_idx_1) + 0.0 / rtb_Sum1_e_idx_0 * (0.0 /
                            distToCenter_tmp_0)) / 2.0 / 3.1415926535897931;
                        *rty_thisTaskStatus = localDW->obj_f.NumCircles;
                        u[0] = rtb_Switch_l - rtu_Pose[0];
                        u[1] = rtb_Abs1_il - rtu_Pose[1];
                        if (std::isnan(Lon)) {
                            rtb_Sum1_e_idx_0 = (rtNaN);
                        } else if (Lon < 0.0) {
                            rtb_Sum1_e_idx_0 = -1.0;
                        } else {
                            rtb_Sum1_e_idx_0 = static_cast<real_T>(Lon > 0.0);
                        }

                        switch (static_cast<int32_T>(rtb_Sum1_e_idx_0)) {
                          case 1:
                            if ((distToCenter_tmp[0] - rtu_Pose[0]) * u[1] -
                                    (turnVector_idx_2 - rtu_Pose[1]) * u[0] >
                                    0.0) {
                                Lon = distToCenter_tmp[0];
                                xyCenter_idx_1 = turnVector_idx_2;
                            } else {
                                Lon = distToCenter_tmp[1];
                            }
                            break;

                          case -1:
                            if ((distToCenter_tmp[0] - rtu_Pose[0]) * u[1] -
                                    (turnVector_idx_2 - rtu_Pose[1]) * u[0] <
                                    0.0) {
                                Lon = distToCenter_tmp[0];
                                xyCenter_idx_1 = turnVector_idx_2;
                            } else {
                                Lon = distToCenter_tmp[1];
                            }
                            break;

                          default:
                            if (std::abs(FlightMissionMode_angdiff(rt_atan2d_snf
                                    (turnVector_idx_2 - rtu_Pose[1],
                                     distToCenter_tmp[0] - rtu_Pose[0]),
                                    rtu_Pose[3])) < std::abs
                                    (FlightMissionMode_angdiff(rt_atan2d_snf
                                    (xyCenter_idx_1 - rtu_Pose[1],
                                     distToCenter_tmp[1] - rtu_Pose[0]),
                                    rtu_Pose[3]))) {
                                Lon = distToCenter_tmp[0];
                                xyCenter_idx_1 = turnVector_idx_2;
                            } else {
                                Lon = distToCenter_tmp[1];
                            }

                            if ((Lon - rtu_Pose[0]) * u[1] - (xyCenter_idx_1 -
                                    rtu_Pose[1]) * u[0] > 0.0) {
                                localDW->obj_f.TurnDirectionInternal = 1.0;
                            } else {
                                localDW->obj_f.TurnDirectionInternal = -1.0;
                            }

                            localDW->obj_f.SelectTurnDirectionFlag = false;
                            break;
                        }
                    }
                }

                if (guard1) {
                    rtb_Sum1_e_idx_0 = FlightMissionMode_norm_p(distToCenter_tmp);
                    Lon = rtb_Sum1_e_idx_1 / rtb_Sum1_e_idx_0 * Alt +
                        rtb_Switch_l;
                    xyCenter_idx_1 = turnVector_idx_2 / rtb_Sum1_e_idx_0 * Alt +
                        rtb_Abs1_il;
                    *rty_thisTaskStatus = localDW->obj_f.NumCircles;
                }

                u[2] = -Lat;
                Lon = rt_atan2d_snf(xyCenter_idx_1 - rtu_Pose[1], Lon -
                                    rtu_Pose[0]);
            }

            // BusCreator: '<S9>/GuidanceCMDBusCreator' incorporates:
            //   DataTypeConversion: '<S9>/Param3'
            //   Gain: '<S9>/Down2Height'
            //   MATLABSystem: '<S9>/Orbit Follower'

            rty_GuidanceCmds->Height = -u[2];
            rty_GuidanceCmds->AirSpeed = static_cast<real_T>
                (rtu_Parameters->Param4);
            rty_GuidanceCmds->HeadingAngle = Lon;

            // DataTypeConversion: '<S9>/CastToDouble'
            Lon = static_cast<real_T>(*rtu_FormationIDX);

            // Bias: '<S9>/Bias'
            rtb_Bias_mn = *rtu_MissionUAV;

            // Product: '<S9>/Divide' incorporates:
            //   Constant: '<S9>/two_pi'

            Alt = 6.2831853071795862 / static_cast<real_T>(*rtu_MissionUAV);

            // Product: '<S9>/Map2Radian' incorporates:
            //   Bias: '<S9>/Bias'
            //   Gain: '<S9>/HalveMissionUAV'
            //   Sum: '<S9>/Minus'

            Alt *= Lon - static_cast<real_T>(static_cast<int32_T>(rtb_Bias_mn +
                1)) * 0.5;

            // Reshape: '<S9>/Reshape' incorporates:
            //   Constant: '<S9>/InitialFlightPathAngle'
            //   Constant: '<S9>/InitialRollAngle'
            //   Constant: '<S9>/InitialRollAngleRate'
            //   Constant: '<S9>/halfPi'
            //   DataTypeConversion: '<S9>/Param1'
            //   DataTypeConversion: '<S9>/Param2'
            //   DataTypeConversion: '<S9>/Param3'
            //   Product: '<S9>/EastDis'
            //   Product: '<S9>/NorthDis'
            //   Product: '<S9>/Product'
            //   Sum: '<S9>/Sum'
            //   Sum: '<S9>/SumInitEast'
            //   Sum: '<S9>/SumInitNorth'
            //   Trigonometry: '<S9>/Cos'
            //   Trigonometry: '<S9>/Sin'
            //   UnaryMinus: '<S11>/Ze2height'

            rty_InitialState[0] = std::cos(Alt) * static_cast<real_T>
                (rtu_Parameters->Param1) + rtb_Switch_l;
            rty_InitialState[1] = static_cast<real_T>(rtu_Parameters->Param1) *
                std::sin(Alt) + rtb_Abs1_il;
            rty_InitialState[2] = Lat;
            rty_InitialState[3] = static_cast<real_T>(rtu_Parameters->Param4);
            rty_InitialState[4] = static_cast<real_T>(rtu_Parameters->Param2) *
                1.5707963267948966 + Alt;
            rty_InitialState[5] = 0.0;
            rty_InitialState[6] = 0.0;
            rty_InitialState[7] = 0.0;

            // End of Outputs for SubSystem: '<Root>/Mode1_CirclingNav'
        }
        break;

      case 1:
        {
            FILE* a;
            real_T Lat;
            real_T rtb_Abs1_il;
            real_T rtb_Sum1_e_idx_0;
            real_T rtb_Sum1_e_idx_1;
            int32_T i;
            int32_T n;
            int32_T ntoread;
            int32_T nv;
            int32_T stride;
            boolean_T exitg1;
            boolean_T guard1;
            if (static_cast<int32_T>(rtAction) != static_cast<int32_T>
                    (rtPrevAction)) {
                // SystemReset for IfAction SubSystem: '<Root>/Mode2_HorzScanNav' incorporates:
                //   ActionPort: '<S3>/Action Port'

                // SystemReset for SwitchCase: '<Root>/Switch Case' incorporates:
                //   MATLAB Function: '<S37>/ReadHomePoint'
                //   MATLABSystem: '<S36>/Waypoint Follower'

                localDW->HomePoint_not_empty_g = false;
                a = NULL;
                for (i = 0; i < 20; i++) {
                    localDW->eml_openfiles_b[i] = a;
                }

                localDW->obj_k.WaypointIndex = 1.0;
                for (i = 0; i < 24576; i++) {
                    localDW->obj_k.WaypointsInternal[i] *= 0.0;
                }

                // End of SystemReset for SubSystem: '<Root>/Mode2_HorzScanNav'
            }

            // Outputs for IfAction SubSystem: '<Root>/Mode2_HorzScanNav' incorporates:
            //   ActionPort: '<S3>/Action Port'

            // Abs: '<S36>/Abs' incorporates:
            //   DataTypeConversion: '<S36>/Param3'

            Lat = std::abs(static_cast<real_T>(rtu_Parameters->Param3));

            // Saturate: '<S36>/Saturation'
            if (Lat <= 1.0) {
                rtb_Abs1_il = 1.0;
            } else {
                rtb_Abs1_il = Lat;
            }

            // End of Saturate: '<S36>/Saturation'

            // DataTypeConversion: '<S36>/Param1'
            Lat = static_cast<real_T>(rtu_Parameters->Param1);

            // DataTypeConversion: '<S36>/Param2'
            Lon = static_cast<real_T>(rtu_Parameters->Param2);

            // DataTypeConversion: '<S36>/DoubleMissionUAV'
            Alt = static_cast<real_T>(*rtu_MissionUAV);

            // Gain: '<S38>/Gain1'
            rtb_Switch_l = 0.017453292519943295 * rtu_MissionLocation->degHDG;

            // Outputs for Enabled SubSystem: '<S36>/WayPointGenerator' incorporates:
            //   EnablePort: '<S41>/Enable'

            if (*rtu_Reset) {
                localDW->WayPointGenerator_MODE_h = true;

                // MATLAB Function: '<S41>/CompScanWidth' incorporates:
                //   DataTypeConversion: '<S36>/Param2'

                // MATLAB Function 'Mode2_HorzScanNav/Mode2_Variant/Mode2/WayPointGenerator/CompScanWidth': '<S70>:1' 
                // '<S70>:1:3'
                d = std::ceil(static_cast<real_T>(rtu_Parameters->Param2) /
                              (rtb_Abs1_il * Alt));

                // '<S70>:1:4'
                distToCenter = static_cast<real_T>(rtu_Parameters->Param2) / d;

                // MATLAB Function: '<S41>/CheckPointGenerator' incorporates:
                //   MATLAB Function: '<S41>/CompScanWidth'

                // MATLAB Function 'Mode2_HorzScanNav/Mode2_Variant/Mode2/WayPointGenerator/CheckPointGenerator': '<S69>:1' 
                // '<S69>:1:4'
                for (i = 0; i < 32768; i++) {
                    localDW->CheckPoints[i] = (rtNaN);
                }

                nread = static_cast<int32_T>(d);

                // '<S69>:1:5'
                for (iy = 0; iy <= static_cast<int32_T>(nread - 1); iy++) {
                    if (rt_remd_snf(static_cast<real_T>(iy) + 1.0, 2.0) == 1.0)
                    {
                        // '<S69>:1:6'
                        // '<S69>:1:7'
                        i = static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>(iy + 1) << 1) - 2);
                        localDW->CheckPoints[i] = -0.25 * std::abs(Lat) + 0.25 *
                            Lat;
                        localDW->CheckPoints[static_cast<int32_T>(i + 8192)] =
                            (((static_cast<real_T>(iy) + 1.0) - 1.0) *
                             distToCenter - 0.25 * std::abs(Lon)) + 0.25 * Lon;
                        localDW->CheckPoints[static_cast<int32_T>(i + 16384)] =
                            0.0;
                        localDW->CheckPoints[static_cast<int32_T>(i + 24576)] =
                            0.0;

                        // '<S69>:1:10'
                        i = static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>(iy + 1) << 1) - 1);
                        localDW->CheckPoints[i] = 0.75 * std::abs(Lat) + 0.25 *
                            Lat;
                        localDW->CheckPoints[static_cast<int32_T>(i + 8192)] =
                            (((static_cast<real_T>(iy) + 1.0) - 1.0) *
                             distToCenter - 0.25 * std::abs(Lon)) + 0.25 * Lon;
                        localDW->CheckPoints[static_cast<int32_T>(i + 16384)] =
                            0.0;
                        localDW->CheckPoints[static_cast<int32_T>(i + 24576)] =
                            0.0;
                    } else {
                        // '<S69>:1:14'
                        i = static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>(iy + 1) << 1) - 2);
                        localDW->CheckPoints[i] = 0.75 * std::abs(Lat) + 0.25 *
                            Lat;
                        localDW->CheckPoints[static_cast<int32_T>(i + 8192)] =
                            (((static_cast<real_T>(iy) + 1.0) - 1.0) *
                             distToCenter - 0.25 * std::abs(Lon)) + 0.25 * Lon;
                        localDW->CheckPoints[static_cast<int32_T>(i + 16384)] =
                            0.0;
                        localDW->CheckPoints[static_cast<int32_T>(i + 24576)] =
                            3.1415926535897931;

                        // '<S69>:1:17'
                        i = static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>(iy + 1) << 1) - 1);
                        localDW->CheckPoints[i] = -0.25 * std::abs(Lat) + 0.25 *
                            Lat;
                        localDW->CheckPoints[static_cast<int32_T>(i + 8192)] =
                            (((static_cast<real_T>(iy) + 1.0) - 1.0) *
                             distToCenter - 0.25 * std::abs(Lon)) + 0.25 * Lon;
                        localDW->CheckPoints[static_cast<int32_T>(i + 16384)] =
                            0.0;
                        localDW->CheckPoints[static_cast<int32_T>(i + 24576)] =
                            3.1415926535897931;
                    }
                }

                // End of MATLAB Function: '<S41>/CheckPointGenerator'

                // Product: '<S41>/Product' incorporates:
                //   Bias: '<S41>/Bias'
                //   Gain: '<S41>/half'
                //   Sum: '<S41>/Minus'

                Lat = ((Alt - 1.0) - (Alt - 1.0) * 0.5) * rtb_Abs1_il;

                // Product: '<S41>/ProductEast' incorporates:
                //   Bias: '<S41>/Rotate90'
                //   Trigonometry: '<S41>/Sin'

                localDW->ProductEast = std::sin(rtb_Switch_l -
                    1.5707963267948966) * Lat;

                // Product: '<S41>/ProductNorth' incorporates:
                //   Bias: '<S41>/Rotate90'
                //   Trigonometry: '<S41>/Cos'

                localDW->ProductNorth = std::cos(rtb_Switch_l -
                    1.5707963267948966) * Lat;
            } else {
                localDW->WayPointGenerator_MODE_h = false;
            }

            // End of Outputs for SubSystem: '<S36>/WayPointGenerator'

            // MATLAB Function: '<S37>/ReadHomePoint'
            // MATLAB Function 'Mode2_HorzScanNav/Mode2_Variant/Mode2/Location2XeHdg1/ReadHomePoint': '<S43>:1' 
            if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                    (localDW->HomePoint_not_empty_g) ^ 1))) {
                creal_T tmp_1;
                creal_T tmp_2;
                creal_T tmp_3;

                // '<S43>:1:5'
                // '<S43>:1:6'
                tline->size[0] = 1;
                tline->size[1] = 0;
                rtPrevAction = FlightMissionMode_cfopen_c("config.ini", "rb",
                    localDW);
                if (static_cast<int32_T>(rtPrevAction) < 0) {
                    printf("INI-file \"%s\" was not found or could not be read.\n",
                           "config.ini");
                    fflush(stdout);
                } else {
                    FlightMissionMode_fread_hc(static_cast<real_T>(rtPrevAction),
                        q, localDW);
                    stride = static_cast<int32_T>(data->size[0] * data->size[1]);
                    data->size[0] = 1;
                    data->size[1] = q->size[0];
                    FlightMissionMode_emxEnsureCapacity_char_T_g(data, stride);
                    nv = q->size[0];
                    for (i = 0; i <= static_cast<int32_T>(nv - 1); i++) {
                        data->data[i] = q->data[i];
                    }

                    FlightMissionMode_cfclose_h5(static_cast<real_T>
                        (rtPrevAction), localDW);
                    curSection->size[0] = 1;
                    curSection->size[1] = 0;
                    curKey->size[0] = 1;
                    curKey->size[1] = 0;
                    curVal->size[0] = 1;
                    curVal->size[1] = 0;
                    FlightMissionMode_emxInit_char_T_ey(&tmp_b, 2);
                    FlightMissionMode_emxInit_char_T_ey(&data_5, 2);
                    exitg1 = false;
                    while ((!exitg1) && (data->size[1] != 0)) {
                        stride = static_cast<int32_T>(data_5->size[0] *
                            data_5->size[1]);
                        data_5->size[0] = 1;
                        data_5->size[1] = data->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_g(data_5,
                            stride);
                        i = static_cast<int32_T>(static_cast<int32_T>(data->
                            size[0] * data->size[1]) - 1);
                        for (stride = 0; stride <= i; stride++) {
                            data_5->data[stride] = data->data[stride];
                        }

                        FlightMissionMode_strtok_d(data_5, curLine, data);
                        FlightMissionMode_strtok_dq(curLine, tmp_b);
                        FlightMissionMode_strtrim_f(tmp_b, curLine);
                        if (curLine->size[1] >= 2) {
                            isStable = false;
                            if (curLine->data[0] == '[') {
                                isStable = true;
                            }

                            guard1 = false;
                            if (isStable) {
                                isStable = false;
                                if (curLine->data[static_cast<int32_T>
                                        (curLine->size[1] - 1)] == ']') {
                                    isStable = true;
                                }

                                if (isStable) {
                                    if (static_cast<int32_T>(curLine->size[1] -
                                            1) < 2) {
                                        iy = 0;
                                        nread = 0;
                                    } else {
                                        iy = 1;
                                        nread = static_cast<int32_T>
                                            (curLine->size[1] - 1);
                                    }

                                    stride = static_cast<int32_T>
                                        (curSection->size[0] * curSection->size
                                         [1]);
                                    curSection->size[0] = 1;
                                    nv = static_cast<int32_T>(nread - iy);
                                    curSection->size[1] = nv;
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (curSection, stride);
                                    for (i = 0; i <= static_cast<int32_T>(nv - 1);
                                         i++) {
                                        curSection->data[i] = curLine->data[
                                            static_cast<int32_T>(iy + i)];
                                    }

                                    curKey->size[0] = 1;
                                    curKey->size[1] = 0;
                                } else {
                                    guard1 = true;
                                }
                            } else {
                                guard1 = true;
                            }

                            if (guard1) {
                                if (curLine->data[0] == ';') {
                                    isStable = true;
                                }

                                if ((static_cast<boolean_T>(static_cast<int32_T>
                                                            (static_cast<int32_T>
                                        (isStable) ^ 1))) &&
                                        FlightMissionMode_contains_d(curLine)) {
                                    FlightMissionMode_strtok_dq4(curLine, curVal,
                                        x);
                                    FlightMissionMode_find_token_m(x, &i1,
                                        &nread);
                                    if (i1 > static_cast<int32_T>(nread - 1)) {
                                        iy = 0;
                                        i1 = 0;
                                    } else {
                                        iy = static_cast<int32_T>(i1 - 1);
                                        i1 = static_cast<int32_T>(nread - 1);
                                    }

                                    FlightMissionMode_strtrim_f(curVal, curKey);
                                    stride = static_cast<int32_T>(curLine->size
                                        [0] * curLine->size[1]);
                                    curLine->size[0] = 1;
                                    nv = static_cast<int32_T>(i1 - iy);
                                    curLine->size[1] = nv;
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (curLine, stride);
                                    for (i = 0; i <= static_cast<int32_T>(nv - 1);
                                         i++) {
                                        curLine->data[i] = x->data
                                            [static_cast<int32_T>(iy + i)];
                                    }

                                    FlightMissionMode_strtrim_f(curLine, curVal);
                                }
                            }
                        }

                        if (FlightMissionMode_strcmp_b(curSection) &&
                                FlightMissionMode_strcmp_bx(curKey)) {
                            stride = static_cast<int32_T>(tline->size[0] *
                                tline->size[1]);
                            tline->size[0] = 1;
                            tline->size[1] = curVal->size[1];
                            FlightMissionMode_emxEnsureCapacity_char_T_g(tline,
                                stride);
                            nv = curVal->size[1];
                            for (i = 0; i <= static_cast<int32_T>(nv - 1); i++)
                            {
                                tline->data[i] = curVal->data[i];
                            }

                            exitg1 = true;
                        }
                    }

                    FlightMissionMode_emxFree_char_T_o(&data_5);
                    FlightMissionMode_emxFree_char_T_o(&tmp_b);
                }

                tmp_1 = FlightMissionMode_str2double_k(tline);
                printf("Set Home Point Latitude:\t%f\n", tmp_1.re);
                fflush(stdout);
                tline->size[0] = 1;
                tline->size[1] = 0;
                rtPrevAction = FlightMissionMode_cfopen_c("config.ini", "rb",
                    localDW);
                if (static_cast<int32_T>(rtPrevAction) < 0) {
                    printf("INI-file \"%s\" was not found or could not be read.\n",
                           "config.ini");
                    fflush(stdout);
                } else {
                    FlightMissionMode_fread_hc(static_cast<real_T>(rtPrevAction),
                        q, localDW);
                    stride = static_cast<int32_T>(data->size[0] * data->size[1]);
                    data->size[0] = 1;
                    data->size[1] = q->size[0];
                    FlightMissionMode_emxEnsureCapacity_char_T_g(data, stride);
                    nv = q->size[0];
                    for (i = 0; i <= static_cast<int32_T>(nv - 1); i++) {
                        data->data[i] = q->data[i];
                    }

                    FlightMissionMode_cfclose_h5(static_cast<real_T>
                        (rtPrevAction), localDW);
                    curSection->size[0] = 1;
                    curSection->size[1] = 0;
                    curKey->size[0] = 1;
                    curKey->size[1] = 0;
                    curVal->size[0] = 1;
                    curVal->size[1] = 0;
                    FlightMissionMode_emxInit_char_T_ey(&tmp_a, 2);
                    FlightMissionMode_emxInit_char_T_ey(&data_4, 2);
                    exitg1 = false;
                    while ((!exitg1) && (data->size[1] != 0)) {
                        stride = static_cast<int32_T>(data_4->size[0] *
                            data_4->size[1]);
                        data_4->size[0] = 1;
                        data_4->size[1] = data->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_g(data_4,
                            stride);
                        i = static_cast<int32_T>(static_cast<int32_T>(data->
                            size[0] * data->size[1]) - 1);
                        for (stride = 0; stride <= i; stride++) {
                            data_4->data[stride] = data->data[stride];
                        }

                        FlightMissionMode_strtok_d(data_4, curLine, data);
                        FlightMissionMode_strtok_dq(curLine, tmp_a);
                        FlightMissionMode_strtrim_f(tmp_a, curLine);
                        if (curLine->size[1] >= 2) {
                            isStable = false;
                            if (curLine->data[0] == '[') {
                                isStable = true;
                            }

                            guard1 = false;
                            if (isStable) {
                                isStable = false;
                                if (curLine->data[static_cast<int32_T>
                                        (curLine->size[1] - 1)] == ']') {
                                    isStable = true;
                                }

                                if (isStable) {
                                    if (static_cast<int32_T>(curLine->size[1] -
                                            1) < 2) {
                                        i1 = 0;
                                        ntoread = 0;
                                    } else {
                                        i1 = 1;
                                        ntoread = static_cast<int32_T>
                                            (curLine->size[1] - 1);
                                    }

                                    stride = static_cast<int32_T>
                                        (curSection->size[0] * curSection->size
                                         [1]);
                                    curSection->size[0] = 1;
                                    nv = static_cast<int32_T>(ntoread - i1);
                                    curSection->size[1] = nv;
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (curSection, stride);
                                    for (i = 0; i <= static_cast<int32_T>(nv - 1);
                                         i++) {
                                        curSection->data[i] = curLine->data[
                                            static_cast<int32_T>(i1 + i)];
                                    }

                                    curKey->size[0] = 1;
                                    curKey->size[1] = 0;
                                } else {
                                    guard1 = true;
                                }
                            } else {
                                guard1 = true;
                            }

                            if (guard1) {
                                if (curLine->data[0] == ';') {
                                    isStable = true;
                                }

                                if ((static_cast<boolean_T>(static_cast<int32_T>
                                                            (static_cast<int32_T>
                                        (isStable) ^ 1))) &&
                                        FlightMissionMode_contains_d(curLine)) {
                                    FlightMissionMode_strtok_dq4(curLine, curVal,
                                        x);
                                    FlightMissionMode_find_token_m(x, &iy,
                                        &nread);
                                    if (iy > static_cast<int32_T>(nread - 1)) {
                                        iy = 0;
                                        nread = 0;
                                    } else {
                                        iy = static_cast<int32_T>(iy - 1);
                                        nread = static_cast<int32_T>(nread - 1);
                                    }

                                    FlightMissionMode_strtrim_f(curVal, curKey);
                                    stride = static_cast<int32_T>(curLine->size
                                        [0] * curLine->size[1]);
                                    curLine->size[0] = 1;
                                    nv = static_cast<int32_T>(nread - iy);
                                    curLine->size[1] = nv;
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (curLine, stride);
                                    for (i = 0; i <= static_cast<int32_T>(nv - 1);
                                         i++) {
                                        curLine->data[i] = x->data
                                            [static_cast<int32_T>(iy + i)];
                                    }

                                    FlightMissionMode_strtrim_f(curLine, curVal);
                                }
                            }
                        }

                        if (FlightMissionMode_strcmp_b(curSection) &&
                                FlightMissionMode_strcmp_bxk(curKey)) {
                            stride = static_cast<int32_T>(tline->size[0] *
                                tline->size[1]);
                            tline->size[0] = 1;
                            tline->size[1] = curVal->size[1];
                            FlightMissionMode_emxEnsureCapacity_char_T_g(tline,
                                stride);
                            nv = curVal->size[1];
                            for (i = 0; i <= static_cast<int32_T>(nv - 1); i++)
                            {
                                tline->data[i] = curVal->data[i];
                            }

                            exitg1 = true;
                        }
                    }

                    FlightMissionMode_emxFree_char_T_o(&data_4);
                    FlightMissionMode_emxFree_char_T_o(&tmp_a);
                }

                tmp_2 = FlightMissionMode_str2double_k(tline);
                printf("Set Home Point Longitude:\t%f\n", tmp_2.re);
                fflush(stdout);
                tline->size[0] = 1;
                tline->size[1] = 0;
                rtPrevAction = FlightMissionMode_cfopen_c("config.ini", "rb",
                    localDW);
                if (static_cast<int32_T>(rtPrevAction) < 0) {
                    printf("INI-file \"%s\" was not found or could not be read.\n",
                           "config.ini");
                    fflush(stdout);
                } else {
                    FlightMissionMode_fread_hc(static_cast<real_T>(rtPrevAction),
                        q, localDW);
                    stride = static_cast<int32_T>(data->size[0] * data->size[1]);
                    data->size[0] = 1;
                    data->size[1] = q->size[0];
                    FlightMissionMode_emxEnsureCapacity_char_T_g(data, stride);
                    nv = q->size[0];
                    for (i = 0; i <= static_cast<int32_T>(nv - 1); i++) {
                        data->data[i] = q->data[i];
                    }

                    FlightMissionMode_cfclose_h5(static_cast<real_T>
                        (rtPrevAction), localDW);
                    curSection->size[0] = 1;
                    curSection->size[1] = 0;
                    curKey->size[0] = 1;
                    curKey->size[1] = 0;
                    curVal->size[0] = 1;
                    curVal->size[1] = 0;
                    FlightMissionMode_emxInit_char_T_ey(&tmp_9, 2);
                    FlightMissionMode_emxInit_char_T_ey(&data_3, 2);
                    exitg1 = false;
                    while ((!exitg1) && (data->size[1] != 0)) {
                        stride = static_cast<int32_T>(data_3->size[0] *
                            data_3->size[1]);
                        data_3->size[0] = 1;
                        data_3->size[1] = data->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_g(data_3,
                            stride);
                        i = static_cast<int32_T>(static_cast<int32_T>(data->
                            size[0] * data->size[1]) - 1);
                        for (stride = 0; stride <= i; stride++) {
                            data_3->data[stride] = data->data[stride];
                        }

                        FlightMissionMode_strtok_d(data_3, curLine, data);
                        FlightMissionMode_strtok_dq(curLine, tmp_9);
                        FlightMissionMode_strtrim_f(tmp_9, curLine);
                        if (curLine->size[1] >= 2) {
                            isStable = false;
                            if (curLine->data[0] == '[') {
                                isStable = true;
                            }

                            guard1 = false;
                            if (isStable) {
                                isStable = false;
                                if (curLine->data[static_cast<int32_T>
                                        (curLine->size[1] - 1)] == ']') {
                                    isStable = true;
                                }

                                if (isStable) {
                                    if (static_cast<int32_T>(curLine->size[1] -
                                            1) < 2) {
                                        iy = 0;
                                        i2 = 0;
                                    } else {
                                        iy = 1;
                                        i2 = static_cast<int32_T>(curLine->size
                                            [1] - 1);
                                    }

                                    stride = static_cast<int32_T>
                                        (curSection->size[0] * curSection->size
                                         [1]);
                                    curSection->size[0] = 1;
                                    nv = static_cast<int32_T>(i2 - iy);
                                    curSection->size[1] = nv;
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (curSection, stride);
                                    for (i = 0; i <= static_cast<int32_T>(nv - 1);
                                         i++) {
                                        curSection->data[i] = curLine->data[
                                            static_cast<int32_T>(iy + i)];
                                    }

                                    curKey->size[0] = 1;
                                    curKey->size[1] = 0;
                                } else {
                                    guard1 = true;
                                }
                            } else {
                                guard1 = true;
                            }

                            if (guard1) {
                                if (curLine->data[0] == ';') {
                                    isStable = true;
                                }

                                if ((static_cast<boolean_T>(static_cast<int32_T>
                                                            (static_cast<int32_T>
                                        (isStable) ^ 1))) &&
                                        FlightMissionMode_contains_d(curLine)) {
                                    FlightMissionMode_strtok_dq4(curLine, curVal,
                                        x);
                                    FlightMissionMode_find_token_m(x, &iy,
                                        &nread);
                                    if (iy > static_cast<int32_T>(nread - 1)) {
                                        n = 0;
                                        i = 0;
                                    } else {
                                        n = static_cast<int32_T>(iy - 1);
                                        i = static_cast<int32_T>(nread - 1);
                                    }

                                    FlightMissionMode_strtrim_f(curVal, curKey);
                                    stride = static_cast<int32_T>(curLine->size
                                        [0] * curLine->size[1]);
                                    curLine->size[0] = 1;
                                    nv = static_cast<int32_T>(i - n);
                                    curLine->size[1] = nv;
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (curLine, stride);
                                    for (i = 0; i <= static_cast<int32_T>(nv - 1);
                                         i++) {
                                        curLine->data[i] = x->data
                                            [static_cast<int32_T>(n + i)];
                                    }

                                    FlightMissionMode_strtrim_f(curLine, curVal);
                                }
                            }
                        }

                        if (FlightMissionMode_strcmp_b(curSection) &&
                                FlightMissionMode_strcmp_bxki(curKey)) {
                            stride = static_cast<int32_T>(tline->size[0] *
                                tline->size[1]);
                            tline->size[0] = 1;
                            tline->size[1] = curVal->size[1];
                            FlightMissionMode_emxEnsureCapacity_char_T_g(tline,
                                stride);
                            nv = curVal->size[1];
                            for (i = 0; i <= static_cast<int32_T>(nv - 1); i++)
                            {
                                tline->data[i] = curVal->data[i];
                            }

                            exitg1 = true;
                        }
                    }

                    FlightMissionMode_emxFree_char_T_o(&data_3);
                    FlightMissionMode_emxFree_char_T_o(&tmp_9);
                }

                tmp_3 = FlightMissionMode_str2double_k(tline);
                printf("Set Home Point Altitude:\t%f\n", tmp_3.re);
                fflush(stdout);
                localDW->HomePoint_m[0] = tmp_1.re;
                localDW->HomePoint_m[1] = tmp_2.re;
                localDW->HomePoint_m[2] = tmp_3.re;
                localDW->HomePoint_not_empty_g = true;
                b_x[0] = std::isnan(localDW->HomePoint_m[0]);
                b_x[1] = std::isnan(localDW->HomePoint_m[1]);
                b_x[2] = std::isnan(localDW->HomePoint_m[2]);
                isStable = false;
                nread = 0;
                exitg1 = false;
                while ((!exitg1) && (nread < 3)) {
                    if (b_x[nread]) {
                        isStable = true;
                        exitg1 = true;
                    } else {
                        nread = static_cast<int32_T>(nread + 1);
                    }
                }

                if (isStable) {
                    // '<S43>:1:7'
                    // '<S43>:1:8'
                    localDW->HomePoint_m[0] = 35.8617;
                    localDW->HomePoint_m[1] = 104.1954;
                    localDW->HomePoint_m[2] = 0.0;
                }
            }

            // Sum: '<S42>/Sum' incorporates:
            //   MATLAB Function: '<S37>/ReadHomePoint'

            // '<S43>:1:12'
            Lon = rtu_MissionLocation->Alt - localDW->HomePoint_m[2];

            // DataTypeConversion: '<S36>/CastToDouble'
            Lat = static_cast<real_T>(*rtu_FormationIDX);

            // Sum: '<S36>/Minus' incorporates:
            //   Constant: '<S36>/One2ZeroIdx'

            Alt = Lat - 1.0;

            // Product: '<S36>/Map2Radian' incorporates:
            //   Constant: '<S36>/One2ZeroIdx'
            //   Sum: '<S36>/Minus'

            d = (Lat - 1.0) * rtb_Abs1_il;

            // Switch: '<S57>/Switch' incorporates:
            //   Abs: '<S57>/Abs'
            //   Bias: '<S57>/Bias'
            //   Bias: '<S57>/Bias1'
            //   Constant: '<S57>/Constant2'
            //   Constant: '<S58>/Constant'
            //   MATLAB Function: '<S37>/ReadHomePoint'
            //   Math: '<S57>/Math Function1'
            //   RelationalOperator: '<S58>/Compare'

            if (std::abs(localDW->HomePoint_m[0]) > 180.0) {
                distToCenter = rt_modd_snf(localDW->HomePoint_m[0] + 180.0,
                    360.0) - 180.0;
            } else {
                distToCenter = localDW->HomePoint_m[0];
            }

            // End of Switch: '<S57>/Switch'

            // Abs: '<S54>/Abs1'
            rtb_Abs1_il = std::abs(distToCenter);

            // Switch: '<S54>/Switch' incorporates:
            //   Bias: '<S54>/Bias'
            //   Bias: '<S54>/Bias1'
            //   Constant: '<S45>/Constant'
            //   Constant: '<S45>/Constant1'
            //   Constant: '<S56>/Constant'
            //   Gain: '<S54>/Gain'
            //   Product: '<S54>/Divide1'
            //   RelationalOperator: '<S56>/Compare'
            //   Signum: '<S54>/Sign1'
            //   Switch: '<S45>/Switch1'

            if (rtb_Abs1_il > 90.0) {
                // Signum: '<S54>/Sign1'
                if (std::isnan(distToCenter)) {
                    rtb_Sum1_e_idx_0 = (rtNaN);
                } else if (distToCenter < 0.0) {
                    rtb_Sum1_e_idx_0 = -1.0;
                } else {
                    rtb_Sum1_e_idx_0 = static_cast<real_T>(distToCenter > 0.0);
                }

                distToCenter = (-(rtb_Abs1_il - 90.0) + 90.0) * rtb_Sum1_e_idx_0;
                i = 180;
            } else {
                i = 0;
            }

            // End of Switch: '<S54>/Switch'

            // Sum: '<S45>/Sum' incorporates:
            //   MATLAB Function: '<S37>/ReadHomePoint'
            //   Switch: '<S45>/Switch1'

            Lat = static_cast<real_T>(i) + localDW->HomePoint_m[1];

            // Switch: '<S55>/Switch' incorporates:
            //   Abs: '<S55>/Abs'
            //   Bias: '<S55>/Bias'
            //   Bias: '<S55>/Bias1'
            //   Constant: '<S55>/Constant2'
            //   Constant: '<S59>/Constant'
            //   Math: '<S55>/Math Function1'
            //   RelationalOperator: '<S59>/Compare'

            if (std::abs(Lat) > 180.0) {
                Lat = rt_modd_snf(Lat + 180.0, 360.0) - 180.0;
            }

            // End of Switch: '<S55>/Switch'

            // Sum: '<S42>/Sum1'
            rtb_Sum1_e_idx_0 = rtu_MissionLocation->Lat - distToCenter;
            rtb_Sum1_e_idx_1 = rtu_MissionLocation->Lon - Lat;

            // Switch: '<S51>/Switch' incorporates:
            //   Abs: '<S51>/Abs'
            //   Bias: '<S51>/Bias'
            //   Bias: '<S51>/Bias1'
            //   Constant: '<S51>/Constant2'
            //   Constant: '<S52>/Constant'
            //   Math: '<S51>/Math Function1'
            //   RelationalOperator: '<S52>/Compare'

            if (std::abs(rtb_Sum1_e_idx_0) > 180.0) {
                Lat = rt_modd_snf(rtb_Sum1_e_idx_0 + 180.0, 360.0) - 180.0;
            } else {
                Lat = rtb_Sum1_e_idx_0;
            }

            // End of Switch: '<S51>/Switch'

            // Abs: '<S48>/Abs1'
            rtb_Abs1_il = std::abs(Lat);

            // Switch: '<S48>/Switch' incorporates:
            //   Bias: '<S48>/Bias'
            //   Bias: '<S48>/Bias1'
            //   Constant: '<S44>/Constant'
            //   Constant: '<S44>/Constant1'
            //   Constant: '<S50>/Constant'
            //   Gain: '<S48>/Gain'
            //   Product: '<S48>/Divide1'
            //   RelationalOperator: '<S50>/Compare'
            //   Signum: '<S48>/Sign1'
            //   Switch: '<S44>/Switch1'

            if (rtb_Abs1_il > 90.0) {
                // Signum: '<S48>/Sign1'
                if (std::isnan(Lat)) {
                    rtb_Sum1_e_idx_0 = (rtNaN);
                } else if (Lat < 0.0) {
                    rtb_Sum1_e_idx_0 = -1.0;
                } else {
                    rtb_Sum1_e_idx_0 = static_cast<real_T>(Lat > 0.0);
                }

                Lat = (-(rtb_Abs1_il - 90.0) + 90.0) * rtb_Sum1_e_idx_0;
                i = 180;
            } else {
                i = 0;
            }

            // End of Switch: '<S48>/Switch'

            // Sum: '<S44>/Sum' incorporates:
            //   Switch: '<S44>/Switch1'

            rtb_Abs1_il = static_cast<real_T>(i) + rtb_Sum1_e_idx_1;

            // Switch: '<S49>/Switch' incorporates:
            //   Abs: '<S49>/Abs'
            //   Bias: '<S49>/Bias'
            //   Bias: '<S49>/Bias1'
            //   Constant: '<S49>/Constant2'
            //   Constant: '<S53>/Constant'
            //   Math: '<S49>/Math Function1'
            //   RelationalOperator: '<S53>/Compare'

            if (std::abs(rtb_Abs1_il) > 180.0) {
                rtb_Abs1_il = rt_modd_snf(rtb_Abs1_il + 180.0, 360.0) - 180.0;
            }

            // End of Switch: '<S49>/Switch'

            // UnitConversion: '<S47>/Unit Conversion'
            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            rtb_Sum1_e_idx_0 = 0.017453292519943295 * Lat;
            rtb_Sum1_e_idx_1 = 0.017453292519943295 * rtb_Abs1_il;

            // UnitConversion: '<S62>/Unit Conversion'
            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            distToCenter *= 0.017453292519943295;

            // Trigonometry: '<S63>/Trigonometric Function1'
            rtb_Abs1_il = std::sin(distToCenter);

            // Sum: '<S63>/Sum1' incorporates:
            //   Constant: '<S63>/Constant'
            //   Product: '<S63>/Product1'

            rtb_Abs1_il = 1.0 - 0.0066943799901413295 * rtb_Abs1_il *
                rtb_Abs1_il;

            // Product: '<S61>/Product1' incorporates:
            //   Constant: '<S61>/Constant1'
            //   Sqrt: '<S61>/sqrt'

            Lat = 6.378137E+6 / std::sqrt(rtb_Abs1_il);

            // Product: '<S46>/dNorth' incorporates:
            //   Constant: '<S61>/Constant2'
            //   Product: '<S61>/Product3'
            //   Trigonometry: '<S61>/Trigonometric Function1'

            rtb_Abs1_il = rtb_Sum1_e_idx_0 / rt_atan2d_snf(1.0, Lat *
                0.99330562000985867 / rtb_Abs1_il);

            // Product: '<S46>/dEast' incorporates:
            //   Constant: '<S61>/Constant3'
            //   Product: '<S61>/Product4'
            //   Trigonometry: '<S61>/Trigonometric Function'
            //   Trigonometry: '<S61>/Trigonometric Function2'

            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            distToCenter = 1.0 / rt_atan2d_snf(1.0, Lat * std::cos(distToCenter))
                * rtb_Sum1_e_idx_1;

            // Signum: '<S36>/Sign' incorporates:
            //   DataTypeConversion: '<S36>/Param3'

            if (std::isnan(static_cast<real_T>(rtu_Parameters->Param3))) {
                // Gain: '<S36>/negate'
                Lat = (rtNaN);
                rtb_Sum1_e_idx_0 = (rtNaN);
            } else if (rtu_Parameters->Param3 < 0.0F) {
                // Gain: '<S36>/negate'
                Lat = 1.0;
                rtb_Sum1_e_idx_0 = -1.0;
            } else {
                // Gain: '<S36>/negate'
                Lat = -static_cast<real_T>(rtu_Parameters->Param3 > 0.0F);
                rtb_Sum1_e_idx_0 = static_cast<real_T>(rtu_Parameters->Param3 >
                    0.0F);
            }

            // Saturate: '<S36>/NonNegative' incorporates:
            //   Gain: '<S36>/negate'
            //   Signum: '<S36>/Sign'

            if (-rtb_Sum1_e_idx_0 <= 0.0) {
                Lat = 0.0;
            }

            // End of Saturate: '<S36>/NonNegative'

            // Sum: '<S36>/SumNorth' incorporates:
            //   Product: '<S36>/ProductNorth'

            rtb_Sum1_e_idx_0 = localDW->ProductNorth * Lat +
                rtu_StartLocation->Lat;

            // Sum: '<S36>/SumEast' incorporates:
            //   Product: '<S36>/ProductEast'

            rtb_Sum1_e_idx_1 = localDW->ProductEast * Lat +
                rtu_StartLocation->Lon;

            // Product: '<S36>/Product'
            LLA0_gw[0] = rtb_Sum1_e_idx_0 * Lat;
            LLA0_gw[1] = rtb_Sum1_e_idx_1 * Lat;
            LLA0_gw[2] = rtu_StartLocation->Alt * Lat;

            // Switch: '<S36>/Switch'
            if (Lat != 0.0) {
                // Gain: '<S39>/Gain1'
                Lat = 0.017453292519943295 * rtu_StartLocation->degHDG;
            } else {
                Lat = rtb_Switch_l;
            }

            // End of Switch: '<S36>/Switch'

            // Outputs for Enabled SubSystem: '<S36>/WayPoint' incorporates:
            //   EnablePort: '<S40>/Enable'

            if (*rtu_Reset) {
                int32_T npages;
                int32_T pageroot;
                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>
                                            (localDW->WayPoint_MODE) ^ 1))) {
                    // SystemReset for MATLAB Function: '<S40>/CheckPointInterp' 
                    localDW->SingletonInstance_not_empty = false;
                    a = NULL;
                    for (i = 0; i < 20; i++) {
                        localDW->eml_openfiles_k[i] = a;
                    }

                    // End of SystemReset for MATLAB Function: '<S40>/CheckPointInterp' 
                    localDW->WayPoint_MODE = true;
                }

                // SignalConversion generated from: '<S40>/RotateATMissionHdg' incorporates:
                //   Constant: '<S40>/Zero'

                rtb_TmpSignalConversionAtRotateATMissionHdgInport1_i[0] =
                    rtb_Switch_l;
                rtb_TmpSignalConversionAtRotateATMissionHdgInport1_i[1] = 0.0;
                rtb_TmpSignalConversionAtRotateATMissionHdgInport1_i[2] = 0.0;
                FlightMissionMode_RotateATMissionHdg
                    (rtb_TmpSignalConversionAtRotateATMissionHdgInport1_i,
                     &localDW->RotateATMissionHdg);

                // Reshape: '<S40>/Reshape' incorporates:
                //   Sum: '<S40>/Minus'

                Reshape[3] = Lat - rtb_Switch_l;

                // Product: '<S40>/Matrix Multiply' incorporates:
                //   MATLABSystem: '<S40>/RotateATMissionHdg'
                //   Product: '<S36>/Product'

                i = 0;
                for (i1 = 0; i1 < 3; i1++) {
                    u[i1] = 0.0;
                    u[i1] += localDW->RotateATMissionHdg.RotateATMissionHdg[i] *
                        LLA0_gw[0];
                    u[i1] += localDW->RotateATMissionHdg.RotateATMissionHdg[
                        static_cast<int32_T>(i + 1)] * LLA0_gw[1];
                    u[i1] += localDW->RotateATMissionHdg.RotateATMissionHdg[
                        static_cast<int32_T>(i + 2)] * LLA0_gw[2];
                    i = static_cast<int32_T>(i + 3);
                }

                // Reshape: '<S40>/Reshape' incorporates:
                //   Product: '<S40>/Matrix Multiply'

                Reshape[0] = u[0];
                Reshape[1] = u[1];
                Reshape[2] = u[2];

                // MATLAB Function: '<S40>/CheckPointInterp'
                // MATLAB Function 'Mode2_HorzScanNav/Mode2_Variant/Mode2/WayPoint/CheckPointInterp': '<S66>:1' 
                // '<S66>:1:5'
                // '<S66>:1:4'
                dummyWayPoint->size[0] = 0;
                dummyWayPoint->size[1] = 3;

                // '<S66>:1:5'
                for (i = 0; i < 32768; i++) {
                    localDW->x[i] = std::isnan(localDW->CheckPoints[i]);
                }

                i1 = 0;
                i2 = 24576;
                for (nread = 0; nread < 8192; nread++) {
                    localDW->distinctWptsIdx[nread] = false;
                    i1 = static_cast<int32_T>(i1 + 1);
                    i2 = static_cast<int32_T>(i2 + 1);
                    ntoread = i1;
                    exitg1 = false;
                    while ((!exitg1) && (ntoread <= i2)) {
                        if (localDW->x[static_cast<int32_T>(ntoread - 1)]) {
                            localDW->distinctWptsIdx[nread] = true;
                            exitg1 = true;
                        } else {
                            ntoread = static_cast<int32_T>(ntoread + 8192);
                        }
                    }
                }

                i2 = 0;
                for (nread = 0; nread < 8192; nread++) {
                    isStable = static_cast<boolean_T>(static_cast<int32_T>(
                        static_cast<int32_T>(localDW->distinctWptsIdx[nread]) ^
                        1));
                    if (isStable) {
                        i2 = static_cast<int32_T>(i2 + 1);
                    }

                    localDW->distinctWptsIdx[nread] = isStable;
                }

                n = i2;
                iy = 0;
                for (nread = 0; nread < 8192; nread++) {
                    if (localDW->distinctWptsIdx[nread]) {
                        localDW->d_data[iy] = static_cast<int16_T>
                            (static_cast<int32_T>(nread + 1));
                        iy = static_cast<int32_T>(iy + 1);
                    }
                }

                // '<S66>:1:5'
                FlightMissionMode_emxInit_real_T_h(&CheckPoints, 2);
                stride = static_cast<int32_T>(CheckPoints->size[0] *
                    CheckPoints->size[1]);

                // MATLAB Function: '<S40>/CheckPointInterp'
                CheckPoints->size[0] = i2;
                CheckPoints->size[1] = 4;
                FlightMissionMode_emxEnsureCapacity_real_T_c(CheckPoints, stride);

                // MATLAB Function: '<S40>/CheckPointInterp'
                for (i = 0; i < 4; i++) {
                    for (i1 = 0; i1 <= static_cast<int32_T>(i2 - 1); i1++) {
                        CheckPoints->data[static_cast<int32_T>(i1 + static_cast<
                            int32_T>(CheckPoints->size[0] * i))] =
                            localDW->CheckPoints[static_cast<int32_T>(
                            static_cast<int32_T>(static_cast<int32_T>(i << 13) +
                            static_cast<int32_T>(localDW->d_data[i1])) - 1)];
                    }
                }

                // '<S66>:1:8'
                FlightMissionMode_emxInit_real_T_h(&pathLength, 1);
                stride = pathLength->size[0];

                // MATLAB Function: '<S40>/CheckPointInterp'
                pathLength->size[0] = i2;
                FlightMissionMode_emxEnsureCapacity_real_T_c(pathLength, stride);

                // MATLAB Function: '<S40>/CheckPointInterp' incorporates:
                //   Reshape: '<S40>/Reshape'

                for (i = 0; i <= static_cast<int32_T>(i2 - 1); i++) {
                    pathLength->data[i] = 0.0;
                }

                // '<S66>:1:9'
                for (iy = 0; iy <= static_cast<int32_T>(i2 - 1); iy++) {
                    // '<S66>:1:10'
                    obj = FlightMissionMode_DubinsObjSingleton_getConnector_p
                        (localDW);
                    CheckPoints_0[0] = CheckPoints->data[iy];
                    CheckPoints_0[1] = CheckPoints->data[static_cast<int32_T>(iy
                        + CheckPoints->size[0])];
                    CheckPoints_0[2] = CheckPoints->data[static_cast<int32_T>(
                        static_cast<int32_T>(CheckPoints->size[0] << 1) + iy)];
                    CheckPoints_0[3] = CheckPoints->data[static_cast<int32_T>(
                        static_cast<int32_T>(CheckPoints->size[0] * 3) + iy)];
                    FlightMissionMode_uavDubinsBuiltins_connect_g(obj, Reshape,
                        CheckPoints_0, obj->MinTurningRadius, &a__1_0,
                        &pathLength->data[iy]);

                    // '<S66>:1:10'
                }

                // '<S66>:1:13'
                i1 = pathLength->size[0];
                if (static_cast<int32_T>(static_cast<int32_T>
                                         (static_cast<uint16_T>
                                          (static_cast<int32_T>(pathLength->
                        size[0] - 1))) + 1) <= 2) {
                    if (static_cast<int32_T>(static_cast<int32_T>
                                             (static_cast<uint16_T>(static_cast<
                            int32_T>(pathLength->size[0] - 1))) + 1) == 1) {
                        iy = 1;
                    } else if (pathLength->data[0] > pathLength->data[
                               static_cast<int32_T>(pathLength->size[0] - 1)]) {
                        iy = pathLength->size[0];
                    } else if (std::isnan(pathLength->data[0])) {
                        if (static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(std::isnan(pathLength->
                                data[static_cast<int32_T>(pathLength->size[0] -
                                 1)])) ^ 1))) {
                            iy = pathLength->size[0];
                        } else {
                            iy = 1;
                        }
                    } else {
                        iy = 1;
                    }
                } else {
                    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<
                            int32_T>(std::isnan(pathLength->data[0])) ^ 1))) {
                        i2 = 1;
                    } else {
                        i2 = 0;
                        iy = 2;
                        exitg1 = false;
                        while ((!exitg1) && (iy <= i1)) {
                            if (static_cast<boolean_T>(static_cast<int32_T>(
                                    static_cast<int32_T>(std::isnan
                                    (pathLength->data[static_cast<int32_T>(iy -
                                     1)])) ^ 1))) {
                                i2 = iy;
                                exitg1 = true;
                            } else {
                                iy = static_cast<int32_T>(iy + 1);
                            }
                        }
                    }

                    if (i2 == 0) {
                        iy = 1;
                    } else {
                        rtb_Switch_l = pathLength->data[static_cast<int32_T>(i2
                            - 1)];
                        iy = i2;
                        for (nread = static_cast<int32_T>(i2 + 1); nread <= i1;
                                nread++) {
                            rtb_Sum1_e_idx_0 = pathLength->data
                                [static_cast<int32_T>(nread - 1)];
                            if (rtb_Switch_l > rtb_Sum1_e_idx_0) {
                                rtb_Switch_l = rtb_Sum1_e_idx_0;
                                iy = nread;
                            }
                        }
                    }
                }

                FlightMissionMode_emxFree_real_T_n(&pathLength);

                // MATLAB Function: '<S40>/CheckPointInterp'
                // '<S66>:1:13'
                i2 = (n == 1);
                if (n != 0) {
                    if (static_cast<int32_T>(1 - iy) < 0) {
                        ntoread = static_cast<int32_T>(iy - 1);
                        isStable = false;
                    } else {
                        ntoread = 0;
                        isStable = true;
                    }

                    d_0[0] = static_cast<int16_T>(n);
                    d_0[1] = 4;
                    if (static_cast<int32_T>(d_0[i2]) <= 1) {
                        ntoread = 0;
                    } else {
                        d_0[0] = static_cast<int16_T>(n);
                        d_0[1] = 4;
                        if (ntoread > static_cast<int32_T>(d_0[i2])) {
                            d_0[0] = static_cast<int16_T>(n);
                            d_0[1] = 4;
                            i = static_cast<int32_T>(d_0[i2]);
                            ntoread = static_cast<int32_T>(ntoread -
                                static_cast<int32_T>(i * div_s32(ntoread, i)));
                        }

                        d_0[0] = static_cast<int16_T>(n);
                        d_0[1] = 4;
                        if (ntoread > static_cast<int32_T>(static_cast<int32_T>
                                (d_0[i2]) >> 1)) {
                            d_0[0] = static_cast<int16_T>(n);
                            d_0[1] = 4;
                            ntoread = static_cast<int32_T>(static_cast<int32_T>
                                (d_0[i2]) - ntoread);
                            isStable = static_cast<boolean_T>
                                (static_cast<int32_T>(static_cast<int32_T>
                                  (isStable) ^ 1));
                        }
                    }

                    if (n >= 4) {
                        i = n;
                    } else {
                        i = 4;
                    }

                    nread = static_cast<int32_T>(static_cast<int16_T>(
                        static_cast<int32_T>(i / 2)));
                    for (i = 0; i <= static_cast<int32_T>(nread - 1); i++) {
                        localDW->MAT[i] = 0.0;
                    }

                    d_0[0] = static_cast<int16_T>(n);
                    d_0[1] = 4;
                    iy = static_cast<int32_T>(d_0[i2]);
                    d_0[0] = static_cast<int16_T>(n);
                    d_0[1] = 4;
                    nv = static_cast<int32_T>(d_0[i2]);
                    stride = 1;
                    for (nread = 0; nread <= static_cast<int32_T>(i2 - 1); nread
                            ++) {
                        stride = static_cast<int32_T>(stride * n);
                    }

                    npages = 1;
                    for (nread = static_cast<int32_T>(i2 + 2); nread < 3; nread
                            ++) {
                        npages = static_cast<int32_T>(npages << 2);
                    }

                    d_0[0] = static_cast<int16_T>(n);
                    d_0[1] = 4;
                    nread = static_cast<int32_T>(stride * static_cast<int32_T>
                        (d_0[i2]));
                    d_0[0] = static_cast<int16_T>(n);
                    d_0[1] = 4;
                    if ((static_cast<int32_T>(d_0[i2]) > 1) && (ntoread > 0)) {
                        for (i1 = 0; i1 <= static_cast<int32_T>(npages - 1); i1
                                ++) {
                            pageroot = static_cast<int32_T>(i1 * nread);
                            for (i2 = 0; i2 <= static_cast<int32_T>(stride - 1);
                                 i2++) {
                                int32_T b_i1;
                                b_i1 = static_cast<int32_T>(pageroot + i2);
                                if (isStable) {
                                    for (i = 0; i <= static_cast<int32_T>
                                            (ntoread - 1); i++) {
                                        localDW->MAT[i] = CheckPoints->data[
                                            static_cast<int32_T>(static_cast<
                                            int32_T>(static_cast<int32_T>(
                                            static_cast<int32_T>(i + iy) -
                                            ntoread) * stride) + b_i1)];
                                    }

                                    for (i = nv; i >= static_cast<int32_T>
                                            (ntoread + 1); i--) {
                                        CheckPoints->data[static_cast<int32_T>
                                            (b_i1 + static_cast<int32_T>(
                                              static_cast<int32_T>(i - 1) *
                                              stride))] = CheckPoints->data[
                                            static_cast<int32_T>(static_cast<
                                            int32_T>(static_cast<int32_T>(
                                            static_cast<int32_T>(i - ntoread) -
                                            1) * stride) + b_i1)];
                                    }

                                    for (i = 0; i <= static_cast<int32_T>
                                            (ntoread - 1); i++) {
                                        CheckPoints->data[static_cast<int32_T>
                                            (b_i1 + static_cast<int32_T>(i *
                                              stride))] = localDW->MAT[i];
                                    }
                                } else {
                                    for (i = 0; i <= static_cast<int32_T>
                                            (ntoread - 1); i++) {
                                        localDW->MAT[i] = CheckPoints->data[
                                            static_cast<int32_T>(static_cast<
                                            int32_T>(i * stride) + b_i1)];
                                    }

                                    n = static_cast<int32_T>(static_cast<int32_T>
                                        (iy - ntoread) - 1);
                                    for (i = 0; i <= n; i++) {
                                        CheckPoints->data[static_cast<int32_T>
                                            (b_i1 + static_cast<int32_T>(i *
                                              stride))] = CheckPoints->data[
                                            static_cast<int32_T>(static_cast<
                                            int32_T>(static_cast<int32_T>(i +
                                            ntoread) * stride) + b_i1)];
                                    }

                                    for (i = 0; i <= static_cast<int32_T>
                                            (ntoread - 1); i++) {
                                        CheckPoints->data[static_cast<int32_T>
                                            (b_i1 + static_cast<int32_T>(
                                              static_cast<int32_T>(static_cast<
                                               int32_T>(i + iy) - ntoread) *
                                              stride))] = localDW->MAT[i];
                                    }
                                }
                            }
                        }
                    }
                }

                iy = CheckPoints->size[0];

                // '<S66>:1:16'
                FlightMissionMode_emxInit_real_T_h(&segWayPoints, 2);
                FlightMissionMode_emxInit_real_T_h(&dummyWayPoint_0, 2);

                // MATLAB Function: '<S40>/CheckPointInterp'
                for (nread = 0; nread <= static_cast<int32_T>(iy - 2); nread++)
                {
                    rtb_Sum1_e_idx_0 = CheckPoints->data[static_cast<int32_T>(
                        static_cast<int32_T>(static_cast<int32_T>
                        (CheckPoints->size[0] * 3) + nread) + 1)];
                    if (CheckPoints->data[static_cast<int32_T>
                            (static_cast<int32_T>(CheckPoints->size[0] * 3) +
                             nread)] != rtb_Sum1_e_idx_0) {
                        // '<S66>:1:17'
                        // '<S66>:1:18'
                        CheckPoints_0[0] = CheckPoints->data[nread];
                        CheckPoints_1[0] = CheckPoints->data[static_cast<int32_T>
                            (nread + 1)];
                        CheckPoints_0[1] = CheckPoints->data[static_cast<int32_T>
                            (nread + CheckPoints->size[0])];
                        CheckPoints_1[1] = CheckPoints->data[static_cast<int32_T>
                            (static_cast<int32_T>(nread + CheckPoints->size[0])
                             + 1)];
                        CheckPoints_0[2] = CheckPoints->data[static_cast<int32_T>
                            (static_cast<int32_T>(CheckPoints->size[0] << 1) +
                             nread)];
                        CheckPoints_1[2] = CheckPoints->data[static_cast<int32_T>
                            (static_cast<int32_T>(static_cast<int32_T>
                              (CheckPoints->size[0] << 1) + nread) + 1)];
                        CheckPoints_0[3] = CheckPoints->data[static_cast<int32_T>
                            (static_cast<int32_T>(CheckPoints->size[0] * 3) +
                             nread)];
                        CheckPoints_1[3] = rtb_Sum1_e_idx_0;
                        FlightMissionMode_genSegWP_j(CheckPoints_0,
                            CheckPoints_1, segWayPoints, localDW);

                        // '<S66>:1:19'
                        stride = static_cast<int32_T>(dummyWayPoint_0->size[0] *
                            dummyWayPoint_0->size[1]);
                        dummyWayPoint_0->size[0] = static_cast<int32_T>
                            (dummyWayPoint->size[0] + segWayPoints->size[0]);
                        dummyWayPoint_0->size[1] = 3;
                        FlightMissionMode_emxEnsureCapacity_real_T_c
                            (dummyWayPoint_0, stride);
                        nv = dummyWayPoint->size[0];
                        for (i = 0; i < 3; i++) {
                            for (i1 = 0; i1 <= static_cast<int32_T>(nv - 1); i1
                                    ++) {
                                dummyWayPoint_0->data[static_cast<int32_T>(i1 +
                                    static_cast<int32_T>(dummyWayPoint_0->size[0]
                                    * i))] = dummyWayPoint->data
                                    [static_cast<int32_T>(static_cast<int32_T>
                                    (dummyWayPoint->size[0] * i) + i1)];
                            }
                        }

                        nv = segWayPoints->size[0];
                        for (i = 0; i < 3; i++) {
                            for (i1 = 0; i1 <= static_cast<int32_T>(nv - 1); i1
                                    ++) {
                                dummyWayPoint_0->data[static_cast<int32_T>(
                                    static_cast<int32_T>(i1 +
                                    dummyWayPoint->size[0]) +
                                    static_cast<int32_T>(dummyWayPoint_0->size[0]
                                    * i))] = segWayPoints->data
                                    [static_cast<int32_T>(static_cast<int32_T>
                                    (segWayPoints->size[0] * i) + i1)];
                            }
                        }

                        stride = static_cast<int32_T>(dummyWayPoint->size[0] *
                            dummyWayPoint->size[1]);
                        dummyWayPoint->size[0] = dummyWayPoint_0->size[0];
                        dummyWayPoint->size[1] = 3;
                        FlightMissionMode_emxEnsureCapacity_real_T_c
                            (dummyWayPoint, stride);
                        nv = static_cast<int32_T>(dummyWayPoint_0->size[0] * 3);
                        for (i = 0; i <= static_cast<int32_T>(nv - 1); i++) {
                            dummyWayPoint->data[i] = dummyWayPoint_0->data[i];
                        }
                    }
                }

                // '<S66>:1:24'
                obj = FlightMissionMode_DubinsObjSingleton_getConnector_p
                    (localDW);
                CheckPoints_0[0] = CheckPoints->data[static_cast<int32_T>
                    (CheckPoints->size[0] - 1)];
                CheckPoints_1[0] = CheckPoints->data[0];
                CheckPoints_0[1] = CheckPoints->data[static_cast<int32_T>(
                    static_cast<int32_T>(CheckPoints->size[0] +
                    CheckPoints->size[0]) - 1)];
                CheckPoints_1[1] = CheckPoints->data[CheckPoints->size[0]];
                CheckPoints_0[2] = CheckPoints->data[static_cast<int32_T>(
                    static_cast<int32_T>(static_cast<int32_T>(CheckPoints->size
                    [0] << 1) + CheckPoints->size[0]) - 1)];
                CheckPoints_1[2] = CheckPoints->data[static_cast<int32_T>
                    (CheckPoints->size[0] << 1)];
                CheckPoints_0[3] = CheckPoints->data[static_cast<int32_T>(
                    static_cast<int32_T>(static_cast<int32_T>(CheckPoints->size
                    [0] * 3) + CheckPoints->size[0]) - 1)];
                CheckPoints_1[3] = CheckPoints->data[static_cast<int32_T>
                    (CheckPoints->size[0] * 3)];
                FlightMissionMode_uavDubinsBuiltins_connect_g(obj, CheckPoints_0,
                    CheckPoints_1, obj->MinTurningRadius, &a__1_0, &rtb_Switch_l);
                rtb_Switch_l = std::fmax(2.2204460492503131E-16, a__1_0.Length /
                    128.0);
                FlightMissionMode_emxInit_real_T_h(&lengths, 2);

                // MATLAB Function: '<S40>/CheckPointInterp'
                if (std::isnan(a__1_0.Length)) {
                    stride = static_cast<int32_T>(lengths->size[0] *
                        lengths->size[1]);
                    lengths->size[0] = 1;
                    lengths->size[1] = 1;
                    FlightMissionMode_emxEnsureCapacity_real_T_c(lengths, stride);
                    lengths->data[0] = (rtNaN);
                } else if (a__1_0.Length < 0.0) {
                    lengths->size[0] = 1;
                    lengths->size[1] = 0;
                } else if (std::isinf(a__1_0.Length) && std::isinf(rtb_Switch_l))
                {
                    stride = static_cast<int32_T>(lengths->size[0] *
                        lengths->size[1]);
                    lengths->size[0] = 1;
                    lengths->size[1] = 1;
                    FlightMissionMode_emxEnsureCapacity_real_T_c(lengths, stride);
                    lengths->data[0] = (rtNaN);
                } else if (std::isinf(rtb_Switch_l)) {
                    stride = static_cast<int32_T>(lengths->size[0] *
                        lengths->size[1]);
                    lengths->size[0] = 1;
                    lengths->size[1] = 1;
                    FlightMissionMode_emxEnsureCapacity_real_T_c(lengths, stride);
                    lengths->data[0] = 0.0;
                } else if (std::floor(rtb_Switch_l) == rtb_Switch_l) {
                    stride = static_cast<int32_T>(lengths->size[0] *
                        lengths->size[1]);
                    lengths->size[0] = 1;
                    nv = static_cast<int32_T>(a__1_0.Length / rtb_Switch_l);
                    lengths->size[1] = static_cast<int32_T>(nv + 1);
                    FlightMissionMode_emxEnsureCapacity_real_T_c(lengths, stride);
                    for (i = 0; i <= nv; i++) {
                        lengths->data[i] = rtb_Switch_l * static_cast<real_T>(i);
                    }
                } else {
                    FlightMissionMode_eml_float_colon(rtb_Switch_l,
                        a__1_0.Length, lengths);
                }

                FlightMissionMode_emxInit_real_T_h(&poses, 2);

                // MATLAB Function: '<S40>/CheckPointInterp'
                FlightMissionMode_uavDubinsPathSegment_interpolate_b
                    (a__1_0.StartPose, a__1_0.GoalPose, a__1_0.FlightPathAngle,
                     a__1_0.AirSpeed, a__1_0.MinTurningRadius,
                     a__1_0.HelixRadius, a__1_0.MotionTypes,
                     a__1_0.MotionLengths, a__1_0.Length, lengths, poses);
                FlightMissionMode_emxFree_real_T_n(&lengths);

                // '<S66>:1:25'
                stride = static_cast<int32_T>(dummyWayPoint_0->size[0] *
                    dummyWayPoint_0->size[1]);

                // MATLAB Function: '<S40>/CheckPointInterp'
                dummyWayPoint_0->size[0] = static_cast<int32_T>
                    (dummyWayPoint->size[0] + poses->size[0]);
                dummyWayPoint_0->size[1] = 3;
                FlightMissionMode_emxEnsureCapacity_real_T_c(dummyWayPoint_0,
                    stride);

                // MATLAB Function: '<S40>/CheckPointInterp'
                nv = dummyWayPoint->size[0];
                iy = poses->size[0];
                for (i = 0; i < 3; i++) {
                    for (i1 = 0; i1 <= static_cast<int32_T>(nv - 1); i1++) {
                        dummyWayPoint_0->data[static_cast<int32_T>(i1 +
                            static_cast<int32_T>(dummyWayPoint_0->size[0] * i))]
                            = dummyWayPoint->data[static_cast<int32_T>(
                            static_cast<int32_T>(dummyWayPoint->size[0] * i) +
                            i1)];
                    }

                    for (i1 = 0; i1 <= static_cast<int32_T>(iy - 1); i1++) {
                        dummyWayPoint_0->data[static_cast<int32_T>(static_cast<
                            int32_T>(i1 + dummyWayPoint->size[0]) + static_cast<
                            int32_T>(dummyWayPoint_0->size[0] * i))] =
                            poses->data[static_cast<int32_T>(static_cast<int32_T>
                            (poses->size[0] * i) + i1)];
                    }
                }

                FlightMissionMode_emxFree_real_T_n(&poses);
                stride = static_cast<int32_T>(dummyWayPoint->size[0] *
                    dummyWayPoint->size[1]);

                // MATLAB Function: '<S40>/CheckPointInterp'
                dummyWayPoint->size[0] = dummyWayPoint_0->size[0];
                dummyWayPoint->size[1] = 3;
                FlightMissionMode_emxEnsureCapacity_real_T_c(dummyWayPoint,
                    stride);

                // MATLAB Function: '<S40>/CheckPointInterp'
                nv = static_cast<int32_T>(dummyWayPoint_0->size[0] * 3);
                for (i = 0; i <= static_cast<int32_T>(nv - 1); i++) {
                    dummyWayPoint->data[i] = dummyWayPoint_0->data[i];
                }

                // '<S66>:1:28'
                rtb_Sum1_e_idx_0 = std::ceil(8192.0 / static_cast<real_T>
                    (dummyWayPoint->size[0]));
                stride = static_cast<int32_T>(segWayPoints->size[0] *
                    segWayPoints->size[1]);

                // MATLAB Function: '<S40>/CheckPointInterp'
                segWayPoints->size[0] = dummyWayPoint->size[0];
                segWayPoints->size[1] = 3;
                FlightMissionMode_emxEnsureCapacity_real_T_c(segWayPoints,
                    stride);

                // MATLAB Function: '<S40>/CheckPointInterp'
                nv = static_cast<int32_T>(dummyWayPoint->size[0] * 3);
                for (i = 0; i <= static_cast<int32_T>(nv - 1); i++) {
                    segWayPoints->data[i] = dummyWayPoint->data[i];
                }

                stride = static_cast<int32_T>(dummyWayPoint->size[0] *
                    dummyWayPoint->size[1]);

                // MATLAB Function: '<S40>/CheckPointInterp'
                dummyWayPoint->size[0] = static_cast<int32_T>
                    (dummyWayPoint->size[0] * static_cast<int32_T>
                     (rtb_Sum1_e_idx_0));
                dummyWayPoint->size[1] = 3;
                FlightMissionMode_emxEnsureCapacity_real_T_c(dummyWayPoint,
                    stride);

                // MATLAB Function: '<S40>/CheckPointInterp'
                nv = segWayPoints->size[0];
                stride = static_cast<int32_T>(static_cast<int32_T>
                    (rtb_Sum1_e_idx_0) - 1);
                for (i1 = 0; i1 < 3; i1++) {
                    npages = static_cast<int32_T>(i1 * nv);
                    nread = static_cast<int32_T>(static_cast<int32_T>(
                        static_cast<int32_T>(nv * static_cast<int32_T>
                        (rtb_Sum1_e_idx_0)) * i1) - 1);
                    for (i2 = 0; i2 <= stride; i2++) {
                        pageroot = static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>(i2 * nv) + nread) + 1);
                        for (iy = 0; iy <= static_cast<int32_T>(nv - 1); iy++) {
                            dummyWayPoint->data[static_cast<int32_T>(pageroot +
                                iy)] = segWayPoints->data[static_cast<int32_T>
                                (npages + iy)];
                        }
                    }
                }

                // '<S66>:1:31'
                CheckPoints_0[0] = CheckPoints->data[0];
                CheckPoints_0[1] = CheckPoints->data[CheckPoints->size[0]];
                CheckPoints_0[2] = CheckPoints->data[static_cast<int32_T>
                    (CheckPoints->size[0] << 1)];
                CheckPoints_0[3] = CheckPoints->data[static_cast<int32_T>
                    (CheckPoints->size[0] * 3)];
                FlightMissionMode_emxFree_real_T_n(&CheckPoints);

                // MATLAB Function: '<S40>/CheckPointInterp' incorporates:
                //   Reshape: '<S40>/Reshape'

                FlightMissionMode_genSegWP_j(Reshape, CheckPoints_0,
                    segWayPoints, localDW);

                // '<S66>:1:34'
                stride = static_cast<int32_T>(dummyWayPoint_0->size[0] *
                    dummyWayPoint_0->size[1]);

                // MATLAB Function: '<S40>/CheckPointInterp'
                dummyWayPoint_0->size[0] = static_cast<int32_T>
                    (segWayPoints->size[0] + dummyWayPoint->size[0]);
                dummyWayPoint_0->size[1] = 3;
                FlightMissionMode_emxEnsureCapacity_real_T_c(dummyWayPoint_0,
                    stride);

                // MATLAB Function: '<S40>/CheckPointInterp'
                nv = segWayPoints->size[0];
                iy = dummyWayPoint->size[0];
                for (i = 0; i < 3; i++) {
                    for (i1 = 0; i1 <= static_cast<int32_T>(nv - 1); i1++) {
                        dummyWayPoint_0->data[static_cast<int32_T>(i1 +
                            static_cast<int32_T>(dummyWayPoint_0->size[0] * i))]
                            = segWayPoints->data[static_cast<int32_T>(
                            static_cast<int32_T>(segWayPoints->size[0] * i) + i1)];
                    }

                    for (i1 = 0; i1 <= static_cast<int32_T>(iy - 1); i1++) {
                        dummyWayPoint_0->data[static_cast<int32_T>
                            (static_cast<int32_T>(i1 + segWayPoints->size[0]) +
                             static_cast<int32_T>(dummyWayPoint_0->size[0] * i))]
                            = dummyWayPoint->data[static_cast<int32_T>(
                            static_cast<int32_T>(dummyWayPoint->size[0] * i) +
                            i1)];
                    }
                }

                FlightMissionMode_emxFree_real_T_n(&segWayPoints);

                // MATLAB Function 'biasWayPoint': '<S68>:1'
                // '<S68>:1:4'
                for (i = 0; i < 8192; i++) {
                    // MATLAB Function: '<S40>/CheckPointInterp'
                    localDW->WayPoint_k[i] = dummyWayPoint_0->data[i];
                    localDW->WayPoint_k[static_cast<int32_T>(i + 8192)] =
                        dummyWayPoint_0->data[static_cast<int32_T>(i +
                        dummyWayPoint_0->size[0])];
                    localDW->WayPoint_k[static_cast<int32_T>(i + 16384)] =
                        dummyWayPoint_0->data[static_cast<int32_T>(static_cast<
                        int32_T>(dummyWayPoint_0->size[0] << 1) + i)];

                    // MATLAB Function: '<S40>/biasWayPoint' incorporates:
                    //   MATLAB Function: '<S40>/CheckPointInterp'

                    localDW->WayPoint_k_m[i] = localDW->WayPoint_k[i];
                    localDW->WayPoint_k_m[static_cast<int32_T>(i + 8192)] =
                        localDW->WayPoint_k[static_cast<int32_T>(i + 8192)] + d;
                    localDW->WayPoint_k_m[static_cast<int32_T>(i + 16384)] =
                        localDW->WayPoint_k[static_cast<int32_T>(i + 16384)];
                }

                FlightMissionMode_emxFree_real_T_n(&dummyWayPoint_0);

                // Product: '<S40>/Matrix Divide' incorporates:
                //   MATLAB Function: '<S40>/biasWayPoint'
                //   MATLABSystem: '<S40>/RotateATMissionHdg'

                rt_mrdivide_U1d8192x3_U2d3x3_Yd8192x3_snf(localDW->WayPoint_k_m,
                    localDW->RotateATMissionHdg.RotateATMissionHdg,
                    localDW->WayPoint_k);

                // Reshape: '<S40>/ReshapeRowVec' incorporates:
                //   Constant: '<S36>/Three'
                //   Gain: '<S36>/Gain'
                //   Math: '<S36>/ModRunWayLayer'
                //   Product: '<S46>/x*cos'
                //   Product: '<S46>/x*sin'
                //   Product: '<S46>/y*cos'
                //   Product: '<S46>/y*sin'
                //   Sum: '<S36>/BiasMissionAlt'
                //   Sum: '<S46>/Sum2'
                //   Sum: '<S46>/Sum3'
                //   UnaryMinus: '<S42>/Ze2height'

                LLA0_gw[0] = distToCenter * 0.0 + rtb_Abs1_il;
                LLA0_gw[1] = distToCenter - rtb_Abs1_il * 0.0;
                LLA0_gw[2] = -Lon - 15.0 * rt_modd_snf(Alt, 3.0);

                // MATLAB Function: '<S40>/biasNED' incorporates:
                //   Product: '<S40>/Matrix Divide'
                //   Reshape: '<S40>/ReshapeRowVec'

                // MATLAB Function 'biasNED': '<S67>:1'
                // '<S67>:1:4'
                for (i1 = 0; i1 < 3; i1++) {
                    nread = static_cast<int32_T>(i1 << 13);
                    for (i2 = 0; i2 < 8192; i2++) {
                        localDW->WayPoint_k_m[static_cast<int32_T>(nread + i2)] =
                            LLA0_gw[i1];
                    }
                }

                for (i = 0; i < 8192; i++) {
                    localDW->nedWayPoint_o[i] = localDW->WayPoint_k[i] +
                        localDW->WayPoint_k_m[i];
                    localDW->nedWayPoint_o[static_cast<int32_T>(i + 8192)] =
                        localDW->WayPoint_k[static_cast<int32_T>(i + 8192)] +
                        localDW->WayPoint_k_m[static_cast<int32_T>(i + 8192)];
                    localDW->nedWayPoint_o[static_cast<int32_T>(i + 16384)] =
                        localDW->WayPoint_k[static_cast<int32_T>(i + 16384)] +
                        localDW->WayPoint_k_m[static_cast<int32_T>(i + 16384)];
                }

                // End of MATLAB Function: '<S40>/biasNED'
            } else {
                localDW->WayPoint_MODE = false;
            }

            // End of Outputs for SubSystem: '<S36>/WayPoint'

            // MATLABSystem: '<S36>/Waypoint Follower' incorporates:
            //   MATLAB Function: '<S40>/CheckPointInterp'

            localDW->obj_k.LookaheadDistFlag = 0U;
            localDW->obj_k.InitialPose[0] = 0.0;
            localDW->obj_k.InitialPose[1] = 0.0;
            localDW->obj_k.InitialPose[2] = 0.0;
            localDW->obj_k.InitialPose[3] = 0.0;
            std::memset(&localDW->WayPoint_k[0], 0, static_cast<uint32_T>(24576U
                         * sizeof(real_T)));
            for (i = 0; i < 8192; i++) {
                localDW->WayPoint_k[i] = localDW->nedWayPoint_o[i];
                localDW->WayPoint_k[static_cast<int32_T>(i + 8192)] =
                    localDW->nedWayPoint_o[static_cast<int32_T>(i + 8192)];
                localDW->WayPoint_k[static_cast<int32_T>(i + 16384)] =
                    localDW->nedWayPoint_o[static_cast<int32_T>(i + 16384)];
            }

            localDW->obj_k.NumWaypoints = 8192.0;
            guard1 = false;
            if (localDW->obj_k.NumWaypoints != 8192.0) {
                guard1 = true;
            } else {
                if (localDW->obj_k.NumWaypoints < 1.0) {
                    iy = 0;
                } else {
                    iy = static_cast<int32_T>(localDW->obj_k.NumWaypoints);
                }

                if (localDW->obj_k.NumWaypoints < 1.0) {
                    i1 = 0;
                } else {
                    i1 = static_cast<int32_T>(localDW->obj_k.NumWaypoints);
                }

                isStable = false;
                p = false;
                if (iy == i1) {
                    p = true;
                }

                if (p && (iy != 0) && (i1 != 0)) {
                    nread = 0;
                    exitg1 = false;
                    while ((!exitg1) && (nread <= static_cast<int32_T>(
                             static_cast<int32_T>(i1 * 3) - 1))) {
                        if (static_cast<boolean_T>(static_cast<int32_T>
                                                   ((localDW->obj_k.WaypointsInternal
                                [static_cast<int32_T>(static_cast<int32_T>(
                                 static_cast<int32_T>(nread / iy) << 13) + nread
                                % iy)] == localDW->WayPoint_k
                                [static_cast<int32_T>(static_cast<int32_T>(
                                 static_cast<int32_T>(nread / i1) << 13) + nread
                                % i1)]) ^ 1))) {
                            p = false;
                            exitg1 = true;
                        } else {
                            nread = static_cast<int32_T>(nread + 1);
                        }
                    }
                }

                if (p) {
                    isStable = true;
                }

                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>(isStable) ^ 1)))
                {
                    guard1 = true;
                }
            }

            if (guard1) {
                std::memcpy(&localDW->obj_k.WaypointsInternal[0],
                            &localDW->WayPoint_k[0], static_cast<uint32_T>
                            (24576U * sizeof(real_T)));
                localDW->obj_k.WaypointIndex = 1.0;
            }

            for (i = 0; i < 8192; i++) {
                localDW->distinctWptsIdx[i] = true;
            }

            for (nread = 0; nread < 8191; nread++) {
                i = 0;
                i1 = 0;
                for (i2 = 0; i2 < 3; i2++) {
                    iy = static_cast<int32_T>(i1 + nread);
                    localDW->x_f[static_cast<int32_T>(i + nread)] =
                        (localDW->nedWayPoint_o[static_cast<int32_T>(iy + 1)] !=
                         localDW->nedWayPoint_o[iy]);
                    i = static_cast<int32_T>(i + 8191);
                    i1 = static_cast<int32_T>(i1 + 8192);
                }
            }

            i1 = 0;
            i2 = 16382;
            for (nread = 0; nread < 8191; nread++) {
                localDW->y[nread] = false;
                i1 = static_cast<int32_T>(i1 + 1);
                i2 = static_cast<int32_T>(i2 + 1);
                ntoread = i1;
                exitg1 = false;
                while ((!exitg1) && (ntoread <= i2)) {
                    if (localDW->x_f[static_cast<int32_T>(ntoread - 1)]) {
                        localDW->y[nread] = true;
                        exitg1 = true;
                    } else {
                        ntoread = static_cast<int32_T>(ntoread + 8191);
                    }
                }

                localDW->distinctWptsIdx[nread] = localDW->y[nread];
            }

            i2 = 0;
            for (iy = 0; iy < 8192; iy++) {
                if (localDW->distinctWptsIdx[iy]) {
                    i2 = static_cast<int32_T>(i2 + 1);
                }
            }

            iy = 0;
            for (nread = 0; nread < 8192; nread++) {
                if (localDW->distinctWptsIdx[nread]) {
                    localDW->b_data[iy] = static_cast<int16_T>(static_cast<
                        int32_T>(nread + 1));
                    iy = static_cast<int32_T>(iy + 1);
                }
            }

            stride = static_cast<int32_T>(b_waypointsIn->size[0] *
                b_waypointsIn->size[1]);

            // MATLABSystem: '<S36>/Waypoint Follower'
            b_waypointsIn->size[0] = i2;
            b_waypointsIn->size[1] = 3;
            FlightMissionMode_emxEnsureCapacity_real_T_c(b_waypointsIn, stride);

            // MATLABSystem: '<S36>/Waypoint Follower'
            for (i = 0; i < 3; i++) {
                for (i1 = 0; i1 <= static_cast<int32_T>(i2 - 1); i1++) {
                    b_waypointsIn->data[static_cast<int32_T>(i1 +
                        static_cast<int32_T>(b_waypointsIn->size[0] * i))] =
                        localDW->nedWayPoint_o[static_cast<int32_T>
                        (static_cast<int32_T>(static_cast<int32_T>(i << 13) +
                          static_cast<int32_T>(localDW->b_data[i1])) - 1)];
                }
            }

            localDW->obj_k.LookaheadDistance = 200.0;
            if (i2 == 0) {
                LLA0_gw[2] = rtu_Pose[2];
                Lon = rtu_Pose[3];
                rtb_MergeStatus = 1U;
            } else {
                guard1 = false;
                if (i2 == 1) {
                    if (localDW->obj_k.StartFlag) {
                        localDW->obj_k.InitialPose[0] = rtu_Pose[0];
                        localDW->obj_k.InitialPose[1] = rtu_Pose[1];
                        localDW->obj_k.InitialPose[2] = rtu_Pose[2];
                        localDW->obj_k.InitialPose[3] = rtu_Pose[3];
                    }

                    u[0] = b_waypointsIn->data[0] - rtu_Pose[0];
                    u[1] = b_waypointsIn->data[1] - rtu_Pose[1];
                    u[2] = b_waypointsIn->data[2] - rtu_Pose[2];
                    if (FlightMissionMode_norm_pv(u) < 1.4901161193847656E-8) {
                        LLA0_gw[2] = rtu_Pose[2];
                        Lon = rtu_Pose[3];
                        rtb_MergeStatus = 1U;
                        localDW->obj_k.StartFlag = false;
                    } else {
                        localDW->obj_k.StartFlag = false;
                        localDW->obj_k.NumWaypoints = 2.0;
                        stride = static_cast<int32_T>(waypoints->size[0] *
                            waypoints->size[1]);
                        waypoints->size[0] = static_cast<int32_T>
                            (b_waypointsIn->size[0] + 1);
                        waypoints->size[1] = 3;
                        FlightMissionMode_emxEnsureCapacity_real_T_c(waypoints,
                            stride);
                        nv = b_waypointsIn->size[0];
                        for (i = 0; i < 3; i++) {
                            waypoints->data[static_cast<int32_T>(waypoints->
                                size[0] * i)] = localDW->obj_k.InitialPose[i];
                            for (i1 = 0; i1 <= static_cast<int32_T>(nv - 1); i1
                                    ++) {
                                waypoints->data[static_cast<int32_T>(
                                    static_cast<int32_T>(i1 +
                                    static_cast<int32_T>(waypoints->size[0] * i))
                                    + 1)] = b_waypointsIn->data
                                    [static_cast<int32_T>(static_cast<int32_T>
                                    (b_waypointsIn->size[0] * i) + i1)];
                            }
                        }

                        guard1 = true;
                    }
                } else {
                    stride = static_cast<int32_T>(waypoints->size[0] *
                        waypoints->size[1]);
                    waypoints->size[0] = b_waypointsIn->size[0];
                    waypoints->size[1] = 3;
                    FlightMissionMode_emxEnsureCapacity_real_T_c(waypoints,
                        stride);
                    nv = static_cast<int32_T>(b_waypointsIn->size[0] * 3);
                    for (i = 0; i <= static_cast<int32_T>(nv - 1); i++) {
                        waypoints->data[i] = b_waypointsIn->data[i];
                    }

                    guard1 = true;
                }

                if (guard1) {
                    real_T distToCenter_tmp_0;
                    boolean_T guard2{ false };

                    isStable = false;
                    if (localDW->obj_k.WaypointIndex ==
                            localDW->obj_k.NumWaypoints) {
                        isStable = true;
                    }

                    if (isStable) {
                        localDW->obj_k.LastWaypointFlag = true;
                        localDW->obj_k.WaypointIndex--;
                    }

                    u[0] = rtu_Pose[0] - waypoints->data[static_cast<int32_T>(
                        static_cast<int32_T>(localDW->obj_k.WaypointIndex + 1.0)
                        - 1)];
                    u[1] = rtu_Pose[1] - waypoints->data[static_cast<int32_T>(
                        static_cast<int32_T>(static_cast<int32_T>
                        (localDW->obj_k.WaypointIndex + 1.0) + waypoints->size[0])
                        - 1)];
                    u[2] = rtu_Pose[2] - waypoints->data[static_cast<int32_T>(
                        static_cast<int32_T>(static_cast<int32_T>
                        (localDW->obj_k.WaypointIndex + 1.0) +
                        static_cast<int32_T>(waypoints->size[0] << 1)) - 1)];
                    guard2 = false;
                    if (FlightMissionMode_norm_pv(u) <= 100.0) {
                        guard2 = true;
                    } else {
                        rtb_Abs1_il = waypoints->data[static_cast<int32_T>(
                            static_cast<int32_T>(localDW->obj_k.WaypointIndex +
                            1.0) - 1)];
                        LLA0_gw[0] = rtu_Pose[0] - rtb_Abs1_il;
                        u[0] = rtb_Abs1_il - waypoints->data[static_cast<int32_T>
                            (static_cast<int32_T>(localDW->obj_k.WaypointIndex)
                             - 1)];
                        rtb_Abs1_il = waypoints->data[static_cast<int32_T>(
                            static_cast<int32_T>(static_cast<int32_T>
                            (localDW->obj_k.WaypointIndex + 1.0) +
                            waypoints->size[0]) - 1)];
                        LLA0_gw[1] = rtu_Pose[1] - rtb_Abs1_il;
                        u[1] = rtb_Abs1_il - waypoints->data[static_cast<int32_T>
                            (static_cast<int32_T>(static_cast<int32_T>
                              (localDW->obj_k.WaypointIndex) + waypoints->size[0])
                             - 1)];
                        LLA0_gw[2] = rtu_Pose[2] - waypoints->data
                            [static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>(localDW->obj_k.WaypointIndex +
                            1.0) + static_cast<int32_T>(waypoints->size[0] << 1))
                            - 1)];
                        u[2] = waypoints->data[static_cast<int32_T>(static_cast<
                            int32_T>(static_cast<int32_T>
                                     (localDW->obj_k.WaypointIndex + 1.0) +
                                     static_cast<int32_T>(waypoints->size[0] <<
                            1)) - 1)] - waypoints->data[static_cast<int32_T>(
                            static_cast<int32_T>(static_cast<int32_T>
                            (waypoints->size[0] << 1) + static_cast<int32_T>
                            (localDW->obj_k.WaypointIndex)) - 1)];
                        rtb_Sum1_e_idx_0 = FlightMissionMode_norm_pv(u);
                        distToCenter_tmp_0 = FlightMissionMode_norm_pv(LLA0_gw);
                        distToCenter = waypoints->data[static_cast<int32_T>(
                            static_cast<int32_T>(localDW->obj_k.WaypointIndex) -
                            1)];
                        rtb_Abs1_il = waypoints->data[static_cast<int32_T>(
                            static_cast<int32_T>(localDW->obj_k.WaypointIndex +
                            1.0) - 1)];
                        Alt = waypoints->data[static_cast<int32_T>
                            (static_cast<int32_T>(static_cast<int32_T>
                              (localDW->obj_k.WaypointIndex) + waypoints->size[0])
                             - 1)];
                        rtb_Switch_l = waypoints->data[static_cast<int32_T>(
                            static_cast<int32_T>(static_cast<int32_T>
                            (localDW->obj_k.WaypointIndex + 1.0) +
                            waypoints->size[0]) - 1)];
                        turnVector_idx_2 = waypoints->data[static_cast<int32_T>(
                            static_cast<int32_T>(static_cast<int32_T>
                            (waypoints->size[0] << 1) + static_cast<int32_T>
                            (localDW->obj_k.WaypointIndex)) - 1)];
                        Lon = waypoints->data[static_cast<int32_T>
                            (static_cast<int32_T>(static_cast<int32_T>
                              (localDW->obj_k.WaypointIndex + 1.0) +
                              static_cast<int32_T>(waypoints->size[0] << 1)) - 1)];
                        d = ((rtb_Abs1_il - distToCenter) / rtb_Sum1_e_idx_0 *
                             (LLA0_gw[0] / distToCenter_tmp_0) + (rtb_Switch_l -
                              Alt) / rtb_Sum1_e_idx_0 * (LLA0_gw[1] /
                              distToCenter_tmp_0)) + (Lon - turnVector_idx_2) /
                            rtb_Sum1_e_idx_0 * (LLA0_gw[2] / distToCenter_tmp_0);
                        if (std::isnan(d)) {
                            rtb_Sum1_e_idx_0 = (rtNaN);
                        } else if (d < 0.0) {
                            rtb_Sum1_e_idx_0 = -1.0;
                        } else {
                            rtb_Sum1_e_idx_0 = static_cast<real_T>(d > 0.0);
                        }

                        if (rtb_Sum1_e_idx_0 >= 0.0) {
                            guard2 = true;
                        } else {
                            LLA0_gw[0] = rtb_Abs1_il;
                            LLA0_gw[1] = rtb_Switch_l;
                            LLA0_gw[2] = Lon;
                        }
                    }

                    if (guard2) {
                        localDW->obj_k.WaypointIndex++;
                        isStable = false;
                        if (localDW->obj_k.WaypointIndex ==
                                localDW->obj_k.NumWaypoints) {
                            isStable = true;
                        }

                        if (isStable) {
                            localDW->obj_k.LastWaypointFlag = true;
                            localDW->obj_k.WaypointIndex--;
                        }

                        distToCenter = waypoints->data[static_cast<int32_T>(
                            static_cast<int32_T>(localDW->obj_k.WaypointIndex) -
                            1)];
                        LLA0_gw[0] = waypoints->data[static_cast<int32_T>(
                            static_cast<int32_T>(localDW->obj_k.WaypointIndex +
                            1.0) - 1)];
                        Alt = waypoints->data[static_cast<int32_T>
                            (static_cast<int32_T>(static_cast<int32_T>
                              (localDW->obj_k.WaypointIndex) + waypoints->size[0])
                             - 1)];
                        LLA0_gw[1] = waypoints->data[static_cast<int32_T>(
                            static_cast<int32_T>(static_cast<int32_T>
                            (localDW->obj_k.WaypointIndex + 1.0) +
                            waypoints->size[0]) - 1)];
                        turnVector_idx_2 = waypoints->data[static_cast<int32_T>(
                            static_cast<int32_T>(static_cast<int32_T>
                            (waypoints->size[0] << 1) + static_cast<int32_T>
                            (localDW->obj_k.WaypointIndex)) - 1)];
                        LLA0_gw[2] = waypoints->data[static_cast<int32_T>(
                            static_cast<int32_T>(static_cast<int32_T>
                            (localDW->obj_k.WaypointIndex + 1.0) +
                            static_cast<int32_T>(waypoints->size[0] << 1)) - 1)];
                    }

                    rtb_Sum1_e_idx_1 = LLA0_gw[0] - distToCenter;
                    rtb_Switch_l = rtu_Pose[0] - distToCenter;
                    rtb_Sum1_e_idx_0 = LLA0_gw[1] - Alt;
                    Lon = rtu_Pose[1] - Alt;
                    distToCenter_tmp_0 = LLA0_gw[2] - turnVector_idx_2;
                    d = rtu_Pose[2] - turnVector_idx_2;
                    rtb_Abs1_il = ((Lon * rtb_Sum1_e_idx_0 + rtb_Switch_l *
                                    rtb_Sum1_e_idx_1) + d * distToCenter_tmp_0) /
                        ((rtb_Sum1_e_idx_0 * rtb_Sum1_e_idx_0 + rtb_Sum1_e_idx_1
                          * rtb_Sum1_e_idx_1) + distToCenter_tmp_0 *
                         distToCenter_tmp_0);
                    if (rtb_Abs1_il < 0.0) {
                        u[0] = rtb_Switch_l;
                        u[1] = Lon;
                        u[2] = d;
                        rtb_Abs1_il = FlightMissionMode_norm_pv(u);
                    } else if (rtb_Abs1_il > 1.0) {
                        u[0] = rtu_Pose[0] - LLA0_gw[0];
                        u[1] = rtu_Pose[1] - LLA0_gw[1];
                        u[2] = rtu_Pose[2] - LLA0_gw[2];
                        rtb_Abs1_il = FlightMissionMode_norm_pv(u);
                    } else {
                        u[0] = rtu_Pose[0] - (rtb_Abs1_il * rtb_Sum1_e_idx_1 +
                                              distToCenter);
                        u[1] = rtu_Pose[1] - (rtb_Abs1_il * rtb_Sum1_e_idx_0 +
                                              Alt);
                        u[2] = rtu_Pose[2] - (rtb_Abs1_il * distToCenter_tmp_0 +
                                              turnVector_idx_2);
                        rtb_Abs1_il = FlightMissionMode_norm_pv(u);
                    }

                    if (localDW->obj_k.LastWaypointFlag) {
                        rtb_Abs1_il = (((rtu_Pose[0] - distToCenter) * (LLA0_gw
                                         [0] - distToCenter) + Lon *
                                        rtb_Sum1_e_idx_0) + (rtu_Pose[2] -
                                        turnVector_idx_2) * (LLA0_gw[2] -
                                        turnVector_idx_2)) / (((LLA0_gw[0] -
                            distToCenter) * (LLA0_gw[0] - distToCenter) +
                            rtb_Sum1_e_idx_0 * rtb_Sum1_e_idx_0) + (LLA0_gw[2] -
                            turnVector_idx_2) * (LLA0_gw[2] - turnVector_idx_2));
                        u[0] = rtu_Pose[0] - (rtb_Abs1_il * rtb_Sum1_e_idx_1 +
                                              distToCenter);
                        u[1] = rtu_Pose[1] - (rtb_Abs1_il * rtb_Sum1_e_idx_0 +
                                              Alt);
                        u[2] = rtu_Pose[2] - (rtb_Abs1_il * distToCenter_tmp_0 +
                                              turnVector_idx_2);
                        rtb_Abs1_il = FlightMissionMode_norm_pv(u);
                    }

                    d = std::abs(rtb_Abs1_il);
                    if (static_cast<boolean_T>(static_cast<int32_T>
                                               (static_cast<int32_T>(std::isinf
                            (d)) | static_cast<int32_T>(std::isnan(d))))) {
                        Lon = (rtNaN);
                        rtb_Switch_l = (rtNaN);
                    } else if (d < 4.4501477170144028E-308) {
                        Lon = 4.94065645841247E-324;
                        rtb_Switch_l = 4.94065645841247E-324;
                    } else {
                        std::frexp(d, &rtb_Bias_mn);
                        Lon = std::ldexp(1.0, static_cast<int32_T>(rtb_Bias_mn -
                                          53));
                        std::frexp(d, &b_exponent);
                        rtb_Switch_l = std::ldexp(1.0, static_cast<int32_T>
                            (b_exponent - 53));
                    }

                    if (localDW->obj_k.LookaheadDistance <= std::fmax(std::sqrt
                            (Lon), 5.0 * rtb_Switch_l) + rtb_Abs1_il) {
                        localDW->obj_k.LookaheadDistance =
                            localDW->obj_k.LookaheadFactor * rtb_Abs1_il;
                    }

                    d = distToCenter - rtu_Pose[0];
                    rtb_Switch_l = Alt - rtu_Pose[1];
                    Lon = ((LLA0_gw[0] - distToCenter) * (LLA0_gw[0] -
                            distToCenter) + (LLA0_gw[1] - Alt) * (LLA0_gw[1] -
                            Alt)) + (LLA0_gw[2] - turnVector_idx_2) * (LLA0_gw[2]
                        - turnVector_idx_2);
                    xyCenter_idx_1 = turnVector_idx_2 - rtu_Pose[2];
                    rtb_Abs1_il = ((rtb_Sum1_e_idx_1 * d + rtb_Sum1_e_idx_0 *
                                    rtb_Switch_l) + distToCenter_tmp_0 *
                                   xyCenter_idx_1) * 2.0;
                    rtb_Switch_l = std::sqrt(rtb_Abs1_il * rtb_Abs1_il - (((d *
                        d + rtb_Switch_l * rtb_Switch_l) + xyCenter_idx_1 *
                        xyCenter_idx_1) - localDW->obj_k.LookaheadDistance *
                        localDW->obj_k.LookaheadDistance) * (4.0 * Lon));
                    Lon = std::fmax((-rtb_Abs1_il + rtb_Switch_l) / 2.0 / Lon, (
                                     -rtb_Abs1_il - rtb_Switch_l) / 2.0 / Lon);
                    LLA0_gw[2] = (1.0 - Lon) * turnVector_idx_2 + Lon * LLA0_gw
                        [2];
                    Lon = rt_atan2d_snf(((1.0 - Lon) * Alt + Lon * LLA0_gw[1]) -
                                        rtu_Pose[1], ((1.0 - Lon) * distToCenter
                                         + Lon * LLA0_gw[0]) - rtu_Pose[0]);
                    rtb_MergeStatus = 0U;
                    isStable = false;
                    if (localDW->obj_k.LastWaypointFlag) {
                        isStable = true;
                    }

                    if (isStable) {
                        rtb_MergeStatus = 1U;
                    }

                    localDW->obj_k.LastWaypointFlag = false;
                }
            }

            // Reshape: '<S36>/Reshape' incorporates:
            //   Constant: '<S36>/InitialFlightPathAngle'
            //   Constant: '<S36>/InitialRollAngle'
            //   Constant: '<S36>/InitialRollAngleRate'
            //   DataTypeConversion: '<S36>/Param4'
            //   Gain: '<S36>/Inverse'
            //   Selector: '<S36>/Selector'

            rty_InitialState[0] = localDW->nedWayPoint_o[0];
            rty_InitialState[1] = localDW->nedWayPoint_o[8192];
            rty_InitialState[2] = -localDW->nedWayPoint_o[16384];
            rty_InitialState[3] = static_cast<real_T>(rtu_Parameters->Param4);
            rty_InitialState[4] = Lat;
            rty_InitialState[5] = 0.0;
            rty_InitialState[6] = 0.0;
            rty_InitialState[7] = 0.0;

            // BusCreator: '<S36>/GuidanceCMDBusCreator' incorporates:
            //   DataTypeConversion: '<S36>/Param4'
            //   Gain: '<S36>/Down2Height'
            //   MATLABSystem: '<S36>/Waypoint Follower'

            rty_GuidanceCmds->Height = -LLA0_gw[2];
            rty_GuidanceCmds->AirSpeed = static_cast<real_T>
                (rtu_Parameters->Param4);
            rty_GuidanceCmds->HeadingAngle = Lon;

            // DataTypeConversion: '<S36>/Cast To Double' incorporates:
            //   MATLABSystem: '<S36>/Waypoint Follower'

            *rty_thisTaskStatus = static_cast<real_T>(rtb_MergeStatus);

            // End of Outputs for SubSystem: '<Root>/Mode2_HorzScanNav'
        }
        break;

      case 2:
        {
            real_T Lat;
            real_T rtb_Abs1_il;
            real_T rtb_Sum1_e_idx_0;
            real_T rtb_Sum1_e_idx_1;
            int32_T i;
            if (static_cast<int32_T>(rtAction) != static_cast<int32_T>
                    (rtPrevAction)) {
                FILE* a;

                // InitializeConditions for IfAction SubSystem: '<Root>/Mode3_RunWayNav' incorporates:
                //   ActionPort: '<S4>/Action Port'

                // InitializeConditions for SwitchCase: '<Root>/Switch Case' incorporates:
                //   Delay: '<S72>/Delay'

                std::memset(&localDW->Delay_DSTATE[0], 0, static_cast<uint32_T>
                            (24U * sizeof(real_T)));

                // End of InitializeConditions for SubSystem: '<Root>/Mode3_RunWayNav' 

                // SystemReset for IfAction SubSystem: '<Root>/Mode3_RunWayNav' incorporates:
                //   ActionPort: '<S4>/Action Port'

                // SystemReset for SwitchCase: '<Root>/Switch Case' incorporates:
                //   MATLAB Function: '<S75>/ReadHomePoint'

                localDW->HomePoint_not_empty_o = false;
                a = NULL;
                for (i = 0; i < 20; i++) {
                    localDW->eml_openfiles_d[i] = a;
                }

                // SystemReset for Atomic SubSystem: '<S72>/SegmentSwitch'
                FlightMissionMode_SegmentSwitch_Reset(&localDW->RunWayLineMode_o,
                    &localDW->SegmentSwitch);

                // End of SystemReset for SubSystem: '<S72>/SegmentSwitch'
                // End of SystemReset for SubSystem: '<Root>/Mode3_RunWayNav'
            }

            // Outputs for IfAction SubSystem: '<Root>/Mode3_RunWayNav' incorporates:
            //   ActionPort: '<S4>/Action Port'

            // MATLAB Function: '<S75>/ReadHomePoint'
            // MATLAB Function 'Mode3_RunWayNav/Mode3_Variant/Mode3/Location2XeHdg1/ReadHomePoint': '<S79>:1' 
            if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                    (localDW->HomePoint_not_empty_o) ^ 1))) {
                creal_T tmp_1;
                creal_T tmp_2;
                creal_T tmp_3;
                int32_T nv;
                int32_T stride;
                boolean_T exitg1;
                boolean_T guard1;

                // '<S79>:1:5'
                // '<S79>:1:6'
                tline->size[0] = 1;
                tline->size[1] = 0;
                rtPrevAction = FlightMissionMode_cfopen_d("config.ini", "rb",
                    localDW);
                if (static_cast<int32_T>(rtPrevAction) < 0) {
                    printf("INI-file \"%s\" was not found or could not be read.\n",
                           "config.ini");
                    fflush(stdout);
                } else {
                    FlightMissionMode_fread_ow(static_cast<real_T>(rtPrevAction),
                        q, localDW);
                    stride = static_cast<int32_T>(data->size[0] * data->size[1]);
                    data->size[0] = 1;
                    data->size[1] = q->size[0];
                    FlightMissionMode_emxEnsureCapacity_char_T_g(data, stride);
                    nv = q->size[0];
                    for (i = 0; i <= static_cast<int32_T>(nv - 1); i++) {
                        data->data[i] = q->data[i];
                    }

                    FlightMissionMode_cfclose_a(static_cast<real_T>(rtPrevAction),
                        localDW);
                    curSection->size[0] = 1;
                    curSection->size[1] = 0;
                    curKey->size[0] = 1;
                    curKey->size[1] = 0;
                    curVal->size[0] = 1;
                    curVal->size[1] = 0;
                    FlightMissionMode_emxInit_char_T_ey(&tmp_e, 2);
                    FlightMissionMode_emxInit_char_T_ey(&data_8, 2);
                    exitg1 = false;
                    while ((!exitg1) && (data->size[1] != 0)) {
                        stride = static_cast<int32_T>(data_8->size[0] *
                            data_8->size[1]);
                        data_8->size[0] = 1;
                        data_8->size[1] = data->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_g(data_8,
                            stride);
                        i = static_cast<int32_T>(static_cast<int32_T>(data->
                            size[0] * data->size[1]) - 1);
                        for (stride = 0; stride <= i; stride++) {
                            data_8->data[stride] = data->data[stride];
                        }

                        FlightMissionMode_strtok_d(data_8, curLine, data);
                        FlightMissionMode_strtok_dq(curLine, tmp_e);
                        FlightMissionMode_strtrim_f(tmp_e, curLine);
                        if (curLine->size[1] >= 2) {
                            isStable = false;
                            if (curLine->data[0] == '[') {
                                isStable = true;
                            }

                            guard1 = false;
                            if (isStable) {
                                isStable = false;
                                if (curLine->data[static_cast<int32_T>
                                        (curLine->size[1] - 1)] == ']') {
                                    isStable = true;
                                }

                                if (isStable) {
                                    if (static_cast<int32_T>(curLine->size[1] -
                                            1) < 2) {
                                        iy = 0;
                                        nread = 0;
                                    } else {
                                        iy = 1;
                                        nread = static_cast<int32_T>
                                            (curLine->size[1] - 1);
                                    }

                                    stride = static_cast<int32_T>
                                        (curSection->size[0] * curSection->size
                                         [1]);
                                    curSection->size[0] = 1;
                                    nv = static_cast<int32_T>(nread - iy);
                                    curSection->size[1] = nv;
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (curSection, stride);
                                    for (i = 0; i <= static_cast<int32_T>(nv - 1);
                                         i++) {
                                        curSection->data[i] = curLine->data[
                                            static_cast<int32_T>(iy + i)];
                                    }

                                    curKey->size[0] = 1;
                                    curKey->size[1] = 0;
                                } else {
                                    guard1 = true;
                                }
                            } else {
                                guard1 = true;
                            }

                            if (guard1) {
                                if (curLine->data[0] == ';') {
                                    isStable = true;
                                }

                                if ((static_cast<boolean_T>(static_cast<int32_T>
                                                            (static_cast<int32_T>
                                        (isStable) ^ 1))) &&
                                        FlightMissionMode_contains_d(curLine)) {
                                    FlightMissionMode_strtok_dq4(curLine, curVal,
                                        x);
                                    FlightMissionMode_find_token_m(x, &i1,
                                        &nread);
                                    if (i1 > static_cast<int32_T>(nread - 1)) {
                                        iy = 0;
                                        i1 = 0;
                                    } else {
                                        iy = static_cast<int32_T>(i1 - 1);
                                        i1 = static_cast<int32_T>(nread - 1);
                                    }

                                    FlightMissionMode_strtrim_f(curVal, curKey);
                                    stride = static_cast<int32_T>(curLine->size
                                        [0] * curLine->size[1]);
                                    curLine->size[0] = 1;
                                    nv = static_cast<int32_T>(i1 - iy);
                                    curLine->size[1] = nv;
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (curLine, stride);
                                    for (i = 0; i <= static_cast<int32_T>(nv - 1);
                                         i++) {
                                        curLine->data[i] = x->data
                                            [static_cast<int32_T>(iy + i)];
                                    }

                                    FlightMissionMode_strtrim_f(curLine, curVal);
                                }
                            }
                        }

                        if (FlightMissionMode_strcmp_b(curSection) &&
                                FlightMissionMode_strcmp_bx(curKey)) {
                            stride = static_cast<int32_T>(tline->size[0] *
                                tline->size[1]);
                            tline->size[0] = 1;
                            tline->size[1] = curVal->size[1];
                            FlightMissionMode_emxEnsureCapacity_char_T_g(tline,
                                stride);
                            nv = curVal->size[1];
                            for (i = 0; i <= static_cast<int32_T>(nv - 1); i++)
                            {
                                tline->data[i] = curVal->data[i];
                            }

                            exitg1 = true;
                        }
                    }

                    FlightMissionMode_emxFree_char_T_o(&data_8);
                    FlightMissionMode_emxFree_char_T_o(&tmp_e);
                }

                tmp_1 = FlightMissionMode_str2double_k(tline);
                printf("Set Home Point Latitude:\t%f\n", tmp_1.re);
                fflush(stdout);
                tline->size[0] = 1;
                tline->size[1] = 0;
                rtPrevAction = FlightMissionMode_cfopen_d("config.ini", "rb",
                    localDW);
                if (static_cast<int32_T>(rtPrevAction) < 0) {
                    printf("INI-file \"%s\" was not found or could not be read.\n",
                           "config.ini");
                    fflush(stdout);
                } else {
                    FlightMissionMode_fread_ow(static_cast<real_T>(rtPrevAction),
                        q, localDW);
                    stride = static_cast<int32_T>(data->size[0] * data->size[1]);
                    data->size[0] = 1;
                    data->size[1] = q->size[0];
                    FlightMissionMode_emxEnsureCapacity_char_T_g(data, stride);
                    nv = q->size[0];
                    for (i = 0; i <= static_cast<int32_T>(nv - 1); i++) {
                        data->data[i] = q->data[i];
                    }

                    FlightMissionMode_cfclose_a(static_cast<real_T>(rtPrevAction),
                        localDW);
                    curSection->size[0] = 1;
                    curSection->size[1] = 0;
                    curKey->size[0] = 1;
                    curKey->size[1] = 0;
                    curVal->size[0] = 1;
                    curVal->size[1] = 0;
                    FlightMissionMode_emxInit_char_T_ey(&tmp_d, 2);
                    FlightMissionMode_emxInit_char_T_ey(&data_7, 2);
                    exitg1 = false;
                    while ((!exitg1) && (data->size[1] != 0)) {
                        stride = static_cast<int32_T>(data_7->size[0] *
                            data_7->size[1]);
                        data_7->size[0] = 1;
                        data_7->size[1] = data->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_g(data_7,
                            stride);
                        i = static_cast<int32_T>(static_cast<int32_T>(data->
                            size[0] * data->size[1]) - 1);
                        for (stride = 0; stride <= i; stride++) {
                            data_7->data[stride] = data->data[stride];
                        }

                        FlightMissionMode_strtok_d(data_7, curLine, data);
                        FlightMissionMode_strtok_dq(curLine, tmp_d);
                        FlightMissionMode_strtrim_f(tmp_d, curLine);
                        if (curLine->size[1] >= 2) {
                            isStable = false;
                            if (curLine->data[0] == '[') {
                                isStable = true;
                            }

                            guard1 = false;
                            if (isStable) {
                                isStable = false;
                                if (curLine->data[static_cast<int32_T>
                                        (curLine->size[1] - 1)] == ']') {
                                    isStable = true;
                                }

                                if (isStable) {
                                    int32_T ntoread;
                                    if (static_cast<int32_T>(curLine->size[1] -
                                            1) < 2) {
                                        i1 = 0;
                                        ntoread = 0;
                                    } else {
                                        i1 = 1;
                                        ntoread = static_cast<int32_T>
                                            (curLine->size[1] - 1);
                                    }

                                    stride = static_cast<int32_T>
                                        (curSection->size[0] * curSection->size
                                         [1]);
                                    curSection->size[0] = 1;
                                    nv = static_cast<int32_T>(ntoread - i1);
                                    curSection->size[1] = nv;
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (curSection, stride);
                                    for (i = 0; i <= static_cast<int32_T>(nv - 1);
                                         i++) {
                                        curSection->data[i] = curLine->data[
                                            static_cast<int32_T>(i1 + i)];
                                    }

                                    curKey->size[0] = 1;
                                    curKey->size[1] = 0;
                                } else {
                                    guard1 = true;
                                }
                            } else {
                                guard1 = true;
                            }

                            if (guard1) {
                                if (curLine->data[0] == ';') {
                                    isStable = true;
                                }

                                if ((static_cast<boolean_T>(static_cast<int32_T>
                                                            (static_cast<int32_T>
                                        (isStable) ^ 1))) &&
                                        FlightMissionMode_contains_d(curLine)) {
                                    FlightMissionMode_strtok_dq4(curLine, curVal,
                                        x);
                                    FlightMissionMode_find_token_m(x, &iy,
                                        &nread);
                                    if (iy > static_cast<int32_T>(nread - 1)) {
                                        iy = 0;
                                        nread = 0;
                                    } else {
                                        iy = static_cast<int32_T>(iy - 1);
                                        nread = static_cast<int32_T>(nread - 1);
                                    }

                                    FlightMissionMode_strtrim_f(curVal, curKey);
                                    stride = static_cast<int32_T>(curLine->size
                                        [0] * curLine->size[1]);
                                    curLine->size[0] = 1;
                                    nv = static_cast<int32_T>(nread - iy);
                                    curLine->size[1] = nv;
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (curLine, stride);
                                    for (i = 0; i <= static_cast<int32_T>(nv - 1);
                                         i++) {
                                        curLine->data[i] = x->data
                                            [static_cast<int32_T>(iy + i)];
                                    }

                                    FlightMissionMode_strtrim_f(curLine, curVal);
                                }
                            }
                        }

                        if (FlightMissionMode_strcmp_b(curSection) &&
                                FlightMissionMode_strcmp_bxk(curKey)) {
                            stride = static_cast<int32_T>(tline->size[0] *
                                tline->size[1]);
                            tline->size[0] = 1;
                            tline->size[1] = curVal->size[1];
                            FlightMissionMode_emxEnsureCapacity_char_T_g(tline,
                                stride);
                            nv = curVal->size[1];
                            for (i = 0; i <= static_cast<int32_T>(nv - 1); i++)
                            {
                                tline->data[i] = curVal->data[i];
                            }

                            exitg1 = true;
                        }
                    }

                    FlightMissionMode_emxFree_char_T_o(&data_7);
                    FlightMissionMode_emxFree_char_T_o(&tmp_d);
                }

                tmp_2 = FlightMissionMode_str2double_k(tline);
                printf("Set Home Point Longitude:\t%f\n", tmp_2.re);
                fflush(stdout);
                tline->size[0] = 1;
                tline->size[1] = 0;
                rtPrevAction = FlightMissionMode_cfopen_d("config.ini", "rb",
                    localDW);
                if (static_cast<int32_T>(rtPrevAction) < 0) {
                    printf("INI-file \"%s\" was not found or could not be read.\n",
                           "config.ini");
                    fflush(stdout);
                } else {
                    FlightMissionMode_fread_ow(static_cast<real_T>(rtPrevAction),
                        q, localDW);
                    stride = static_cast<int32_T>(data->size[0] * data->size[1]);
                    data->size[0] = 1;
                    data->size[1] = q->size[0];
                    FlightMissionMode_emxEnsureCapacity_char_T_g(data, stride);
                    nv = q->size[0];
                    for (i = 0; i <= static_cast<int32_T>(nv - 1); i++) {
                        data->data[i] = q->data[i];
                    }

                    FlightMissionMode_cfclose_a(static_cast<real_T>(rtPrevAction),
                        localDW);
                    curSection->size[0] = 1;
                    curSection->size[1] = 0;
                    curKey->size[0] = 1;
                    curKey->size[1] = 0;
                    curVal->size[0] = 1;
                    curVal->size[1] = 0;
                    FlightMissionMode_emxInit_char_T_ey(&tmp_c, 2);
                    FlightMissionMode_emxInit_char_T_ey(&data_6, 2);
                    exitg1 = false;
                    while ((!exitg1) && (data->size[1] != 0)) {
                        stride = static_cast<int32_T>(data_6->size[0] *
                            data_6->size[1]);
                        data_6->size[0] = 1;
                        data_6->size[1] = data->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_g(data_6,
                            stride);
                        i = static_cast<int32_T>(static_cast<int32_T>(data->
                            size[0] * data->size[1]) - 1);
                        for (stride = 0; stride <= i; stride++) {
                            data_6->data[stride] = data->data[stride];
                        }

                        FlightMissionMode_strtok_d(data_6, curLine, data);
                        FlightMissionMode_strtok_dq(curLine, tmp_c);
                        FlightMissionMode_strtrim_f(tmp_c, curLine);
                        if (curLine->size[1] >= 2) {
                            isStable = false;
                            if (curLine->data[0] == '[') {
                                isStable = true;
                            }

                            guard1 = false;
                            if (isStable) {
                                isStable = false;
                                if (curLine->data[static_cast<int32_T>
                                        (curLine->size[1] - 1)] == ']') {
                                    isStable = true;
                                }

                                if (isStable) {
                                    if (static_cast<int32_T>(curLine->size[1] -
                                            1) < 2) {
                                        iy = 0;
                                        i2 = 0;
                                    } else {
                                        iy = 1;
                                        i2 = static_cast<int32_T>(curLine->size
                                            [1] - 1);
                                    }

                                    stride = static_cast<int32_T>
                                        (curSection->size[0] * curSection->size
                                         [1]);
                                    curSection->size[0] = 1;
                                    nv = static_cast<int32_T>(i2 - iy);
                                    curSection->size[1] = nv;
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (curSection, stride);
                                    for (i = 0; i <= static_cast<int32_T>(nv - 1);
                                         i++) {
                                        curSection->data[i] = curLine->data[
                                            static_cast<int32_T>(iy + i)];
                                    }

                                    curKey->size[0] = 1;
                                    curKey->size[1] = 0;
                                } else {
                                    guard1 = true;
                                }
                            } else {
                                guard1 = true;
                            }

                            if (guard1) {
                                if (curLine->data[0] == ';') {
                                    isStable = true;
                                }

                                if ((static_cast<boolean_T>(static_cast<int32_T>
                                                            (static_cast<int32_T>
                                        (isStable) ^ 1))) &&
                                        FlightMissionMode_contains_d(curLine)) {
                                    int32_T n;
                                    FlightMissionMode_strtok_dq4(curLine, curVal,
                                        x);
                                    FlightMissionMode_find_token_m(x, &iy,
                                        &nread);
                                    if (iy > static_cast<int32_T>(nread - 1)) {
                                        n = 0;
                                        i = 0;
                                    } else {
                                        n = static_cast<int32_T>(iy - 1);
                                        i = static_cast<int32_T>(nread - 1);
                                    }

                                    FlightMissionMode_strtrim_f(curVal, curKey);
                                    stride = static_cast<int32_T>(curLine->size
                                        [0] * curLine->size[1]);
                                    curLine->size[0] = 1;
                                    nv = static_cast<int32_T>(i - n);
                                    curLine->size[1] = nv;
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (curLine, stride);
                                    for (i = 0; i <= static_cast<int32_T>(nv - 1);
                                         i++) {
                                        curLine->data[i] = x->data
                                            [static_cast<int32_T>(n + i)];
                                    }

                                    FlightMissionMode_strtrim_f(curLine, curVal);
                                }
                            }
                        }

                        if (FlightMissionMode_strcmp_b(curSection) &&
                                FlightMissionMode_strcmp_bxki(curKey)) {
                            stride = static_cast<int32_T>(tline->size[0] *
                                tline->size[1]);
                            tline->size[0] = 1;
                            tline->size[1] = curVal->size[1];
                            FlightMissionMode_emxEnsureCapacity_char_T_g(tline,
                                stride);
                            nv = curVal->size[1];
                            for (i = 0; i <= static_cast<int32_T>(nv - 1); i++)
                            {
                                tline->data[i] = curVal->data[i];
                            }

                            exitg1 = true;
                        }
                    }

                    FlightMissionMode_emxFree_char_T_o(&data_6);
                    FlightMissionMode_emxFree_char_T_o(&tmp_c);
                }

                tmp_3 = FlightMissionMode_str2double_k(tline);
                printf("Set Home Point Altitude:\t%f\n", tmp_3.re);
                fflush(stdout);
                localDW->HomePoint_o[0] = tmp_1.re;
                localDW->HomePoint_o[1] = tmp_2.re;
                localDW->HomePoint_o[2] = tmp_3.re;
                localDW->HomePoint_not_empty_o = true;
                b_x[0] = std::isnan(localDW->HomePoint_o[0]);
                b_x[1] = std::isnan(localDW->HomePoint_o[1]);
                b_x[2] = std::isnan(localDW->HomePoint_o[2]);
                isStable = false;
                nread = 0;
                exitg1 = false;
                while ((!exitg1) && (nread < 3)) {
                    if (b_x[nread]) {
                        isStable = true;
                        exitg1 = true;
                    } else {
                        nread = static_cast<int32_T>(nread + 1);
                    }
                }

                if (isStable) {
                    // '<S79>:1:7'
                    // '<S79>:1:8'
                    localDW->HomePoint_o[0] = 35.8617;
                    localDW->HomePoint_o[1] = 104.1954;
                    localDW->HomePoint_o[2] = 0.0;
                }
            }

            // Switch: '<S93>/Switch' incorporates:
            //   Abs: '<S93>/Abs'
            //   Bias: '<S93>/Bias'
            //   Bias: '<S93>/Bias1'
            //   Constant: '<S93>/Constant2'
            //   Constant: '<S94>/Constant'
            //   MATLAB Function: '<S75>/ReadHomePoint'
            //   Math: '<S93>/Math Function1'
            //   RelationalOperator: '<S94>/Compare'

            // '<S79>:1:12'
            if (std::abs(localDW->HomePoint_o[0]) > 180.0) {
                Alt = rt_modd_snf(localDW->HomePoint_o[0] + 180.0, 360.0) -
                    180.0;
            } else {
                Alt = localDW->HomePoint_o[0];
            }

            // End of Switch: '<S93>/Switch'

            // Abs: '<S90>/Abs1'
            rtb_Abs1_il = std::abs(Alt);

            // Switch: '<S90>/Switch' incorporates:
            //   Bias: '<S90>/Bias'
            //   Bias: '<S90>/Bias1'
            //   Constant: '<S81>/Constant'
            //   Constant: '<S81>/Constant1'
            //   Constant: '<S92>/Constant'
            //   Gain: '<S90>/Gain'
            //   Product: '<S90>/Divide1'
            //   RelationalOperator: '<S92>/Compare'
            //   Signum: '<S90>/Sign1'
            //   Switch: '<S81>/Switch1'

            if (rtb_Abs1_il > 90.0) {
                // Signum: '<S90>/Sign1'
                if (std::isnan(Alt)) {
                    rtb_Sum1_e_idx_0 = (rtNaN);
                } else if (Alt < 0.0) {
                    rtb_Sum1_e_idx_0 = -1.0;
                } else {
                    rtb_Sum1_e_idx_0 = static_cast<real_T>(Alt > 0.0);
                }

                Alt = (-(rtb_Abs1_il - 90.0) + 90.0) * rtb_Sum1_e_idx_0;
                i = 180;
            } else {
                i = 0;
            }

            // End of Switch: '<S90>/Switch'

            // Sum: '<S81>/Sum' incorporates:
            //   MATLAB Function: '<S75>/ReadHomePoint'
            //   Switch: '<S81>/Switch1'

            rtb_Switch_l = static_cast<real_T>(i) + localDW->HomePoint_o[1];

            // Switch: '<S91>/Switch' incorporates:
            //   Abs: '<S91>/Abs'
            //   Bias: '<S91>/Bias'
            //   Bias: '<S91>/Bias1'
            //   Constant: '<S91>/Constant2'
            //   Constant: '<S95>/Constant'
            //   Math: '<S91>/Math Function1'
            //   RelationalOperator: '<S95>/Compare'

            if (std::abs(rtb_Switch_l) > 180.0) {
                rtb_Switch_l = rt_modd_snf(rtb_Switch_l + 180.0, 360.0) - 180.0;
            }

            // End of Switch: '<S91>/Switch'

            // Sum: '<S78>/Sum1'
            rtb_Sum1_e_idx_0 = rtu_MissionLocation->Lat - Alt;
            rtb_Sum1_e_idx_1 = rtu_MissionLocation->Lon - rtb_Switch_l;

            // Switch: '<S87>/Switch' incorporates:
            //   Abs: '<S87>/Abs'
            //   Bias: '<S87>/Bias'
            //   Bias: '<S87>/Bias1'
            //   Constant: '<S87>/Constant2'
            //   Constant: '<S88>/Constant'
            //   Math: '<S87>/Math Function1'
            //   RelationalOperator: '<S88>/Compare'

            if (std::abs(rtb_Sum1_e_idx_0) > 180.0) {
                rtb_Switch_l = rt_modd_snf(rtb_Sum1_e_idx_0 + 180.0, 360.0) -
                    180.0;
            } else {
                rtb_Switch_l = rtb_Sum1_e_idx_0;
            }

            // End of Switch: '<S87>/Switch'

            // Abs: '<S84>/Abs1'
            rtb_Abs1_il = std::abs(rtb_Switch_l);

            // Switch: '<S84>/Switch' incorporates:
            //   Bias: '<S84>/Bias'
            //   Bias: '<S84>/Bias1'
            //   Constant: '<S80>/Constant'
            //   Constant: '<S80>/Constant1'
            //   Constant: '<S86>/Constant'
            //   Gain: '<S84>/Gain'
            //   Product: '<S84>/Divide1'
            //   RelationalOperator: '<S86>/Compare'
            //   Signum: '<S84>/Sign1'
            //   Switch: '<S80>/Switch1'

            if (rtb_Abs1_il > 90.0) {
                // Signum: '<S84>/Sign1'
                if (std::isnan(rtb_Switch_l)) {
                    rtb_Sum1_e_idx_0 = (rtNaN);
                } else if (rtb_Switch_l < 0.0) {
                    rtb_Sum1_e_idx_0 = -1.0;
                } else {
                    rtb_Sum1_e_idx_0 = static_cast<real_T>(rtb_Switch_l > 0.0);
                }

                rtb_Switch_l = (-(rtb_Abs1_il - 90.0) + 90.0) * rtb_Sum1_e_idx_0;
                i = 180;
            } else {
                i = 0;
            }

            // End of Switch: '<S84>/Switch'

            // Sum: '<S80>/Sum' incorporates:
            //   Switch: '<S80>/Switch1'

            Lat = static_cast<real_T>(i) + rtb_Sum1_e_idx_1;

            // Switch: '<S85>/Switch' incorporates:
            //   Abs: '<S85>/Abs'
            //   Bias: '<S85>/Bias'
            //   Bias: '<S85>/Bias1'
            //   Constant: '<S85>/Constant2'
            //   Constant: '<S89>/Constant'
            //   Math: '<S85>/Math Function1'
            //   RelationalOperator: '<S89>/Compare'

            if (std::abs(Lat) > 180.0) {
                Lat = rt_modd_snf(Lat + 180.0, 360.0) - 180.0;
            }

            // End of Switch: '<S85>/Switch'

            // UnitConversion: '<S83>/Unit Conversion'
            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            rtb_Sum1_e_idx_0 = 0.017453292519943295 * rtb_Switch_l;
            rtb_Sum1_e_idx_1 = 0.017453292519943295 * Lat;

            // UnitConversion: '<S98>/Unit Conversion'
            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            Alt *= 0.017453292519943295;

            // Trigonometry: '<S99>/Trigonometric Function1'
            Lat = std::sin(Alt);

            // Sum: '<S99>/Sum1' incorporates:
            //   Constant: '<S99>/Constant'
            //   Product: '<S99>/Product1'

            Lat = 1.0 - 0.0066943799901413295 * Lat * Lat;

            // Product: '<S97>/Product1' incorporates:
            //   Constant: '<S97>/Constant1'
            //   Sqrt: '<S97>/sqrt'

            rtb_Switch_l = 6.378137E+6 / std::sqrt(Lat);

            // Product: '<S82>/dNorth' incorporates:
            //   Constant: '<S97>/Constant2'
            //   Product: '<S97>/Product3'
            //   Trigonometry: '<S97>/Trigonometric Function1'

            Lat = rtb_Sum1_e_idx_0 / rt_atan2d_snf(1.0, rtb_Switch_l *
                0.99330562000985867 / Lat);

            // Product: '<S82>/dEast' incorporates:
            //   Constant: '<S97>/Constant3'
            //   Product: '<S97>/Product4'
            //   Trigonometry: '<S97>/Trigonometric Function'
            //   Trigonometry: '<S97>/Trigonometric Function2'

            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            rtb_Switch_l = 1.0 / rt_atan2d_snf(1.0, rtb_Switch_l * std::cos(Alt))
                * rtb_Sum1_e_idx_1;

            // Sum: '<S78>/Sum' incorporates:
            //   MATLAB Function: '<S75>/ReadHomePoint'

            Alt = rtu_MissionLocation->Alt - localDW->HomePoint_o[2];

            // Gain: '<S74>/Gain1'
            d = 0.017453292519943295 * rtu_MissionLocation->degHDG;

            // Outputs for Enabled SubSystem: '<S72>/WayPointGenerator' incorporates:
            //   EnablePort: '<S77>/Enable'

            if (*rtu_Reset) {
                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>
                                            (localDW->WayPointGenerator_MODE_k) ^
                      1))) {
                    // SystemReset for MATLAB Function: '<S77>/StartPointGenerator' 
                    FlightMissionMode_StartPointGenerator_Reset
                        (&localDW->sf_StartPointGenerator);

                    // SystemReset for MATLAB Function: '<S77>/WayPointGenerator' 
                    FlightMissionMode_WayPointGenerator_Reset
                        (&localDW->sf_WayPointGenerator);
                    localDW->WayPointGenerator_MODE_k = true;
                }

                // DataTypeConversion: '<S77>/DoubleMissionUAV'
                distToCenter = static_cast<real_T>(*rtu_MissionUAV);

                // DataTypeConversion: '<S77>/Cast To Double'
                rtb_Abs1_il = static_cast<real_T>(*rtu_FormationIDX);

                // MATLAB Function: '<S77>/StartPointGenerator' incorporates:
                //   Concatenate: '<S77>/Matrix Concatenate WayPoint'
                //   DataTypeConversion: '<S72>/Param3'

                FlightMissionMode_StartPointGenerator(static_cast<real_T>
                    (rtu_Parameters->Param3), distToCenter, rtb_Abs1_il,
                    &localDW->MatrixConcatenateWayPoint_g[1536],
                    localDW->startPose_a, &localDW->sf_StartPointGenerator);

                // MATLAB Function: '<S77>/WayPointGenerator' incorporates:
                //   Concatenate: '<S77>/Matrix Concatenate WayPoint'
                //   DataTypeConversion: '<S72>/Param3'

                FlightMissionMode_WayPointGenerator(static_cast<real_T>
                    (rtu_Parameters->Param3),
                    &localDW->MatrixConcatenateWayPoint_g[0],
                    &localDW->MatrixConcatenateWayPoint_g[384],
                    &localDW->MatrixConcatenateWayPoint_g[768],
                    &localDW->MatrixConcatenateWayPoint_g[1152],
                    &localDW->sf_WayPointGenerator);

                // SignalConversion generated from: '<S77>/RotateUpward' incorporates:
                //   Constant: '<S77>/Constant'
                //   Constant: '<S77>/Zero'

                rtb_TmpSignalConversionAtRotateUpwardInport1[0] = 0.0;
                rtb_TmpSignalConversionAtRotateUpwardInport1[1] = 0.0;
                rtb_TmpSignalConversionAtRotateUpwardInport1[2] =
                    0.034906585039886591;
                FlightMissionMode_RotateATMissionHdg
                    (rtb_TmpSignalConversionAtRotateUpwardInport1,
                     &localDW->RotateUpward);

                // Product: '<S77>/IndivRunwayRotAng' incorporates:
                //   DataTypeConversion: '<S72>/Param2'
                //   DataTypeConversion: '<S72>/Param5'
                //   Gain: '<S108>/Gain1'
                //   Gain: '<S77>/Gain'

                distToCenter = 0.5 * static_cast<real_T>(rtu_Parameters->Param2)
                    * 0.017453292519943295 * static_cast<real_T>
                    (rtu_Parameters->Param5);

                // SignalConversion generated from: '<S77>/RotateATRunWayHdg' incorporates:
                //   Constant: '<S77>/Zero'

                rtb_TmpSignalConversionAtRotateATRunWayHdgInport1_l[0] =
                    distToCenter;
                rtb_TmpSignalConversionAtRotateATRunWayHdgInport1_l[1] = 0.0;
                rtb_TmpSignalConversionAtRotateATRunWayHdgInport1_l[2] = 0.0;
                FlightMissionMode_RotateATMissionHdg
                    (rtb_TmpSignalConversionAtRotateATRunWayHdgInport1_l,
                     &localDW->RotateATRunWayHdg);

                // SignalConversion generated from: '<S77>/RotateATMissionHdg' incorporates:
                //   Constant: '<S77>/Zero'

                rtb_TmpSignalConversionAtRotateATMissionHdgInport1_p[0] = d;
                rtb_TmpSignalConversionAtRotateATMissionHdgInport1_p[1] = 0.0;
                rtb_TmpSignalConversionAtRotateATMissionHdgInport1_p[2] = 0.0;
                FlightMissionMode_RotateATMissionHdg
                    (rtb_TmpSignalConversionAtRotateATMissionHdgInport1_p,
                     &localDW->RotateATMissionHdg_m);

                // Reshape: '<S77>/Reshape' incorporates:
                //   Constant: '<S77>/Zero'
                //   DataTypeConversion: '<S72>/Param1'

                u[0] = static_cast<real_T>(rtu_Parameters->Param1);
                u[1] = 0.0;
                u[2] = 0.0;

                // Reshape: '<S77>/ReshapeRowVecStartpose' incorporates:
                //   Product: '<S82>/x*cos'
                //   Product: '<S82>/x*sin'
                //   Product: '<S82>/y*cos'
                //   Product: '<S82>/y*sin'
                //   Sum: '<S82>/Sum2'
                //   Sum: '<S82>/Sum3'
                //   UnaryMinus: '<S78>/Ze2height'

                LLA0_gw[0] = rtb_Switch_l * 0.0 + Lat;
                LLA0_gw[1] = rtb_Switch_l - Lat * 0.0;
                LLA0_gw[2] = -Alt;

                // Outputs for Iterator SubSystem: '<S77>/TransformWayPoint' incorporates:
                //   ForEach: '<S110>/For Each'

                for (iy = 0; iy < 5; iy++) {
                    // ForEachSliceSelector generated from: '<S110>/RawRunWay' incorporates:
                    //   Concatenate: '<S77>/Matrix Concatenate WayPoint'

                    std::memcpy
                        (&rtb_ImpSel_InsertedFor_RawRunWay_at_outport_0_k[0],
                         &localDW->MatrixConcatenateWayPoint_g
                         [static_cast<int32_T>(iy * 384)], static_cast<uint32_T>
                         (384U * sizeof(real_T)));

                    // MATLAB Function: '<S110>/minus'
                    FlightMissionMode_minus
                        (rtb_ImpSel_InsertedFor_RawRunWay_at_outport_0_k, u,
                         rtb_y);

                    // Product: '<S110>/Matrix Divide' incorporates:
                    //   MATLABSystem: '<S77>/RotateATMissionHdg'
                    //   MATLABSystem: '<S77>/RotateATRunWayHdg'
                    //   MATLABSystem: '<S77>/RotateUpward'

                    rt_invd3x3_snf
                        (localDW->RotateATMissionHdg_m.RotateATMissionHdg, tmp);
                    rt_mldivided3x3_snf
                        (localDW->RotateATRunWayHdg.RotateATMissionHdg, tmp,
                         tmp_i);
                    rt_mldivided3x3_snf(localDW->RotateUpward.RotateATMissionHdg,
                                        tmp_i, tmp);
                    for (i = 0; i < 128; i++) {
                        // Product: '<S110>/Matrix Divide'
                        i1 = 0;
                        i2 = 0;
                        for (rtb_Bias_mn = 0; rtb_Bias_mn < 3; rtb_Bias_mn++) {
                            b_exponent = static_cast<int32_T>(i1 + i);
                            rtb_MatrixDivide_g[b_exponent] = 0.0;
                            rtb_MatrixDivide_g[b_exponent] += tmp[i2] * rtb_y[i];
                            rtb_MatrixDivide_g[b_exponent] += tmp
                                [static_cast<int32_T>(i2 + 1)] * rtb_y[
                                static_cast<int32_T>(i + 128)];
                            rtb_MatrixDivide_g[b_exponent] += tmp
                                [static_cast<int32_T>(i2 + 2)] * rtb_y[
                                static_cast<int32_T>(i + 256)];
                            i1 = static_cast<int32_T>(i1 + 128);
                            i2 = static_cast<int32_T>(i2 + 3);
                        }

                        // End of Product: '<S110>/Matrix Divide'
                    }

                    // MATLAB Function: '<S110>/biasNED'
                    FlightMissionMode_biasNED(LLA0_gw, rtb_MatrixDivide_g,
                        rtb_nedWayPoint_CoreSubsysCanOut_b);

                    // ForEachSliceAssignment generated from: '<S110>/nedWayPoint' 
                    std::memcpy
                        (&localDW->ImpAsg_InsertedFor_nedWayPoint_at_inport_0_c[
                         static_cast<int32_T>(iy * 384)],
                         &rtb_nedWayPoint_CoreSubsysCanOut_b[0],
                         static_cast<uint32_T>(384U * sizeof(real_T)));
                }

                // End of Outputs for SubSystem: '<S77>/TransformWayPoint'

                // Product: '<S77>/Matrix Divide' incorporates:
                //   MATLABSystem: '<S77>/RotateATMissionHdg'
                //   MATLABSystem: '<S77>/RotateATRunWayHdg'
                //   MATLABSystem: '<S77>/RotateUpward'

                rt_invd3x3_snf(localDW->RotateATMissionHdg_m.RotateATMissionHdg,
                               tmp);
                rt_mldivided3x3_snf
                    (localDW->RotateATRunWayHdg.RotateATMissionHdg, tmp, tmp_i);
                rt_mldivided3x3_snf(localDW->RotateUpward.RotateATMissionHdg,
                                    tmp_i, tmp);

                // Sum: '<S77>/BiasStartPose1' incorporates:
                //   DataTypeConversion: '<S72>/Param1'

                Lat = localDW->startPose_a[0] - static_cast<real_T>
                    (rtu_Parameters->Param1);
                rtb_Abs1_il = localDW->startPose_a[1];
                rtb_Switch_l = localDW->startPose_a[2];

                // Product: '<S77>/Matrix Divide'
                i = 0;
                for (i1 = 0; i1 < 3; i1++) {
                    u[i1] = 0.0;
                    u[i1] += tmp[i] * Lat;
                    u[i1] += tmp[static_cast<int32_T>(i + 1)] * rtb_Abs1_il;
                    u[i1] += tmp[static_cast<int32_T>(i + 2)] * rtb_Switch_l;
                    i = static_cast<int32_T>(i + 3);
                }

                // MATLAB Function: '<S77>/biasNEDstartpose'
                FlightMissionMode_biasNEDstartpose(LLA0_gw, u,
                    localDW->nedWayPoint_j);

                // Sum: '<S77>/Sum'
                localDW->Sum_i = (d + distToCenter) + localDW->startPose_a[3];
            } else {
                localDW->WayPointGenerator_MODE_k = false;
            }

            // End of Outputs for SubSystem: '<S72>/WayPointGenerator'

            // Reshape: '<S72>/Reshape' incorporates:
            //   Constant: '<S72>/InitialFlightPathAngle'
            //   Constant: '<S72>/InitialRollAngleRate'
            //   DataTypeConversion: '<S72>/Param4'
            //   Gain: '<S72>/Down2Up'

            rty_InitialState[0] = localDW->nedWayPoint_j[0];
            rty_InitialState[1] = localDW->nedWayPoint_j[1];
            rty_InitialState[2] = -localDW->nedWayPoint_j[2];
            rty_InitialState[3] = static_cast<real_T>(rtu_Parameters->Param4);
            rty_InitialState[4] = localDW->Sum_i;
            rty_InitialState[5] = 0.0;
            rty_InitialState[6] = localDW->startPose_a[4];
            rty_InitialState[7] = 0.0;

            // Outputs for Atomic SubSystem: '<S72>/SegmentSwitch'
            FlightMissionMode_SegmentSwitch(rtu_Reset, rtu_Pose,
                localDW->ImpAsg_InsertedFor_nedWayPoint_at_inport_0_c,
                localDW->MergeLookAheadP_j, &localDW->MergeDesiredCourse_p,
                &localDW->RunWayLineMode_o, 200.0, &localDW->SegmentSwitch);

            // End of Outputs for SubSystem: '<S72>/SegmentSwitch'

            // Switch: '<S72>/Switch' incorporates:
            //   Constant: '<S73>/Constant'
            //   DataTypeConversion: '<S72>/Cast To Double'
            //   Delay: '<S72>/Delay'
            //   RelationalOperator: '<S73>/Compare'

            if (static_cast<int32_T>(localDW->RunWayLineMode_o) == 2) {
                *rty_thisTaskStatus = 2.0;
            } else {
                *rty_thisTaskStatus = localDW->Delay_DSTATE[0];
            }

            // End of Switch: '<S72>/Switch'

            // BusCreator: '<S72>/GuidanceCMDBusCreator1' incorporates:
            //   DataTypeConversion: '<S72>/Param4'
            //   Gain: '<S72>/Down2Height1'

            rty_GuidanceCmds->Height = -localDW->MergeLookAheadP_j[2];
            rty_GuidanceCmds->AirSpeed = static_cast<real_T>
                (rtu_Parameters->Param4);
            rty_GuidanceCmds->HeadingAngle = localDW->MergeDesiredCourse_p;

            // Update for Delay: '<S72>/Delay' incorporates:
            //   Bias: '<S9>/Bias'
            //   DataTypeConversion: '<S72>/Cast To Double'

            for (rtb_Bias_mn = 0; rtb_Bias_mn < 23; rtb_Bias_mn++) {
                localDW->Delay_DSTATE[rtb_Bias_mn] = localDW->Delay_DSTATE[
                    static_cast<int_T>(rtb_Bias_mn + 1)];
            }

            localDW->Delay_DSTATE[23] = static_cast<real_T>
                (localDW->RunWayLineMode_o);

            // End of Update for Delay: '<S72>/Delay'
            // End of Outputs for SubSystem: '<Root>/Mode3_RunWayNav'
        }
        break;

      case 3:
        {
            real_T Lat;
            real_T rtb_Abs1_il;
            real_T rtb_Sum1_e_idx_0;
            real_T rtb_Sum1_e_idx_1;
            int32_T i;
            if (static_cast<int32_T>(rtAction) != static_cast<int32_T>
                    (rtPrevAction)) {
                FILE* a;

                // SystemReset for IfAction SubSystem: '<Root>/Mode44_ProtLine' incorporates:
                //   ActionPort: '<S5>/Action Port'

                // SystemReset for SwitchCase: '<Root>/Switch Case' incorporates:
                //   MATLAB Function: '<S118>/ReadHomePoint'

                localDW->HomePoint_not_empty = false;
                a = NULL;
                for (i = 0; i < 20; i++) {
                    localDW->eml_openfiles_bx[i] = a;
                }

                // SystemReset for Atomic SubSystem: '<S116>/SegmentSwitch'
                FlightMissionMode_SegmentSwitch_Reset(&localDW->RunWayLineMode,
                    &localDW->SegmentSwitch_p);

                // End of SystemReset for SubSystem: '<S116>/SegmentSwitch'
                // End of SystemReset for SubSystem: '<Root>/Mode44_ProtLine'
            }

            // Outputs for IfAction SubSystem: '<Root>/Mode44_ProtLine' incorporates:
            //   ActionPort: '<S5>/Action Port'

            // MATLAB Function: '<S118>/ReadHomePoint'
            // MATLAB Function 'Mode44_ProtLine/Mode44_Variant/Mode44/Location2XeHdg1/ReadHomePoint': '<S123>:1' 
            if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                    (localDW->HomePoint_not_empty) ^ 1))) {
                creal_T tmp_1;
                creal_T tmp_2;
                creal_T tmp_3;
                int32_T nv;
                int32_T stride;
                boolean_T exitg1;
                boolean_T guard1;

                // '<S123>:1:5'
                // '<S123>:1:6'
                tline->size[0] = 1;
                tline->size[1] = 0;
                rtPrevAction = FlightMissionMode_cfopen_du("config.ini", "rb",
                    localDW);
                if (static_cast<int32_T>(rtPrevAction) < 0) {
                    printf("INI-file \"%s\" was not found or could not be read.\n",
                           "config.ini");
                    fflush(stdout);
                } else {
                    FlightMissionMode_fread_j(static_cast<real_T>(rtPrevAction),
                        q, localDW);
                    stride = static_cast<int32_T>(data->size[0] * data->size[1]);
                    data->size[0] = 1;
                    data->size[1] = q->size[0];
                    FlightMissionMode_emxEnsureCapacity_char_T_g(data, stride);
                    nv = q->size[0];
                    for (i = 0; i <= static_cast<int32_T>(nv - 1); i++) {
                        data->data[i] = q->data[i];
                    }

                    FlightMissionMode_cfclose_d(static_cast<real_T>(rtPrevAction),
                        localDW);
                    curSection->size[0] = 1;
                    curSection->size[1] = 0;
                    curKey->size[0] = 1;
                    curKey->size[1] = 0;
                    curVal->size[0] = 1;
                    curVal->size[1] = 0;
                    FlightMissionMode_emxInit_char_T_ey(&tmp_h, 2);
                    FlightMissionMode_emxInit_char_T_ey(&data_b, 2);
                    exitg1 = false;
                    while ((!exitg1) && (data->size[1] != 0)) {
                        stride = static_cast<int32_T>(data_b->size[0] *
                            data_b->size[1]);
                        data_b->size[0] = 1;
                        data_b->size[1] = data->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_g(data_b,
                            stride);
                        i = static_cast<int32_T>(static_cast<int32_T>(data->
                            size[0] * data->size[1]) - 1);
                        for (stride = 0; stride <= i; stride++) {
                            data_b->data[stride] = data->data[stride];
                        }

                        FlightMissionMode_strtok_d(data_b, curLine, data);
                        FlightMissionMode_strtok_dq(curLine, tmp_h);
                        FlightMissionMode_strtrim_f(tmp_h, curLine);
                        if (curLine->size[1] >= 2) {
                            isStable = false;
                            if (curLine->data[0] == '[') {
                                isStable = true;
                            }

                            guard1 = false;
                            if (isStable) {
                                isStable = false;
                                if (curLine->data[static_cast<int32_T>
                                        (curLine->size[1] - 1)] == ']') {
                                    isStable = true;
                                }

                                if (isStable) {
                                    if (static_cast<int32_T>(curLine->size[1] -
                                            1) < 2) {
                                        iy = 0;
                                        nread = 0;
                                    } else {
                                        iy = 1;
                                        nread = static_cast<int32_T>
                                            (curLine->size[1] - 1);
                                    }

                                    stride = static_cast<int32_T>
                                        (curSection->size[0] * curSection->size
                                         [1]);
                                    curSection->size[0] = 1;
                                    nv = static_cast<int32_T>(nread - iy);
                                    curSection->size[1] = nv;
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (curSection, stride);
                                    for (i = 0; i <= static_cast<int32_T>(nv - 1);
                                         i++) {
                                        curSection->data[i] = curLine->data[
                                            static_cast<int32_T>(iy + i)];
                                    }

                                    curKey->size[0] = 1;
                                    curKey->size[1] = 0;
                                } else {
                                    guard1 = true;
                                }
                            } else {
                                guard1 = true;
                            }

                            if (guard1) {
                                if (curLine->data[0] == ';') {
                                    isStable = true;
                                }

                                if ((static_cast<boolean_T>(static_cast<int32_T>
                                                            (static_cast<int32_T>
                                        (isStable) ^ 1))) &&
                                        FlightMissionMode_contains_d(curLine)) {
                                    FlightMissionMode_strtok_dq4(curLine, curVal,
                                        x);
                                    FlightMissionMode_find_token_m(x, &i1,
                                        &nread);
                                    if (i1 > static_cast<int32_T>(nread - 1)) {
                                        iy = 0;
                                        i1 = 0;
                                    } else {
                                        iy = static_cast<int32_T>(i1 - 1);
                                        i1 = static_cast<int32_T>(nread - 1);
                                    }

                                    FlightMissionMode_strtrim_f(curVal, curKey);
                                    stride = static_cast<int32_T>(curLine->size
                                        [0] * curLine->size[1]);
                                    curLine->size[0] = 1;
                                    nv = static_cast<int32_T>(i1 - iy);
                                    curLine->size[1] = nv;
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (curLine, stride);
                                    for (i = 0; i <= static_cast<int32_T>(nv - 1);
                                         i++) {
                                        curLine->data[i] = x->data
                                            [static_cast<int32_T>(iy + i)];
                                    }

                                    FlightMissionMode_strtrim_f(curLine, curVal);
                                }
                            }
                        }

                        if (FlightMissionMode_strcmp_b(curSection) &&
                                FlightMissionMode_strcmp_bx(curKey)) {
                            stride = static_cast<int32_T>(tline->size[0] *
                                tline->size[1]);
                            tline->size[0] = 1;
                            tline->size[1] = curVal->size[1];
                            FlightMissionMode_emxEnsureCapacity_char_T_g(tline,
                                stride);
                            nv = curVal->size[1];
                            for (i = 0; i <= static_cast<int32_T>(nv - 1); i++)
                            {
                                tline->data[i] = curVal->data[i];
                            }

                            exitg1 = true;
                        }
                    }

                    FlightMissionMode_emxFree_char_T_o(&data_b);
                    FlightMissionMode_emxFree_char_T_o(&tmp_h);
                }

                tmp_1 = FlightMissionMode_str2double_k(tline);
                printf("Set Home Point Latitude:\t%f\n", tmp_1.re);
                fflush(stdout);
                tline->size[0] = 1;
                tline->size[1] = 0;
                rtPrevAction = FlightMissionMode_cfopen_du("config.ini", "rb",
                    localDW);
                if (static_cast<int32_T>(rtPrevAction) < 0) {
                    printf("INI-file \"%s\" was not found or could not be read.\n",
                           "config.ini");
                    fflush(stdout);
                } else {
                    FlightMissionMode_fread_j(static_cast<real_T>(rtPrevAction),
                        q, localDW);
                    stride = static_cast<int32_T>(data->size[0] * data->size[1]);
                    data->size[0] = 1;
                    data->size[1] = q->size[0];
                    FlightMissionMode_emxEnsureCapacity_char_T_g(data, stride);
                    nv = q->size[0];
                    for (i = 0; i <= static_cast<int32_T>(nv - 1); i++) {
                        data->data[i] = q->data[i];
                    }

                    FlightMissionMode_cfclose_d(static_cast<real_T>(rtPrevAction),
                        localDW);
                    curSection->size[0] = 1;
                    curSection->size[1] = 0;
                    curKey->size[0] = 1;
                    curKey->size[1] = 0;
                    curVal->size[0] = 1;
                    curVal->size[1] = 0;
                    FlightMissionMode_emxInit_char_T_ey(&tmp_g, 2);
                    FlightMissionMode_emxInit_char_T_ey(&data_a, 2);
                    exitg1 = false;
                    while ((!exitg1) && (data->size[1] != 0)) {
                        stride = static_cast<int32_T>(data_a->size[0] *
                            data_a->size[1]);
                        data_a->size[0] = 1;
                        data_a->size[1] = data->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_g(data_a,
                            stride);
                        i = static_cast<int32_T>(static_cast<int32_T>(data->
                            size[0] * data->size[1]) - 1);
                        for (stride = 0; stride <= i; stride++) {
                            data_a->data[stride] = data->data[stride];
                        }

                        FlightMissionMode_strtok_d(data_a, curLine, data);
                        FlightMissionMode_strtok_dq(curLine, tmp_g);
                        FlightMissionMode_strtrim_f(tmp_g, curLine);
                        if (curLine->size[1] >= 2) {
                            isStable = false;
                            if (curLine->data[0] == '[') {
                                isStable = true;
                            }

                            guard1 = false;
                            if (isStable) {
                                isStable = false;
                                if (curLine->data[static_cast<int32_T>
                                        (curLine->size[1] - 1)] == ']') {
                                    isStable = true;
                                }

                                if (isStable) {
                                    int32_T ntoread;
                                    if (static_cast<int32_T>(curLine->size[1] -
                                            1) < 2) {
                                        i1 = 0;
                                        ntoread = 0;
                                    } else {
                                        i1 = 1;
                                        ntoread = static_cast<int32_T>
                                            (curLine->size[1] - 1);
                                    }

                                    stride = static_cast<int32_T>
                                        (curSection->size[0] * curSection->size
                                         [1]);
                                    curSection->size[0] = 1;
                                    nv = static_cast<int32_T>(ntoread - i1);
                                    curSection->size[1] = nv;
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (curSection, stride);
                                    for (i = 0; i <= static_cast<int32_T>(nv - 1);
                                         i++) {
                                        curSection->data[i] = curLine->data[
                                            static_cast<int32_T>(i1 + i)];
                                    }

                                    curKey->size[0] = 1;
                                    curKey->size[1] = 0;
                                } else {
                                    guard1 = true;
                                }
                            } else {
                                guard1 = true;
                            }

                            if (guard1) {
                                if (curLine->data[0] == ';') {
                                    isStable = true;
                                }

                                if ((static_cast<boolean_T>(static_cast<int32_T>
                                                            (static_cast<int32_T>
                                        (isStable) ^ 1))) &&
                                        FlightMissionMode_contains_d(curLine)) {
                                    FlightMissionMode_strtok_dq4(curLine, curVal,
                                        x);
                                    FlightMissionMode_find_token_m(x, &iy,
                                        &nread);
                                    if (iy > static_cast<int32_T>(nread - 1)) {
                                        iy = 0;
                                        nread = 0;
                                    } else {
                                        iy = static_cast<int32_T>(iy - 1);
                                        nread = static_cast<int32_T>(nread - 1);
                                    }

                                    FlightMissionMode_strtrim_f(curVal, curKey);
                                    stride = static_cast<int32_T>(curLine->size
                                        [0] * curLine->size[1]);
                                    curLine->size[0] = 1;
                                    nv = static_cast<int32_T>(nread - iy);
                                    curLine->size[1] = nv;
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (curLine, stride);
                                    for (i = 0; i <= static_cast<int32_T>(nv - 1);
                                         i++) {
                                        curLine->data[i] = x->data
                                            [static_cast<int32_T>(iy + i)];
                                    }

                                    FlightMissionMode_strtrim_f(curLine, curVal);
                                }
                            }
                        }

                        if (FlightMissionMode_strcmp_b(curSection) &&
                                FlightMissionMode_strcmp_bxk(curKey)) {
                            stride = static_cast<int32_T>(tline->size[0] *
                                tline->size[1]);
                            tline->size[0] = 1;
                            tline->size[1] = curVal->size[1];
                            FlightMissionMode_emxEnsureCapacity_char_T_g(tline,
                                stride);
                            nv = curVal->size[1];
                            for (i = 0; i <= static_cast<int32_T>(nv - 1); i++)
                            {
                                tline->data[i] = curVal->data[i];
                            }

                            exitg1 = true;
                        }
                    }

                    FlightMissionMode_emxFree_char_T_o(&data_a);
                    FlightMissionMode_emxFree_char_T_o(&tmp_g);
                }

                tmp_2 = FlightMissionMode_str2double_k(tline);
                printf("Set Home Point Longitude:\t%f\n", tmp_2.re);
                fflush(stdout);
                tline->size[0] = 1;
                tline->size[1] = 0;
                rtPrevAction = FlightMissionMode_cfopen_du("config.ini", "rb",
                    localDW);
                if (static_cast<int32_T>(rtPrevAction) < 0) {
                    printf("INI-file \"%s\" was not found or could not be read.\n",
                           "config.ini");
                    fflush(stdout);
                } else {
                    FlightMissionMode_fread_j(static_cast<real_T>(rtPrevAction),
                        q, localDW);
                    stride = static_cast<int32_T>(data->size[0] * data->size[1]);
                    data->size[0] = 1;
                    data->size[1] = q->size[0];
                    FlightMissionMode_emxEnsureCapacity_char_T_g(data, stride);
                    nv = q->size[0];
                    for (i = 0; i <= static_cast<int32_T>(nv - 1); i++) {
                        data->data[i] = q->data[i];
                    }

                    FlightMissionMode_cfclose_d(static_cast<real_T>(rtPrevAction),
                        localDW);
                    curSection->size[0] = 1;
                    curSection->size[1] = 0;
                    curKey->size[0] = 1;
                    curKey->size[1] = 0;
                    curVal->size[0] = 1;
                    curVal->size[1] = 0;
                    FlightMissionMode_emxInit_char_T_ey(&tmp_f, 2);
                    FlightMissionMode_emxInit_char_T_ey(&data_9, 2);
                    exitg1 = false;
                    while ((!exitg1) && (data->size[1] != 0)) {
                        stride = static_cast<int32_T>(data_9->size[0] *
                            data_9->size[1]);
                        data_9->size[0] = 1;
                        data_9->size[1] = data->size[1];
                        FlightMissionMode_emxEnsureCapacity_char_T_g(data_9,
                            stride);
                        i = static_cast<int32_T>(static_cast<int32_T>(data->
                            size[0] * data->size[1]) - 1);
                        for (stride = 0; stride <= i; stride++) {
                            data_9->data[stride] = data->data[stride];
                        }

                        FlightMissionMode_strtok_d(data_9, curLine, data);
                        FlightMissionMode_strtok_dq(curLine, tmp_f);
                        FlightMissionMode_strtrim_f(tmp_f, curLine);
                        if (curLine->size[1] >= 2) {
                            isStable = false;
                            if (curLine->data[0] == '[') {
                                isStable = true;
                            }

                            guard1 = false;
                            if (isStable) {
                                isStable = false;
                                if (curLine->data[static_cast<int32_T>
                                        (curLine->size[1] - 1)] == ']') {
                                    isStable = true;
                                }

                                if (isStable) {
                                    if (static_cast<int32_T>(curLine->size[1] -
                                            1) < 2) {
                                        iy = 0;
                                        i2 = 0;
                                    } else {
                                        iy = 1;
                                        i2 = static_cast<int32_T>(curLine->size
                                            [1] - 1);
                                    }

                                    stride = static_cast<int32_T>
                                        (curSection->size[0] * curSection->size
                                         [1]);
                                    curSection->size[0] = 1;
                                    nv = static_cast<int32_T>(i2 - iy);
                                    curSection->size[1] = nv;
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (curSection, stride);
                                    for (i = 0; i <= static_cast<int32_T>(nv - 1);
                                         i++) {
                                        curSection->data[i] = curLine->data[
                                            static_cast<int32_T>(iy + i)];
                                    }

                                    curKey->size[0] = 1;
                                    curKey->size[1] = 0;
                                } else {
                                    guard1 = true;
                                }
                            } else {
                                guard1 = true;
                            }

                            if (guard1) {
                                if (curLine->data[0] == ';') {
                                    isStable = true;
                                }

                                if ((static_cast<boolean_T>(static_cast<int32_T>
                                                            (static_cast<int32_T>
                                        (isStable) ^ 1))) &&
                                        FlightMissionMode_contains_d(curLine)) {
                                    int32_T n;
                                    FlightMissionMode_strtok_dq4(curLine, curVal,
                                        x);
                                    FlightMissionMode_find_token_m(x, &iy,
                                        &nread);
                                    if (iy > static_cast<int32_T>(nread - 1)) {
                                        n = 0;
                                        i = 0;
                                    } else {
                                        n = static_cast<int32_T>(iy - 1);
                                        i = static_cast<int32_T>(nread - 1);
                                    }

                                    FlightMissionMode_strtrim_f(curVal, curKey);
                                    stride = static_cast<int32_T>(curLine->size
                                        [0] * curLine->size[1]);
                                    curLine->size[0] = 1;
                                    nv = static_cast<int32_T>(i - n);
                                    curLine->size[1] = nv;
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (curLine, stride);
                                    for (i = 0; i <= static_cast<int32_T>(nv - 1);
                                         i++) {
                                        curLine->data[i] = x->data
                                            [static_cast<int32_T>(n + i)];
                                    }

                                    FlightMissionMode_strtrim_f(curLine, curVal);
                                }
                            }
                        }

                        if (FlightMissionMode_strcmp_b(curSection) &&
                                FlightMissionMode_strcmp_bxki(curKey)) {
                            stride = static_cast<int32_T>(tline->size[0] *
                                tline->size[1]);
                            tline->size[0] = 1;
                            tline->size[1] = curVal->size[1];
                            FlightMissionMode_emxEnsureCapacity_char_T_g(tline,
                                stride);
                            nv = curVal->size[1];
                            for (i = 0; i <= static_cast<int32_T>(nv - 1); i++)
                            {
                                tline->data[i] = curVal->data[i];
                            }

                            exitg1 = true;
                        }
                    }

                    FlightMissionMode_emxFree_char_T_o(&data_9);
                    FlightMissionMode_emxFree_char_T_o(&tmp_f);
                }

                tmp_3 = FlightMissionMode_str2double_k(tline);
                printf("Set Home Point Altitude:\t%f\n", tmp_3.re);
                fflush(stdout);
                localDW->HomePoint[0] = tmp_1.re;
                localDW->HomePoint[1] = tmp_2.re;
                localDW->HomePoint[2] = tmp_3.re;
                localDW->HomePoint_not_empty = true;
                b_x[0] = std::isnan(localDW->HomePoint[0]);
                b_x[1] = std::isnan(localDW->HomePoint[1]);
                b_x[2] = std::isnan(localDW->HomePoint[2]);
                isStable = false;
                nread = 0;
                exitg1 = false;
                while ((!exitg1) && (nread < 3)) {
                    if (b_x[nread]) {
                        isStable = true;
                        exitg1 = true;
                    } else {
                        nread = static_cast<int32_T>(nread + 1);
                    }
                }

                if (isStable) {
                    // '<S123>:1:7'
                    // '<S123>:1:8'
                    localDW->HomePoint[0] = 35.8617;
                    localDW->HomePoint[1] = 104.1954;
                    localDW->HomePoint[2] = 0.0;
                }
            }

            // Switch: '<S137>/Switch' incorporates:
            //   Abs: '<S137>/Abs'
            //   Bias: '<S137>/Bias'
            //   Bias: '<S137>/Bias1'
            //   Constant: '<S137>/Constant2'
            //   Constant: '<S138>/Constant'
            //   MATLAB Function: '<S118>/ReadHomePoint'
            //   Math: '<S137>/Math Function1'
            //   RelationalOperator: '<S138>/Compare'

            // '<S123>:1:12'
            if (std::abs(localDW->HomePoint[0]) > 180.0) {
                Alt = rt_modd_snf(localDW->HomePoint[0] + 180.0, 360.0) - 180.0;
            } else {
                Alt = localDW->HomePoint[0];
            }

            // End of Switch: '<S137>/Switch'

            // Abs: '<S134>/Abs1'
            rtb_Abs1_il = std::abs(Alt);

            // Switch: '<S134>/Switch' incorporates:
            //   Bias: '<S134>/Bias'
            //   Bias: '<S134>/Bias1'
            //   Constant: '<S125>/Constant'
            //   Constant: '<S125>/Constant1'
            //   Constant: '<S136>/Constant'
            //   Gain: '<S134>/Gain'
            //   Product: '<S134>/Divide1'
            //   RelationalOperator: '<S136>/Compare'
            //   Signum: '<S134>/Sign1'
            //   Switch: '<S125>/Switch1'

            if (rtb_Abs1_il > 90.0) {
                // Signum: '<S134>/Sign1'
                if (std::isnan(Alt)) {
                    rtb_Sum1_e_idx_0 = (rtNaN);
                } else if (Alt < 0.0) {
                    rtb_Sum1_e_idx_0 = -1.0;
                } else {
                    rtb_Sum1_e_idx_0 = static_cast<real_T>(Alt > 0.0);
                }

                Alt = (-(rtb_Abs1_il - 90.0) + 90.0) * rtb_Sum1_e_idx_0;
                i = 180;
            } else {
                i = 0;
            }

            // End of Switch: '<S134>/Switch'

            // Sum: '<S125>/Sum' incorporates:
            //   MATLAB Function: '<S118>/ReadHomePoint'
            //   Switch: '<S125>/Switch1'

            rtb_Switch_l = static_cast<real_T>(i) + localDW->HomePoint[1];

            // Switch: '<S135>/Switch' incorporates:
            //   Abs: '<S135>/Abs'
            //   Bias: '<S135>/Bias'
            //   Bias: '<S135>/Bias1'
            //   Constant: '<S135>/Constant2'
            //   Constant: '<S139>/Constant'
            //   Math: '<S135>/Math Function1'
            //   RelationalOperator: '<S139>/Compare'

            if (std::abs(rtb_Switch_l) > 180.0) {
                rtb_Switch_l = rt_modd_snf(rtb_Switch_l + 180.0, 360.0) - 180.0;
            }

            // End of Switch: '<S135>/Switch'

            // Sum: '<S122>/Sum1'
            rtb_Sum1_e_idx_0 = rtu_MissionLocation->Lat - Alt;
            rtb_Sum1_e_idx_1 = rtu_MissionLocation->Lon - rtb_Switch_l;

            // Switch: '<S131>/Switch' incorporates:
            //   Abs: '<S131>/Abs'
            //   Bias: '<S131>/Bias'
            //   Bias: '<S131>/Bias1'
            //   Constant: '<S131>/Constant2'
            //   Constant: '<S132>/Constant'
            //   Math: '<S131>/Math Function1'
            //   RelationalOperator: '<S132>/Compare'

            if (std::abs(rtb_Sum1_e_idx_0) > 180.0) {
                rtb_Switch_l = rt_modd_snf(rtb_Sum1_e_idx_0 + 180.0, 360.0) -
                    180.0;
            } else {
                rtb_Switch_l = rtb_Sum1_e_idx_0;
            }

            // End of Switch: '<S131>/Switch'

            // Abs: '<S128>/Abs1'
            rtb_Abs1_il = std::abs(rtb_Switch_l);

            // Switch: '<S128>/Switch' incorporates:
            //   Bias: '<S128>/Bias'
            //   Bias: '<S128>/Bias1'
            //   Constant: '<S124>/Constant'
            //   Constant: '<S124>/Constant1'
            //   Constant: '<S130>/Constant'
            //   Gain: '<S128>/Gain'
            //   Product: '<S128>/Divide1'
            //   RelationalOperator: '<S130>/Compare'
            //   Signum: '<S128>/Sign1'
            //   Switch: '<S124>/Switch1'

            if (rtb_Abs1_il > 90.0) {
                // Signum: '<S128>/Sign1'
                if (std::isnan(rtb_Switch_l)) {
                    rtb_Sum1_e_idx_0 = (rtNaN);
                } else if (rtb_Switch_l < 0.0) {
                    rtb_Sum1_e_idx_0 = -1.0;
                } else {
                    rtb_Sum1_e_idx_0 = static_cast<real_T>(rtb_Switch_l > 0.0);
                }

                rtb_Switch_l = (-(rtb_Abs1_il - 90.0) + 90.0) * rtb_Sum1_e_idx_0;
                i = 180;
            } else {
                i = 0;
            }

            // End of Switch: '<S128>/Switch'

            // Sum: '<S124>/Sum' incorporates:
            //   Switch: '<S124>/Switch1'

            Lat = static_cast<real_T>(i) + rtb_Sum1_e_idx_1;

            // Switch: '<S129>/Switch' incorporates:
            //   Abs: '<S129>/Abs'
            //   Bias: '<S129>/Bias'
            //   Bias: '<S129>/Bias1'
            //   Constant: '<S129>/Constant2'
            //   Constant: '<S133>/Constant'
            //   Math: '<S129>/Math Function1'
            //   RelationalOperator: '<S133>/Compare'

            if (std::abs(Lat) > 180.0) {
                Lat = rt_modd_snf(Lat + 180.0, 360.0) - 180.0;
            }

            // End of Switch: '<S129>/Switch'

            // UnitConversion: '<S127>/Unit Conversion'
            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            rtb_Sum1_e_idx_0 = 0.017453292519943295 * rtb_Switch_l;
            rtb_Sum1_e_idx_1 = 0.017453292519943295 * Lat;

            // UnitConversion: '<S142>/Unit Conversion'
            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            Alt *= 0.017453292519943295;

            // Trigonometry: '<S143>/Trigonometric Function1'
            Lat = std::sin(Alt);

            // Sum: '<S143>/Sum1' incorporates:
            //   Constant: '<S143>/Constant'
            //   Product: '<S143>/Product1'

            Lat = 1.0 - 0.0066943799901413295 * Lat * Lat;

            // Product: '<S141>/Product1' incorporates:
            //   Constant: '<S141>/Constant1'
            //   Sqrt: '<S141>/sqrt'

            rtb_Switch_l = 6.378137E+6 / std::sqrt(Lat);

            // Product: '<S126>/dNorth' incorporates:
            //   Constant: '<S141>/Constant2'
            //   Product: '<S141>/Product3'
            //   Trigonometry: '<S141>/Trigonometric Function1'

            Lat = rtb_Sum1_e_idx_0 / rt_atan2d_snf(1.0, rtb_Switch_l *
                0.99330562000985867 / Lat);

            // Product: '<S126>/dEast' incorporates:
            //   Constant: '<S141>/Constant3'
            //   Product: '<S141>/Product4'
            //   Trigonometry: '<S141>/Trigonometric Function'
            //   Trigonometry: '<S141>/Trigonometric Function2'

            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            rtb_Switch_l = 1.0 / rt_atan2d_snf(1.0, rtb_Switch_l * std::cos(Alt))
                * rtb_Sum1_e_idx_1;

            // Sum: '<S122>/Sum' incorporates:
            //   MATLAB Function: '<S118>/ReadHomePoint'

            Alt = rtu_MissionLocation->Alt - localDW->HomePoint[2];

            // Gain: '<S117>/Gain1'
            d = 0.017453292519943295 * rtu_MissionLocation->degHDG;

            // Outputs for Atomic SubSystem: '<S116>/OneSidePercentage'
            // Gain: '<S119>/Gain' incorporates:
            //   DataTypeConversion: '<S116>/Param3'

            distToCenter = 0.5 * static_cast<real_T>(rtu_Parameters->Param3);

            // Outputs for Enabled SubSystem: '<S116>/WayPointGenerator' incorporates:
            //   EnablePort: '<S121>/Enable'

            // Gain: '<S146>/Gain1' incorporates:
            //   DataTypeConversion: '<S116>/Param2'
            //   Gain: '<S153>/Gain1'

            rtb_Sum1_e_idx_0 = 0.017453292519943295 * static_cast<real_T>
                (rtu_Parameters->Param2);

            // End of Outputs for SubSystem: '<S116>/WayPointGenerator'

            // Switch: '<S119>/Switch' incorporates:
            //   Constant: '<S119>/Constant'
            //   Constant: '<S119>/Half'
            //   Constant: '<S119>/One'
            //   DataTypeConversion: '<S116>/Param1'
            //   Gain: '<S146>/Gain1'
            //   Math: '<S119>/Square'
            //   Product: '<S119>/Product'
            //   RelationalOperator: '<S119>/Relational Operator'
            //   Sqrt: '<S119>/Sqrt'
            //   Sum: '<S119>/Minus'
            //   Trigonometry: '<S119>/Cos'

            if (std::sqrt(distToCenter * distToCenter * 2.0 * (1.0 - std::cos
                    (rtb_Sum1_e_idx_0))) < static_cast<real_T>
                    (rtu_Parameters->Param1)) {
                distToCenter = 0.5;
            } else {
                distToCenter = 1.0;
            }

            // End of Switch: '<S119>/Switch'
            // End of Outputs for SubSystem: '<S116>/OneSidePercentage'

            // Outputs for Enabled SubSystem: '<S116>/WayPointGenerator' incorporates:
            //   EnablePort: '<S121>/Enable'

            if (*rtu_Reset) {
                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>
                                            (localDW->WayPointGenerator_MODE_m) ^
                      1))) {
                    // SystemReset for MATLAB Function: '<S121>/StartPointGenerator' 
                    FlightMissionMode_StartPointGenerator_Reset
                        (&localDW->sf_StartPointGenerator_k);

                    // SystemReset for MATLAB Function: '<S121>/WayPointGenerator' 
                    FlightMissionMode_WayPointGenerator_Reset
                        (&localDW->sf_WayPointGenerator_f);
                    localDW->WayPointGenerator_MODE_m = true;
                }

                // DataTypeConversion: '<S121>/DoubleFormationIDX'
                rtb_Abs1_il = static_cast<real_T>(*rtu_FormationIDX);

                // Signum: '<S121>/Sign'
                if (rtb_Abs1_il < 0.0) {
                    rtb_Bias_mn = -1;
                } else {
                    rtb_Bias_mn = (rtb_Abs1_il > 0.0);
                }

                // End of Signum: '<S121>/Sign'

                // Product: '<S121>/ProductRotAng' incorporates:
                //   Product: '<S121>/ProductFlipRotAng'

                rtb_Sum1_e_idx_0 = rtb_Sum1_e_idx_0 * static_cast<real_T>
                    (rtb_Bias_mn) * distToCenter;

                // SignalConversion generated from: '<S121>/RotateATRunWayHdg' incorporates:
                //   Constant: '<S121>/Zero'

                rtb_TmpSignalConversionAtRotateATRunWayHdgInport1[0] =
                    rtb_Sum1_e_idx_0;
                rtb_TmpSignalConversionAtRotateATRunWayHdgInport1[1] = 0.0;
                rtb_TmpSignalConversionAtRotateATRunWayHdgInport1[2] = 0.0;
                FlightMissionMode_RotateATMissionHdg
                    (rtb_TmpSignalConversionAtRotateATRunWayHdgInport1,
                     &localDW->RotateATRunWayHdg_k);

                // SignalConversion generated from: '<S121>/Matrix Concatenate' incorporates:
                //   Constant: '<S121>/Constant'
                //   Constant: '<S121>/One'

                rtb_MatrixConcatenate[0] = 1;
                rtb_MatrixConcatenate[1] = 0;
                rtb_MatrixConcatenate[2] = 0;

                // SignalConversion generated from: '<S121>/Matrix Concatenate' incorporates:
                //   Constant: '<S121>/Constant'

                rtb_MatrixConcatenate[3] = 0;
                rtb_MatrixConcatenate[4] = static_cast<int8_T>(rtb_Bias_mn);
                rtb_MatrixConcatenate[5] = 0;

                // SignalConversion generated from: '<S121>/Matrix Concatenate' incorporates:
                //   Constant: '<S121>/Constant'
                //   Constant: '<S121>/One'

                rtb_MatrixConcatenate[6] = 0;
                rtb_MatrixConcatenate[7] = 0;
                rtb_MatrixConcatenate[8] = 1;

                // Abs: '<S121>/Abs'
                rtb_Sum1_e_idx_1 = std::abs(rtb_Abs1_il);

                // DataTypeConversion: '<S121>/DoubleMissionUAV'
                rtb_Abs1_il = static_cast<real_T>(*rtu_MissionUAV);

                // MATLAB Function: '<S121>/StartPointGenerator' incorporates:
                //   Concatenate: '<S121>/Matrix Concatenate WayPoint'
                //   DataTypeConversion: '<S116>/Param3'
                //   Product: '<S121>/ProductOneSideUAV'

                FlightMissionMode_StartPointGenerator(static_cast<real_T>
                    (rtu_Parameters->Param3), rtb_Abs1_il * distToCenter,
                    rtb_Sum1_e_idx_1, &localDW->MatrixConcatenateWayPoint[1536],
                    startPose, &localDW->sf_StartPointGenerator_k);

                // MATLAB Function: '<S121>/WayPointGenerator' incorporates:
                //   Concatenate: '<S121>/Matrix Concatenate WayPoint'
                //   DataTypeConversion: '<S116>/Param3'

                FlightMissionMode_WayPointGenerator(static_cast<real_T>
                    (rtu_Parameters->Param3),
                    &localDW->MatrixConcatenateWayPoint[0],
                    &localDW->MatrixConcatenateWayPoint[384],
                    &localDW->MatrixConcatenateWayPoint[768],
                    &localDW->MatrixConcatenateWayPoint[1152],
                    &localDW->sf_WayPointGenerator_f);

                // Product: '<S121>/ProductFlipXbias' incorporates:
                //   DataTypeConversion: '<S116>/Param1'
                //   Product: '<S121>/ProductSepDis'

                rtb_Abs1_il = distToCenter * static_cast<real_T>
                    (rtu_Parameters->Param1) * static_cast<real_T>(rtb_Bias_mn);

                // Reshape: '<S121>/Reshape' incorporates:
                //   Constant: '<S121>/Zero'

                u[0] = 0.0;
                u[1] = rtb_Abs1_il;
                u[2] = 0.0;

                // Reshape: '<S121>/ReshapeRowVec' incorporates:
                //   Product: '<S126>/x*cos'
                //   Product: '<S126>/x*sin'
                //   Product: '<S126>/y*cos'
                //   Product: '<S126>/y*sin'
                //   Reshape: '<S121>/ReshapeRowVecStartpose'
                //   Sum: '<S126>/Sum2'
                //   Sum: '<S126>/Sum3'
                //   UnaryMinus: '<S122>/Ze2height'

                LLA0_gw[0] = rtb_Switch_l * 0.0 + Lat;
                LLA0_gw[1] = rtb_Switch_l - Lat * 0.0;
                LLA0_gw[2] = -Alt;

                // SignalConversion generated from: '<S121>/RotateATMissionHdg' incorporates:
                //   Constant: '<S121>/Zero'

                rtb_TmpSignalConversionAtRotateATMissionHdgInport1[0] = d;
                rtb_TmpSignalConversionAtRotateATMissionHdgInport1[1] = 0.0;
                rtb_TmpSignalConversionAtRotateATMissionHdgInport1[2] = 0.0;
                FlightMissionMode_RotateATMissionHdg
                    (rtb_TmpSignalConversionAtRotateATMissionHdgInport1,
                     &localDW->RotateATMissionHdg_k);

                // Outputs for Iterator SubSystem: '<S121>/TransformWayPoint' incorporates:
                //   ForEach: '<S155>/For Each'

                for (i2 = 0; i2 < 5; i2++) {
                    // Product: '<S155>/ProductFlipRunWay' incorporates:
                    //   Concatenate: '<S121>/Matrix Concatenate'
                    //   Concatenate: '<S121>/Matrix Concatenate WayPoint'
                    //   ForEachSliceSelector generated from: '<S155>/RawRunWay'

                    for (i = 0; i < 128; i++) {
                        for (i1 = 0; i1 < 3; i1++) {
                            b_exponent = static_cast<int32_T>
                                (static_cast<int32_T>(i1 << 7) + i);
                            rtb_y_e[b_exponent] = 0.0;

                            // ForEachSliceSelector generated from: '<S155>/RawRunWay' 
                            iy = static_cast<int32_T>(static_cast<int32_T>(384 *
                                i2) + i);
                            rtb_y_e[b_exponent] += static_cast<real_T>
                                (rtb_MatrixConcatenate[static_cast<int32_T>(3 *
                                  i1)]) * localDW->MatrixConcatenateWayPoint[iy];
                            rtb_y_e[b_exponent] += static_cast<real_T>
                                (rtb_MatrixConcatenate[static_cast<int32_T>(
                                  static_cast<int32_T>(3 * i1) + 1)]) *
                                localDW->MatrixConcatenateWayPoint
                                [static_cast<int32_T>(iy + 128)];
                            rtb_y_e[b_exponent] += static_cast<real_T>
                                (rtb_MatrixConcatenate[static_cast<int32_T>(
                                  static_cast<int32_T>(3 * i1) + 2)]) *
                                localDW->MatrixConcatenateWayPoint
                                [static_cast<int32_T>(iy + 256)];
                        }
                    }

                    // End of Product: '<S155>/ProductFlipRunWay'

                    // Product: '<S155>/RotateRunway' incorporates:
                    //   MATLABSystem: '<S121>/RotateATRunWayHdg'

                    rt_mrdivide_U1d128x3_U2d3x3_Yd128x3_snf(rtb_y_e,
                        localDW->RotateATRunWayHdg_k.RotateATMissionHdg,
                        rtb_RotateRunway);

                    // MATLAB Function: '<S155>/minus'
                    FlightMissionMode_minus(rtb_RotateRunway, u, rtb_y_e);

                    // Product: '<S155>/RotateIndivWayPoint' incorporates:
                    //   MATLABSystem: '<S121>/RotateATMissionHdg'

                    rt_mrdivide_U1d128x3_U2d3x3_Yd128x3_snf(rtb_y_e,
                        localDW->RotateATMissionHdg_k.RotateATMissionHdg,
                        rtb_RotateIndivWayPoint);

                    // MATLAB Function: '<S155>/biasNED' incorporates:
                    //   Reshape: '<S121>/ReshapeRowVec'

                    FlightMissionMode_biasNED(LLA0_gw, rtb_RotateIndivWayPoint,
                        rtb_nedWayPoint_CoreSubsysCanOut);

                    // ForEachSliceAssignment generated from: '<S155>/nedWayPoint' 
                    std::memcpy
                        (&localDW->ImpAsg_InsertedFor_nedWayPoint_at_inport_0[
                         static_cast<int32_T>(i2 * 384)],
                         &rtb_nedWayPoint_CoreSubsysCanOut[0],
                         static_cast<uint32_T>(384U * sizeof(real_T)));
                }

                // End of Outputs for SubSystem: '<S121>/TransformWayPoint'

                // Product: '<S121>/ProductFlipStartPose'
                localDW->ProductFlipStartPose[0] = startPose[0];
                localDW->ProductFlipStartPose[1] = startPose[1] *
                    static_cast<real_T>(rtb_Bias_mn);
                localDW->ProductFlipStartPose[2] = startPose[2];
                localDW->ProductFlipStartPose[3] = startPose[3];
                localDW->ProductFlipStartPose[4] = startPose[4];

                // Product: '<S121>/RotateRunwayStartpose' incorporates:
                //   MATLABSystem: '<S121>/RotateATRunWayHdg'

                rt_mrdivide_U1d1x3_U2d3x3_Yd1x3_snf
                    (&localDW->ProductFlipStartPose[0],
                     localDW->RotateATRunWayHdg_k.RotateATMissionHdg, u);

                // Sum: '<S121>/BiasStartPose'
                tmp_0[0] = u[0];
                tmp_0[1] = u[1] - rtb_Abs1_il;
                tmp_0[2] = u[2];

                // Product: '<S121>/RotateIndivWayPointStartpose' incorporates:
                //   MATLABSystem: '<S121>/RotateATMissionHdg'

                rt_mrdivide_U1d1x3_U2d3x3_Yd1x3_snf(tmp_0,
                    localDW->RotateATMissionHdg_k.RotateATMissionHdg, u);

                // MATLAB Function: '<S121>/biasNEDstartpose'
                FlightMissionMode_biasNEDstartpose(LLA0_gw, u,
                    localDW->nedWayPoint);

                // Sum: '<S121>/Sum' incorporates:
                //   Product: '<S121>/ProductFlipStartHeading'

                localDW->Sum = (d + rtb_Sum1_e_idx_0) + static_cast<real_T>
                    (rtb_Bias_mn) * localDW->ProductFlipStartPose[3];
            } else {
                localDW->WayPointGenerator_MODE_m = false;
            }

            // End of Outputs for SubSystem: '<S116>/WayPointGenerator'

            // Reshape: '<S116>/Reshape' incorporates:
            //   Constant: '<S116>/InitialFlightPathAngle'
            //   Constant: '<S116>/InitialRollAngleRate'
            //   DataTypeConversion: '<S116>/Param4'
            //   Gain: '<S116>/Down2Up'

            rty_InitialState[0] = localDW->nedWayPoint[0];
            rty_InitialState[1] = localDW->nedWayPoint[1];
            rty_InitialState[2] = -localDW->nedWayPoint[2];
            rty_InitialState[3] = static_cast<real_T>(rtu_Parameters->Param4);
            rty_InitialState[4] = localDW->Sum;
            rty_InitialState[5] = 0.0;
            rty_InitialState[6] = localDW->ProductFlipStartPose[4];
            rty_InitialState[7] = 0.0;

            // Outputs for Atomic SubSystem: '<S116>/SegmentSwitch'
            FlightMissionMode_SegmentSwitch(rtu_Reset, rtu_Pose,
                localDW->ImpAsg_InsertedFor_nedWayPoint_at_inport_0,
                localDW->MergeLookAheadP, &localDW->MergeDesiredCourse,
                &localDW->RunWayLineMode, 200.0, &localDW->SegmentSwitch_p);

            // End of Outputs for SubSystem: '<S116>/SegmentSwitch'

            // DataTypeConversion: '<S116>/Cast To Double'
            *rty_thisTaskStatus = static_cast<real_T>(localDW->RunWayLineMode);

            // BusCreator: '<S116>/GuidanceCMDBusCreator' incorporates:
            //   DataTypeConversion: '<S116>/Param4'
            //   Gain: '<S116>/Down2Height'

            rty_GuidanceCmds->Height = -localDW->MergeLookAheadP[2];
            rty_GuidanceCmds->AirSpeed = static_cast<real_T>
                (rtu_Parameters->Param4);
            rty_GuidanceCmds->HeadingAngle = localDW->MergeDesiredCourse;

            // End of Outputs for SubSystem: '<Root>/Mode44_ProtLine'
        }
        break;

      case 4:
        {
            real_T Lat;
            real_T rtb_Abs1_il;
            real_T rtb_Sum1_e_idx_0;
            real_T rtb_Sum1_e_idx_1;
            int32_T i;
            int32_T ntoread;
            int32_T nv;
            int32_T stride;
            real32_T tmp_4;
            boolean_T exitg1;
            if (static_cast<int32_T>(rtAction) != static_cast<int32_T>
                    (rtPrevAction)) {
                // SystemReset for IfAction SubSystem: '<Root>/Mode55_FrmnWayPoint' incorporates:
                //   ActionPort: '<S6>/Action Port'

                // SystemReset for SwitchCase: '<Root>/Switch Case' incorporates:
                //   MATLAB Function: '<S163>/ReadHomePoint'

                FlightMissionMode_ReadHomePoint_Reset
                    (&localDW->sf_ReadHomePoint_l);

                // End of SystemReset for SubSystem: '<Root>/Mode55_FrmnWayPoint' 
            }

            // Outputs for IfAction SubSystem: '<Root>/Mode55_FrmnWayPoint' incorporates:
            //   ActionPort: '<S6>/Action Port'

            // Outputs for Enabled SubSystem: '<S161>/WayPointGenerator' incorporates:
            //   EnablePort: '<S166>/Enable'

            if (*rtu_Reset) {
                FILE* a;
                if (static_cast<boolean_T>(static_cast<int32_T>
                                           (static_cast<int32_T>
                                            (localDW->WayPointGenerator_MODE) ^
                                            1))) {
                    // SystemReset for MATLAB Function: '<S166>/ReadHomePoint'
                    FlightMissionMode_ReadHomePoint_Reset
                        (&localDW->sf_ReadHomePoint_kc);

                    // SystemReset for MATLAB Function: '<S166>/WayPointGenerator' 
                    a = NULL;
                    for (i = 0; i < 20; i++) {
                        localDW->eml_openfiles_i[i] = a;
                    }

                    // End of SystemReset for MATLAB Function: '<S166>/WayPointGenerator' 
                    localDW->WayPointGenerator_MODE = true;
                }

                // MATLAB Function: '<S166>/ReadHomePoint'
                FlightMissionMode_ReadHomePoint(u, &localDW->sf_ReadHomePoint_kc);

                // MATLAB Function: '<S166>/WayPointGenerator' incorporates:
                //   DataTypeConversion: '<S161>/Param2'
                //   DataTypeConversion: '<S161>/Param3'

                // MATLAB Function 'Mode55_FrmnWayPoint/Mode55_Variant/Mode55/WayPointGenerator/WayPointGenerator': '<S192>:1' 
                // '<S192>:1:3'
                FlightMissionMode_string_string(static_cast<real_T>
                    (rtu_Parameters->Param3), obj_Value_data, obj_Value_size);
                j_size[0] = 1;
                j_size[1] = static_cast<int32_T>(obj_Value_size[1] + 14);
                for (i = 0; i < 14; i++) {
                    j_data[i] = j[i];
                }

                nv = obj_Value_size[1];
                for (i = 0; i <= static_cast<int32_T>(nv - 1); i++) {
                    j_data[static_cast<int32_T>(i + 14)] = obj_Value_data[i];
                }

                rtPrevAction = FlightMissionMode_cfopen_h(j_data, j_size, "rb",
                    localDW);
                if (static_cast<int32_T>(rtPrevAction) != -1) {
                    // '<S192>:1:5'
                    // '<S192>:1:6'
                    FlightMissionMode_cfclose_k(static_cast<real_T>(rtPrevAction),
                        localDW);

                    // '<S192>:1:7'
                    FlightMissionMode_string_string(static_cast<real_T>
                        (rtu_Parameters->Param3), obj_Value_data, obj_Value_size);
                    j_size[0] = 1;
                    j_size[1] = static_cast<int32_T>(obj_Value_size[1] + 14);
                    for (i = 0; i < 14; i++) {
                        j_data[i] = j[i];
                    }

                    nv = obj_Value_size[1];
                    for (i = 0; i <= static_cast<int32_T>(nv - 1); i++) {
                        j_data[static_cast<int32_T>(i + 14)] = obj_Value_data[i];
                    }

                    rtPrevAction = FlightMissionMode_cfopen_h(j_data, j_size,
                        "rb", localDW);
                    std::memset(&localDW->MAT[0], 0, static_cast<uint32_T>
                                (sizeof(real_T) << 12U));
                    FlightMissionMode_fgetl(static_cast<real_T>(rtPrevAction),
                                            tline, localDW);
                    rtb_Abs1_il = 0.0;
                    a = NULL;
                    int32_T exitg2;
                    do {
                        FILE* filestar;
                        exitg2 = 0;
                        if (tline->size[1] != 0) {
                            rtb_Abs1_il++;
                            Lat = 0.0;
                            while (!(tline->size[1] == 0)) {
                                int32_T n;
                                Lat++;
                                stride = static_cast<int32_T>(data->size[0] *
                                    data->size[1]);
                                data->size[0] = 1;
                                data->size[1] = tline->size[1];
                                FlightMissionMode_emxEnsureCapacity_char_T_g
                                    (data, stride);
                                nv = tline->size[1];
                                for (i = 0; i <= static_cast<int32_T>(nv - 1); i
                                        ++) {
                                    data->data[i] = tline->data[i];
                                }

                                n = tline->size[1];
                                nread = 0;
                                while ((static_cast<int32_T>(nread + 1) <= n) &&
                                       (tline->data[nread] == ',')) {
                                    nread = static_cast<int32_T>(nread + 1);
                                }

                                i1 = static_cast<int32_T>(nread + 1);
                                while ((static_cast<int32_T>(nread + 1) <= n) &&
                                       (tline->data[nread] != ',')) {
                                    nread = static_cast<int32_T>(nread + 1);
                                }

                                if (static_cast<int32_T>(nread + 1) >
                                        tline->size[1]) {
                                    iy = 0;
                                    i2 = 0;
                                } else {
                                    iy = nread;
                                    i2 = tline->size[1];
                                }

                                i2 = static_cast<int32_T>(i2 - iy);
                                for (i = 0; i <= static_cast<int32_T>(i2 - 1); i
                                        ++) {
                                    tline->data[i] = tline->data
                                        [static_cast<int32_T>(iy + i)];
                                }

                                stride = static_cast<int32_T>(tline->size[0] *
                                    tline->size[1]);
                                tline->size[0] = 1;
                                tline->size[1] = i2;
                                FlightMissionMode_emxEnsureCapacity_char_T_g
                                    (tline, stride);
                                if (i1 > nread) {
                                    iy = 0;
                                    i1 = 0;
                                } else {
                                    iy = static_cast<int32_T>(i1 - 1);
                                    i1 = nread;
                                }

                                stride = static_cast<int32_T>(curSection->size[0]
                                    * curSection->size[1]);
                                curSection->size[0] = 1;
                                nv = static_cast<int32_T>(i1 - iy);
                                curSection->size[1] = nv;
                                FlightMissionMode_emxEnsureCapacity_char_T_g
                                    (curSection, stride);
                                for (i = 0; i <= static_cast<int32_T>(nv - 1); i
                                        ++) {
                                    curSection->data[i] = data->data[
                                        static_cast<int32_T>(iy + i)];
                                }

                                localDW->MAT[static_cast<int32_T>
                                    (static_cast<int32_T>(static_cast<int32_T>
                                      (rtb_Abs1_il) + static_cast<int32_T>(
                                       static_cast<int32_T>(static_cast<int32_T>
                                        (Lat) - 1) << 10)) - 1)] = (rtNaN);
                                if (nv >= 1) {
                                    ntoread = 0;
                                    nread = 1;
                                    exitg1 = false;
                                    while ((!exitg1) && (nread <= nv)) {
                                        char_T tmp_5;
                                        tmp_5 = data->data[static_cast<int32_T>(
                                            static_cast<int32_T>(iy + nread) - 1)];
                                        if (o[static_cast<int32_T>
                                                (static_cast<int32_T>(
                                                static_cast<uint8_T>(tmp_5)) &
                                                 127)] || (tmp_5 == '\x00')) {
                                            nread = static_cast<int32_T>(nread +
                                                1);
                                        } else {
                                            exitg1 = true;
                                        }
                                    }

                                    stride = static_cast<int32_T>(data->size[0] *
                                        data->size[1]);
                                    data->size[0] = 1;
                                    data->size[1] = static_cast<int32_T>(nv + 2);
                                    FlightMissionMode_emxEnsureCapacity_char_T_g
                                        (data, stride);
                                    for (i = 0; i <= static_cast<int32_T>(nv + 1);
                                         i++) {
                                        data->data[i] = '\x00';
                                    }

                                    i2 = 1;
                                    FlightMissionMode_readfloat_n0(data, &i2,
                                        curSection, &nread, static_cast<int32_T>
                                        (i1 - iy), &isStable, &p, &Lon, &a__1,
                                        &success);
                                    if (p) {
                                        ntoread = 1;
                                    }

                                    if (static_cast<boolean_T>
                                            (static_cast<int32_T>((nread <= nv)
                                            & static_cast<int32_T>(success)))) {
                                        data->data[static_cast<int32_T>(i2 - 1)]
                                            = ' ';
                                        i2 = static_cast<int32_T>(i2 + 1);
                                        FlightMissionMode_readfloat_n0(data, &i2,
                                            curSection, &nread,
                                            static_cast<int32_T>(i1 - iy), &a__1,
                                            &success, &Alt, &foundsign,
                                            &c_success);
                                        if (success) {
                                            ntoread = static_cast<int32_T>
                                                (ntoread + 1);
                                        }

                                        success = static_cast<boolean_T>(
                                            static_cast<int32_T>
                                            (static_cast<int32_T>
                                             (static_cast<boolean_T>(
                                            static_cast<int32_T>
                                            (static_cast<int32_T>
                                             (static_cast<boolean_T>(
                                            static_cast<int32_T>((nread > nv) &
                                            static_cast<int32_T>(c_success)))) &
                                             static_cast<int32_T>
                                             (static_cast<boolean_T>(
                                            static_cast<int32_T>
                                            (static_cast<int32_T>(isStable) ^
                                             static_cast<int32_T>(a__1))))))) &
                                             static_cast<int32_T>(foundsign)));
                                    } else {
                                        Alt = 0.0;
                                    }

                                    if (success) {
                                        data->data[static_cast<int32_T>(i2 - 1)]
                                            = '\x00';
                                        switch (ntoread) {
                                          case 2:
                                            nread = sscanf(&data->data[0],
                                                           "%lf %lf", &Lon, &Alt);
                                            if (nread != 2) {
                                                Lon = (rtNaN);
                                                Alt = (rtNaN);
                                            }
                                            break;

                                          case 1:
                                            nread = sscanf(&data->data[0], "%lf",
                                                           &d);
                                            if (p) {
                                                if (nread == 1) {
                                                    Lon = d;
                                                } else {
                                                    Lon = (rtNaN);
                                                }
                                            } else if (nread == 1) {
                                                Alt = d;
                                            } else {
                                                Alt = (rtNaN);
                                            }
                                            break;
                                        }

                                        if (isStable) {
                                            localDW->MAT[static_cast<int32_T>(
                                                static_cast<int32_T>(
                                                static_cast<int32_T>(rtb_Abs1_il)
                                                + static_cast<int32_T>(
                                                static_cast<int32_T>(
                                                static_cast<int32_T>(Lat) - 1) <<
                                                10)) - 1)] = Alt;
                                        } else {
                                            localDW->MAT[static_cast<int32_T>(
                                                static_cast<int32_T>(
                                                static_cast<int32_T>(rtb_Abs1_il)
                                                + static_cast<int32_T>(
                                                static_cast<int32_T>(
                                                static_cast<int32_T>(Lat) - 1) <<
                                                10)) - 1)] = Lon;
                                        }
                                    }
                                }
                            }
                        }

                        filestar = FlightMissionMode_fileManager_b(static_cast<
                            real_T>(rtPrevAction), localDW);
                        if (filestar == a) {
                            nread = 0;
                        } else {
                            int st;
                            st = feof(filestar);
                            nread = ((int32_T)st != 0);
                        }

                        if (nread != 0) {
                            exitg2 = 1;
                        } else {
                            FlightMissionMode_fgetl(static_cast<real_T>
                                                    (rtPrevAction), tline,
                                                    localDW);
                        }
                    } while (exitg2 == 0);

                    if (rtb_Abs1_il < 1.0) {
                        iy = -1;
                    } else {
                        iy = static_cast<int32_T>(static_cast<int32_T>
                            (rtb_Abs1_il) - 1);
                    }

                    FlightMissionMode_cfclose_k(static_cast<real_T>(rtPrevAction),
                        localDW);

                    // '<S192>:1:8'
                    // '<S192>:1:9'
                    // '<S192>:1:10'
                    q_size[0] = static_cast<int32_T>(iy + 1);
                    q_size[1] = 3;
                    i = 0;
                    for (i1 = 0; i1 < 3; i1++) {
                        for (i2 = 0; i2 <= iy; i2++) {
                            localDW->q_data[static_cast<int32_T>(i2 +
                                static_cast<int32_T>(static_cast<int32_T>(iy + 1)
                                * i1))] = localDW->MAT[static_cast<int32_T>(i2 +
                                i)];
                        }

                        i = static_cast<int32_T>(i + 1024);
                    }

                    FlightMissionMode_circshift(localDW->q_data, q_size,
                        static_cast<real_T>(rtu_Parameters->Param2));
                    FlightMissionMode_lla2ned(localDW->q_data, q_size, u,
                        localDW->NED_WP_data, NED_WP_size, localDW);
                } else {
                    // '<S192>:1:12'
                    NED_WP_size[0] = 4;
                    for (i = 0; i < 12; i++) {
                        localDW->NED_WP_data[i] = static_cast<real_T>(l[i]);
                    }

                    // '<S192>:1:16'
                    printf("Path waypoint doesn\'t exist!\n");
                    fflush(stdout);
                }

                // '<S192>:1:20'
                rtb_Sum1_e_idx_0 = std::ceil(8192.0 / static_cast<real_T>
                    (NED_WP_size[0]));
                stride = static_cast<int32_T>(dummyWayPoint->size[0] *
                    dummyWayPoint->size[1]);

                // MATLAB Function: '<S166>/WayPointGenerator'
                dummyWayPoint->size[0] = static_cast<int32_T>(NED_WP_size[0] *
                    static_cast<int32_T>(rtb_Sum1_e_idx_0));
                dummyWayPoint->size[1] = 3;
                FlightMissionMode_emxEnsureCapacity_real_T_c(dummyWayPoint,
                    stride);

                // MATLAB Function: '<S166>/WayPointGenerator'
                nv = NED_WP_size[0];
                stride = static_cast<int32_T>(static_cast<int32_T>
                    (rtb_Sum1_e_idx_0) - 1);
                for (i1 = 0; i1 < 3; i1++) {
                    int32_T npages;
                    npages = static_cast<int32_T>(i1 * nv);
                    nread = static_cast<int32_T>(static_cast<int32_T>(
                        static_cast<int32_T>(nv * static_cast<int32_T>
                        (rtb_Sum1_e_idx_0)) * i1) - 1);
                    for (i2 = 0; i2 <= stride; i2++) {
                        int32_T pageroot;
                        pageroot = static_cast<int32_T>(static_cast<int32_T>(
                            static_cast<int32_T>(i2 * nv) + nread) + 1);
                        for (iy = 0; iy <= static_cast<int32_T>(nv - 1); iy++) {
                            dummyWayPoint->data[static_cast<int32_T>(pageroot +
                                iy)] = localDW->NED_WP_data[static_cast<int32_T>
                                (npages + iy)];
                        }
                    }
                }

                // '<S192>:1:23'
                for (i = 0; i < 8192; i++) {
                    localDW->WayPoint[i] = dummyWayPoint->data[i];
                    localDW->WayPoint[static_cast<int32_T>(i + 8192)] =
                        dummyWayPoint->data[static_cast<int32_T>(i +
                        dummyWayPoint->size[0])];
                    localDW->WayPoint[static_cast<int32_T>(i + 16384)] =
                        dummyWayPoint->data[static_cast<int32_T>
                        (static_cast<int32_T>(dummyWayPoint->size[0] << 1) + i)];
                }
            } else {
                localDW->WayPointGenerator_MODE = false;
            }

            // End of Outputs for SubSystem: '<S161>/WayPointGenerator'

            // SwitchCase: '<S161>/Switch Case' incorporates:
            //   DataTypeConversion: '<S161>/Param1'
            //   MATLAB Function: '<S166>/WayPointGenerator'
            //   MATLABSystem: '<S164>/Waypoint Follower'
            //   MATLABSystem: '<S165>/Waypoint Follower'

            rtPrevAction = localDW->SwitchCase_ActiveSubsystem_c;
            tmp_4 = std::trunc(rtu_Parameters->Param1);
            if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<int32_T>
                    (std::isnan(tmp_4)) | static_cast<int32_T>(std::isinf(tmp_4)))))
            {
                tmp_4 = 0.0F;
            } else {
                tmp_4 = std::fmod(tmp_4, 4.2949673E+9F);
            }

            if ((tmp_4 < 0.0F ? static_cast<int32_T>(-static_cast<int32_T>(
                    static_cast<uint32_T>(-tmp_4))) : static_cast<int32_T>(
                    static_cast<uint32_T>(tmp_4))) == 99) {
                rtAction = 0;
            } else {
                rtAction = 1;
            }

            localDW->SwitchCase_ActiveSubsystem_c = rtAction;
            if (static_cast<int32_T>(rtAction) == 0) {
                boolean_T guard1;
                if (static_cast<int32_T>(rtPrevAction) != 0) {
                    // SystemReset for IfAction SubSystem: '<S161>/StartFromClosest' incorporates:
                    //   ActionPort: '<S164>/Action Port'

                    // SystemReset for SwitchCase: '<S161>/Switch Case' incorporates:
                    //   MATLABSystem: '<S164>/Waypoint Follower'

                    localDW->obj_j.WaypointIndex = 1.0;
                    for (i = 0; i < 24576; i++) {
                        localDW->obj_j.WaypointsInternal[i] *= 0.0;
                    }

                    // End of SystemReset for SubSystem: '<S161>/StartFromClosest' 
                }

                // Outputs for IfAction SubSystem: '<S161>/StartFromClosest' incorporates:
                //   ActionPort: '<S164>/Action Port'

                // MATLABSystem: '<S164>/Waypoint Follower'
                localDW->obj_j.LookaheadDistFlag = 0U;
                localDW->obj_j.InitialPose[0] = 0.0;
                localDW->obj_j.InitialPose[1] = 0.0;
                localDW->obj_j.InitialPose[2] = 0.0;
                localDW->obj_j.InitialPose[3] = 0.0;
                std::memset(&localDW->WayPoint_k[0], 0, static_cast<uint32_T>
                            (24576U * sizeof(real_T)));
                for (i = 0; i < 8192; i++) {
                    localDW->WayPoint_k[i] = localDW->WayPoint[i];
                    localDW->WayPoint_k[static_cast<int32_T>(i + 8192)] =
                        localDW->WayPoint[static_cast<int32_T>(i + 8192)];
                    localDW->WayPoint_k[static_cast<int32_T>(i + 16384)] =
                        localDW->WayPoint[static_cast<int32_T>(i + 16384)];
                }

                localDW->obj_j.NumWaypoints = 8192.0;
                guard1 = false;
                if (localDW->obj_j.NumWaypoints != 8192.0) {
                    guard1 = true;
                } else {
                    if (localDW->obj_j.NumWaypoints < 1.0) {
                        iy = 0;
                    } else {
                        iy = static_cast<int32_T>(localDW->obj_j.NumWaypoints);
                    }

                    if (localDW->obj_j.NumWaypoints < 1.0) {
                        i1 = 0;
                    } else {
                        i1 = static_cast<int32_T>(localDW->obj_j.NumWaypoints);
                    }

                    isStable = false;
                    p = false;
                    if (iy == i1) {
                        p = true;
                    }

                    if (p && (iy != 0) && (i1 != 0)) {
                        nread = 0;
                        exitg1 = false;
                        while ((!exitg1) && (nread <= static_cast<int32_T>(
                                 static_cast<int32_T>(i1 * 3) - 1))) {
                            if (static_cast<boolean_T>(static_cast<int32_T>
                                                       ((localDW->obj_j.WaypointsInternal
                                    [static_cast<int32_T>(static_cast<int32_T>(
                                     static_cast<int32_T>(nread / iy) << 13) +
                                    nread % iy)] == localDW->WayPoint_k[
                                    static_cast<int32_T>(static_cast<int32_T>(
                                     static_cast<int32_T>(nread / i1) << 13) +
                                    nread % i1)]) ^ 1))) {
                                p = false;
                                exitg1 = true;
                            } else {
                                nread = static_cast<int32_T>(nread + 1);
                            }
                        }
                    }

                    if (p) {
                        isStable = true;
                    }

                    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<
                            int32_T>(isStable) ^ 1))) {
                        guard1 = true;
                    }
                }

                if (guard1) {
                    std::memcpy(&localDW->obj_j.WaypointsInternal[0],
                                &localDW->WayPoint_k[0], static_cast<uint32_T>
                                (24576U * sizeof(real_T)));
                    localDW->obj_j.WaypointIndex = 1.0;
                    localDW->obj_j.SearchFlag = true;
                }

                for (i = 0; i < 8192; i++) {
                    localDW->distinctWptsIdx[i] = true;
                }

                for (nread = 0; nread < 8191; nread++) {
                    i = 0;
                    i1 = 0;
                    for (i2 = 0; i2 < 3; i2++) {
                        iy = static_cast<int32_T>(i1 + nread);
                        localDW->x_f[static_cast<int32_T>(i + nread)] =
                            (localDW->WayPoint[static_cast<int32_T>(iy + 1)] !=
                             localDW->WayPoint[iy]);
                        i = static_cast<int32_T>(i + 8191);
                        i1 = static_cast<int32_T>(i1 + 8192);
                    }
                }

                i1 = 0;
                i2 = 16382;
                for (nread = 0; nread < 8191; nread++) {
                    localDW->y[nread] = false;
                    i1 = static_cast<int32_T>(i1 + 1);
                    i2 = static_cast<int32_T>(i2 + 1);
                    ntoread = i1;
                    exitg1 = false;
                    while ((!exitg1) && (ntoread <= i2)) {
                        if (localDW->x_f[static_cast<int32_T>(ntoread - 1)]) {
                            localDW->y[nread] = true;
                            exitg1 = true;
                        } else {
                            ntoread = static_cast<int32_T>(ntoread + 8191);
                        }
                    }

                    localDW->distinctWptsIdx[nread] = localDW->y[nread];
                }

                i2 = 0;
                for (iy = 0; iy < 8192; iy++) {
                    if (localDW->distinctWptsIdx[iy]) {
                        i2 = static_cast<int32_T>(i2 + 1);
                    }
                }

                iy = 0;
                for (nread = 0; nread < 8192; nread++) {
                    if (localDW->distinctWptsIdx[nread]) {
                        localDW->b_data[iy] = static_cast<int16_T>(static_cast<
                            int32_T>(nread + 1));
                        iy = static_cast<int32_T>(iy + 1);
                    }
                }

                stride = static_cast<int32_T>(b_waypointsIn->size[0] *
                    b_waypointsIn->size[1]);

                // MATLABSystem: '<S164>/Waypoint Follower'
                b_waypointsIn->size[0] = i2;
                b_waypointsIn->size[1] = 3;
                FlightMissionMode_emxEnsureCapacity_real_T_c(b_waypointsIn,
                    stride);

                // MATLABSystem: '<S164>/Waypoint Follower'
                for (i = 0; i < 3; i++) {
                    for (i1 = 0; i1 <= static_cast<int32_T>(i2 - 1); i1++) {
                        b_waypointsIn->data[static_cast<int32_T>(i1 +
                            static_cast<int32_T>(b_waypointsIn->size[0] * i))] =
                            localDW->WayPoint[static_cast<int32_T>
                            (static_cast<int32_T>(static_cast<int32_T>(i << 13)
                              + static_cast<int32_T>(localDW->b_data[i1])) - 1)];
                    }
                }

                localDW->obj_j.LookaheadDistance = 200.0;
                if (i2 == 0) {
                    // SignalConversion generated from: '<S164>/Waypoint Follower' incorporates:
                    //   Merge: '<S161>/MergeLAP'

                    LLA0_gw[2] = rtu_Pose[2];

                    // SignalConversion generated from: '<S164>/Waypoint Follower' 
                    rtb_Switch_l = rtu_Pose[3];

                    // SignalConversion generated from: '<S164>/Waypoint Follower' 
                    rtb_MergeStatus = 1U;
                } else {
                    guard1 = false;
                    if (i2 == 1) {
                        if (localDW->obj_j.StartFlag) {
                            localDW->obj_j.InitialPose[0] = rtu_Pose[0];
                            localDW->obj_j.InitialPose[1] = rtu_Pose[1];
                            localDW->obj_j.InitialPose[2] = rtu_Pose[2];
                            localDW->obj_j.InitialPose[3] = rtu_Pose[3];
                        }

                        u[0] = b_waypointsIn->data[0] - rtu_Pose[0];
                        u[1] = b_waypointsIn->data[1] - rtu_Pose[1];
                        u[2] = b_waypointsIn->data[2] - rtu_Pose[2];
                        if (FlightMissionMode_norm_pv(u) < 1.4901161193847656E-8)
                        {
                            // SignalConversion generated from: '<S164>/Waypoint Follower' incorporates:
                            //   Merge: '<S161>/MergeLAP'

                            LLA0_gw[2] = rtu_Pose[2];

                            // SignalConversion generated from: '<S164>/Waypoint Follower' 
                            rtb_Switch_l = rtu_Pose[3];

                            // SignalConversion generated from: '<S164>/Waypoint Follower' 
                            rtb_MergeStatus = 1U;
                            localDW->obj_j.StartFlag = false;
                        } else {
                            localDW->obj_j.StartFlag = false;
                            localDW->obj_j.NumWaypoints = 2.0;
                            stride = static_cast<int32_T>(waypoints->size[0] *
                                waypoints->size[1]);
                            waypoints->size[0] = static_cast<int32_T>
                                (b_waypointsIn->size[0] + 1);
                            waypoints->size[1] = 3;
                            FlightMissionMode_emxEnsureCapacity_real_T_c
                                (waypoints, stride);
                            nv = b_waypointsIn->size[0];
                            for (i = 0; i < 3; i++) {
                                waypoints->data[static_cast<int32_T>
                                    (waypoints->size[0] * i)] =
                                    localDW->obj_j.InitialPose[i];
                                for (i1 = 0; i1 <= static_cast<int32_T>(nv - 1);
                                     i1++) {
                                    waypoints->data[static_cast<int32_T>(
                                        static_cast<int32_T>(i1 +
                                        static_cast<int32_T>(waypoints->size[0] *
                                        i)) + 1)] = b_waypointsIn->data[
                                        static_cast<int32_T>(static_cast<int32_T>
                                        (b_waypointsIn->size[0] * i) + i1)];
                                }
                            }

                            guard1 = true;
                        }
                    } else {
                        stride = static_cast<int32_T>(waypoints->size[0] *
                            waypoints->size[1]);
                        waypoints->size[0] = b_waypointsIn->size[0];
                        waypoints->size[1] = 3;
                        FlightMissionMode_emxEnsureCapacity_real_T_c(waypoints,
                            stride);
                        nv = static_cast<int32_T>(b_waypointsIn->size[0] * 3);
                        for (i = 0; i <= static_cast<int32_T>(nv - 1); i++) {
                            waypoints->data[i] = b_waypointsIn->data[i];
                        }

                        guard1 = true;
                    }

                    if (guard1) {
                        real_T distToCenter_tmp_0;
                        boolean_T guard2;
                        if (localDW->obj_j.SearchFlag) {
                            FlightMissionMode_WaypointFollowerBase_searchClosestPath
                                (&localDW->obj_j, waypoints, rtu_Pose);
                        }

                        isStable = false;
                        if (localDW->obj_j.WaypointIndex ==
                                localDW->obj_j.NumWaypoints) {
                            isStable = true;
                        }

                        if (isStable) {
                            localDW->obj_j.LastWaypointFlag = true;
                            localDW->obj_j.WaypointIndex--;
                        }

                        u[0] = rtu_Pose[0] - waypoints->data[static_cast<int32_T>
                            (static_cast<int32_T>(localDW->obj_j.WaypointIndex +
                              1.0) - 1)];
                        u[1] = rtu_Pose[1] - waypoints->data[static_cast<int32_T>
                            (static_cast<int32_T>(static_cast<int32_T>
                              (localDW->obj_j.WaypointIndex + 1.0) +
                              waypoints->size[0]) - 1)];
                        u[2] = rtu_Pose[2] - waypoints->data[static_cast<int32_T>
                            (static_cast<int32_T>(static_cast<int32_T>
                              (localDW->obj_j.WaypointIndex + 1.0) +
                              static_cast<int32_T>(waypoints->size[0] << 1)) - 1)];
                        guard2 = false;
                        if (FlightMissionMode_norm_pv(u) <= 30.0) {
                            guard2 = true;
                        } else {
                            rtb_Abs1_il = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>
                                (localDW->obj_j.WaypointIndex + 1.0) - 1)];
                            LLA0_gw[0] = rtu_Pose[0] - rtb_Abs1_il;
                            u[0] = rtb_Abs1_il - waypoints->data
                                [static_cast<int32_T>(static_cast<int32_T>
                                (localDW->obj_j.WaypointIndex) - 1)];
                            rtb_Abs1_il = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>
                                (localDW->obj_j.WaypointIndex + 1.0) +
                                waypoints->size[0]) - 1)];
                            LLA0_gw[1] = rtu_Pose[1] - rtb_Abs1_il;
                            u[1] = rtb_Abs1_il - waypoints->data
                                [static_cast<int32_T>(static_cast<int32_T>(
                                static_cast<int32_T>
                                (localDW->obj_j.WaypointIndex) + waypoints->
                                size[0]) - 1)];
                            LLA0_gw[2] = rtu_Pose[2] - waypoints->data[
                                static_cast<int32_T>(static_cast<int32_T>(
                                static_cast<int32_T>
                                (localDW->obj_j.WaypointIndex + 1.0) +
                                static_cast<int32_T>(waypoints->size[0] << 1)) -
                                1)];
                            u[2] = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>
                                (localDW->obj_j.WaypointIndex + 1.0) +
                                static_cast<int32_T>(waypoints->size[0] << 1)) -
                                1)] - waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>
                                (waypoints->size[0] << 1) + static_cast<int32_T>
                                (localDW->obj_j.WaypointIndex)) - 1)];
                            rtb_Sum1_e_idx_0 = FlightMissionMode_norm_pv(u);
                            distToCenter_tmp_0 = FlightMissionMode_norm_pv
                                (LLA0_gw);
                            distToCenter = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>
                                (localDW->obj_j.WaypointIndex) - 1)];
                            rtb_Abs1_il = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>
                                (localDW->obj_j.WaypointIndex + 1.0) - 1)];
                            Alt = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>
                                (localDW->obj_j.WaypointIndex) + waypoints->
                                size[0]) - 1)];
                            rtb_Switch_l = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>
                                (localDW->obj_j.WaypointIndex + 1.0) +
                                waypoints->size[0]) - 1)];
                            turnVector_idx_2 = waypoints->data
                                [static_cast<int32_T>(static_cast<int32_T>(
                                static_cast<int32_T>(waypoints->size[0] << 1) +
                                static_cast<int32_T>
                                (localDW->obj_j.WaypointIndex)) - 1)];
                            Lon = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>
                                (localDW->obj_j.WaypointIndex + 1.0) +
                                static_cast<int32_T>(waypoints->size[0] << 1)) -
                                1)];
                            d = ((rtb_Abs1_il - distToCenter) / rtb_Sum1_e_idx_0
                                 * (LLA0_gw[0] / distToCenter_tmp_0) +
                                 (rtb_Switch_l - Alt) / rtb_Sum1_e_idx_0 *
                                 (LLA0_gw[1] / distToCenter_tmp_0)) + (Lon -
                                turnVector_idx_2) / rtb_Sum1_e_idx_0 * (LLA0_gw
                                [2] / distToCenter_tmp_0);
                            if (std::isnan(d)) {
                                rtb_Sum1_e_idx_0 = (rtNaN);
                            } else if (d < 0.0) {
                                rtb_Sum1_e_idx_0 = -1.0;
                            } else {
                                rtb_Sum1_e_idx_0 = static_cast<real_T>(d > 0.0);
                            }

                            if (rtb_Sum1_e_idx_0 >= 0.0) {
                                guard2 = true;
                            } else {
                                LLA0_gw[0] = rtb_Abs1_il;
                                LLA0_gw[1] = rtb_Switch_l;
                                LLA0_gw[2] = Lon;
                            }
                        }

                        if (guard2) {
                            localDW->obj_j.WaypointIndex++;
                            isStable = false;
                            if (localDW->obj_j.WaypointIndex ==
                                    localDW->obj_j.NumWaypoints) {
                                isStable = true;
                            }

                            if (isStable) {
                                localDW->obj_j.LastWaypointFlag = true;
                                localDW->obj_j.WaypointIndex--;
                            }

                            distToCenter = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>
                                (localDW->obj_j.WaypointIndex) - 1)];
                            LLA0_gw[0] = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>
                                (localDW->obj_j.WaypointIndex + 1.0) - 1)];
                            Alt = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>
                                (localDW->obj_j.WaypointIndex) + waypoints->
                                size[0]) - 1)];
                            LLA0_gw[1] = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>
                                (localDW->obj_j.WaypointIndex + 1.0) +
                                waypoints->size[0]) - 1)];
                            turnVector_idx_2 = waypoints->data
                                [static_cast<int32_T>(static_cast<int32_T>(
                                static_cast<int32_T>(waypoints->size[0] << 1) +
                                static_cast<int32_T>
                                (localDW->obj_j.WaypointIndex)) - 1)];
                            LLA0_gw[2] = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>
                                (localDW->obj_j.WaypointIndex + 1.0) +
                                static_cast<int32_T>(waypoints->size[0] << 1)) -
                                1)];
                        }

                        rtb_Sum1_e_idx_1 = LLA0_gw[0] - distToCenter;
                        rtb_Switch_l = rtu_Pose[0] - distToCenter;
                        rtb_Sum1_e_idx_0 = LLA0_gw[1] - Alt;
                        Lon = rtu_Pose[1] - Alt;
                        distToCenter_tmp_0 = LLA0_gw[2] - turnVector_idx_2;
                        d = rtu_Pose[2] - turnVector_idx_2;
                        rtb_Abs1_il = ((Lon * rtb_Sum1_e_idx_0 + rtb_Switch_l *
                                        rtb_Sum1_e_idx_1) + d *
                                       distToCenter_tmp_0) / ((rtb_Sum1_e_idx_0 *
                            rtb_Sum1_e_idx_0 + rtb_Sum1_e_idx_1 *
                            rtb_Sum1_e_idx_1) + distToCenter_tmp_0 *
                            distToCenter_tmp_0);
                        if (rtb_Abs1_il < 0.0) {
                            u[0] = rtb_Switch_l;
                            u[1] = Lon;
                            u[2] = d;
                            rtb_Abs1_il = FlightMissionMode_norm_pv(u);
                        } else if (rtb_Abs1_il > 1.0) {
                            u[0] = rtu_Pose[0] - LLA0_gw[0];
                            u[1] = rtu_Pose[1] - LLA0_gw[1];
                            u[2] = rtu_Pose[2] - LLA0_gw[2];
                            rtb_Abs1_il = FlightMissionMode_norm_pv(u);
                        } else {
                            u[0] = rtu_Pose[0] - (rtb_Abs1_il * rtb_Sum1_e_idx_1
                                                  + distToCenter);
                            u[1] = rtu_Pose[1] - (rtb_Abs1_il * rtb_Sum1_e_idx_0
                                                  + Alt);
                            u[2] = rtu_Pose[2] - (rtb_Abs1_il *
                                                  distToCenter_tmp_0 +
                                                  turnVector_idx_2);
                            rtb_Abs1_il = FlightMissionMode_norm_pv(u);
                        }

                        if (localDW->obj_j.LastWaypointFlag) {
                            rtb_Abs1_il = (((rtu_Pose[0] - distToCenter) *
                                            (LLA0_gw[0] - distToCenter) + Lon *
                                            rtb_Sum1_e_idx_0) + (rtu_Pose[2] -
                                            turnVector_idx_2) * (LLA0_gw[2] -
                                            turnVector_idx_2)) / (((LLA0_gw[0] -
                                distToCenter) * (LLA0_gw[0] - distToCenter) +
                                rtb_Sum1_e_idx_0 * rtb_Sum1_e_idx_0) + (LLA0_gw
                                [2] - turnVector_idx_2) * (LLA0_gw[2] -
                                turnVector_idx_2));
                            u[0] = rtu_Pose[0] - (rtb_Abs1_il * rtb_Sum1_e_idx_1
                                                  + distToCenter);
                            u[1] = rtu_Pose[1] - (rtb_Abs1_il * rtb_Sum1_e_idx_0
                                                  + Alt);
                            u[2] = rtu_Pose[2] - (rtb_Abs1_il *
                                                  distToCenter_tmp_0 +
                                                  turnVector_idx_2);
                            rtb_Abs1_il = FlightMissionMode_norm_pv(u);
                        }

                        d = std::abs(rtb_Abs1_il);
                        if (static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(std::isinf(d)) |
                                static_cast<int32_T>(std::isnan(d))))) {
                            Lon = (rtNaN);
                            rtb_Switch_l = (rtNaN);
                        } else if (d < 4.4501477170144028E-308) {
                            Lon = 4.94065645841247E-324;
                            rtb_Switch_l = 4.94065645841247E-324;
                        } else {
                            std::frexp(d, &rtb_Bias_mn);
                            Lon = std::ldexp(1.0, static_cast<int32_T>
                                             (rtb_Bias_mn - 53));
                            std::frexp(d, &b_exponent);
                            rtb_Switch_l = std::ldexp(1.0, static_cast<int32_T>
                                (b_exponent - 53));
                        }

                        if (localDW->obj_j.LookaheadDistance <= std::fmax(std::
                                sqrt(Lon), 5.0 * rtb_Switch_l) + rtb_Abs1_il) {
                            localDW->obj_j.LookaheadDistance =
                                localDW->obj_j.LookaheadFactor * rtb_Abs1_il;
                        }

                        d = distToCenter - rtu_Pose[0];
                        u[0] = d;
                        rtb_Switch_l = Alt - rtu_Pose[1];
                        u[1] = rtb_Switch_l;
                        Lon = ((LLA0_gw[0] - distToCenter) * (LLA0_gw[0] -
                                distToCenter) + (LLA0_gw[1] - Alt) * (LLA0_gw[1]
                                - Alt)) + (LLA0_gw[2] - turnVector_idx_2) *
                            (LLA0_gw[2] - turnVector_idx_2);
                        xyCenter_idx_1 = turnVector_idx_2 - rtu_Pose[2];
                        u[2] = xyCenter_idx_1;
                        rtb_Abs1_il = ((rtb_Sum1_e_idx_1 * d + rtb_Sum1_e_idx_0 *
                                        rtb_Switch_l) + distToCenter_tmp_0 *
                                       xyCenter_idx_1) * 2.0;
                        rtb_Switch_l = std::sqrt(rtb_Abs1_il * rtb_Abs1_il -
                            (((d * d + rtb_Switch_l * rtb_Switch_l) +
                              xyCenter_idx_1 * xyCenter_idx_1) -
                             localDW->obj_j.LookaheadDistance *
                             localDW->obj_j.LookaheadDistance) * (4.0 * Lon));
                        Lon = std::fmax((-rtb_Abs1_il + rtb_Switch_l) / 2.0 /
                                        Lon, (-rtb_Abs1_il - rtb_Switch_l) / 2.0
                                        / Lon);
                        LLA0_gw[2] = (1.0 - Lon) * turnVector_idx_2 + Lon *
                            LLA0_gw[2];

                        // SignalConversion generated from: '<S164>/Waypoint Follower' 
                        rtb_Switch_l = rt_atan2d_snf(((1.0 - Lon) * Alt + Lon *
                            LLA0_gw[1]) - rtu_Pose[1], ((1.0 - Lon) *
                            distToCenter + Lon * LLA0_gw[0]) - rtu_Pose[0]);

                        // SignalConversion generated from: '<S164>/Waypoint Follower' 
                        rtb_MergeStatus = 0U;
                        isStable = false;
                        if (localDW->obj_j.LastWaypointFlag) {
                            isStable = true;
                        }

                        if (isStable) {
                            // SignalConversion generated from: '<S164>/Waypoint Follower' 
                            rtb_MergeStatus = 1U;
                        }

                        localDW->obj_j.LastWaypointFlag = false;
                    }
                }

                // End of Outputs for SubSystem: '<S161>/StartFromClosest'
            } else {
                boolean_T guard1;
                if (static_cast<int32_T>(rtPrevAction) != 1) {
                    // SystemReset for IfAction SubSystem: '<S161>/StartFromFirst' incorporates:
                    //   ActionPort: '<S165>/Action Port'

                    // SystemReset for SwitchCase: '<S161>/Switch Case' incorporates:
                    //   MATLABSystem: '<S165>/Waypoint Follower'

                    localDW->obj.WaypointIndex = 1.0;
                    for (i = 0; i < 24576; i++) {
                        localDW->obj.WaypointsInternal[i] *= 0.0;
                    }

                    // End of SystemReset for SubSystem: '<S161>/StartFromFirst' 
                }

                // Outputs for IfAction SubSystem: '<S161>/StartFromFirst' incorporates:
                //   ActionPort: '<S165>/Action Port'

                // MATLABSystem: '<S165>/Waypoint Follower'
                localDW->obj.LookaheadDistFlag = 0U;
                localDW->obj.InitialPose[0] = 0.0;
                localDW->obj.InitialPose[1] = 0.0;
                localDW->obj.InitialPose[2] = 0.0;
                localDW->obj.InitialPose[3] = 0.0;
                std::memset(&localDW->WayPoint_k[0], 0, static_cast<uint32_T>
                            (24576U * sizeof(real_T)));
                for (i = 0; i < 8192; i++) {
                    localDW->WayPoint_k[i] = localDW->WayPoint[i];
                    localDW->WayPoint_k[static_cast<int32_T>(i + 8192)] =
                        localDW->WayPoint[static_cast<int32_T>(i + 8192)];
                    localDW->WayPoint_k[static_cast<int32_T>(i + 16384)] =
                        localDW->WayPoint[static_cast<int32_T>(i + 16384)];
                }

                localDW->obj.NumWaypoints = 8192.0;
                guard1 = false;
                if (localDW->obj.NumWaypoints != 8192.0) {
                    guard1 = true;
                } else {
                    if (localDW->obj.NumWaypoints < 1.0) {
                        iy = 0;
                    } else {
                        iy = static_cast<int32_T>(localDW->obj.NumWaypoints);
                    }

                    if (localDW->obj.NumWaypoints < 1.0) {
                        i1 = 0;
                    } else {
                        i1 = static_cast<int32_T>(localDW->obj.NumWaypoints);
                    }

                    isStable = false;
                    p = false;
                    if (iy == i1) {
                        p = true;
                    }

                    if (p && (iy != 0) && (i1 != 0)) {
                        nread = 0;
                        exitg1 = false;
                        while ((!exitg1) && (nread <= static_cast<int32_T>(
                                 static_cast<int32_T>(i1 * 3) - 1))) {
                            if (static_cast<boolean_T>(static_cast<int32_T>
                                                       ((localDW->obj.WaypointsInternal
                                    [static_cast<int32_T>(static_cast<int32_T>(
                                     static_cast<int32_T>(nread / iy) << 13) +
                                    nread % iy)] == localDW->WayPoint_k[
                                    static_cast<int32_T>(static_cast<int32_T>(
                                     static_cast<int32_T>(nread / i1) << 13) +
                                    nread % i1)]) ^ 1))) {
                                p = false;
                                exitg1 = true;
                            } else {
                                nread = static_cast<int32_T>(nread + 1);
                            }
                        }
                    }

                    if (p) {
                        isStable = true;
                    }

                    if (static_cast<boolean_T>(static_cast<int32_T>(static_cast<
                            int32_T>(isStable) ^ 1))) {
                        guard1 = true;
                    }
                }

                if (guard1) {
                    std::memcpy(&localDW->obj.WaypointsInternal[0],
                                &localDW->WayPoint_k[0], static_cast<uint32_T>
                                (24576U * sizeof(real_T)));
                    localDW->obj.WaypointIndex = 1.0;
                }

                for (i = 0; i < 8192; i++) {
                    localDW->distinctWptsIdx[i] = true;
                }

                for (nread = 0; nread < 8191; nread++) {
                    i = 0;
                    i1 = 0;
                    for (i2 = 0; i2 < 3; i2++) {
                        iy = static_cast<int32_T>(i1 + nread);
                        localDW->x_f[static_cast<int32_T>(i + nread)] =
                            (localDW->WayPoint[static_cast<int32_T>(iy + 1)] !=
                             localDW->WayPoint[iy]);
                        i = static_cast<int32_T>(i + 8191);
                        i1 = static_cast<int32_T>(i1 + 8192);
                    }
                }

                i1 = 0;
                i2 = 16382;
                for (nread = 0; nread < 8191; nread++) {
                    localDW->y[nread] = false;
                    i1 = static_cast<int32_T>(i1 + 1);
                    i2 = static_cast<int32_T>(i2 + 1);
                    ntoread = i1;
                    exitg1 = false;
                    while ((!exitg1) && (ntoread <= i2)) {
                        if (localDW->x_f[static_cast<int32_T>(ntoread - 1)]) {
                            localDW->y[nread] = true;
                            exitg1 = true;
                        } else {
                            ntoread = static_cast<int32_T>(ntoread + 8191);
                        }
                    }

                    localDW->distinctWptsIdx[nread] = localDW->y[nread];
                }

                i2 = 0;
                for (iy = 0; iy < 8192; iy++) {
                    if (localDW->distinctWptsIdx[iy]) {
                        i2 = static_cast<int32_T>(i2 + 1);
                    }
                }

                iy = 0;
                for (nread = 0; nread < 8192; nread++) {
                    if (localDW->distinctWptsIdx[nread]) {
                        localDW->b_data[iy] = static_cast<int16_T>(static_cast<
                            int32_T>(nread + 1));
                        iy = static_cast<int32_T>(iy + 1);
                    }
                }

                stride = static_cast<int32_T>(b_waypointsIn->size[0] *
                    b_waypointsIn->size[1]);

                // MATLABSystem: '<S165>/Waypoint Follower'
                b_waypointsIn->size[0] = i2;
                b_waypointsIn->size[1] = 3;
                FlightMissionMode_emxEnsureCapacity_real_T_c(b_waypointsIn,
                    stride);

                // MATLABSystem: '<S165>/Waypoint Follower'
                for (i = 0; i < 3; i++) {
                    for (i1 = 0; i1 <= static_cast<int32_T>(i2 - 1); i1++) {
                        b_waypointsIn->data[static_cast<int32_T>(i1 +
                            static_cast<int32_T>(b_waypointsIn->size[0] * i))] =
                            localDW->WayPoint[static_cast<int32_T>
                            (static_cast<int32_T>(static_cast<int32_T>(i << 13)
                              + static_cast<int32_T>(localDW->b_data[i1])) - 1)];
                    }
                }

                localDW->obj.LookaheadDistance = 200.0;
                if (i2 == 0) {
                    // SignalConversion generated from: '<S165>/Waypoint Follower' incorporates:
                    //   Merge: '<S161>/MergeLAP'

                    LLA0_gw[2] = rtu_Pose[2];

                    // SignalConversion generated from: '<S165>/Waypoint Follower' 
                    rtb_Switch_l = rtu_Pose[3];

                    // SignalConversion generated from: '<S165>/Waypoint Follower' 
                    rtb_MergeStatus = 1U;
                } else {
                    guard1 = false;
                    if (i2 == 1) {
                        if (localDW->obj.StartFlag) {
                            localDW->obj.InitialPose[0] = rtu_Pose[0];
                            localDW->obj.InitialPose[1] = rtu_Pose[1];
                            localDW->obj.InitialPose[2] = rtu_Pose[2];
                            localDW->obj.InitialPose[3] = rtu_Pose[3];
                        }

                        u[0] = b_waypointsIn->data[0] - rtu_Pose[0];
                        u[1] = b_waypointsIn->data[1] - rtu_Pose[1];
                        u[2] = b_waypointsIn->data[2] - rtu_Pose[2];
                        if (FlightMissionMode_norm_pv(u) < 1.4901161193847656E-8)
                        {
                            // SignalConversion generated from: '<S165>/Waypoint Follower' incorporates:
                            //   Merge: '<S161>/MergeLAP'

                            LLA0_gw[2] = rtu_Pose[2];

                            // SignalConversion generated from: '<S165>/Waypoint Follower' 
                            rtb_Switch_l = rtu_Pose[3];

                            // SignalConversion generated from: '<S165>/Waypoint Follower' 
                            rtb_MergeStatus = 1U;
                            localDW->obj.StartFlag = false;
                        } else {
                            localDW->obj.StartFlag = false;
                            localDW->obj.NumWaypoints = 2.0;
                            stride = static_cast<int32_T>(waypoints->size[0] *
                                waypoints->size[1]);
                            waypoints->size[0] = static_cast<int32_T>
                                (b_waypointsIn->size[0] + 1);
                            waypoints->size[1] = 3;
                            FlightMissionMode_emxEnsureCapacity_real_T_c
                                (waypoints, stride);
                            nv = b_waypointsIn->size[0];
                            for (i = 0; i < 3; i++) {
                                waypoints->data[static_cast<int32_T>
                                    (waypoints->size[0] * i)] =
                                    localDW->obj.InitialPose[i];
                                for (i1 = 0; i1 <= static_cast<int32_T>(nv - 1);
                                     i1++) {
                                    waypoints->data[static_cast<int32_T>(
                                        static_cast<int32_T>(i1 +
                                        static_cast<int32_T>(waypoints->size[0] *
                                        i)) + 1)] = b_waypointsIn->data[
                                        static_cast<int32_T>(static_cast<int32_T>
                                        (b_waypointsIn->size[0] * i) + i1)];
                                }
                            }

                            guard1 = true;
                        }
                    } else {
                        stride = static_cast<int32_T>(waypoints->size[0] *
                            waypoints->size[1]);
                        waypoints->size[0] = b_waypointsIn->size[0];
                        waypoints->size[1] = 3;
                        FlightMissionMode_emxEnsureCapacity_real_T_c(waypoints,
                            stride);
                        nv = static_cast<int32_T>(b_waypointsIn->size[0] * 3);
                        for (i = 0; i <= static_cast<int32_T>(nv - 1); i++) {
                            waypoints->data[i] = b_waypointsIn->data[i];
                        }

                        guard1 = true;
                    }

                    if (guard1) {
                        real_T distToCenter_tmp_0;
                        boolean_T guard2;
                        isStable = false;
                        if (localDW->obj.WaypointIndex ==
                                localDW->obj.NumWaypoints) {
                            isStable = true;
                        }

                        if (isStable) {
                            localDW->obj.LastWaypointFlag = true;
                            localDW->obj.WaypointIndex--;
                        }

                        u[0] = rtu_Pose[0] - waypoints->data[static_cast<int32_T>
                            (static_cast<int32_T>(localDW->obj.WaypointIndex +
                              1.0) - 1)];
                        u[1] = rtu_Pose[1] - waypoints->data[static_cast<int32_T>
                            (static_cast<int32_T>(static_cast<int32_T>
                              (localDW->obj.WaypointIndex + 1.0) +
                              waypoints->size[0]) - 1)];
                        u[2] = rtu_Pose[2] - waypoints->data[static_cast<int32_T>
                            (static_cast<int32_T>(static_cast<int32_T>
                              (localDW->obj.WaypointIndex + 1.0) +
                              static_cast<int32_T>(waypoints->size[0] << 1)) - 1)];
                        guard2 = false;
                        if (FlightMissionMode_norm_pv(u) <= 30.0) {
                            guard2 = true;
                        } else {
                            rtb_Abs1_il = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(localDW->obj.WaypointIndex
                                + 1.0) - 1)];
                            LLA0_gw[0] = rtu_Pose[0] - rtb_Abs1_il;
                            u[0] = rtb_Abs1_il - waypoints->data
                                [static_cast<int32_T>(static_cast<int32_T>
                                (localDW->obj.WaypointIndex) - 1)];
                            rtb_Abs1_il = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>
                                (localDW->obj.WaypointIndex + 1.0) +
                                waypoints->size[0]) - 1)];
                            LLA0_gw[1] = rtu_Pose[1] - rtb_Abs1_il;
                            u[1] = rtb_Abs1_il - waypoints->data
                                [static_cast<int32_T>(static_cast<int32_T>(
                                static_cast<int32_T>(localDW->obj.WaypointIndex)
                                + waypoints->size[0]) - 1)];
                            LLA0_gw[2] = rtu_Pose[2] - waypoints->data[
                                static_cast<int32_T>(static_cast<int32_T>(
                                static_cast<int32_T>(localDW->obj.WaypointIndex
                                + 1.0) + static_cast<int32_T>(waypoints->size[0]
                                << 1)) - 1)];
                            u[2] = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>
                                (localDW->obj.WaypointIndex + 1.0) +
                                static_cast<int32_T>(waypoints->size[0] << 1)) -
                                1)] - waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>
                                (waypoints->size[0] << 1) + static_cast<int32_T>
                                (localDW->obj.WaypointIndex)) - 1)];
                            rtb_Sum1_e_idx_0 = FlightMissionMode_norm_pv(u);
                            distToCenter_tmp_0 = FlightMissionMode_norm_pv
                                (LLA0_gw);
                            distToCenter = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(localDW->obj.WaypointIndex)
                                - 1)];
                            rtb_Abs1_il = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(localDW->obj.WaypointIndex
                                + 1.0) - 1)];
                            Alt = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>
                                (localDW->obj.WaypointIndex) + waypoints->size[0])
                                - 1)];
                            rtb_Switch_l = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>
                                (localDW->obj.WaypointIndex + 1.0) +
                                waypoints->size[0]) - 1)];
                            turnVector_idx_2 = waypoints->data
                                [static_cast<int32_T>(static_cast<int32_T>(
                                static_cast<int32_T>(waypoints->size[0] << 1) +
                                static_cast<int32_T>(localDW->obj.WaypointIndex))
                                - 1)];
                            Lon = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>
                                (localDW->obj.WaypointIndex + 1.0) +
                                static_cast<int32_T>(waypoints->size[0] << 1)) -
                                1)];
                            d = ((rtb_Abs1_il - distToCenter) / rtb_Sum1_e_idx_0
                                 * (LLA0_gw[0] / distToCenter_tmp_0) +
                                 (rtb_Switch_l - Alt) / rtb_Sum1_e_idx_0 *
                                 (LLA0_gw[1] / distToCenter_tmp_0)) + (Lon -
                                turnVector_idx_2) / rtb_Sum1_e_idx_0 * (LLA0_gw
                                [2] / distToCenter_tmp_0);
                            if (std::isnan(d)) {
                                rtb_Sum1_e_idx_0 = (rtNaN);
                            } else if (d < 0.0) {
                                rtb_Sum1_e_idx_0 = -1.0;
                            } else {
                                rtb_Sum1_e_idx_0 = static_cast<real_T>(d > 0.0);
                            }

                            if (rtb_Sum1_e_idx_0 >= 0.0) {
                                guard2 = true;
                            } else {
                                LLA0_gw[0] = rtb_Abs1_il;
                                LLA0_gw[1] = rtb_Switch_l;
                                LLA0_gw[2] = Lon;
                            }
                        }

                        if (guard2) {
                            localDW->obj.WaypointIndex++;
                            isStable = false;
                            if (localDW->obj.WaypointIndex ==
                                    localDW->obj.NumWaypoints) {
                                isStable = true;
                            }

                            if (isStable) {
                                localDW->obj.LastWaypointFlag = true;
                                localDW->obj.WaypointIndex--;
                            }

                            distToCenter = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(localDW->obj.WaypointIndex)
                                - 1)];
                            LLA0_gw[0] = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(localDW->obj.WaypointIndex
                                + 1.0) - 1)];
                            Alt = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>
                                (localDW->obj.WaypointIndex) + waypoints->size[0])
                                - 1)];
                            LLA0_gw[1] = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>
                                (localDW->obj.WaypointIndex + 1.0) +
                                waypoints->size[0]) - 1)];
                            turnVector_idx_2 = waypoints->data
                                [static_cast<int32_T>(static_cast<int32_T>(
                                static_cast<int32_T>(waypoints->size[0] << 1) +
                                static_cast<int32_T>(localDW->obj.WaypointIndex))
                                - 1)];
                            LLA0_gw[2] = waypoints->data[static_cast<int32_T>(
                                static_cast<int32_T>(static_cast<int32_T>
                                (localDW->obj.WaypointIndex + 1.0) +
                                static_cast<int32_T>(waypoints->size[0] << 1)) -
                                1)];
                        }

                        Lat = LLA0_gw[0] - distToCenter;
                        rtb_Switch_l = rtu_Pose[0] - distToCenter;
                        rtb_Sum1_e_idx_0 = LLA0_gw[1] - Alt;
                        Lon = rtu_Pose[1] - Alt;
                        distToCenter_tmp_0 = LLA0_gw[2] - turnVector_idx_2;
                        d = rtu_Pose[2] - turnVector_idx_2;
                        rtb_Abs1_il = ((Lon * rtb_Sum1_e_idx_0 + rtb_Switch_l *
                                        Lat) + d * distToCenter_tmp_0) /
                            ((rtb_Sum1_e_idx_0 * rtb_Sum1_e_idx_0 + Lat * Lat) +
                             distToCenter_tmp_0 * distToCenter_tmp_0);
                        if (rtb_Abs1_il < 0.0) {
                            u[0] = rtb_Switch_l;
                            u[1] = Lon;
                            u[2] = d;
                            rtb_Abs1_il = FlightMissionMode_norm_pv(u);
                        } else if (rtb_Abs1_il > 1.0) {
                            u[0] = rtu_Pose[0] - LLA0_gw[0];
                            u[1] = rtu_Pose[1] - LLA0_gw[1];
                            u[2] = rtu_Pose[2] - LLA0_gw[2];
                            rtb_Abs1_il = FlightMissionMode_norm_pv(u);
                        } else {
                            u[0] = rtu_Pose[0] - (rtb_Abs1_il * Lat +
                                                  distToCenter);
                            u[1] = rtu_Pose[1] - (rtb_Abs1_il * rtb_Sum1_e_idx_0
                                                  + Alt);
                            u[2] = rtu_Pose[2] - (rtb_Abs1_il *
                                                  distToCenter_tmp_0 +
                                                  turnVector_idx_2);
                            rtb_Abs1_il = FlightMissionMode_norm_pv(u);
                        }

                        if (localDW->obj.LastWaypointFlag) {
                            rtb_Abs1_il = ((rtb_Switch_l * Lat + Lon *
                                            rtb_Sum1_e_idx_0) + (rtu_Pose[2] -
                                            turnVector_idx_2) * (LLA0_gw[2] -
                                            turnVector_idx_2)) / ((Lat * Lat +
                                rtb_Sum1_e_idx_0 * rtb_Sum1_e_idx_0) + (LLA0_gw
                                [2] - turnVector_idx_2) * (LLA0_gw[2] -
                                turnVector_idx_2));
                            u[0] = rtu_Pose[0] - (rtb_Abs1_il * Lat +
                                                  distToCenter);
                            u[1] = rtu_Pose[1] - (rtb_Abs1_il * rtb_Sum1_e_idx_0
                                                  + Alt);
                            u[2] = rtu_Pose[2] - (rtb_Abs1_il *
                                                  distToCenter_tmp_0 +
                                                  turnVector_idx_2);
                            rtb_Abs1_il = FlightMissionMode_norm_pv(u);
                        }

                        d = std::abs(rtb_Abs1_il);
                        if (static_cast<boolean_T>(static_cast<int32_T>(
                                static_cast<int32_T>(std::isinf(d)) |
                                static_cast<int32_T>(std::isnan(d))))) {
                            Lon = (rtNaN);
                            rtb_Switch_l = (rtNaN);
                        } else if (d < 4.4501477170144028E-308) {
                            Lon = 4.94065645841247E-324;
                            rtb_Switch_l = 4.94065645841247E-324;
                        } else {
                            std::frexp(d, &rtb_Bias_mn);
                            Lon = std::ldexp(1.0, static_cast<int32_T>
                                             (rtb_Bias_mn - 53));
                            std::frexp(d, &b_exponent);
                            rtb_Switch_l = std::ldexp(1.0, static_cast<int32_T>
                                (b_exponent - 53));
                        }

                        if (localDW->obj.LookaheadDistance <= std::fmax(std::
                                sqrt(Lon), 5.0 * rtb_Switch_l) + rtb_Abs1_il) {
                            localDW->obj.LookaheadDistance =
                                localDW->obj.LookaheadFactor * rtb_Abs1_il;
                        }

                        d = distToCenter - rtu_Pose[0];
                        u[0] = d;
                        rtb_Switch_l = Alt - rtu_Pose[1];
                        u[1] = rtb_Switch_l;
                        Lon = ((LLA0_gw[0] - distToCenter) * (LLA0_gw[0] -
                                distToCenter) + (LLA0_gw[1] - Alt) * (LLA0_gw[1]
                                - Alt)) + (LLA0_gw[2] - turnVector_idx_2) *
                            (LLA0_gw[2] - turnVector_idx_2);
                        xyCenter_idx_1 = turnVector_idx_2 - rtu_Pose[2];
                        u[2] = xyCenter_idx_1;
                        rtb_Abs1_il = ((Lat * d + rtb_Sum1_e_idx_0 *
                                        rtb_Switch_l) + distToCenter_tmp_0 *
                                       xyCenter_idx_1) * 2.0;
                        rtb_Switch_l = std::sqrt(rtb_Abs1_il * rtb_Abs1_il -
                            (((d * d + rtb_Switch_l * rtb_Switch_l) +
                              xyCenter_idx_1 * xyCenter_idx_1) -
                             localDW->obj.LookaheadDistance *
                             localDW->obj.LookaheadDistance) * (4.0 * Lon));
                        Lon = std::fmax((-rtb_Abs1_il + rtb_Switch_l) / 2.0 /
                                        Lon, (-rtb_Abs1_il - rtb_Switch_l) / 2.0
                                        / Lon);
                        LLA0_gw[2] = (1.0 - Lon) * turnVector_idx_2 + Lon *
                            LLA0_gw[2];

                        // SignalConversion generated from: '<S165>/Waypoint Follower' 
                        rtb_Switch_l = rt_atan2d_snf(((1.0 - Lon) * Alt + Lon *
                            LLA0_gw[1]) - rtu_Pose[1], ((1.0 - Lon) *
                            distToCenter + Lon * LLA0_gw[0]) - rtu_Pose[0]);

                        // SignalConversion generated from: '<S165>/Waypoint Follower' 
                        rtb_MergeStatus = 0U;
                        isStable = false;
                        if (localDW->obj.LastWaypointFlag) {
                            isStable = true;
                        }

                        if (isStable) {
                            // SignalConversion generated from: '<S165>/Waypoint Follower' 
                            rtb_MergeStatus = 1U;
                        }

                        localDW->obj.LastWaypointFlag = false;
                    }
                }

                // End of Outputs for SubSystem: '<S161>/StartFromFirst'
            }

            // End of SwitchCase: '<S161>/Switch Case'

            // MATLAB Function: '<S163>/ReadHomePoint'
            FlightMissionMode_ReadHomePoint(u, &localDW->sf_ReadHomePoint_l);

            // Switch: '<S182>/Switch' incorporates:
            //   Abs: '<S182>/Abs'
            //   Bias: '<S182>/Bias'
            //   Bias: '<S182>/Bias1'
            //   Constant: '<S182>/Constant2'
            //   Constant: '<S183>/Constant'
            //   Math: '<S182>/Math Function1'
            //   RelationalOperator: '<S183>/Compare'

            if (std::abs(u[0]) > 180.0) {
                Lon = rt_modd_snf(u[0] + 180.0, 360.0) - 180.0;
            } else {
                Lon = u[0];
            }

            // End of Switch: '<S182>/Switch'

            // Abs: '<S179>/Abs1'
            rtb_Abs1_il = std::abs(Lon);

            // Switch: '<S179>/Switch' incorporates:
            //   Bias: '<S179>/Bias'
            //   Bias: '<S179>/Bias1'
            //   Constant: '<S170>/Constant'
            //   Constant: '<S170>/Constant1'
            //   Constant: '<S181>/Constant'
            //   Gain: '<S179>/Gain'
            //   Product: '<S179>/Divide1'
            //   RelationalOperator: '<S181>/Compare'
            //   Signum: '<S179>/Sign1'
            //   Switch: '<S170>/Switch1'

            if (rtb_Abs1_il > 90.0) {
                // Signum: '<S179>/Sign1'
                if (std::isnan(Lon)) {
                    rtb_Sum1_e_idx_0 = (rtNaN);
                } else if (Lon < 0.0) {
                    rtb_Sum1_e_idx_0 = -1.0;
                } else {
                    rtb_Sum1_e_idx_0 = static_cast<real_T>(Lon > 0.0);
                }

                Lon = (-(rtb_Abs1_il - 90.0) + 90.0) * rtb_Sum1_e_idx_0;
                i = 180;
            } else {
                i = 0;
            }

            // End of Switch: '<S179>/Switch'

            // Sum: '<S170>/Sum' incorporates:
            //   Switch: '<S170>/Switch1'

            Lat = static_cast<real_T>(i) + u[1];

            // Switch: '<S180>/Switch' incorporates:
            //   Abs: '<S180>/Abs'
            //   Bias: '<S180>/Bias'
            //   Bias: '<S180>/Bias1'
            //   Constant: '<S180>/Constant2'
            //   Constant: '<S184>/Constant'
            //   Math: '<S180>/Math Function1'
            //   RelationalOperator: '<S184>/Compare'

            if (std::abs(Lat) > 180.0) {
                Lat = rt_modd_snf(Lat + 180.0, 360.0) - 180.0;
            }

            // End of Switch: '<S180>/Switch'

            // Sum: '<S167>/Sum1'
            rtb_Sum1_e_idx_0 = rtu_MissionLocation->Lat - Lon;
            rtb_Sum1_e_idx_1 = rtu_MissionLocation->Lon - Lat;

            // Switch: '<S176>/Switch' incorporates:
            //   Abs: '<S176>/Abs'
            //   Bias: '<S176>/Bias'
            //   Bias: '<S176>/Bias1'
            //   Constant: '<S176>/Constant2'
            //   Constant: '<S177>/Constant'
            //   Math: '<S176>/Math Function1'
            //   RelationalOperator: '<S177>/Compare'

            if (std::abs(rtb_Sum1_e_idx_0) > 180.0) {
                Lat = rt_modd_snf(rtb_Sum1_e_idx_0 + 180.0, 360.0) - 180.0;
            } else {
                Lat = rtb_Sum1_e_idx_0;
            }

            // End of Switch: '<S176>/Switch'

            // Abs: '<S173>/Abs1'
            rtb_Abs1_il = std::abs(Lat);

            // Switch: '<S173>/Switch' incorporates:
            //   Bias: '<S173>/Bias'
            //   Bias: '<S173>/Bias1'
            //   Constant: '<S169>/Constant'
            //   Constant: '<S169>/Constant1'
            //   Constant: '<S175>/Constant'
            //   Gain: '<S173>/Gain'
            //   Product: '<S173>/Divide1'
            //   RelationalOperator: '<S175>/Compare'
            //   Signum: '<S173>/Sign1'
            //   Switch: '<S169>/Switch1'

            if (rtb_Abs1_il > 90.0) {
                // Signum: '<S173>/Sign1'
                if (std::isnan(Lat)) {
                    rtb_Sum1_e_idx_0 = (rtNaN);
                } else if (Lat < 0.0) {
                    rtb_Sum1_e_idx_0 = -1.0;
                } else {
                    rtb_Sum1_e_idx_0 = static_cast<real_T>(Lat > 0.0);
                }

                Lat = (-(rtb_Abs1_il - 90.0) + 90.0) * rtb_Sum1_e_idx_0;
                i = 180;
            } else {
                i = 0;
            }

            // End of Switch: '<S173>/Switch'

            // Sum: '<S169>/Sum' incorporates:
            //   Switch: '<S169>/Switch1'

            Alt = static_cast<real_T>(i) + rtb_Sum1_e_idx_1;

            // Switch: '<S174>/Switch' incorporates:
            //   Abs: '<S174>/Abs'
            //   Bias: '<S174>/Bias'
            //   Bias: '<S174>/Bias1'
            //   Constant: '<S174>/Constant2'
            //   Constant: '<S178>/Constant'
            //   Math: '<S174>/Math Function1'
            //   RelationalOperator: '<S178>/Compare'

            if (std::abs(Alt) > 180.0) {
                Alt = rt_modd_snf(Alt + 180.0, 360.0) - 180.0;
            }

            // End of Switch: '<S174>/Switch'

            // UnitConversion: '<S172>/Unit Conversion'
            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            rtb_Sum1_e_idx_0 = 0.017453292519943295 * Lat;
            rtb_Sum1_e_idx_1 = 0.017453292519943295 * Alt;

            // UnitConversion: '<S187>/Unit Conversion'
            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            Lon *= 0.017453292519943295;

            // Trigonometry: '<S188>/Trigonometric Function1'
            Alt = std::sin(Lon);

            // Sum: '<S188>/Sum1' incorporates:
            //   Constant: '<S188>/Constant'
            //   Product: '<S188>/Product1'

            Alt = 1.0 - 0.0066943799901413295 * Alt * Alt;

            // Product: '<S186>/Product1' incorporates:
            //   Constant: '<S186>/Constant1'
            //   Sqrt: '<S186>/sqrt'

            Lat = 6.378137E+6 / std::sqrt(Alt);

            // Product: '<S171>/dNorth' incorporates:
            //   Constant: '<S186>/Constant2'
            //   Product: '<S186>/Product3'
            //   Trigonometry: '<S186>/Trigonometric Function1'

            Alt = rtb_Sum1_e_idx_0 / rt_atan2d_snf(1.0, Lat *
                0.99330562000985867 / Alt);

            // Product: '<S171>/dEast' incorporates:
            //   Constant: '<S186>/Constant3'
            //   Product: '<S186>/Product4'
            //   Trigonometry: '<S186>/Trigonometric Function'
            //   Trigonometry: '<S186>/Trigonometric Function2'

            // Unit Conversion - from: deg to: rad
            // Expression: output = (0.0174533*input) + (0)
            Lat = 1.0 / rt_atan2d_snf(1.0, Lat * std::cos(Lon)) *
                rtb_Sum1_e_idx_1;

            // Gain: '<S162>/Gain1'
            Lon = 0.017453292519943295 * rtu_MissionLocation->degHDG;

            // Sum: '<S167>/Sum' incorporates:
            //   Gain: '<S163>/inverse'

            distToCenter = rtu_MissionLocation->Alt - u[2];

            // Reshape: '<S161>/Reshape' incorporates:
            //   Constant: '<S161>/InitialFlightPathAngle'
            //   Constant: '<S161>/InitialRollAngle'
            //   Constant: '<S161>/InitialRollAngleRate'
            //   DataTypeConversion: '<S161>/Param4'
            //   Product: '<S171>/x*cos'
            //   Product: '<S171>/x*sin'
            //   Product: '<S171>/y*cos'
            //   Product: '<S171>/y*sin'
            //   Sum: '<S171>/Sum2'
            //   Sum: '<S171>/Sum3'
            //   UnaryMinus: '<S167>/Ze2height'

            rty_InitialState[0] = Lat * 0.0 + Alt;
            rty_InitialState[1] = Lat - Alt * 0.0;
            rty_InitialState[2] = distToCenter;
            rty_InitialState[3] = static_cast<real_T>(rtu_Parameters->Param4);
            rty_InitialState[4] = Lon;
            rty_InitialState[5] = 0.0;
            rty_InitialState[6] = 0.0;
            rty_InitialState[7] = 0.0;

            // BusCreator: '<S161>/GuidanceCMDBusCreator' incorporates:
            //   DataTypeConversion: '<S161>/Param4'
            //   Gain: '<S161>/Down2Height'

            rty_GuidanceCmds->Height = -LLA0_gw[2];
            rty_GuidanceCmds->AirSpeed = static_cast<real_T>
                (rtu_Parameters->Param4);
            rty_GuidanceCmds->HeadingAngle = rtb_Switch_l;

            // DataTypeConversion: '<S161>/Cast To Double'
            *rty_thisTaskStatus = static_cast<real_T>(rtb_MergeStatus);

            // End of Outputs for SubSystem: '<Root>/Mode55_FrmnWayPoint'
        }
        break;

      default:
        // Outputs for IfAction SubSystem: '<Root>/Mode255_WaitToStart' incorporates:
        //   ActionPort: '<S2>/Action Port'

        // SignalConversion generated from: '<S2>/thisTaskStatus'
        *rty_thisTaskStatus = 0.0;

        // SignalConversion generated from: '<S2>/GuidanceCmds'
        *rty_GuidanceCmds = FlightMissionMode_rtZFixedWingGuidanceBus;

        // SignalConversion generated from: '<S2>/InitialState '
        std::memset(&rty_InitialState[0], 0, static_cast<uint32_T>(sizeof(real_T)
                     << 3U));

        // End of Outputs for SubSystem: '<Root>/Mode255_WaitToStart'
        break;
    }

    FlightMissionMode_emxFree_real_T_n(&b_waypointsIn);
    FlightMissionMode_emxFree_real_T_n(&waypoints);
    FlightMissionMode_emxFree_char_T_o(&q);
    FlightMissionMode_emxFree_char_T_o(&x);
    FlightMissionMode_emxFree_char_T_o(&curLine);
    FlightMissionMode_emxFree_char_T_o(&curVal);
    FlightMissionMode_emxFree_char_T_o(&curKey);
    FlightMissionMode_emxFree_char_T_o(&curSection);
    FlightMissionMode_emxFree_char_T_o(&data);
    FlightMissionMode_emxFree_real_T_n(&dummyWayPoint);
    FlightMissionMode_emxFree_char_T_o(&tline);
}

// Model initialize function
void FlightMissionMode_initialize(const char_T **rt_errorStatus,
    RT_MODEL_FlightMissionMode_T *const FlightMissionMode_M)
{
    // Registration code

    // initialize non-finites
    rt_InitInfAndNaN(sizeof(real_T));

    // initialize error status
    rtmSetErrorStatusPointer(FlightMissionMode_M, rt_errorStatus);
}

//
// File trailer for generated code.
//
// [EOF]
//
